1
00:00:00,000 --> 00:00:03,486
[音乐播放] 

2
00:00:49,800 --> 00:00:50,962
[视频回放] 

3
00:00:50,962 --> 00:00:52,840
-  - 我们知道？ 

4
00:00:52,840 --> 00:00:56,660
- 在9点15分，Ray Santoya在ATM上。 

5
00:00:56,660 --> 00:00:59,890
- 所以问题是，他在9:16做了什么？ 

6
00:00:59,890 --> 00:01:02,690
- 射击9毫米的东西。 

7
00:01:02,690 --> 00:01:04,330
也许他看到了狙击手。 

8
00:01:04,330 --> 00:01:06,445
- 或者他和他一起工作。 

9
00:01:06,445 --> 00:01:07,680
- 对。 

10
00:01:07,680 --> 00:01:08,620
回去一个。 

11
00:01:08,620 --> 00:01:09,370
- 你看到了什么？ 

12
00:01:17,190 --> 00:01:18,310
- 抬起头来。 

13
00:01:18,310 --> 00:01:20,900
全屏。 

14
00:01:20,900 --> 00:01:22,020
- 他的眼镜。 

15
00:01:22,020 --> 00:01:23,324
- 有一种反思。 

16
00:01:33,490 --> 00:01:35,080
- 那是Neuvitas棒球队。 

17
00:01:35,080 --> 00:01:36,200
那是他们的标志。 

18
00:01:36,200 --> 00:01:39,110
- 而且他正在和穿那件夹克的人说话。 

19
00:01:39,110 --> 00:01:40,405
- 我们可能有证人。 

20
00:01:40,405 --> 00:01:41,757
- 两次枪击事件。 

21
00:01:41,757 --> 00:01:42,340
[结束播放] 

22
00:01:42,340 --> 00:01:45,910
大卫马兰：这是他的CS50，这是讲座3，那

23
00:01:45,910 --> 00:01:47,809
不是计算机科学的工作方式。 

24
00:01:47,809 --> 00:01:49,600
事实上，到今天结束时，我们将会做出

25
00:01:49,600 --> 00:01:52,270
确切地说明什么是对的，什么是不对的， 

26
00:01:52,270 --> 00:01:57,340
并且希望在以后看电视或电影的时候给你一些停顿

27
00:01:57,340 --> 00:02:00,160
并注意到许多作家看起来的这些小事

28
00:02:00,160 --> 00:02:02,390
理所当然。 

29
00:02:02,390 --> 00:02:06,620
所以回想一下，上次我们看看实际编译的水平较低

30
00:02:06,620 --> 00:02:07,120
是。 

31
00:02:07,120 --> 00:02:10,570
并回想一下，这是一些事情，这四个步骤的预处理

32
00:02:10,570 --> 00:02:12,386
和编译，组装和链接， 

33
00:02:12,386 --> 00:02:14,260
所以当你开始他们的源鳕鱼， 

34
00:02:14,260 --> 00:02:17,140
这可能看起来像我们过去编写的代码， 

35
00:02:17,140 --> 00:02:20,590
你首先必须预处理它，预处理的第一步是

36
00:02:20,590 --> 00:02:23,180
转换所有这些处理器指令 - 

37
00:02:23,180 --> 00:02:26,655
任何以开头的哈希开头的东西 - 等同于它们的东西。 

38
00:02:26,655 --> 00:02:29,530
因此，打开文件并有效地复制和粘贴内容

39
00:02:29,530 --> 00:02:32,680
那么程序和编译器就知道get_string是什么了

40
00:02:32,680 --> 00:02:34,330
是的，知道printf是什么。 

41
00:02:34,330 --> 00:02:36,400
之后的下一步实际上是

42
00:02:36,400 --> 00:02:39,820
编译，从技术上编译就意味着采用该来源

43
00:02:39,820 --> 00:02:42,790
代码，一旦被预处理，并打印和生成

44
00:02:42,790 --> 00:02:45,710
这个非常神秘的东西叫做汇编代码。 

45
00:02:45,710 --> 00:02:50,140
那些汇编代码或汇编指令真的是CPU-- 

46
00:02:50,140 --> 00:02:52,780
计算机的大脑 - 实际上是理解的， 

47
00:02:52,780 --> 00:02:55,840
虽然从技术上讲，计算机仅在表格中理解它们

48
00:02:55,840 --> 00:02:57,170
0和1的。 

49
00:02:57,170 --> 00:03:00,010
所以，当你“组装 - 第三步 - 

50
00:03:00,010 --> 00:03:02,952
那个汇编代码，你实际上得到了那些0和1。 

51
00:03:02,952 --> 00:03:06,160
但即使是最简单的程序，我们只是提示用户输入一个字符串

52
00:03:06,160 --> 00:03:10,010
然后打印出他们的名字仍然涉及更多的文件。 

53
00:03:10,010 --> 00:03:15,730
顶部不仅有cs50.h和stdio.h， 

54
00:03:15,730 --> 00:03:20,650
在计算机系统的某个地方，可能有一些名为cs50.c的文件， 

55
00:03:20,650 --> 00:03:25,060
在stdio，printf.c的情况下，其中代码实际上是

56
00:03:25,060 --> 00:03:28,300
对于这两个函数，这两个函数必须编译下来

57
00:03:28,300 --> 00:03:31,690
到0和1，然后我们需要把所有东西连在一起， 

58
00:03:31,690 --> 00:03:35,140
合并那些0和1，以便计算机可以访问您的代码

59
00:03:35,140 --> 00:03:39,020
和printf的代码以及cs50库的代码等等。 

60
00:03:39,020 --> 00:03:43,420
但是所有这些我们通常可以在编译的描述中包含起来。 

61
00:03:43,420 --> 00:03:45,520
这是我们上周采取的外观之一。 

62
00:03:45,520 --> 00:03:49,090
我们上周和之前也介绍了一些工具。 

63
00:03:49,090 --> 00:03:52,420
可能的是，你可能已经有很多挫折

64
00:03:52,420 --> 00:03:54,667
与你成就的p-sets一样

65
00:03:54,667 --> 00:03:55,750
和满足感。 

66
00:03:55,750 --> 00:03:59,440
这是正常的，并确保秤最终会更多

67
00:03:59,440 --> 00:04:01,900
走向幸福，远离悲伤，但我们会

68
00:04:01,900 --> 00:04:05,260
今天为你提供了比实际发现更多的工具

69
00:04:05,260 --> 00:04:07,750
代码中的问题或缺点。 

70
00:04:07,750 --> 00:04:10,690
help50，回想一下，帮助你进入什么过程？ 

71
00:04:10,690 --> 00:04:14,130
当你本能地考虑使用help50？ 

72
00:04:14,130 --> 00:04:15,880
当您在屏幕上看到错误消息时。 

73
00:04:15,880 --> 00:04:18,370
你不明白的东西是你犯了一些错误的结果

74
00:04:18,370 --> 00:04:21,411
可能已经制作但你不太明白电脑讲的是什么

75
00:04:21,411 --> 00:04:24,527
你，运行help50，然后同样的命令，我们，工作人员， 

76
00:04:24,527 --> 00:04:26,860
我们的代码将尝试为您理解消息

77
00:04:26,860 --> 00:04:28,390
并为您提供反馈。 

78
00:04:28,390 --> 00:04:30,500
style50正是如此。 

79
00:04:30,500 --> 00:04:34,449
它可以帮助您看到红色和绿色的颜色编码究竟应该是什么空间

80
00:04:34,449 --> 00:04:36,740
在那里，不应该在那里 - 它只是帮助你漂亮

81
00:04:36,740 --> 00:04:39,920
你的代码，以便你可以更好地阅读它，其他人也可以。 

82
00:04:39,920 --> 00:04:44,440
然后是printf，它有点像你工具箱里最粗糙的工具， 

83
00:04:44,440 --> 00:04:47,980
这只是帮助您不仅看到要查看的邮件， 

84
00:04:47,980 --> 00:04:49,357
但只是变量的值。 

85
00:04:49,357 --> 00:04:51,440
无论你想要什么，你都可以打印整数和字符串

86
00:04:51,440 --> 00:04:54,085
然后你可以删除那些printf行

87
00:04:54,085 --> 00:04:55,960
一旦你确信你的计划正在运作。 

88
00:04:55,960 --> 00:04:59,001
但这有点单调乏味，说实话，随着我们的计划变得更大， 

89
00:04:59,001 --> 00:05:02,140
我们想要比手动打印更强大的工具

90
00:05:02,140 --> 00:05:04,702
出来，重新编译，重新运行，它很快就会变得单调乏味。 

91
00:05:04,702 --> 00:05:07,660
编程的目标不是单调乏味，而是赋予权力， 

92
00:05:07,660 --> 00:05:10,840
而这就是我们今天要走到今天的地方。 

93
00:05:10,840 --> 00:05:14,920
所以CS50 IDE就是那种更有趣的版本

94
00:05:14,920 --> 00:05:18,910
你一直在使用名为CS50 Sandbox，反过来，CS50实验室。 

95
00:05:18,910 --> 00:05:21,555
现在回想一下这两个工具，Sandbox和Lab， 

96
00:05:21,555 --> 00:05:23,680
有一个终端窗口，您可以在其中键入命令， 

97
00:05:23,680 --> 00:05:29,242
他们有一个代码编辑器，您可以在其中实际编写代码， 

98
00:05:29,242 --> 00:05:31,450
然后他们有一个带有图标等的文件浏览器

99
00:05:31,450 --> 00:05:34,100
您可以在哪里实际查看文件和文件夹。 

100
00:05:34,100 --> 00:05:38,410
事实证明，CS50 IDE是乍一看的另一个工具

101
00:05:38,410 --> 00:05:41,740
是非常非常相似的，即使它的布局略有不同， 

102
00:05:41,740 --> 00:05:45,820
但它拥有与沙盒和实验室一样多的功能，但还有更多功能。 

103
00:05:45,820 --> 00:05:49,630
更多功能实际上可以帮助您解决代码中的问题

104
00:05:49,630 --> 00:05:53,010
如果您愿意，甚至可以与他人合作完成最终的项目时间。 

105
00:05:53,010 --> 00:05:54,760
所以我们将看到这是CS50 IDE。 

106
00:05:54,760 --> 00:05:56,110
它配备了所谓的夜间模式，所以你

107
00:05:56,110 --> 00:05:58,540
可以使屏幕上的所有内容都变得更暗，特别是在p设置时

108
00:05:58,540 --> 00:06:00,670
晚上，让我们实际看看吧

109
00:06:00,670 --> 00:06:04,150
你可以用这种工具做什么。 

110
00:06:04,150 --> 00:06:08,525
当您在下一个问题集中第一次登录此工具时， 

111
00:06:08,525 --> 00:06:10,900
你会看到一个与以前几乎相同的界面。 

112
00:06:10,900 --> 00:06:13,210
颜色有点不同，字体大小略有不同， 

113
00:06:13,210 --> 00:06:16,100
但默认情况下在底部，你有所谓的终端窗口， 

114
00:06:16,100 --> 00:06:17,980
虽然现在不是美元符号，但你会

115
00:06:17,980 --> 00:06:21,440
看到一个更详细的工作空间，但稍微更多。 

116
00:06:21,440 --> 00:06:23,650
在这里你只有代码编辑器窗口， 

117
00:06:23,650 --> 00:06:25,599
没有什么真的发生在那里。 

118
00:06:25,599 --> 00:06:27,640
然后我们有了Ceiling Cat的附加功能

119
00:06:27,640 --> 00:06:29,390
在右上角。 

120
00:06:29,390 --> 00:06:31,760
而且我们还会看到其他一些功能。 

121
00:06:31,760 --> 00:06:35,250
那么让我们实际在CS50 IDE中编写一个程序，很明显， 

122
00:06:35,250 --> 00:06:39,390
是另一个基于Web的编程环境，也为您提供

123
00:06:39,390 --> 00:06:42,600
访问您自己的基于云的服务器。 

124
00:06:42,600 --> 00:06:45,990
它也运行Ubuntu Linux，这是一种流行的操作系统

125
00:06:45,990 --> 00:06:47,970
不是macOS，它不是Windows。 

126
00:06:47,970 --> 00:06:51,420
但与您甚至没有登录的沙箱环境不同

127
00:06:51,420 --> 00:06:53,310
而你最终会丢失你的文件

128
00:06:53,310 --> 00:06:56,018
可能知道您的cookie何时丢失或出现问题， 

129
00:06:56,018 --> 00:06:57,209
IDE保存所有内容。 

130
00:06:57,209 --> 00:06:59,250
并且您将使用您的帐户登录，等等

131
00:06:59,250 --> 00:07:02,130
你上周放在那里将在本周和下周到那里

132
00:07:02,130 --> 00:07:03,040
超越。 

133
00:07:03,040 --> 00:07:07,230
所以，让我继续文件，新文件，或者我可以点击这个小加号

134
00:07:07,230 --> 00:07:10,650
在右上角的图标，让我继续前进，先发制人

135
00:07:10,650 --> 00:07:13,300
Control-S或Command-S或转到文件，保存 - 

136
00:07:13,300 --> 00:07:17,110
您会发现界面与任何Mac或PC程序非常相似 - 

137
00:07:17,110 --> 00:07:20,380
让我继续保存此文件，如下所示。 

138
00:07:20,380 --> 00:07:23,039
我打算叫这个hello.c。 

139
00:07:23,039 --> 00:07:25,080
提及文件扩展名很重要， 

140
00:07:25,080 --> 00:07:27,510
否则IDE，如沙箱和实验室， 

141
00:07:27,510 --> 00:07:29,564
我不知道你写的是什么类型的节目。 

142
00:07:29,564 --> 00:07:32,230
然后让我继续，只写我最简单的程序。 

143
00:07:32,230 --> 00:07:37,770
所以让我继续包括stdio.h，int main void。 

144
00:07:37,770 --> 00:07:40,920
让我继续打开我的花括号printf-- 

145
00:07:40,920 --> 00:07:43,894
你好，世界，反斜杠n和分号。 

146
00:07:43,894 --> 00:07:46,060
所以你会注意到几乎所有东西都是一样的。 

147
00:07:46,060 --> 00:07:48,270
颜色有点不同，也许， 

148
00:07:48,270 --> 00:07:50,207
你可能会看到一些不同的辅助

149
00:07:50,207 --> 00:07:53,040
您键入代码时的功能，但最终结果是相同的。 

150
00:07:53,040 --> 00:07:55,560
您可以免费获得颜色编码，因为它有帮助

151
00:07:55,560 --> 00:07:57,760
请注意代码的不同部分。 

152
00:07:57,760 --> 00:07:59,515
让我继续吧 - 

153
00:07:59,515 --> 00:08:00,465
哦注意这个。 

154
00:08:00,465 --> 00:08:01,740
有一点不同。 

155
00:08:01,740 --> 00:08:05,179
IDE是一个功能更强大的工具，但同样，它是一个更加手动的工具

156
00:08:05,179 --> 00:08:07,470
而且它不仅仅是为您自动保存代码。 

157
00:08:07,470 --> 00:08:10,170
很好，就像沙盒一样，你永远不会

158
00:08:10,170 --> 00:08:12,270
实际上有命令-S或Control-S-- 

159
00:08:12,270 --> 00:08:14,870
如果你是，你不需要，IDE 

160
00:08:14,870 --> 00:08:18,570
当你想要它时，它只会保存东西

161
00:08:18,570 --> 00:08:20,740
将会神奇地发生。 

162
00:08:20,740 --> 00:08:24,570
所以我要做的就是回到这里，File，Save或Command-S 

163
00:08:24,570 --> 00:08:26,460
或者Control-S，你会看到一个小绿点

164
00:08:26,460 --> 00:08:29,070
简单地说，现在又回到我的提示。 

165
00:08:29,070 --> 00:08:33,750
我现在要继续，输入我熟悉的命令，打招呼，回车， 

166
00:08:33,750 --> 00:08:36,270
你会看到几乎同样神秘的客户

167
00:08:36,270 --> 00:08:40,950
像以前一样命令，因为IDE的配置与Sandbox非常相似。 

168
00:08:40,950 --> 00:08:44,190
如果我想继续现在运行，我该如何运行这个程序？ 

169
00:08:44,190 --> 00:08:46,150
快速检查？ 

170
00:08:46,150 --> 00:08:48,710
./hello，它和以前完全一样。 

171
00:08:48,710 --> 00:08:51,680
./hello，我们有它，你好，世界。 

172
00:08:51,680 --> 00:08:54,830
长话短说，到目前为止用户界面有点不同， 

173
00:08:54,830 --> 00:08:56,227
但在功能上它是一样的。 

174
00:08:56,227 --> 00:08:58,560
我们现在才开始看到更多功能。 

175
00:08:58,560 --> 00:08:59,510
那些功能是什么？ 

176
00:08:59,510 --> 00:09:02,060
让我们介绍一些实际上新的功能

177
00:09:02,060 --> 00:09:05,760
可能在Sandbox中，我们当时并没有真正介绍它们。 

178
00:09:05,760 --> 00:09:09,710
如果我单击左上角的此文件夹图标，您将看到我的所有文件和文件夹。 

179
00:09:09,710 --> 00:09:12,014
今天的讲座我有很多预先制作的例子

180
00:09:12,014 --> 00:09:14,930
已经在课程网站上，其中一些我们会看到， 

181
00:09:14,930 --> 00:09:16,850
其中一些我们会参考网站， 

182
00:09:16,850 --> 00:09:18,870
但这些只是熟悉的文件和文件夹。 

183
00:09:18,870 --> 00:09:21,410
你可以看到我帐户中的所有内容

184
00:09:21,410 --> 00:09:23,720
显然是在一个叫做Workspace的东西里面

185
00:09:23,720 --> 00:09:26,180
只是一个文件夹，名称或目录。 

186
00:09:26,180 --> 00:09:28,190
这是我的sc3目录，它再次出现

187
00:09:28,190 --> 00:09:30,980
来自今天讲座的网站，讲座3。 

188
00:09:30,980 --> 00:09:33,960
然后这是我刚刚在程序和文件中编译的文件

189
00:09:33,960 --> 00:09:35,650
我写的，你好。 

190
00:09:35,650 --> 00:09:38,662
你也会注意到这里有这个时髦的符号，代字号， 

191
00:09:38,662 --> 00:09:41,120
你可能没有机会用英语写作， 

192
00:09:41,120 --> 00:09:44,010
但在其他语言的西班牙语中，您可以使用此字符。 

193
00:09:44,010 --> 00:09:48,600
这实际上是所谓的主目录的简写表示法。 

194
00:09:48,600 --> 00:09:52,190
在这个环境中，CS50 IDE，你有自己的主目录，其中

195
00:09:52,190 --> 00:09:55,880
表示您要创建的文件和其他文件夹的文件夹， 

196
00:09:55,880 --> 00:09:59,210
你拥有，并且每次登录时都会持续存在 - 你不是

197
00:09:59,210 --> 00:10:00,920
将失去其中的内容。 

198
00:10:00,920 --> 00:10:05,660
所以这只意味着在你的主目录中，也就是代字号， 

199
00:10:05,660 --> 00:10:09,212
我正在使用一个名为workspace的文件夹。 

200
00:10:09,212 --> 00:10:12,170
这只是我工作的所有工作的一个文件夹， 

201
00:10:12,170 --> 00:10:15,615
因为在这个云环境中有这么多其他文件和文件夹， 

202
00:10:15,615 --> 00:10:17,990
就像你的Mac和PC一样，我们只是一般

203
00:10:17,990 --> 00:10:19,430
不在乎他们是什么。 

204
00:10:19,430 --> 00:10:25,520
但是请注意除了编译之外我们可以在这个终端窗口做什么

205
00:10:25,520 --> 00:10:26,600
并运行代码。 

206
00:10:26,600 --> 00:10:27,740
还有其他命令。 

207
00:10:27,740 --> 00:10:33,650
例如，这里的蓝色文本，与顶部的文件浏览器类似， 

208
00:10:33,650 --> 00:10:37,260
现在不仅表示这是我按美元符号的提示， 

209
00:10:37,260 --> 00:10:40,790
但是在我的主目录的工作区目录中。 

210
00:10:40,790 --> 00:10:44,666
所以这意味着我可以在其他地方，即使我没有

211
00:10:44,666 --> 00:10:46,040
指定我想去的地方。 

212
00:10:46,040 --> 00:10:49,460
事实上，我可以做到这一点。 ls代表清单， 

213
00:10:49,460 --> 00:10:51,270
它只是简写符号。 

214
00:10:51,270 --> 00:10:56,450
现在我看到了文件树的文本版本，可以这么说。 

215
00:10:56,450 --> 00:10:59,344
所以你会在这里看到，sc3是一个文件夹，而你

216
00:10:59,344 --> 00:11:01,760
可以说得多，因为它的末尾有一个斜线。 

217
00:11:01,760 --> 00:11:04,500
hello.c当然是我刚才写的文件。 

218
00:11:04,500 --> 00:11:08,750
然后绿色你好是我编译的程序和明星

219
00:11:08,750 --> 00:11:10,275
或星号只是 - 

220
00:11:10,275 --> 00:11:12,650
它不是文件的名称，它只是向我指示

221
00:11:12,650 --> 00:11:14,390
视觉上这是可执行的。 

222
00:11:14,390 --> 00:11:17,510
这是我可以运行的程序，所以我知道编译的是什么

223
00:11:17,510 --> 00:11:19,190
什么是源代码。 

224
00:11:19,190 --> 00:11:23,120
所以当你正在运行./hello时，这一直是这个原因

225
00:11:23,120 --> 00:11:28,670
work是因为在dot中，你当前的文件夹中有一个名为hello的文件， 

226
00:11:28,670 --> 00:11:32,160
当你按Enter键时，你正在那里运行那个程序。 

227
00:11:32,160 --> 00:11:36,470
因此，如果今天之后你回到CS50沙盒或CS50实验室并输入ls， 

228
00:11:36,470 --> 00:11:39,560
你会看到与小文件夹完全相同的东西

229
00:11:39,560 --> 00:11:41,840
这些程序中的图标也是如此。 

230
00:11:41,840 --> 00:11:44,660
但是假设我想进入一个目录。 

231
00:11:44,660 --> 00:11:48,200
在macOS或Windows甚至IDE中，我当然可以

232
00:11:48,200 --> 00:11:51,080
转到我的文件图标，然后按小三角形

233
00:11:51,080 --> 00:11:53,390
在这里，看起来很直观，你只需点击它

234
00:11:53,390 --> 00:11:56,150
你可以看到里面发生了什么，这并不奇怪。 

235
00:11:56,150 --> 00:11:57,740
但你怎么用文字做的呢？ 

236
00:11:57,740 --> 00:12:00,270
在命令提示符下，它并不是那么难。 

237
00:12:00,270 --> 00:12:02,160
您只需要更改目录即可。 

238
00:12:02,160 --> 00:12:08,670
所以，如果我做CD空间sc3，Enter，似乎没有任何事情发生

239
00:12:08,670 --> 00:12:10,796
除了我的提示改变了。 

240
00:12:10,796 --> 00:12:13,670
这是指示 - 这是我的提示，但在它的左边

241
00:12:13,670 --> 00:12:17,540
你看到蓝色，我现在在我的主目录的工作区文件夹中， 

242
00:12:17,540 --> 00:12:19,990
在我的sc3文件夹中。 

243
00:12:19,990 --> 00:12:23,411
所以它只是基于文本的GUI版本，即图形用户界面

244
00:12:23,411 --> 00:12:25,160
我们所有人都肯定会接受

245
00:12:25,160 --> 00:12:29,010
到目前为止，在macOS和Windows的世界中是理所当然的。 

246
00:12:29,010 --> 00:12:33,410
好吧，假设我对我的hello程序做了一点点

247
00:12:33,410 --> 00:12:34,430
我想删除它。 

248
00:12:34,430 --> 00:12:37,920
在IDE中，就像在Sandbox中一样，你可以实际上到这里，你可以

249
00:12:37,920 --> 00:12:41,030
单击它，然后您通常可以右键单击或按住Control键单击， 

250
00:12:41,030 --> 00:12:44,000
你会得到一整套其他选项，其中一个是删除 - 

251
00:12:44,000 --> 00:12:46,590
并随意在自己的环境中修补。 

252
00:12:46,590 --> 00:12:48,020
但命令行怎么样？ 

253
00:12:48,020 --> 00:12:52,392
如果我放大这里，我想删除你好，你就是

254
00:12:52,392 --> 00:12:55,100
不打算删除，因为这只是感觉有点冗长

255
00:12:55,100 --> 00:12:58,250
和人类几十年前决定打字太繁琐了， 

256
00:12:58,250 --> 00:13:00,410
我们只需要调用这个命令rm-- 

257
00:13:00,410 --> 00:13:04,920
删除 - 你好，你会看到一个有点神秘的提示。 

258
00:13:04,920 --> 00:13:07,040
rm--删除常规文件'hello？' 

259
00:13:07,040 --> 00:13:09,830
这比它需要的更神秘，但它只是问， 

260
00:13:09,830 --> 00:13:11,590
你确定要删除'你好吗？' 

261
00:13:11,590 --> 00:13:12,950
然后它就在等你。 

262
00:13:12,950 --> 00:13:18,050
在这里你可以输入y或yes或者其他命令， 

263
00:13:18,050 --> 00:13:20,420
现在我已经证实我的意图是肯定的。 

264
00:13:20,420 --> 00:13:23,600
如果我再次输入ls，我 - 哎呀，在错误的文件夹中。 

265
00:13:23,600 --> 00:13:27,810
如果我在打招呼后再次输入ls-- 

266
00:13:27,810 --> 00:13:31,940
没有 - 在打招呼后做了ls，现在我会

267
00:13:31,940 --> 00:13:34,580
只看到那两件事 -  sc3和hello.c。 

268
00:13:34,580 --> 00:13:36,440
如果我想制作文件夹怎么办？ 

269
00:13:36,440 --> 00:13:37,340
请注意这一点。 

270
00:13:37,340 --> 00:13:41,080
如果我在这里键入底部，请创建目录 - 

271
00:13:41,080 --> 00:13:45,050
mkdir--测试只是为了制作一个测试文件夹，我

272
00:13:45,050 --> 00:13:48,170
即将按Enter键，但请注意左上角

273
00:13:48,170 --> 00:13:51,680
我目前有那些其他文件和文件夹，当我按Enter键时， 

274
00:13:51,680 --> 00:13:53,040
现在我有一个测试文件夹。 

275
00:13:53,040 --> 00:13:54,290
所以这些都是一样的。 

276
00:13:54,290 --> 00:13:57,440
一个是图形，一个是命令行，甚至还有其他命令

277
00:13:57,440 --> 00:13:59,060
如果我决定我不想要那个。 

278
00:13:59,060 --> 00:14:02,210
rmdir是删除目录，它就消失了

279
00:14:02,210 --> 00:14:04,590
因为它是空的，因此是安全的。 

280
00:14:04,590 --> 00:14:06,680
然后对任何这些命令有任何疑问

281
00:14:06,680 --> 00:14:11,505
或者只是我们正在看的整体布局？ 

282
00:14:11,505 --> 00:14:13,880
好吧，所以不要挂断任何这些命令， 

283
00:14:13,880 --> 00:14:15,200
并且问题集和其他问题将永远存在

284
00:14:15,200 --> 00:14:16,670
提醒你这些功能。 

285
00:14:16,670 --> 00:14:19,461
现在的观点是，我们处于一个新的环境中， 

286
00:14:19,461 --> 00:14:23,289
但它基本上仍然相同，它具有相同的功能。 

287
00:14:23,289 --> 00:14:24,830
那么我们看到的其他工具是什么？ 

288
00:14:24,830 --> 00:14:28,550
所以你可能听说过有关一个名为check50的工具的谣言，事实上， 

289
00:14:28,550 --> 00:14:31,970
这是工作人员用来评估问题集1和问题集的工具

290
00:14:31,970 --> 00:14:35,450
2评估它们的正确性，以便我们自己不必打字

291
00:14:35,450 --> 00:14:41,660
./mario或./caesar一次又一次地测试学生的代码。 

292
00:14:41,660 --> 00:14:44,640
但是从本周开始，你也可以访问同一个程序。 

293
00:14:44,640 --> 00:14:48,440
check50是来自工作人员的命令，用于检查代码的正确性

294
00:14:48,440 --> 00:14:51,800
就像style50检查代码的样式一样。 

295
00:14:51,800 --> 00:14:53,990
事实上，如果我回到我的IDE， 

296
00:14:53,990 --> 00:14:57,440
让我们尝试通过制作相同版本的hello来第一次使用它

297
00:14:57,440 --> 00:15:00,090
你可能为你的第一个问题集做了什么。 

298
00:15:00,090 --> 00:15:04,400
因此，如果我继续并不仅包括stdio，而是包括cs50.h， 

299
00:15:04,400 --> 00:15:07,010
然后我继续从用户那里得到一个字符串

300
00:15:07,010 --> 00:15:10,280
使用get_string，提示他们输入他们的名字，然后继续

301
00:15:10,280 --> 00:15:14,990
并打印不只是你好，世界，但你好，百分比的逗号名称， 

302
00:15:14,990 --> 00:15:17,960
我相信这可能是你自己的同一个程序

303
00:15:17,960 --> 00:15:20,010
写道，或其中的一些变体。 

304
00:15:20,010 --> 00:15:22,190
所以如果我现在继续自己测试 - 

305
00:15:22,190 --> 00:15:26,150
打招呼，回车，好像，./ hello。 

306
00:15:26,150 --> 00:15:29,004
我要继续写下我的名字，瞧，大卫。 

307
00:15:29,004 --> 00:15:30,920
现在假设你感觉很好，你就是

308
00:15:30,920 --> 00:15:32,711
非常有信心你的代码是正确的， 

309
00:15:32,711 --> 00:15:36,080
最重要的是，您已经测试了自己的代码。 

310
00:15:36,080 --> 00:15:38,780
单靠我们的工具是不够的

311
00:15:38,780 --> 00:15:41,540
测试你的代码，因为它也可能不是详尽无遗的。 

312
00:15:41,540 --> 00:15:45,310
所以，一旦你尝试了一些输入，不仅仅是大卫，也许是

313
00:15:45,310 --> 00:15:47,570
Veronica的名字似乎也有效。 

314
00:15:47,570 --> 00:15:49,940
布莱恩的名字似乎也有效。 

315
00:15:49,940 --> 00:15:52,704
没有名字，似乎没有用，也许？ 

316
00:15:52,704 --> 00:15:54,620
但我们必须回顾问题集

317
00:15:54,620 --> 00:15:56,420
看看这实际上是不是一个问题。 

318
00:15:56,420 --> 00:15:58,640
现在让我继续，然后运行check50。 

319
00:15:58,640 --> 00:16:02,330
check50期待一个特殊的slug，可以这么说。 

320
00:16:02,330 --> 00:16:05,335
只是您要检查的问题的唯一标识符。 

321
00:16:05,335 --> 00:16:07,460
而你只会通过阅读问题来了解这一点

322
00:16:07,460 --> 00:16:09,081
在线设置或文档。 

323
00:16:09,081 --> 00:16:12,080
我碰巧回忆起工作人员一直在使用的命令

324
00:16:12,080 --> 00:16:18,280
评分和评价你好只是cs50 / 2018 / fall /你好。 

325
00:16:18,280 --> 00:16:21,030
而斜线只是在视觉上区分这些词， 

326
00:16:21,030 --> 00:16:24,560
这不是您自己帐户中的文件夹或文件等。 

327
00:16:24,560 --> 00:16:29,030
所以我将在同一时间运行check50 cs50 / 2018 / fall / hello 

328
00:16:29,030 --> 00:16:31,550
hello.c所在的目录。 

329
00:16:31,550 --> 00:16:32,700
输入。 

330
00:16:32,700 --> 00:16:35,740
它将继续并连接到后端的GitHub， 

331
00:16:35,740 --> 00:16:37,490
回想一下，我们用它来存储你的代码。 

332
00:16:37,490 --> 00:16:40,800
它现在正在验证我，这意味着你的用户名和密码是什么？ 

333
00:16:40,800 --> 00:16:43,850
我将继续使用我的一个测试帐户。 

334
00:16:43,850 --> 00:16:45,630
现在它提示我输入密码， 

335
00:16:45,630 --> 00:16:47,360
我要继续打字。 

336
00:16:47,360 --> 00:16:49,970
你会发现你看到的星星就像你在网站上看到的子弹一样

337
00:16:49,970 --> 00:16:52,950
只是为了让一个看着你肩膀的人看不到你在打字的东西。 

338
00:16:52,950 --> 00:16:55,190
现在我要继续观察进展情况。 

339
00:16:55,190 --> 00:16:58,490
它正在准备中，让我继续前进并放大。 

340
00:16:58,490 --> 00:16:59,890
点 - 点 - 点。 

341
00:16:59,890 --> 00:17:03,050
它正在查看我的代码，它已准备好提交， 

342
00:17:03,050 --> 00:17:07,460
它现在上传到GitHub.com，一旦它在服务器上， 

343
00:17:07,460 --> 00:17:11,150
然后它会告诉CS50服务器，这是某某的提交， 

344
00:17:11,150 --> 00:17:14,359
继续并对其进行一些自动化测试， 

345
00:17:14,359 --> 00:17:17,960
因此检查它的正确性，希望我们即将看到一些

346
00:17:17,960 --> 00:17:21,200
绿色，快乐的笑脸，瞧，是的， 

347
00:17:21,200 --> 00:17:24,109
它看起来像这个问题的check50命令 - 

348
00:17:24,109 --> 00:17:26,150
或slu ,,可以这么说 - 

349
00:17:26,150 --> 00:17:29,630
检查hello.c是否存在，因为如果我忘了写文件

350
00:17:29,630 --> 00:17:32,020
或者，如果我误称它，什么都不会起作用。 

351
00:17:32,020 --> 00:17:33,860
我们检查它编译成功， 

352
00:17:33,860 --> 00:17:35,630
所以，这也是一个快乐的绿色面孔。 

353
00:17:35,630 --> 00:17:37,070
然后它显然检查 - 

354
00:17:37,070 --> 00:17:38,840
如果我们输入Veronica怎么办？ 

355
00:17:38,840 --> 00:17:40,250
我们见到你好，Veronica？ 

356
00:17:40,250 --> 00:17:41,030
显然是的。 

357
00:17:41,030 --> 00:17:42,800
如果我们输入另一个词怎么样，Brian？ 

358
00:17:42,800 --> 00:17:44,482
是的，显然我们打招呼，Brian。 

359
00:17:44,482 --> 00:17:46,190
所以很有可能，我们要走了

360
00:17:46,190 --> 00:17:49,920
根据这四个测试得出的结论是，您的代码实际上是正确的， 

361
00:17:49,920 --> 00:17:51,810
至少就这些投入而言。 

362
00:17:51,810 --> 00:17:54,302
通过底部的URL通常会有更多细节

363
00:17:54,302 --> 00:17:56,510
在那里你可以实际看到更多的图形

364
00:17:56,510 --> 00:17:57,740
对您的代码的反馈。 

365
00:17:57,740 --> 00:18:01,490
当然，第一次，第二次，第三次也许你运行这个命令， 

366
00:18:01,490 --> 00:18:03,410
你可能看不到一些绿色的幸福面孔， 

367
00:18:03,410 --> 00:18:06,867
你可能会看到一些红色的不快乐的脸或一些黄色的平面， 

368
00:18:06,867 --> 00:18:09,950
这意味着我们甚至无法运行检查，因为其他东西是

369
00:18:09,950 --> 00:18:10,590
错误。 

370
00:18:10,590 --> 00:18:14,480
但随着时间的推移，这将帮助您感觉更舒适，更自信

371
00:18:14,480 --> 00:18:18,504
在您实际使用submit50并提交之前，您的代码是正确的。 

372
00:18:18,504 --> 00:18:21,170
进入它你会感觉好一点或有点沮丧

373
00:18:21,170 --> 00:18:24,470
提前知道 - 等一下，我准备提交这个但是没有， 

374
00:18:24,470 --> 00:18:25,550
它还不正确。 

375
00:18:25,550 --> 00:18:28,490
所以意识到这是一把双刃剑。 

376
00:18:28,490 --> 00:18:34,470
到目前为止有关check50或任何这些命令的任何问题？ 

377
00:18:34,470 --> 00:18:36,974
什么都没有？ 

378
00:18:36,974 --> 00:18:37,741
没有？ 

379
00:18:37,741 --> 00:18:38,240
行。 

380
00:18:38,240 --> 00:18:41,030
那么让我们来看看最终和最强大的

381
00:18:41,030 --> 00:18:45,380
工具现在可在IDE环境中使用。 

382
00:18:45,380 --> 00:18:49,119
内置于CS50 IDE，代表集成开发

383
00:18:49,119 --> 00:18:52,160
环境，这不是CS50的东西 - 这是工业界的常用术语

384
00:18:52,160 --> 00:18:54,780
对于使编写代码更容易的工具， 

385
00:18:54,780 --> 00:18:58,470
事实证明，除了猫之外还有其他一些功能。 

386
00:18:58,470 --> 00:19:00,920
也就是说，您可以共享您的工作区

387
00:19:00,920 --> 00:19:03,090
与教学人员和课程助理

388
00:19:03,090 --> 00:19:06,230
因此，他们可以实时帮助您实现Google Docs，甚至聊天

389
00:19:06,230 --> 00:19:07,370
和你在一起实时。 

390
00:19:07,370 --> 00:19:09,910
但它也为您提供了所谓的调试器。 

391
00:19:09,910 --> 00:19:12,320
顾名思义，调试器可以消除错误 - 

392
00:19:12,320 --> 00:19:15,350
或者更确切地说，帮助您从代码中删除错误

393
00:19:15,350 --> 00:19:17,630
让你不仅仅诉诸于printf-- 

394
00:19:17,630 --> 00:19:19,700
打印出整数和字符串等等

395
00:19:19,700 --> 00:19:22,580
很好，你的程序正在进行，它有点自动化

396
00:19:22,580 --> 00:19:24,140
这对你来说非常繁琐。 

397
00:19:24,140 --> 00:19:26,330
它让您可以浏览代码

398
00:19:26,330 --> 00:19:29,330
按照自己舒适的节奏一次排队

399
00:19:29,330 --> 00:19:33,984
并查看该程序中变量的所有值。 

400
00:19:33,984 --> 00:19:36,900
要激活此调试器，我将继续执行以下操作。 

401
00:19:36,900 --> 00:19:39,960
我将一如既往地使用make hello编译我的代码。 

402
00:19:39,960 --> 00:19:42,344
它必须编译，否则我可能想要

403
00:19:42,344 --> 00:19:44,510
使用help50并找出它为什么不编译， 

404
00:19:44,510 --> 00:19:46,250
但它似乎确实已编译。 

405
00:19:46,250 --> 00:19:50,210
现在我要继续运行debug50，space，然后

406
00:19:50,210 --> 00:19:52,280
我想调试的程序的名称。 

407
00:19:52,280 --> 00:19:54,738
还有我想要调试的程序的名称

408
00:19:54,738 --> 00:19:56,690
是当前目录的文件名为hello。 

409
00:19:56,690 --> 00:19:59,106
让我们假设它可能有些问题。 

410
00:19:59,106 --> 00:20:01,417
但是，第一次运行此命令时，调试50 

411
00:20:01,417 --> 00:20:03,875
不会对我感到满意，因为它会说， 

412
00:20:03,875 --> 00:20:06,270
看起来你没有设置任何断点。 

413
00:20:06,270 --> 00:20:09,380
通过单击行号左侧设置至少一个断点

414
00:20:09,380 --> 00:20:10,920
然后重新运行debug50。 

415
00:20:10,920 --> 00:20:12,170
什么是断点？ 

416
00:20:12,170 --> 00:20:14,420
正如名称所暗示的那样，它允许

417
00:20:14,420 --> 00:20:19,130
您可以在任何一行中断或暂停代码的运行。 

418
00:20:19,130 --> 00:20:21,620
过去几周的这段时间， 

419
00:20:21,620 --> 00:20:23,480
您的代码已自动进行行编号。 

420
00:20:23,480 --> 00:20:27,110
这很有用，因为这个程序中最有趣的一行， 

421
00:20:27,110 --> 00:20:29,880
一旦它真的开始，不是这个东西在顶部， 

422
00:20:29,880 --> 00:20:31,130
它不是主要的空洞，对吗？ 

423
00:20:31,130 --> 00:20:33,650
这是以前程序的所有复制粘贴。 

424
00:20:33,650 --> 00:20:37,910
这真的是第六行，我实际上有自己的逻辑。 

425
00:20:37,910 --> 00:20:41,360
在CS50 IDE中，您现在可以做的是

426
00:20:41,360 --> 00:20:43,340
点击其中一个行号的左侧， 

427
00:20:43,340 --> 00:20:46,460
像停车标志一样的小红灯会出现， 

428
00:20:46,460 --> 00:20:49,700
在这条线上打破或暂停我的程序

429
00:20:49,700 --> 00:20:52,130
我可以围绕我的实际代码。 

430
00:20:52,130 --> 00:20:54,180
沙盒和实验室无法做到这一点。 

431
00:20:54,180 --> 00:20:58,970
所以现在我要继续以完全相同的方式重新运行debug50，点击

432
00:20:58,970 --> 00:21:01,400
输入，但现在我有一个断点。 

433
00:21:01,400 --> 00:21:05,390
你会在右侧看到一个更加高级的菜单

434
00:21:05,390 --> 00:21:07,827
由猫提供了一堆功能。 

435
00:21:07,827 --> 00:21:10,160
乍一看，坦白说，这有点压倒性

436
00:21:10,160 --> 00:21:13,940
因为这里有很多事情，但你会先注意到， 

437
00:21:13,940 --> 00:21:17,540
最重要的是，有一些提到我的名字变量。 

438
00:21:17,540 --> 00:21:21,470
我不太了解0x0或诸如此类的东西，但我确实理解字符串。 

439
00:21:21,470 --> 00:21:26,240
所以debug50程序实现的是哦，在这一行及以下， 

440
00:21:26,240 --> 00:21:28,160
你有一个名为name的变量。 

441
00:21:28,160 --> 00:21:29,950
它似乎还没有价值。 

442
00:21:29,950 --> 00:21:33,890
事实证明，0x0只是意味着空或null或0。 

443
00:21:33,890 --> 00:21:37,400
但那很好，因为现在，当我真正执行这条线时， 

444
00:21:37,400 --> 00:21:41,000
希望它能取名David或Veronica或Brian。 

445
00:21:41,000 --> 00:21:42,510
那么让我们看看会发生什么。 

446
00:21:42,510 --> 00:21:46,010
请注意，它以黄色突出显示，第6行，这意味着它

447
00:21:46,010 --> 00:21:48,440
还没有执行这行代码。 

448
00:21:48,440 --> 00:21:52,670
我的代码暂停了，因为我设置了断点。 

449
00:21:52,670 --> 00:21:57,260
然后注意到有点像这里的音乐播放器，有几个图标。 

450
00:21:57,260 --> 00:21:59,930
播放按钮就是说啊，播放我的节目， 

451
00:21:59,930 --> 00:22:03,200
一直跑到最后，有点像带有绿色标志的划痕。 

452
00:22:03,200 --> 00:22:04,970
但更强大的是这个。 

453
00:22:04,970 --> 00:22:09,110
你可以跨过这一行，因此只执行一次。 

454
00:22:09,110 --> 00:22:12,020
如果它是一个功能，你可以进入这一行

455
00:22:12,020 --> 00:22:15,710
并实际查看你正在使用的函数内部，如get_string， 

456
00:22:15,710 --> 00:22:19,500
或者你可以退出另一个功能，但在另一个时间更多。 

457
00:22:19,500 --> 00:22:20,859
所以我要做的就是这个。 

458
00:22:20,859 --> 00:22:23,900
当我试图理解时，我最常点击的按钮

459
00:22:23,900 --> 00:22:25,358
我的计划是如何运作的 - 

460
00:22:25,358 --> 00:22:26,340
跳过。 

461
00:22:26,340 --> 00:22:31,670
所以它是左边第二个图标，紧挨着三角形。 

462
00:22:31,670 --> 00:22:34,230
所以一旦我点击这个，看看会发生什么， 

463
00:22:34,230 --> 00:22:38,635
即使它有点小，在我的名字变量的右侧。 

464
00:22:38,635 --> 00:22:41,510
请注意，我被提示输入我的名字，因为该程序

465
00:22:41,510 --> 00:22:44,630
仍在我的终端窗口中运行，但是当我立即按Enter键时， 

466
00:22:44,630 --> 00:22:49,310
提供我自己的名字，自动在右侧看到

467
00:22:49,310 --> 00:22:53,270
这个名称变量的值现在是，quote-unquote， 

468
00:22:53,270 --> 00:22:55,020
类型字符串的“大卫”。 

469
00:22:55,020 --> 00:22:59,240
有这个0x1083010--稍后会更多，只是有点神秘， 

470
00:22:59,240 --> 00:23:02,260
但我现在不必使用printf，我实际上可以看到发生了什么。 

471
00:23:02,260 --> 00:23:04,411
现在您可以看到第7行突出显示， 

472
00:23:04,411 --> 00:23:07,160
因为我在它上面设置了一个断点，所以现在我在第二行

473
00:23:07,160 --> 00:23:08,540
因为我刚踏入它。 

474
00:23:08,540 --> 00:23:11,090
让我继续，再次单击“下一步”，你就可以了

475
00:23:11,090 --> 00:23:14,300
看到在我的终端窗口，你好，大卫刚刚被执行。 

476
00:23:14,300 --> 00:23:17,330
现在，如果我继续前进，它将继续前进并运行到最后

477
00:23:17,330 --> 00:23:18,810
并关闭调试器。 

478
00:23:18,810 --> 00:23:21,530
所以对于这个项目来说并不是那么有用，因为坦率地说，我是

479
00:23:21,530 --> 00:23:25,550
很确定这是正确的，但debug50和调试器的功能更多

480
00:23:25,550 --> 00:23:28,700
通常是它让你，无论你是舒适还是舒适， 

481
00:23:28,700 --> 00:23:33,050
像TF或CA可能会说的那样按照自己的速度遍历自己的代码，好吧， 

482
00:23:33,050 --> 00:23:34,050
这条线在做什么？ 

483
00:23:34,050 --> 00:23:35,160
这条线在做什么？ 

484
00:23:35,160 --> 00:23:38,440
你不必诉诸printf，你可以非常有条不紊地

485
00:23:38,440 --> 00:23:41,410
浏览你的代码，找到那个困扰你的该死的bug 

486
00:23:41,410 --> 00:23:43,120
几分钟甚至几小时。 

487
00:23:43,120 --> 00:23:47,530
因此，以后，只要您的代码中存在编译错误

488
00:23:47,530 --> 00:23:51,010
但这在逻辑上是不正确的 - 马里奥的金字塔不太正确， 

489
00:23:51,010 --> 00:23:53,920
你对Caesar的加密不太正确，或其他什么， 

490
00:23:53,920 --> 00:23:58,240
你的第一直觉应该是，让我编译它，运行debug50， 

491
00:23:58,240 --> 00:24:01,910
然后单步执行代码，在任何我想要的地方设置断点， 

492
00:24:01,910 --> 00:24:04,450
所以你只关注几行，而不是全部 - 

493
00:24:04,450 --> 00:24:05,500
就像我刚刚做的那样 - 

494
00:24:05,500 --> 00:24:08,840
看看你是否可以逻辑地找出一个值不是你想要的值， 

495
00:24:08,840 --> 00:24:09,490
那么哦 - 

496
00:24:09,490 --> 00:24:13,000
继续，只需单击“恢复”，修复错误，然后重试。 

497
00:24:13,000 --> 00:24:15,110
这么强大的工具。 

498
00:24:15,110 --> 00:24:17,000
任何问题？ 

499
00:24:17,000 --> 00:24:19,180
是吗？ 

500
00:24:19,180 --> 00:24:19,710
它是什么？ 

501
00:24:19,710 --> 00:24:21,780
听众：有错误时会是什么样子？ 

502
00:24:21,780 --> 00:24:24,113
DAVID MALAN：当有错误时它会是什么样子？ 

503
00:24:24,113 --> 00:24:28,170
因此，调试器不会找到您的错误，它本身也不会向您显示您的错误。 

504
00:24:28,170 --> 00:24:31,137
它会让你看到正在执行的行， 

505
00:24:31,137 --> 00:24:32,970
它会让你看到输出的是什么， 

506
00:24:32,970 --> 00:24:34,950
它会让你接受输入，但一切都是

507
00:24:34,950 --> 00:24:36,949
在右侧进行的只是展示

508
00:24:36,949 --> 00:24:38,910
你一路上的事物的价值观。 

509
00:24:38,910 --> 00:24:42,840
你可以从这些信息中推断出什么

510
00:24:42,840 --> 00:24:46,140
这就是出错了，就像你过去几周使用printf一样

511
00:24:46,140 --> 00:24:48,420
看你的计划中发生了什么。 

512
00:24:48,420 --> 00:24:50,590
其他问题？ 

513
00:24:50,590 --> 00:24:52,360
让我也保存这个。 

514
00:24:52,360 --> 00:24:55,600
这很容易养成这种习惯，特别是在有这么多东西的时候

515
00:24:55,600 --> 00:24:57,940
过去几周刚刚说新的啊， 

516
00:24:57,940 --> 00:24:59,860
这是另一件需要学习的事情。 

517
00:24:59,860 --> 00:25:02,620
如果你这样，这就是那种工具

518
00:25:02,620 --> 00:25:05,622
本周和下周花几分钟时间使用它， 

519
00:25:05,622 --> 00:25:07,330
它变得更舒服了

520
00:25:07,330 --> 00:25:09,927
从长远来看，你可以节省数小时的时间， 

521
00:25:09,927 --> 00:25:12,010
因为你一直在手动花钱

522
00:25:12,010 --> 00:25:14,550
试图修复你的错误或在线发布问题

523
00:25:14,550 --> 00:25:16,420
试图理解事物，这是一个工具

524
00:25:16,420 --> 00:25:18,640
如果你预先投入这些会议纪要就行了

525
00:25:18,640 --> 00:25:21,340
帮助您了解程序内部的所有内容， 

526
00:25:21,340 --> 00:25:27,190
并且绝对会在接下来的几周内为您节省更多时间。 

527
00:25:27,190 --> 00:25:30,665
好的，有什么问题吗？是吗？ 

528
00:25:30,665 --> 00:25:34,060
听众：所以你有一个for [循环]运行[听不清]次， 

529
00:25:34,060 --> 00:25:38,199
[听不清]单独的break语句，所以你不必[听不清] .. 

530
00:25:38,199 --> 00:25:39,490
大卫马兰：啊，好问题。 

531
00:25:39,490 --> 00:25:42,156
如果你有像for循环或while循环这样的东西

532
00:25:42,156 --> 00:25:45,630
这种情况发生了很多，你能用这种方式设置一个断点吗？ 

533
00:25:45,630 --> 00:25:49,382
它只会打破，所以你不必走100次

534
00:25:49,382 --> 00:25:50,340
只看到那个价值？ 

535
00:25:50,340 --> 00:25:51,480
简短的回答，是的。 

536
00:25:51,480 --> 00:25:54,720
让我只关注部分和在线资源

537
00:25:54,720 --> 00:25:57,240
这些功能，但其中一个，你可以真正看到价值观， 

538
00:25:57,240 --> 00:25:59,323
你可以拥有所谓的表达式。 

539
00:25:59,323 --> 00:26:03,330
如果x大于50，你可以说给我看这个值

540
00:26:03,330 --> 00:26:04,470
或类似的东西。 

541
00:26:04,470 --> 00:26:06,840
或者你自己可以添加一些代码行。 

542
00:26:06,840 --> 00:26:11,430
您可以添加一个，如果x等于等于50，然后打印出一些东西， 

543
00:26:11,430 --> 00:26:14,080
你可以在那个新的临时线上设置一个断点， 

544
00:26:14,080 --> 00:26:15,724
所以有几种方法可以做到这一点。 

545
00:26:15,724 --> 00:26:16,890
期待的好问题。 

546
00:26:16,890 --> 00:26:17,390
是吗？ 

547
00:26:17,390 --> 00:26:18,181
背后。 

548
00:26:18,181 --> 00:26:22,029
听众：如果你运行debug50，你不是在添加

549
00:26:22,029 --> 00:26:26,994
在第4行的主要方法中，[听不清]的另一个问题是什么？ 

550
00:26:26,994 --> 00:26:28,410
DAVID MALAN：非常好的问题。 

551
00:26:28,410 --> 00:26:30,450
如果你正在运行debug50，你不是在添加

552
00:26:30,450 --> 00:26:33,540
根据我们上周的命令行讨论，另一个论点 -  argv-- 

553
00:26:33,540 --> 00:26:34,320
参数呢？ 

554
00:26:34,320 --> 00:26:36,827
简短的回答，不，因为debug50纠正了这一点， 

555
00:26:36,827 --> 00:26:38,410
所以你不必担心。 

556
00:26:38,410 --> 00:26:40,530
它不会在数字上改变。 

557
00:26:40,530 --> 00:26:41,730
真的很好想。 

558
00:26:41,730 --> 00:26:43,800
其他问题？ 

559
00:26:43,800 --> 00:26:50,040
好吧，所以说，现在让我们开一些训练轮。 

560
00:26:50,040 --> 00:26:53,070
所以我几年前买这些训练轮的唯一原因

561
00:26:53,070 --> 00:26:57,870
是为了让这个非常引人注目的目前正在取消训练轮

562
00:26:57,870 --> 00:26:59,660
今天。 

563
00:26:59,660 --> 00:27:01,470
好的，这是什么意思？ 

564
00:27:01,470 --> 00:27:03,300
非常值得前往Target。 

565
00:27:03,300 --> 00:27:04,350
那么这是什么意思？ 

566
00:27:04,350 --> 00:27:07,110
在过去的几周里，我们一直在使用一大堆

567
00:27:07,110 --> 00:27:09,310
来自CS50库的功能。 

568
00:27:09,310 --> 00:27:12,500
相对而言，所有这些都只是为了让它变得相当简单， 

569
00:27:12,500 --> 00:27:14,712
在最初的几周内得到用户的意见。 

570
00:27:14,712 --> 00:27:16,420
因为事实证明，正如我们今天所看到的， 

571
00:27:16,420 --> 00:27:20,910
在C中获取用户输入实际上是一种痛苦， 

572
00:27:20,910 --> 00:27:23,834
坦率地说，甚至在其他语言中的可靠性。 

573
00:27:23,834 --> 00:27:27,000
因为你会记得get_string和get_int以及所有这些函数

574
00:27:27,000 --> 00:27:30,180
如果他们实际上没有重新提示用户的负担

575
00:27:30,180 --> 00:27:32,130
给你一个int或不给你一个浮点数

576
00:27:32,130 --> 00:27:34,880
或者不给你一个你期待的焦炭，他们会重新提示， 

577
00:27:34,880 --> 00:27:37,296
他们正在使用while循环或do-while循环等， 

578
00:27:37,296 --> 00:27:40,200
所以这些功能内置了很多错误检测。 

579
00:27:40,200 --> 00:27:44,370
但是，最重要的是 - 也是最误导的， 

580
00:27:44,370 --> 00:27:46,470
是这个名单上的最后一个。 

581
00:27:46,470 --> 00:27:50,400
回想一下，几周前我们引入了一个字符串的概念。 

582
00:27:50,400 --> 00:27:53,570
而且一个字符串是英文的么？ 

583
00:27:53,570 --> 00:27:54,780
一系列人物，不错。 

584
00:27:54,780 --> 00:27:57,300
这是一系列人物，我们上周得知序列可以

585
00:27:57,300 --> 00:27:59,758
在数组中实现，这只是一块内存

586
00:27:59,758 --> 00:28:01,290
背到后端到后端到后端。 

587
00:28:01,290 --> 00:28:06,120
因此，字符串与其他任何数据类型都不太相似。 

588
00:28:06,120 --> 00:28:10,800
事实证明，它不像int或char，甚至bool或float， 

589
00:28:10,800 --> 00:28:13,480
我们现在可以开始看到如下。 

590
00:28:13,480 --> 00:28:15,522
我今天要继续进入IDE-- 

591
00:28:15,522 --> 00:28:17,813
从此我们将开始使用IDE， 

592
00:28:17,813 --> 00:28:20,942
但是欢迎您继续使用沙盒来快速和肮脏的程序， 

593
00:28:20,942 --> 00:28:22,650
但对于你想留下的任何东西， 

594
00:28:22,650 --> 00:28:24,937
你的直觉现在应该是打开你的IDE。 

595
00:28:24,937 --> 00:28:26,770
我要继续创建一个新文件， 

596
00:28:26,770 --> 00:28:31,710
我将从比较事物的第一个例子中将它称为compare0.c。 

597
00:28:31,710 --> 00:28:34,860
而且我将继续推进一个相对较短的计划

598
00:28:34,860 --> 00:28:37,130
您希望开箱即用。 

599
00:28:37,130 --> 00:28:40,230
所以我将继续包括熟悉的cs50.h. 

600
00:28:40,230 --> 00:28:42,540
我要去包括stdio.h。 

601
00:28:42,540 --> 00:28:44,710
我要继续做主要的虚空。 

602
00:28:44,710 --> 00:28:46,390
我要继续前进到这里 - 

603
00:28:46,390 --> 00:28:49,800
让我用一个名为i的变量来使用用户的get_int， 

604
00:28:49,800 --> 00:28:51,750
并且只是提示他们。 

605
00:28:51,750 --> 00:28:55,080
让我继续，然后提示用户另一个get_int。 

606
00:28:55,080 --> 00:28:57,292
我们称之为j并从中得到它。 

607
00:28:57,292 --> 00:28:59,000
然后让我们比较一下这些事情。 

608
00:28:59,000 --> 00:29:03,120
所以，如果我等于j，那么继续打印出来

609
00:29:03,120 --> 00:29:05,730
与printf相同和一个新的行。 

610
00:29:05,730 --> 00:29:10,870
然后继续打印相反的，这是不同的。 

611
00:29:10,870 --> 00:29:13,920
所以，我认为我唯一可能搞砸的地方， 

612
00:29:13,920 --> 00:29:16,200
如果我这样做，如果你这是合理的

613
00:29:16,200 --> 00:29:17,783
进来知道什么是等号。 

614
00:29:17,783 --> 00:29:20,250
但同样，在代码中，我们通常需要两个相同的符号

615
00:29:20,250 --> 00:29:21,710
因为它比较了两个值。 

616
00:29:21,710 --> 00:29:24,750
所以我没有犯这个错误，我对此感觉非常好。 

617
00:29:24,750 --> 00:29:28,170
让我用Command-S或Control-S或通过File保存它， 

618
00:29:28,170 --> 00:29:31,840
保存;转到我的提示并运行make compare0。 

619
00:29:31,840 --> 00:29:33,450
好，一切都编译好了。 

620
00:29:33,450 --> 00:29:38,760
让我继续，运行compare0，回车，然后输入50， 

621
00:29:38,760 --> 00:29:42,240
我输入50，他们似乎是一样的。 

622
00:29:42,240 --> 00:29:46,532
让我继续这样做，让我们输入42和13， 

623
00:29:46,532 --> 00:29:47,490
他们是不同的。 

624
00:29:47,490 --> 00:29:50,698
我应该测试一些，也许是一些负面的价值，也许是一些

625
00:29:50,698 --> 00:29:52,609
0，正值等，但我是

626
00:29:52,609 --> 00:29:54,900
对这段代码的正确性感觉很好。 

627
00:29:54,900 --> 00:29:55,500
行。 

628
00:29:55,500 --> 00:29:57,214
所以让我们改变一下这个程序吧。 

629
00:29:57,214 --> 00:29:59,130
让我继续创建另一个文件

630
00:29:59,130 --> 00:30:02,470
我可以使用小绿色加或通过文件，新文件。 

631
00:30:02,470 --> 00:30:04,670
我将继续将此作为compare1.c保存。 

632
00:30:04,670 --> 00:30:08,880
目前我将继续并粘贴代码

633
00:30:08,880 --> 00:30:11,340
从以前开始，但我现在要做一些改变。 

634
00:30:11,340 --> 00:30:16,170
我将继续重命名并将我的数据类型重新键入为字符串。 

635
00:30:16,170 --> 00:30:18,840
所以给我一个名为s的字符串，并提示用户

636
00:30:18,840 --> 00:30:21,000
为了使用get_string，那我就走了

637
00:30:21,000 --> 00:30:23,880
继续将此1更改为字符串t， 

638
00:30:23,880 --> 00:30:25,860
我要继续前进并获得get_string。 

639
00:30:25,860 --> 00:30:30,180
当然，我现在需要比较s和t，而不是i和j。 

640
00:30:30,180 --> 00:30:33,510
s是字符串的常见变量名。在s之后， 

641
00:30:33,510 --> 00:30:36,860
所以这也很合理，但我当然应该更新它。 

642
00:30:36,860 --> 00:30:39,390
所以我认为现在一切都在逻辑上相同。 

643
00:30:39,390 --> 00:30:41,940
我只是改变了我的数据类型和变量名。 

644
00:30:41,940 --> 00:30:42,930
所以我保存了这个。 

645
00:30:42,930 --> 00:30:45,380
让我继续并运行make compare1。 

646
00:30:45,380 --> 00:30:47,110
好的，一切都是正确的。 

647
00:30:47,110 --> 00:30:51,630
让我继续做./compare1。 

648
00:30:51,630 --> 00:30:56,280
让我继续，输入Brian和Veronica。 

649
00:30:56,280 --> 00:30:58,380
当然，那些是不同的。 

650
00:30:58,380 --> 00:31:01,770
现在让我继续输入大卫，让我再次输入大卫， 

651
00:31:01,770 --> 00:31:05,591
那些当然是不同的？ 

652
00:31:05,591 --> 00:31:06,090
呵呵。 

653
00:31:06,090 --> 00:31:08,470
也许是因为我只是按空格键或其他东西。 

654
00:31:08,470 --> 00:31:11,554
让我们试试艾琳吧。 

655
00:31:11,554 --> 00:31:12,720
她的名字有点短。 

656
00:31:12,720 --> 00:31:13,800
嗯。 

657
00:31:13,800 --> 00:31:16,530
好吧，让我们试试 - 哦，她叫什么名字？ 

658
00:31:16,530 --> 00:31:17,040
TJ。 

659
00:31:17,040 --> 00:31:19,000
好的，甚至更短，更完美。 

660
00:31:19,000 --> 00:31:21,281
TJ，不能出错。 

661
00:31:21,281 --> 00:31:21,780
不同。 

662
00:31:21,780 --> 00:31:23,140
我的意思是，发生了什么？ 

663
00:31:23,140 --> 00:31:25,590
我只想说我，我。 

664
00:31:25,590 --> 00:31:27,010
不同？ 

665
00:31:27,010 --> 00:31:29,650
那么这个程序中的逻辑错误在哪里？ 

666
00:31:34,070 --> 00:31:36,460
这是怎么回事？ 

667
00:31:36,460 --> 00:31:37,482
是的，你觉得怎么样？ 

668
00:31:37,482 --> 00:31:39,190
听众：是否比较整数值？ 

669
00:31:39,190 --> 00:31:40,570
DAVID MALAN：它是否比较整数值？ 

670
00:31:40,570 --> 00:31:41,140
也许。 

671
00:31:41,140 --> 00:31:43,150
我的意思是，到目前为止，我们使用了平等

672
00:31:43,150 --> 00:31:45,520
我们可能主要用它来比较整数， 

673
00:31:45,520 --> 00:31:47,560
所以也许我只是在滥用它，当然。 

674
00:31:47,560 --> 00:31:48,862
其他想法？ 

675
00:31:48,862 --> 00:31:51,687
听众：[听不清] 

676
00:31:51,687 --> 00:31:54,770
大卫马兰：哦，这是一个很重要的词，我们将在一点点内达到。 

677
00:31:54,770 --> 00:31:58,240
但是正确，正确 - 但是出于非常相似的原因。 

678
00:31:58,240 --> 00:32:02,650
所以事情在逻辑上涉及比较， 

679
00:32:02,650 --> 00:32:06,580
因为我使用的是相等的，但也许我正在使用它来处理错误的数据类型？ 

680
00:32:06,580 --> 00:32:09,580
我的意思是，它显然已被打破。 

681
00:32:09,580 --> 00:32:11,890
那么为什么会这样呢？ 

682
00:32:11,890 --> 00:32:16,450
事实证明，字符串实际上并不存在。 

683
00:32:16,450 --> 00:32:19,150
所以我们知道的字符串只是一系列字符

684
00:32:19,150 --> 00:32:22,720
或者字符数组不是实际的数据类型。 

685
00:32:22,720 --> 00:32:27,440
int是，float是，double是，long是，bool是，甚至更多

686
00:32:27,440 --> 00:32:28,870
是实际的数据类型。 

687
00:32:28,870 --> 00:32:30,970
字符串是我们的一点点白色谎言

688
00:32:30,970 --> 00:32:35,170
几个星期以来，它只在CS50库中实现。 

689
00:32:35,170 --> 00:32:37,350
现在字串在编程中非常常见。 

690
00:32:37,350 --> 00:32:40,516
像每个程序员一样，当你说字符串时，你会知道你的意思。 

691
00:32:40,516 --> 00:32:44,740
这不是CS50，但我们在C中使用它是CS50特有的。 

692
00:32:44,740 --> 00:32:47,590
因为在那个名为cs50.h的文件中

693
00:32:47,590 --> 00:32:50,290
声明get_string和get_int以及get_float等函数

694
00:32:50,290 --> 00:32:53,860
还有其他一些东西，我们还有一条特殊的线说， 

695
00:32:53,860 --> 00:32:57,760
创建一个名为string的数据类型。 

696
00:32:57,760 --> 00:33:00,860
但它实际上做了什么或者它实际意味着什么？ 

697
00:33:00,860 --> 00:33:04,090
好吧，让我们继续思考可能会发生什么事情

698
00:33:04,090 --> 00:33:04,850
这里。 

699
00:33:04,850 --> 00:33:08,950
所以，如果我继续绘制我们刚才的程序

700
00:33:08,950 --> 00:33:12,490
运行，程序compare1从用户获取一个字符串s， 

701
00:33:12,490 --> 00:33:15,730
然后从用户获取一个字符串t，然后比较它们。 

702
00:33:15,730 --> 00:33:18,500
所以我们从上周知道字符串是什么，它只是一个数组。 

703
00:33:18,500 --> 00:33:22,520
所以当我运行第一行代码并从用户那里获取一个字符串时 - 

704
00:33:22,520 --> 00:33:28,270
比如，Brian，我要去看看BRIAN， 

705
00:33:28,270 --> 00:33:33,415
我们从上周知道实际上是一个可能看起来的内存数组

706
00:33:33,415 --> 00:33:36,040
像这样的图像 - 这也是一个白色的谎言， 

707
00:33:36,040 --> 00:33:37,704
还有别的东西。 

708
00:33:37,704 --> 00:33:38,560
听众：空。 

709
00:33:38,560 --> 00:33:41,350
DAVID MALAN：是的，可以这么说，null字符和ul， 

710
00:33:41,350 --> 00:33:45,540
我们通常只用反斜杠0编写，这只是全0位。 

711
00:33:45,540 --> 00:33:49,390
事实证明，你可能还记得早些时候的调试器，你看到了这个 - 

712
00:33:49,390 --> 00:33:52,480
这是表达空字符的更加神秘的方式， 

713
00:33:52,480 --> 00:33:53,350
反斜杠0。 

714
00:33:53,350 --> 00:33:55,940
只是不同的程序以不同的方式显示它。 

715
00:33:55,940 --> 00:34:00,200
因此，当我使用get_string并输入Brian时，这就是在内存中分配的内容。 

716
00:34:00,200 --> 00:34:05,922
当我输入Veronica时，我可以看到一个VERONICA。 

717
00:34:05,922 --> 00:34:07,630
我会先发制人地做到这一点。 

718
00:34:07,630 --> 00:34:08,850
反斜杠0。 

719
00:34:08,850 --> 00:34:12,190
那也是一块记忆，我会这样画。 

720
00:34:12,190 --> 00:34:16,989
1,2，并将它们分成间隔字符或字节。 

721
00:34:16,989 --> 00:34:20,380
从上次回忆起这些字节只是来自我的记忆， 

722
00:34:20,380 --> 00:34:23,469
并且内存中只有一堆字节，可能是数百万甚至是

723
00:34:23,469 --> 00:34:24,699
这些天数十亿。 

724
00:34:24,699 --> 00:34:26,830
老实说，如果你有这么多东西， 

725
00:34:26,830 --> 00:34:29,290
任何人或计算机都可以编号。 

726
00:34:29,290 --> 00:34:31,600
像这样是字节1,2,3,4。 

727
00:34:31,600 --> 00:34:34,030
所以我们只是为了讨论而假设

728
00:34:34,030 --> 00:34:36,610
脱离我的电脑硬件的背景， 

729
00:34:36,610 --> 00:34:46,659
Brian刚刚到达位置100，位置101和102,103,104,105。 

730
00:34:46,659 --> 00:34:49,179
所以这是我电脑里的第100个字节， 

731
00:34:49,179 --> 00:34:51,310
这是我计算机中的第105个字节，而Brian 

732
00:34:51,310 --> 00:34:53,100
总共使用了那么多字符。 

733
00:34:53,100 --> 00:34:55,030
维罗妮卡，她最终到了别的地方。 

734
00:34:55,030 --> 00:35:02,710
也许她因为位置900,901,902,903而离得更远了， 

735
00:35:02,710 --> 00:35:09,910
904,905,906--更多的记忆，907和908-- 

736
00:35:09,910 --> 00:35:14,010
但是你现在可以更直观地看到布莱恩的名字长度 - 

737
00:35:14,010 --> 00:35:18,398
布莱恩的strlen是什么？ 

738
00:35:18,398 --> 00:35:21,230
听众：[听不清] 

739
00:35:21,230 --> 00:35:22,950
大卫马兰：我听到五个，我听到六个。 

740
00:35:22,950 --> 00:35:24,330
布赖恩的名字长度 - 

741
00:35:24,330 --> 00:35:25,835
布莱恩，你的名字有多长？ 

742
00:35:25,835 --> 00:35:26,460
听众：五。 

743
00:35:26,460 --> 00:35:28,834
大卫马兰：好的，这肯定是五个字符

744
00:35:28,834 --> 00:35:31,530
是Brian的名字的长度，但你有

745
00:35:31,530 --> 00:35:35,370
要知道在计算机中，布莱恩的五个角色确实存在

746
00:35:35,370 --> 00:35:36,270
占用六个字节。 

747
00:35:36,270 --> 00:35:39,750
所以这两个答案都是正确的，但是字符串的长度从此开始

748
00:35:39,750 --> 00:35:41,700
始终是实际字符的数量。 

749
00:35:41,700 --> 00:35:45,720
它占用的空间量是空字符加1。 

750
00:35:45,720 --> 00:35:49,710
所以你实际上可以看到为什么Brian的名字在这张图片中占据了六个字节

751
00:35:49,710 --> 00:35:52,380
而不仅仅是实际长度，即五。 

752
00:35:52,380 --> 00:35:55,620
所以当你现在调用get_string时，以及当你调用时

753
00:35:55,620 --> 00:35:57,480
get_string并获取另一个字符串 - 

754
00:35:57,480 --> 00:36:01,740
布莱恩和维罗妮卡分别是什么实际上被交回来了？ 

755
00:36:01,740 --> 00:36:04,350
几周前，艾琳出现了，她有点喜欢

756
00:36:04,350 --> 00:36:07,200
递给我一个字符串，一个来自观众的学生的名字。 

757
00:36:07,200 --> 00:36:11,970
在那张纸上，我们认为是学生的名字。 

758
00:36:11,970 --> 00:36:13,030
但事实并非如此。 

759
00:36:13,030 --> 00:36:15,750
事实证明，当函数返回一个值时， 

760
00:36:15,750 --> 00:36:20,310
它几乎只返回1个字节或2或4个字节。 

761
00:36:20,310 --> 00:36:25,450
它不能返回任意数量的字节，如布莱恩为6或者为1,2,3， 

762
00:36:25,450 --> 00:36:29,460
4,5,6,7,8,9--它不能为Veronica返回9个字节。 

763
00:36:29,460 --> 00:36:32,850
如果您甚至键入整个段落或页面的文本， 

764
00:36:32,850 --> 00:36:37,600
它无法返回所有文本，它只能返回单个值。 

765
00:36:37,600 --> 00:36:40,440
所以你早先的直觉，实际上可能是什么

766
00:36:40,440 --> 00:36:44,730
当人类拥有时，会被get_string返回

767
00:36:44,730 --> 00:36:47,726
输入像Brian或Veronica这样的名字？ 

768
00:36:47,726 --> 00:36:49,495
听众：[听不清] 

769
00:36:49,495 --> 00:36:50,870
DAVID MALAN：记忆位置。 

770
00:36:50,870 --> 00:36:53,510
的确，一个整数，或者你所说的指针， 

771
00:36:53,510 --> 00:36:55,770
我们将在短时间内更正式地介绍。 

772
00:36:55,770 --> 00:36:58,820
所以当get_string字符串返回“Brian”时，quote-unquote， 

773
00:36:58,820 --> 00:37:05,570
它实际上没有返回BRIAN反斜杠0，它只是返回100。 

774
00:37:05,570 --> 00:37:08,360
当get_string返回Veronica时，它没有返回她的名字， 

775
00:37:08,360 --> 00:37:10,580
它返回900。 

776
00:37:10,580 --> 00:37:13,780
所以，如果你现在意识到，当你这样做的时候

777
00:37:13,780 --> 00:37:19,820
等于平等，你实际上问的问题更平常吗？ 

778
00:37:19,820 --> 00:37:20,960
是啊。 

779
00:37:20,960 --> 00:37:24,200
内存位置和内存位置 -  100等于900？ 

780
00:37:24,200 --> 00:37:25,670
显然不是。 

781
00:37:25,670 --> 00:37:28,680
所以这就是为什么Brian的名字，Veronica的名字， 

782
00:37:28,680 --> 00:37:32,870
我的名字，TJ的名字 - 我输入的每个字当然都不同， 

783
00:37:32,870 --> 00:37:36,560
因为每个输入都在内存中的不同位置结束。 

784
00:37:36,560 --> 00:37:40,509
即使我两次输入像大卫这样的同一个词，一个大卫也会去这里， 

785
00:37:40,509 --> 00:37:42,800
一个大卫去了别的地方，他们结束了

786
00:37:42,800 --> 00:37:44,050
在不同的记忆位置。 

787
00:37:44,050 --> 00:37:46,460
也许100，也许900，也许别的东西， 

788
00:37:46,460 --> 00:37:48,920
但他们最终在记忆中的不同位置。 

789
00:37:48,920 --> 00:37:51,890
所以equ-equals比较值，但是该死

790
00:37:51,890 --> 00:37:54,280
如果不是比较错误的值。 

791
00:37:54,280 --> 00:37:54,780
是吗？ 

792
00:37:54,780 --> 00:37:56,907
听众：如果你使用一些char * s怎么办？ 

793
00:37:56,907 --> 00:37:58,740
大卫马兰：啊，我们会再回过头来看看。 

794
00:37:58,740 --> 00:38:00,490
让我回过头来看看。 

795
00:38:00,490 --> 00:38:02,689
char *实际上是错综复杂的。 

796
00:38:02,689 --> 00:38:03,730
稍后详细介绍。 

797
00:38:03,730 --> 00:38:04,230
是吗？ 

798
00:38:04,230 --> 00:38:06,170
听众：如果在内存中添加两个整数 - 

799
00:38:06,170 --> 00:38:06,658
大卫马兰：嗯？ 

800
00:38:06,658 --> 00:38:09,098
听众：他们不会在记忆的不同地方吗？ 

801
00:38:09,098 --> 00:38:11,050
所以你会回来 - 

802
00:38:11,050 --> 00:38:12,727
所以你需要一个不同的价值。 

803
00:38:12,727 --> 00:38:14,310
大卫马兰：好的，非常好的问题。 

804
00:38:14,310 --> 00:38:19,700
所以等一下，同样的逻辑，我正在返回一些东西的地址

805
00:38:19,700 --> 00:38:23,750
肯定也适用于整数或浮点数值？ 

806
00:38:23,750 --> 00:38:25,910
因为如果我像我一样输入数字50 

807
00:38:25,910 --> 00:38:29,960
早些时候，那也是在记忆中的某个地方 - 就像记忆中的盒子一样， 

808
00:38:29,960 --> 00:38:32,780
而且，在内存中的某个地方也有一个地址， 

809
00:38:32,780 --> 00:38:36,135
但事实证明，出于你刚才提到的原因， 

810
00:38:36,135 --> 00:38:38,540
int将作为其值返回。 

811
00:38:38,540 --> 00:38:40,740
字符作为其值返回。 

812
00:38:40,740 --> 00:38:42,200
Bools作为其值返回。 

813
00:38:42,200 --> 00:38:43,700
浮动作为其值返回。 

814
00:38:43,700 --> 00:38:45,260
字符串是不同的。 

815
00:38:45,260 --> 00:38:48,920
字符串由其地址返回。 

816
00:38:48,920 --> 00:38:54,080
事实证明，这些地址最终将被调用

817
00:38:54,080 --> 00:38:56,700
char *，我们稍后会看到。 

818
00:38:56,700 --> 00:38:59,780
那么我们如何从根本上解决这个问题呢？ 

819
00:38:59,780 --> 00:39:03,170
就像你不知道如何编码它一样，直观地说， 

820
00:39:03,170 --> 00:39:06,030
如果我确实想要删除 - 

821
00:39:06,030 --> 00:39:09,670
如果我真的想比较 - 

822
00:39:09,670 --> 00:39:10,170
抱歉。 

823
00:39:13,530 --> 00:39:14,050
好。 

824
00:39:14,050 --> 00:39:19,180
如果我想继续比较Brian和Veronica的平等， 

825
00:39:19,180 --> 00:39:21,370
我想直观地做什么？ 

826
00:39:21,370 --> 00:39:23,050
我不能只是比较他们的地址。 

827
00:39:23,050 --> 00:39:25,872
我需要做什么？ 

828
00:39:25,872 --> 00:39:27,955
隔离字符然后用它们做什么？ 

829
00:39:27,955 --> 00:39:30,820
听众：[听不清] 

830
00:39:30,820 --> 00:39:31,570
大卫马兰：很好。 

831
00:39:31,570 --> 00:39:32,445
是的，良好的直觉。 

832
00:39:32,445 --> 00:39:35,260
使用for循环，使用while循环 - 任何类型的循环结构。 

833
00:39:35,260 --> 00:39:37,184
直观地说，比较第一个字符， 

834
00:39:37,184 --> 00:39:40,350
如果它们不同，那么我们就知道我们不需要再进一步了。 

835
00:39:40,350 --> 00:39:43,147
B不是V，所以这些名字肯定不同。 

836
00:39:43,147 --> 00:39:44,230
但在我的情况下怎么样？ 

837
00:39:44,230 --> 00:39:46,870
如果是大卫和大卫，你会比较前两个。 

838
00:39:46,870 --> 00:39:48,460
D和D是一样的。 

839
00:39:48,460 --> 00:39:50,710
比较后两个，A和A是相同的。 

840
00:39:50,710 --> 00:39:55,570
V和V，我和我，D和D，然后我最后会打什么？ 

841
00:39:55,570 --> 00:39:56,500
空字符。 

842
00:39:56,500 --> 00:39:58,660
我应该继续超越空角色吗？ 

843
00:39:58,660 --> 00:39:59,160
没有。 

844
00:39:59,160 --> 00:40:02,250
所以这就是字符串超级简单设计的美妙之处。 

845
00:40:02,250 --> 00:40:07,750
只要字符串由起始地址标识，只需字节即可

846
00:40:07,750 --> 00:40:10,390
在他们开始的时候，你仍然需要知道

847
00:40:10,390 --> 00:40:14,650
它们有多长，因为否则一个词的开头和结尾怎么办

848
00:40:14,650 --> 00:40:16,330
还有另一个词开头？ 

849
00:40:16,330 --> 00:40:20,320
所以我们上周作出的简单决定 - 几十年前的人类 - 

850
00:40:20,320 --> 00:40:25,600
用反斜杠0或全0来终止所有字符串是一个超级方便的技巧， 

851
00:40:25,600 --> 00:40:28,630
所以，如果我告诉你，Brian从100开始， 

852
00:40:28,630 --> 00:40:31,120
你可以推断他到底在哪里？ 

853
00:40:33,800 --> 00:40:37,400
在字节编号105或104，如果您愿意，但是您想要考虑它， 

854
00:40:37,400 --> 00:40:40,610
因为你需要在线性时间做所有事情， 

855
00:40:40,610 --> 00:40:43,640
如果你愿意，左或右，是检查 - 反斜杠0，反斜杠0--啊！ 

856
00:40:43,640 --> 00:40:46,790
反斜杠0，现在我知道Brian的名字有多长。 

857
00:40:46,790 --> 00:40:49,880
所以我们暂时考虑这个程序叫做字符串长度。 

858
00:40:49,880 --> 00:40:52,460
strlen实际上如何工作？ 

859
00:40:52,460 --> 00:40:57,140
当你传递给strlen时，一个包含字符串的变量，比如Brian， 

860
00:40:57,140 --> 00:41:00,299
什么是英镑可能在做什么？ 

861
00:41:00,299 --> 00:41:02,345
听众：[听不清] 

862
00:41:02,345 --> 00:41:03,220
大卫马兰：没错。 

863
00:41:03,220 --> 00:41:05,740
它正在查看该空字符的地址

864
00:41:05,740 --> 00:41:09,340
并减去起始地址和结束地址， 

865
00:41:09,340 --> 00:41:12,160
弄清楚差异是什么，并实际返回

866
00:41:12,160 --> 00:41:14,890
减去总数的1。 

867
00:41:14,890 --> 00:41:16,940
更机械地，我们马上就会看到， 

868
00:41:16,940 --> 00:41:19,090
它可能与我做的完全一样， 

869
00:41:19,090 --> 00:41:20,357
这是反斜杠0吗？ 

870
00:41:20,357 --> 00:41:21,190
这是反斜杠0吗？ 

871
00:41:21,190 --> 00:41:22,780
是这个，是这个吗？ 

872
00:41:22,780 --> 00:41:25,840
在我看到反斜杠0之前，我问了五次这个问题。 

873
00:41:25,840 --> 00:41:29,320
strlen只是人类多年前写的一个功能

874
00:41:29,320 --> 00:41:31,930
这可能只是一个简单的for循环和if条件， 

875
00:41:31,930 --> 00:41:33,220
然后就是这样。 

876
00:41:33,220 --> 00:41:35,320
因为那个人在我们之前就明白了

877
00:41:35,320 --> 00:41:39,050
是如何实际实现字符串的。 

878
00:41:39,050 --> 00:41:41,047
有问题吗？ 

879
00:41:41,047 --> 00:41:42,880
好吧，让我们实际实现这一点。 

880
00:41:42,880 --> 00:41:46,930
让我继续进入我的编辑器，并在此处再举一个例子

881
00:41:46,930 --> 00:41:48,730
我打算叫compare2。 

882
00:41:48,730 --> 00:41:55,150
我将继续包含cs50.h并包含stdio.h， 

883
00:41:55,150 --> 00:41:57,940
然后我要做主要的虚空，我就是

884
00:41:57,940 --> 00:42:03,040
快速进入现在从我获得字符串之前获取代码

885
00:42:03,040 --> 00:42:06,380
我比较了它们，但我必须明确地解决这个问题。 

886
00:42:06,380 --> 00:42:08,290
所以这是我以前的代码。 

887
00:42:08,290 --> 00:42:10,130
我会以正确的方式做到这一点。 

888
00:42:10,130 --> 00:42:14,630
我将在s和t中调用一个名为compare_strings的函数。 

889
00:42:14,630 --> 00:42:16,870
因为正如你所提议的那样，我们需要做一些逻辑。 

890
00:42:16,870 --> 00:42:18,910
我们不必将它传递给函数，但我们可以。 

891
00:42:18,910 --> 00:42:20,618
我们可以在这里做一个for循环，但我是

892
00:42:20,618 --> 00:42:23,600
将继续执行compare_strings，如下所示。 

893
00:42:23,600 --> 00:42:28,150
如果我想编写一个返回yes / no回答的函数，那么是什么数据类型

894
00:42:28,150 --> 00:42:29,890
它会回来吗？ 

895
00:42:29,890 --> 00:42:30,490
一个布尔。 

896
00:42:30,490 --> 00:42:32,800
所以我们还没有必要这样做，但是你

897
00:42:32,800 --> 00:42:36,280
可以返回一个bool就像你可以int或char或其他东西。 

898
00:42:36,280 --> 00:42:38,500
我要调用这个函数compare_strings。 

899
00:42:38,500 --> 00:42:42,570
它将接受一个名为a的字符串和另一个名为b的字符串， 

900
00:42:42,570 --> 00:42:44,600
但我可以称之为我想要的任何东西。 

901
00:42:44,600 --> 00:42:47,740
现在最容易检查的是什么？ 

902
00:42:47,740 --> 00:42:50,812
如果我传两个字符串，a和b，或Brian和Veronica， 

903
00:42:50,812 --> 00:42:53,770
什么是你能提出的最简单的问题，并且马上说，不， 

904
00:42:53,770 --> 00:42:55,235
这些是不同的？ 

905
00:42:55,235 --> 00:42:56,110
字符串长度，对吗？ 

906
00:42:56,110 --> 00:43:00,190
就像BRIAN与Veronica的名字不一样， 

907
00:43:00,190 --> 00:43:02,830
除此之外，我们不需要做任何逻辑， 

908
00:43:02,830 --> 00:43:04,542
我们可以放弃并说错。 

909
00:43:04,542 --> 00:43:05,500
所以，让我这样做。 

910
00:43:05,500 --> 00:43:10,430
如果a的strlen不等于b的strlen，你知道吗？ 

911
00:43:10,430 --> 00:43:13,300
让我们继续前进并返回false并离开这里。 

912
00:43:13,300 --> 00:43:17,200
好的，但现在，如果我们通过那个网关，可以这么说， 

913
00:43:17,200 --> 00:43:19,780
检查，那个问题，那个布尔表达式， 

914
00:43:19,780 --> 00:43:23,182
现在我必须逐字逐句地比较事物。 

915
00:43:23,182 --> 00:43:26,390
所以我可以通过多种方式实现这一点，但我喜欢for循环的建议。 

916
00:43:26,390 --> 00:43:30,610
所以对于int i为0，n为效率 - 实际上， 

917
00:43:30,610 --> 00:43:33,720
让我做的是小于字符串长度 - 

918
00:43:33,720 --> 00:43:36,825
我应该做a或b的字符串长度吗？ 

919
00:43:36,825 --> 00:43:38,380
这没关系，对吧？ 

920
00:43:38,380 --> 00:43:39,430
让我们一起来吧。 

921
00:43:39,430 --> 00:43:41,560
坦率地说，如果我早期很聪明，我

922
00:43:41,560 --> 00:43:44,110
可以将值存储在变量中，然后重用它， 

923
00:43:44,110 --> 00:43:45,820
但我们现在就继续前进。 

924
00:43:45,820 --> 00:43:48,590
然后我再加上，但我记得上次 - 这是正确的， 

925
00:43:48,590 --> 00:43:49,710
但这不是好设计。 

926
00:43:49,710 --> 00:43:50,209
为什么？ 

927
00:43:52,772 --> 00:43:55,980
是的，我一次又一次地打电话给strlen，因为记得，在for循环中， 

928
00:43:55,980 --> 00:43:58,110
一次又一次地检查这种情况

929
00:43:58,110 --> 00:44:00,160
再一次 - 你只是在浪费自己的时间。 

930
00:44:00,160 --> 00:44:02,970
所以让我继续，实际上这样做。 

931
00:44:02,970 --> 00:44:09,270
n或任何变量等于a的strlen，然后只需将i与n进行比较， 

932
00:44:09,270 --> 00:44:12,960
因为现在我正在增加，但是n永远不会改变。 

933
00:44:12,960 --> 00:44:15,250
所以现在让我继续实现这个循环。 

934
00:44:15,250 --> 00:44:21,510
所以，如果 -  a的第i个字符与第i个字符不相等

935
00:44:21,510 --> 00:44:24,780
b，我可以立即得出结论 - 

936
00:44:24,780 --> 00:44:28,410
不，这些字符串不能相同，因为有些字母，就像一个B， 

937
00:44:28,410 --> 00:44:31,440
与另一个不同，就像V，或者我们实际上的任何字母

938
00:44:31,440 --> 00:44:32,580
比较。 

939
00:44:32,580 --> 00:44:34,380
然后我认为就是这样。 

940
00:44:34,380 --> 00:44:37,590
如果我遇到这些问题 - 

941
00:44:37,590 --> 00:44:38,850
你的长度不同吗？ 

942
00:44:38,850 --> 00:44:40,100
你的角色不一样吗？ 

943
00:44:40,100 --> 00:44:45,370
我仍然没有说错，我应该默认返回什么？ 

944
00:44:45,370 --> 00:44:45,870
是啊。 

945
00:44:45,870 --> 00:44:49,060
就像你通过所有这些问题并且一切都很好， 

946
00:44:49,060 --> 00:44:54,040
大卫必须确实等于大卫或其他任何用户

947
00:44:54,040 --> 00:44:54,920
键入。 

948
00:44:54,920 --> 00:44:56,140
现在我还没完成。 

949
00:44:56,140 --> 00:44:58,780
当我实现了函数或辅助函数时

950
00:44:58,780 --> 00:45:01,030
像这样，因为它帮助我做我的工作， 

951
00:45:01,030 --> 00:45:02,680
还有什么我必须添加到文件？ 

952
00:45:02,680 --> 00:45:03,077
哦？ 

953
00:45:03,077 --> 00:45:04,270
听众：我有一个合乎逻辑的问题。 

954
00:45:04,270 --> 00:45:05,020
大卫马兰：当然。 

955
00:45:05,020 --> 00:45:08,642
听众：在电脑里，你不能用大写字母D输入大卫

956
00:45:08,642 --> 00:45:11,546
然后用小写的d大卫，你要跑[听不清] ,, 

957
00:45:11,546 --> 00:45:12,914
他们不会同步，因为你的第一个角色不是

958
00:45:12,914 --> 00:45:13,785
同一个角色。 

959
00:45:13,785 --> 00:45:14,660
大卫马兰：正确。 

960
00:45:14,660 --> 00:45:17,240
所以这是一个功能，而不是目前的错误。 

961
00:45:17,240 --> 00:45:20,040
我的程序目前是区分大小写的。 

962
00:45:20,040 --> 00:45:22,790
如果我输入DAVID和所有大写字母，那就是不同的字符串

963
00:45:22,790 --> 00:45:25,460
我声称现在比大卫全部小写。 

964
00:45:25,460 --> 00:45:27,590
如果你想容忍大写和小写， 

965
00:45:27,590 --> 00:45:29,090
你必须添加更多的逻辑。 

966
00:45:29,090 --> 00:45:32,460
但是现在这是我想要的设计决定。 

967
00:45:32,460 --> 00:45:32,960
行。 

968
00:45:32,960 --> 00:45:36,540
我还需要在程序中添加什么？ 

969
00:45:36,540 --> 00:45:38,057
是的，原型在顶部。 

970
00:45:38,057 --> 00:45:41,140
您可以逐字复制和粘贴 - 这是复制和粘贴的唯一时间

971
00:45:41,140 --> 00:45:43,210
可能是合法的事情 - 

972
00:45:43,210 --> 00:45:45,880
在顶部，然后是分号 - 不要重新实施它。 

973
00:45:45,880 --> 00:45:48,550
但我确实需要另一个头文件。 

974
00:45:48,550 --> 00:45:54,740
我正在使用不在cs50.h或stdio.h中的函数。 

975
00:45:54,740 --> 00:45:56,900
字符串长度？ 

976
00:45:56,900 --> 00:45:58,630
字符串长度在哪里？ 

977
00:45:58,630 --> 00:45:59,840
是的，string.h。 

978
00:45:59,840 --> 00:46:03,460
所以我只需要这个，包括string.h，save。 

979
00:46:03,460 --> 00:46:05,510
现在我认为这是正确的。 

980
00:46:05,510 --> 00:46:08,190
我们会看看我是否会在一瞬间吃掉这个词。 

981
00:46:08,190 --> 00:46:10,700
但要意识到如果你自己编写这段代码， 

982
00:46:10,700 --> 00:46:13,940
这样在办公时间编写程序并不是一件很自然的事情

983
00:46:13,940 --> 00:46:16,648
或者在宿舍的家里，第一次就把它弄好。 

984
00:46:16,648 --> 00:46:19,970
经过20年的努力，我们才意识到 - 

985
00:46:19,970 --> 00:46:21,720
而且我这里也有一张备忘单 - 

986
00:46:21,720 --> 00:46:23,750
我们碰巧经常这样做， 

987
00:46:23,750 --> 00:46:26,010
但意识到这不会是常见的情况。 

988
00:46:26,010 --> 00:46:28,490
所以，考虑到这种保证，让我们看看

989
00:46:28,490 --> 00:46:33,140
如果我现在必须把所有这些拿回来。比较2。 

990
00:46:33,140 --> 00:46:33,860
好的 -  p。 

991
00:46:33,860 --> 00:46:34,700
20年了。 

992
00:46:34,700 --> 00:46:37,940
所以现在我要继续./compare2。 

993
00:46:37,940 --> 00:46:40,850
让我们输入Brian，让我们输入Veronica。 

994
00:46:40,850 --> 00:46:42,800
这些确实仍然有所不同。 

995
00:46:42,800 --> 00:46:45,680
现在让我们试试自己，大卫和大卫。 

996
00:46:45,680 --> 00:46:46,539
唷！ 

997
00:46:46,539 --> 00:46:47,330
那些是一样的。 

998
00:46:47,330 --> 00:46:52,550
在你的观点，大卫在大写，大卫全部小写， 

999
00:46:52,550 --> 00:46:56,780
不同，但这就是我现在的期望。 

1000
00:46:56,780 --> 00:46:58,071
有关compare2的任何问题吗？ 

1001
00:46:58,071 --> 00:46:58,571
是吗？ 

1002
00:46:58,571 --> 00:47:01,833
听众：[听不清] 

1003
00:47:01,833 --> 00:47:02,499
大卫马兰：好的。 

1004
00:47:02,499 --> 00:47:06,743
听众：程序中的[听不清]字符串。 

1005
00:47:06,743 --> 00:47:07,409
大卫马兰：好的。 

1006
00:47:07,409 --> 00:47:10,207
听众：这仍然有用[听不清] 

1007
00:47:10,207 --> 00:47:12,290
大卫·马兰：如果你要对字符串进行硬编码？ 

1008
00:47:12,290 --> 00:47:14,000
简而言之，是的，这仍然有效。 

1009
00:47:14,000 --> 00:47:19,160
如果你出于某种原因没有这样做并使用get_string， 

1010
00:47:19,160 --> 00:47:25,100
但你做了大卫，在这里，比如大卫，这也会起作用。 

1011
00:47:25,100 --> 00:47:28,088
无论您的错误是什么，如果您可以重新创建它，请告诉我们。 

1012
00:47:28,088 --> 00:47:31,574
听众：它似乎就像一根绳子会增加

1013
00:47:31,574 --> 00:47:33,566
对于只有[听不清]的一套？ 

1014
00:47:33,566 --> 00:47:36,557
并且它在小[[听不清]中有问题.. 

1015
00:47:36,557 --> 00:47:39,390
大卫马兰：我必须看到它确定，但很高兴聊天。 

1016
00:47:39,390 --> 00:47:42,090
好吧，让我们看看我们现在是不是可以清理它

1017
00:47:42,090 --> 00:47:45,790
如下所示。 

1018
00:47:45,790 --> 00:47:51,160
让我继续这里，揭示实际发生的事情。 

1019
00:47:51,160 --> 00:47:53,997
确实，没有字符串这样的东西。 

1020
00:47:53,997 --> 00:47:55,830
事实上，正如你刚才指出的那样， 

1021
00:47:55,830 --> 00:47:57,371
它实际上是一个不同的名称。 

1022
00:47:57,371 --> 00:48:01,150
String只是所谓char *的同义词。 

1023
00:48:01,150 --> 00:48:02,440
那现在甚至意味着什么？ 

1024
00:48:02,440 --> 00:48:04,106
所以char就像往常一样。 

1025
00:48:04,106 --> 00:48:05,160
这是一个单一的角色。 

1026
00:48:05,160 --> 00:48:09,820
用C编写的程序中的明星当然可以意味着乘法， 

1027
00:48:09,820 --> 00:48:10,650
我们已经看到了。 

1028
00:48:10,650 --> 00:48:12,270
这是明星的另一种用途。 

1029
00:48:12,270 --> 00:48:15,480
每当你看到像char这样的数据类型后， 

1030
00:48:15,480 --> 00:48:19,500
这意味着有问题的数据类型不仅仅是char， 

1031
00:48:19,500 --> 00:48:21,750
这是一个char的地址。 

1032
00:48:21,750 --> 00:48:25,330
所以星星只是指左边数据类型的地址， 

1033
00:48:25,330 --> 00:48:27,330
正如你先前所指出的那样，这是什么

1034
00:48:27,330 --> 00:48:29,170
我们要开始调用指针。 

1035
00:48:29,170 --> 00:48:32,320
出于所有意图和目的，指针是地址。 

1036
00:48:32,320 --> 00:48:34,650
这只是描述地址的流行语。 

1037
00:48:34,650 --> 00:48:40,380
这里的数据类型char *表示我想要一个不存储char的变量， 

1038
00:48:40,380 --> 00:48:42,690
它存储了char的地址。 

1039
00:48:42,690 --> 00:48:45,360
数字100，数字900。 

1040
00:48:45,360 --> 00:48:48,330
但是这个地址才会被称为指针。 

1041
00:48:48,330 --> 00:48:52,440
指针变量是存储某事物地址的变量。 

1042
00:48:52,440 --> 00:48:54,850
char或甚至其他数据类型。 

1043
00:48:54,850 --> 00:49:00,720
所以考虑到这一点，让我实际上快速创建compare3.c，粘贴它

1044
00:49:00,720 --> 00:49:05,670
在，并保存为compare3.c，让我起飞，如果你愿意， 

1045
00:49:05,670 --> 00:49:06,750
那些训练轮。 

1046
00:49:06,750 --> 00:49:10,110
事实证明，当你得到一个带有get_string的字符串时， 

1047
00:49:10,110 --> 00:49:12,660
它本身不会返回一个字符串，因为

1048
00:49:12,660 --> 00:49:16,620
这个词在C中不存在，它实际上返回一个char *。 

1049
00:49:16,620 --> 00:49:19,905
当我在这里再次调用它并返回另一个字符串时，它也是

1050
00:49:19,905 --> 00:49:21,090
返回一个char *。 

1051
00:49:21,090 --> 00:49:24,190
从技术上讲，这颗恒星周围可以有空间。 

1052
00:49:24,190 --> 00:49:27,420
有些人这样写，但这是一种正确的方法

1053
00:49:27,420 --> 00:49:30,750
或者默认方式应该是将星形放在变量名称旁边

1054
00:49:30,750 --> 00:49:31,900
为清楚起见。 

1055
00:49:31,900 --> 00:49:33,870
所以我必须做一些其他的改变。 

1056
00:49:33,870 --> 00:49:37,770
这也应该改变，因为今天没有更多的字符串了。 

1057
00:49:37,770 --> 00:49:41,700
我要把它改成char *;然后我还需要在这里改变它， 

1058
00:49:41,700 --> 00:49:48,990
字符*;然后在这里，char *;那就是它。 

1059
00:49:48,990 --> 00:49:53,640
老实说，这是我们两周前没有介绍过这个的唯一原因

1060
00:49:53,640 --> 00:49:55,015
是因为它看起来很神秘。 

1061
00:49:55,015 --> 00:49:58,181
就像没有人想在他们第一次触摸键盘时编程一样

1062
00:49:58,181 --> 00:50:01,230
并编写代码并查看char *并需要担心这意味着什么， 

1063
00:50:01,230 --> 00:50:03,000
它只是一个概念上的字符串。 

1064
00:50:03,000 --> 00:50:06,450
但是我在技术上需要做出的唯一改变就是采取这些训练轮

1065
00:50:06,450 --> 00:50:11,139
off只是将字符串的所有提及更改为char *的数据类型。 

1066
00:50:11,139 --> 00:50:12,930
这只是意味着你知道什么 - 一个？ 

1067
00:50:12,930 --> 00:50:17,160
是的它是一个字符串，但从技术上讲它是一个字符串的地址。 

1068
00:50:17,160 --> 00:50:21,720
或者更确切地说，它是字符串的第一个字节的地址， 

1069
00:50:21,720 --> 00:50:25,170
对于Brian来说是100，对于Veronica来说是900，我甚至都不是

1070
00:50:25,170 --> 00:50:28,950
要告诉你字符串的结束，因为你，程序员， 

1071
00:50:28,950 --> 00:50:32,460
可以通过调用strlen或仅使用循环来解决这个问题

1072
00:50:32,460 --> 00:50:35,550
并找出实际上反斜杠0的位置。 

1073
00:50:35,550 --> 00:50:37,990
所以这是传递它的足够信息。 

1074
00:50:37,990 --> 00:50:41,910
所以，如果现在继续编译，请生成compare3， 

1075
00:50:41,910 --> 00:50:47,190
然后我继续做./compare3，让我们继续并输入Brian 

1076
00:50:47,190 --> 00:50:49,770
和Veronica，这些确实仍然不同。 

1077
00:50:49,770 --> 00:50:53,662
现在让我继续输入大卫和大卫，这些实际上是相同的。 

1078
00:50:53,662 --> 00:50:56,370
所以训练轮关闭，没有弦， 

1079
00:50:56,370 --> 00:50:57,560
从此它是一个char *。 

1080
00:50:57,560 --> 00:51:00,060
我们继续吧，快点休息五分钟， 

1081
00:51:00,060 --> 00:51:02,070
我们会回来再潜入更多。 

1082
00:51:02,070 --> 00:51:03,240
行。 

1083
00:51:03,240 --> 00:51:06,630
所以我们回来了，让我们继续简化这个， 

1084
00:51:06,630 --> 00:51:07,710
正如我们的倾向一样。 

1085
00:51:07,710 --> 00:51:09,450
这是一堆代码，但我认为

1086
00:51:09,450 --> 00:51:10,610
我们可以让它更紧凑。 

1087
00:51:10,610 --> 00:51:12,434
而不是手动输入这个， 

1088
00:51:12,434 --> 00:51:14,850
让我继续，然后打开我们预先制作的一个例子

1089
00:51:14,850 --> 00:51:18,840
从今天开始，这一切都在课程的网站上，名为compare4。 

1090
00:51:18,840 --> 00:51:21,540
你会在compare4中看到，就是这样。 

1091
00:51:21,540 --> 00:51:23,670
这次我只有一个主要功能。 

1092
00:51:23,670 --> 00:51:26,970
我已经摆脱了compare_strings函数，因为你知道什么？ 

1093
00:51:26,970 --> 00:51:29,600
我似乎在使用某种东西。 

1094
00:51:29,600 --> 00:51:33,090
我明显部署了什么功能？ 

1095
00:51:33,090 --> 00:51:35,640
是的，STRCMP，或者发音的人， 

1096
00:51:35,640 --> 00:51:37,830
只是str比较或strcmp。 

1097
00:51:37,830 --> 00:51:41,040
所以这就像strlen一样，也简洁明了， 

1098
00:51:41,040 --> 00:51:43,650
只是一个实际声明的函数

1099
00:51:43,650 --> 00:51:46,980
在我们熟悉的图书馆之一，string.h， 

1100
00:51:46,980 --> 00:51:49,960
如果你看一下手册页就可以了，可以这么说

1101
00:51:49,960 --> 00:51:53,025
通过键入man strcmp，或者如果你去CS50引用并且实际上

1102
00:51:53,025 --> 00:51:55,650
看看那里功能不太舒服的描述， 

1103
00:51:55,650 --> 00:51:57,733
这只是一个生活中唯一目的的功能

1104
00:51:57,733 --> 00:51:59,730
是为你比较字符串。 

1105
00:51:59,730 --> 00:52:01,899
但它的行为有点不同，因为它是

1106
00:52:01,899 --> 00:52:03,690
比我刚刚写的那个更加迷人。 

1107
00:52:03,690 --> 00:52:07,860
让我放大一下，你会在这里看到第14行，我

1108
00:52:07,860 --> 00:52:11,490
不是以同样的方式对待它。 

1109
00:52:11,490 --> 00:52:14,840
我的逻辑有点不同。 

1110
00:52:14,840 --> 00:52:20,102
这次我在布尔表达式中实际检查了什么？ 

1111
00:52:20,102 --> 00:52:21,459
听众：[听不清] 

1112
00:52:21,459 --> 00:52:23,250
大卫马兰：是的，这有点奇怪。 

1113
00:52:23,250 --> 00:52:28,860
我正在明确检查 - 如果strcmp的返回值等于0。 

1114
00:52:28,860 --> 00:52:33,140
在我刚才说过之前，如果是compare_strings的逗号

1115
00:52:33,140 --> 00:52:38,460
因为我期待一个布尔 - 无论是真还是假。 strcmp，有点奇怪， 

1116
00:52:38,460 --> 00:52:40,060
行为方式相反。 

1117
00:52:40,060 --> 00:52:43,380
事实证明，strcmp不会返回true和false。 

1118
00:52:43,380 --> 00:52:48,120
如果您阅读其文档，如果字符串相等，则返回0， 

1119
00:52:48,120 --> 00:52:52,120
但超级方便，它返回一个正值

1120
00:52:52,120 --> 00:52:56,190
如果s应该在t之前，它返回一个负值

1121
00:52:56,190 --> 00:52:59,950
如果s应该按字母顺序排在后面。 

1122
00:52:59,950 --> 00:53:03,270
所以事实证明你可以使用strcmp来比较相等， 

1123
00:53:03,270 --> 00:53:04,530
但不平等 - 

1124
00:53:04,530 --> 00:53:05,760
小于或等于 - 

1125
00:53:05,760 --> 00:53:08,880
小于或大于，可以这么说，按字母顺序， 

1126
00:53:08,880 --> 00:53:10,810
或者按照ASCII顺序，可以这么说。 

1127
00:53:10,810 --> 00:53:13,860
它实际上会逐字符地比较ASCII值， 

1128
00:53:13,860 --> 00:53:16,050
这将确保B来自A， 

1129
00:53:16,050 --> 00:53:18,430
和C来自B，依此类推。 

1130
00:53:18,430 --> 00:53:20,940
所以你实际上可以使用strcmp来排序字典， 

1131
00:53:20,940 --> 00:53:24,310
或者对iPhone或Android手机中的联系人进行排序。 

1132
00:53:24,310 --> 00:53:27,090
长话短说，这是我们可以使用的功能， 

1133
00:53:27,090 --> 00:53:30,120
我们不必重新发明这个轮子，因此，我们没有更多的代码

1134
00:53:30,120 --> 00:53:30,840
甚至在此之后。 

1135
00:53:30,840 --> 00:53:33,810
我们只需要正确使用它，在那里，文档

1136
00:53:33,810 --> 00:53:34,720
是你的朋友。 

1137
00:53:34,720 --> 00:53:37,770
所以，如果我运行这个程序，它将以完全相同的方式工作， 

1138
00:53:37,770 --> 00:53:40,590
但让我继续指出一些缺陷。 

1139
00:53:40,590 --> 00:53:44,820
结果一直都是这样，我的错误检查让我有点懒惰 - 

1140
00:53:44,820 --> 00:53:46,200
检查错误。 

1141
00:53:46,200 --> 00:53:49,635
在CS50的第1周，有很多事情可能出错

1142
00:53:49,635 --> 00:53:52,260
我们只是对此视而不见，因为它只会

1143
00:53:52,260 --> 00:53:56,091
膨胀我们的代码，使它更长，并且写起来不那么有趣和有趣

1144
00:53:56,091 --> 00:53:57,090
并且不太容易理解。 

1145
00:53:57,090 --> 00:53:59,776
但今天，既然我们知道实际发生了什么， 

1146
00:53:59,776 --> 00:54:01,650
我们可以开始提出一些其他问题

1147
00:54:01,650 --> 00:54:04,020
并使我们的代码更强大，更强大

1148
00:54:04,020 --> 00:54:05,820
事实上，没有任何事情会出错。 

1149
00:54:05,820 --> 00:54:08,940
事实证明，如果您在手册页中阅读了get_string的文档

1150
00:54:08,940 --> 00:54:11,880
或者在CS50参考中，结果是get_string 

1151
00:54:11,880 --> 00:54:14,010
确实会返回一个字符串 - 呃，不是真的。 

1152
00:54:14,010 --> 00:54:15,690
它返回一个字符串的地址。 

1153
00:54:15,690 --> 00:54:16,380
呃，不是真的。 

1154
00:54:16,380 --> 00:54:22,230
它从技术上返回字符串第一个字节的地址。 

1155
00:54:22,230 --> 00:54:26,700
但如果出现问题，它会返回一个名为null的特殊字符。 

1156
00:54:26,700 --> 00:54:32,230
不要与NUL混淆，它返回一个名为null的特殊地址 - 

1157
00:54:32,230 --> 00:54:34,510
几十年前，左手并没有用右手说话。 

1158
00:54:34,510 --> 00:54:41,100
所以null，NULL，只是意味着地址0，没有任何东西应该存在。 

1159
00:54:41,100 --> 00:54:44,190
这只是一个虚假的无效地址。 

1160
00:54:44,190 --> 00:54:49,200
只要get_string返回内存中字符串的地址， 

1161
00:54:49,200 --> 00:54:53,760
如果是get_string，那么对于Brian来说是100，对于Veronica来说是900， 

1162
00:54:53,760 --> 00:54:56,640
遇到问题，计算机出现问题， 

1163
00:54:56,640 --> 00:55:01,830
如果它返回0，特别是0，又名

1164
00:55:01,830 --> 00:55:07,470
null-- NULL，然后你可以检测到出错了。 

1165
00:55:07,470 --> 00:55:10,089
所以要做到这一点，它会变得有点单调乏味， 

1166
00:55:10,089 --> 00:55:11,880
但它仍然是正确的做法， 

1167
00:55:11,880 --> 00:55:14,430
我需要更加防守。 

1168
00:55:14,430 --> 00:55:21,270
如果s equals-等于null，也称为0，也称为0x0， 

1169
00:55:21,270 --> 00:55:23,160
但是我会按照惯例写这个， 

1170
00:55:23,160 --> 00:55:27,270
我将继续并返回1作为我的退出代码。 

1171
00:55:27,270 --> 00:55:32,370
如果t equals-等于null，我将继续并返回1作为我的退出代码， 

1172
00:55:32,370 --> 00:55:34,140
或者我可以返回2或3-- 

1173
00:55:34,140 --> 00:55:36,952
我只需要返回一些值来向计算机发出信号

1174
00:55:36,952 --> 00:55:38,910
出了什么问题，但默认我们会

1175
00:55:38,910 --> 00:55:43,410
每当出现问题时返回1，但如果一切顺利， 

1176
00:55:43,410 --> 00:55:44,910
我要继续前进并返回0。 

1177
00:55:44,910 --> 00:55:47,580
所以从上周再次回忆起来，我们并没有花费大量时间

1178
00:55:47,580 --> 00:55:48,300
在这 - 

1179
00:55:48,300 --> 00:55:50,340
main本身可以返回值。 

1180
00:55:50,340 --> 00:55:53,790
默认情况下，从第1周开始，如果你没有返回任何东西， 

1181
00:55:53,790 --> 00:55:58,200
main为你自动秘密返回0，因为0很好。 

1182
00:55:58,200 --> 00:56:02,079
0的原因是因为世界上只有一个0，显然， 

1183
00:56:02,079 --> 00:56:03,870
但是左边有一个无数的数字

1184
00:56:03,870 --> 00:56:06,900
并且有无数的正确，消极和积极的。 

1185
00:56:06,900 --> 00:56:09,340
这很好，因为你在过去几周已经经历过， 

1186
00:56:09,340 --> 00:56:11,640
感觉就像有无数的东西可能会出错

1187
00:56:11,640 --> 00:56:13,410
写甚至最短的节目。 

1188
00:56:13,410 --> 00:56:17,190
这意味着我们可以为错误代码分配很多数字， 

1189
00:56:17,190 --> 00:56:18,250
可以这么说。 

1190
00:56:18,250 --> 00:56:20,670
现在我真的不在乎错误代码是什么， 

1191
00:56:20,670 --> 00:56:23,340
所以我现在才会采用人类大会 - 

1192
00:56:23,340 --> 00:56:27,480
如果出现任何问题，则返回0以外的任何内容。 

1193
00:56:27,480 --> 00:56:31,650
所以我要在这里返回1，但如果没有出错，请返回0。 

1194
00:56:31,650 --> 00:56:36,720
这里的要点是通过在这里添加这三行和这三行

1195
00:56:36,720 --> 00:56:38,790
在这里，我要避免所谓的

1196
00:56:38,790 --> 00:56:42,210
分段错误或段错误。有没有人

1197
00:56:42,210 --> 00:56:43,590
遇到这个神秘的错误？ 

1198
00:56:43,590 --> 00:56:44,130
好。 

1199
00:56:44,130 --> 00:56:46,920
你这么多，如果你可能不知道这意味着什么， 

1200
00:56:46,920 --> 00:56:49,380
但从今天开始你会多一点，在接下来的几个星期里， 

1201
00:56:49,380 --> 00:56:50,790
你会明白的。 

1202
00:56:50,790 --> 00:56:54,690
分段错误意味着您触及了您不应该拥有的内存。 

1203
00:56:54,690 --> 00:56:58,050
或者出了什么问题，你没有发现它。 

1204
00:56:58,050 --> 00:57:01,320
对于与记忆相关的问题，这是一个包罗万象的短语。 

1205
00:57:01,320 --> 00:57:03,960
这有助于抵御这些错误。 

1206
00:57:03,960 --> 00:57:06,690
这不是唯一的方法，但它就是这样的方式。 

1207
00:57:06,690 --> 00:57:09,330
所以从今天开始，问题设定了程序和任何东西

1208
00:57:09,330 --> 00:57:12,090
你在课程中写作，你总是想要思考， 

1209
00:57:12,090 --> 00:57:14,647
即使你以后再回来添加它，这可能会出错吗？ 

1210
00:57:14,647 --> 00:57:16,313
这会出错吗？ 

1211
00:57:16,313 --> 00:57:18,197
只需添加一些额外的ifs和else-ifs 

1212
00:57:18,197 --> 00:57:21,280
并处理这些情况，以便您的程序不会崩溃

1213
00:57:21,280 --> 00:57:25,260
或者实际上使用它的人会发生错误或惊讶。 

1214
00:57:25,260 --> 00:57:28,410
好的，让我们来看看最后一个例子， 

1215
00:57:28,410 --> 00:57:30,300
因为坦白说这有点乏味。 

1216
00:57:30,300 --> 00:57:32,110
我要继续开放 - 

1217
00:57:32,110 --> 00:57:34,590
这个文件可以在compare5.c中找到。 

1218
00:57:34,590 --> 00:57:39,120
让我继续保存，以便我们拥有它 - 比较5.c。 

1219
00:57:39,120 --> 00:57:41,095
我打算做一个最后的比较例子。 

1220
00:57:41,095 --> 00:57:43,800
我将把它保存为compare6.c。 

1221
00:57:43,800 --> 00:57:46,020
事实证明人类喜欢他们的简洁。 

1222
00:57:46,020 --> 00:57:50,890
并且为null，因为它在技术上是0地址， 

1223
00:57:50,890 --> 00:57:52,920
你实际上可以有点聪明。 

1224
00:57:52,920 --> 00:57:59,430
如果不是s，如果不是，则是表达相同事物的充分方式。 

1225
00:57:59,430 --> 00:58:00,960
因为爆炸是做什么的？ 

1226
00:58:00,960 --> 00:58:04,050
你还记得代码中的感叹号吗？ 

1227
00:58:04,050 --> 00:58:05,170
它颠倒了一些东西。 

1228
00:58:05,170 --> 00:58:11,725
所以，如果这是说，如果s不是0，也就是说，如果s不为null，或者说 - 

1229
00:58:15,210 --> 00:58:18,005
如果 - 现在我感到困惑。 

1230
00:58:18,005 --> 00:58:18,505
是。 

1231
00:58:18,505 --> 00:58:21,910
如果我刚刚说过，如果是s，那么这是一个有效的地址

1232
00:58:21,910 --> 00:58:23,750
我应该继续我的事业。 

1233
00:58:23,750 --> 00:58:28,300
但如果它不是s或者s是null，我想要

1234
00:58:28,300 --> 00:58:31,240
继续前进并返回1，因为有错误，也在这里。 

1235
00:58:31,240 --> 00:58:33,910
因此，每当你检查某些东西是否等于null时， 

1236
00:58:33,910 --> 00:58:37,390
如果不是s，你可以说它更简洁;如果它是null， 

1237
00:58:37,390 --> 00:58:38,020
返回1。 

1238
00:58:38,020 --> 00:58:39,190
如果为null，则返回1。 

1239
00:58:39,190 --> 00:58:42,680
这只是句法简写。 

1240
00:58:42,680 --> 00:58:43,180
唷！ 

1241
00:58:43,180 --> 00:58:45,100
我不得不考虑那一个。 

1242
00:58:45,100 --> 00:58:45,820
任何问题？ 

1243
00:58:45,820 --> 00:58:53,160
听众：为什么[听不清]会存储[听不清] 

1244
00:58:53,160 --> 00:58:54,280
大卫马兰：正确。 

1245
00:58:54,280 --> 00:58:58,020
您正在存储地址，但如果该地址为0。 

1246
00:58:58,020 --> 00:59:04,300
如果它不是0，那么0就像是假的，所以不是假的意思是真的， 

1247
00:59:04,300 --> 00:59:07,990
因此它具有反转逻辑的效果。 

1248
00:59:07,990 --> 00:59:08,590
就这样。 

1249
00:59:08,590 --> 00:59:12,570
无论何时使用爆炸或感叹号，它都会将0更改为非0-- 

1250
00:59:12,570 --> 00:59:14,955
听众：[听不清]，但即使 - 

1251
00:59:14,955 --> 00:59:20,820
我不明白为什么[听不清]暗示它是[听不清] .. 

1252
00:59:20,820 --> 00:59:22,820
大卫马兰：所以你可以这样思考。 

1253
00:59:22,820 --> 00:59:24,725
如果s--之前我们有过这个。 

1254
00:59:24,725 --> 00:59:30,350
如果s equals-equals null就像说s字面上等于0。 

1255
00:59:30,350 --> 00:59:32,480
你可以非正式地想到这一点

1256
00:59:32,480 --> 00:59:34,970
如果s没有有效的指针 - 

1257
00:59:34,970 --> 00:59:38,110
0不是有效点，或者根据定义它不是有效地址。 

1258
00:59:38,110 --> 00:59:42,450
100有效，900有效，0仅由人类约定无效。 

1259
00:59:42,450 --> 00:59:46,680
所以这就像说，如果s没有值，那就是有效的。 

1260
00:59:46,680 --> 00:59:52,130
所以简明扼要地说，如果不是s， 

1261
00:59:52,130 --> 00:59:55,040
而这只是速记，是思考它的另一种方式。 

1262
00:59:55,040 --> 00:59:58,270
好的，让我们来看看一个非常不同的节目， 

1263
00:59:58,270 --> 01:00:02,070
但这揭示了同样的问题如下。 

1264
01:00:02,070 --> 01:00:05,030
我要继续打开一个名为的例子

1265
01:00:05,030 --> 01:00:09,410
copy0，其生活目的有望复制字符串。 

1266
01:00:09,410 --> 01:00:11,690
所以请注意，在我的程序中，我

1267
01:00:11,690 --> 01:00:15,440
提前写道，我从第11行的用户那里得到了一个字符串， 

1268
01:00:15,440 --> 01:00:17,240
我将它存储在一个名为s的字符串中。 

1269
01:00:17,240 --> 01:00:20,210
我现在可以将其更改为char *，但我们知道它是什么。 

1270
01:00:20,210 --> 01:00:24,560
我将继续将字符串的地址从s复制到t。 

1271
01:00:24,560 --> 01:00:29,370
然后我会说，如果t的长度大于0， 

1272
01:00:29,370 --> 01:00:31,620
然后继续并将第一个角色大写。 

1273
01:00:31,620 --> 01:00:32,660
所以它有点神秘，但你可能会有

1274
01:00:32,660 --> 01:00:35,120
用Caesar和最近的字符串做了类似的事情

1275
01:00:35,120 --> 01:00:35,930
操纵。 

1276
01:00:35,930 --> 01:00:38,810
这只是确保，我至少有一个角色吗？ 

1277
01:00:38,810 --> 01:00:42,340
如果是这样，你记得第一个字符是0括号0。 

1278
01:00:42,340 --> 01:00:45,554
toupper是上周ctype.h中的一个函数

1279
01:00:45,554 --> 01:00:46,970
只是将这封信大写。 

1280
01:00:46,970 --> 01:00:50,060
所以这一行代码19只是将第一个字母大写

1281
01:00:50,060 --> 01:00:51,232
在t，就是这样。 

1282
01:00:51,232 --> 01:00:54,440
然后在最后我们打印出什么是什么并打印出来是什么。 

1283
01:00:54,440 --> 01:00:55,010
就这样。 

1284
01:00:55,010 --> 01:00:59,390
所以这个程序只是将s复制到t，大写t，就是这样。 

1285
01:00:59,390 --> 01:01:02,339
所以让我继续制作copy0。 

1286
01:01:02,339 --> 01:01:03,630
这是我们今天的代码。 

1287
01:01:03,630 --> 01:01:07,340
所以我要做cd sc3，因为我已经在那个目录中写了它。 

1288
01:01:07,340 --> 01:01:08,975
制作copy0。 

1289
01:01:08,975 --> 01:01:12,810
顺利。 ./copy0。 

1290
01:01:12,810 --> 01:01:17,240
让我们继续，再用小写输入tj。 

1291
01:01:17,240 --> 01:01:18,270
输入。 

1292
01:01:18,270 --> 01:01:19,760
呵呵。 

1293
01:01:19,760 --> 01:01:21,939
TJ，TJ--都是资本化的。 

1294
01:01:21,939 --> 01:01:24,230
好吧，也许这只是首字母的奇怪之处。 

1295
01:01:24,230 --> 01:01:28,520
让我们做Veronica，全是小写。 

1296
01:01:28,520 --> 01:01:30,140
嗯，这绝对是资本。 

1297
01:01:30,140 --> 01:01:32,720
让我们做的更明显的区别，布莱恩在哪里

1298
01:01:32,720 --> 01:01:35,070
B真的会有所不同。 

1299
01:01:35,070 --> 01:01:38,270
然而，我只是在利用资本。 

1300
01:01:38,270 --> 01:01:40,580
那么让我们考虑一下这里到底发生了什么。 

1301
01:01:40,580 --> 01:01:46,080
在这种情况下，当我从用户，s和t获取字符串，然后输入， 

1302
01:01:46,080 --> 01:01:51,020
例如，brian全部小写，反斜杠0，当然， 

1303
01:01:51,020 --> 01:01:54,710
只是引擎盖下的阵列。 

1304
01:01:54,710 --> 01:01:56,150
这占用了六个字节。 

1305
01:01:56,150 --> 01:01:58,922
当我存储在s中时，s是一个字符串。 

1306
01:01:58,922 --> 01:01:59,630
所以你知道吗？ 

1307
01:01:59,630 --> 01:02:00,671
我们之前没有这样做过。 

1308
01:02:00,671 --> 01:02:05,300
让我实际上为s创建一个变量，一块内存并将其称为s。 

1309
01:02:05,300 --> 01:02:07,760
并且假设Brian就在他以前的位置 - 

1310
01:02:07,760 --> 01:02:13,230
100,101,102,103,104和105。 

1311
01:02:13,230 --> 01:02:18,110
所以如果我做了等于get_string并且get_string返回Brian， 

1312
01:02:18,110 --> 01:02:21,626
我在名为s的方框中写了什么？ 

1313
01:02:21,626 --> 01:02:22,820
是的，只有100，对吧？ 

1314
01:02:22,820 --> 01:02:24,780
这就是所有这一切

1315
01:02:24,780 --> 01:02:27,050
即使我们没有在这个级别谈论它。 

1316
01:02:27,050 --> 01:02:30,920
事实上，事实证明 - 指针实际上可以用图形方式。 

1317
01:02:30,920 --> 01:02:34,940
如果你真的更喜欢把指针想象成一个地址

1318
01:02:34,940 --> 01:02:37,957
或者像某种导致你某个地方的地图，另一种是人类

1319
01:02:37,957 --> 01:02:40,040
通常会画一个指针 - 因为老实说， 

1320
01:02:40,040 --> 01:02:41,960
谁真的关心Brian在地址100？ 

1321
01:02:41,960 --> 01:02:45,230
就像那个级别太低，那是第0周的东西。 

1322
01:02:45,230 --> 01:02:46,820
他只是指着那里。 

1323
01:02:46,820 --> 01:02:49,190
所以s是指向那块内存的指针。 

1324
01:02:49,190 --> 01:02:52,640
碰巧是100，无论如何，箭头就是你的字面意思

1325
01:02:52,640 --> 01:02:56,060
如果你在一些笔记上画这个，那就指向一大堆记忆。 

1326
01:02:56,060 --> 01:02:57,710
所以这也是正确的。 

1327
01:02:57,710 --> 01:03:00,980
所以问题出现在这里。 

1328
01:03:00,980 --> 01:03:07,280
当我真正尝试复制s并存储在t中时，请考虑发生了什么。 

1329
01:03:07,280 --> 01:03:10,830
右边只是s的值，恰好是100。 

1330
01:03:10,830 --> 01:03:13,460
左边只是说，嘿电脑，给我

1331
01:03:13,460 --> 01:03:16,760
另一个变量，第一个字符串，并将其称为t。 

1332
01:03:16,760 --> 01:03:19,730
所以这就像说，嘿，电脑，给我另一块记忆， 

1333
01:03:19,730 --> 01:03:22,766
称之为t，然后将s存储在其中。 

1334
01:03:22,766 --> 01:03:24,140
但是存储s意味着什么？ 

1335
01:03:24,140 --> 01:03:27,800
那么这个时间点的价值是多少呢？ 

1336
01:03:27,800 --> 01:03:30,140
它是指向Brian的指针，或者它在技术上 - 

1337
01:03:30,140 --> 01:03:34,000
我只是为了彻底而写两个 - 它实际上是数字100。 

1338
01:03:34,000 --> 01:03:39,720
所以如果你做t等于s，那就像说把100放在那里， 

1339
01:03:39,720 --> 01:03:42,580
并且象征性地说这就是这样。 

1340
01:03:42,580 --> 01:03:46,860
所以在故事的这一点上，当我把s复制到t时， 

1341
01:03:46,860 --> 01:03:48,540
电脑从字面上看我。 

1342
01:03:48,540 --> 01:03:51,390
它确实将s复制到了t，但是什么是s？ 

1343
01:03:51,390 --> 01:03:52,470
这只是地址。 

1344
01:03:52,470 --> 01:03:56,800
它不是BRIAN反斜杠0，它只是地址。 

1345
01:03:56,800 --> 01:04:00,810
所以，当我说，t括号0得到toupper-- 

1346
01:04:00,810 --> 01:04:02,370
让我们来看看这行代码。 

1347
01:04:02,370 --> 01:04:04,590
这里的一行代码突出显示， 

1348
01:04:04,590 --> 01:04:07,740
当我说去t的第0个字符并存储

1349
01:04:07,740 --> 01:04:11,962
同一个字符的大写版本，你只需按照箭头。 

1350
01:04:11,962 --> 01:04:13,920
如果你小时候玩过滑槽和梯子， 

1351
01:04:13,920 --> 01:04:16,253
你只需按照箭头，看看你最终到了哪里。 

1352
01:04:16,253 --> 01:04:19,750
t括号0是这里的位置，因为

1353
01:04:19,750 --> 01:04:22,330
如果这是一块内存，那么上周这是一个数组， 

1354
01:04:22,330 --> 01:04:26,580
所以你也可以把它想象为括号0，这是括号1， 

1355
01:04:26,580 --> 01:04:30,460
这是括号2，依此类推。 

1356
01:04:30,460 --> 01:04:31,600
所以它只是一个数组。 

1357
01:04:31,600 --> 01:04:36,810
所以t括号0是小写字母b，而小写字母b的toupper是

1358
01:04:36,810 --> 01:04:40,650
当然，将这个小b改为B.但是现在

1359
01:04:40,650 --> 01:04:43,220
s和t仍然指向同一块内存， 

1360
01:04:43,220 --> 01:04:47,620
所以当然s和t都是Bryan大写的， 

1361
01:04:47,620 --> 01:04:51,000
或者在我的第一个例子中也是TJ。 

1362
01:04:51,000 --> 01:04:57,260
那么关于我们刚刚做了什么以及为什么会这样的问题呢？ 

1363
01:04:57,260 --> 01:04:59,100
好吧，直观地解决了什么问题？ 

1364
01:04:59,100 --> 01:05:01,100
如果您不知道如何编码它并不重要， 

1365
01:05:01,100 --> 01:05:04,880
比如我们要从根本上复制一个字符串，而不是

1366
01:05:04,880 --> 01:05:06,572
一个地址？ 

1367
01:05:06,572 --> 01:05:08,830
听众：[听不清] 

1368
01:05:08,830 --> 01:05:10,136
大卫马兰：创造一个新的东西？ 

1369
01:05:10,136 --> 01:05:12,500
听众：基本上创造[听不清] .. 

1370
01:05:12,500 --> 01:05:13,250
大卫马兰：是的。 

1371
01:05:13,250 --> 01:05:15,249
在新的内存块中创建相同的字符串。 

1372
01:05:15,249 --> 01:05:17,970
我真正需要做的是分配或给自己

1373
01:05:17,970 --> 01:05:21,720
一堆像Brian一样大的记忆， 

1374
01:05:21,720 --> 01:05:24,750
包括他的反斜杠0。 

1375
01:05:24,750 --> 01:05:28,450
然后逻辑上我只需要复制每个字符。 

1376
01:05:28,450 --> 01:05:31,020
所以，如果我回到原来的小写字母b， 

1377
01:05:31,020 --> 01:05:34,080
我需要使用for循环或while循环逻辑地制作副本

1378
01:05:34,080 --> 01:05:35,130
或者你喜欢什么 - 

1379
01:05:35,130 --> 01:05:42,990
BRIAN反斜杠0，这样当我复制字符串然后将其存储在t中时， 

1380
01:05:42,990 --> 01:05:45,480
它实际上并不是真正复制的。 

1381
01:05:45,480 --> 01:05:49,540
让我们假设他最终在任意位置300结束 - 

1382
01:05:49,540 --> 01:05:51,010
只是编造简单的数字。 

1383
01:05:51,010 --> 01:05:54,780
t现在存储300个点。 

1384
01:05:54,780 --> 01:05:59,370
所以当我在这个版本的故事中执行这一行时，t括起0 

1385
01:05:59,370 --> 01:06:02,250
得到好戏，我到底在做什么？ 

1386
01:06:02,250 --> 01:06:04,440
我这次跟着不同的箭头

1387
01:06:04,440 --> 01:06:08,280
因为我给了自己一个不同的记忆，把这个Brian， 

1388
01:06:08,280 --> 01:06:13,170
因此希望能够修复bug，尽管只是口头上的。 

1389
01:06:13,170 --> 01:06:14,910
那么我们如何在代码中执行此操作？ 

1390
01:06:14,910 --> 01:06:16,300
我们需要做到这一点。 

1391
01:06:16,300 --> 01:06:18,400
我们需要给自己更多的记忆， 

1392
01:06:18,400 --> 01:06:23,832
所以让我们介绍一下C的另一个特性。在copy1.c中， 

1393
01:06:23,832 --> 01:06:25,930
我们看到了这个问题的解决方案。 

1394
01:06:25,930 --> 01:06:31,260
注意在顶部我做的事情稍微低一点 - 哎呀，惊喜。 

1395
01:06:31,260 --> 01:06:33,740
请注意，在此版本的代码中，copy1.c， 

1396
01:06:33,740 --> 01:06:37,950
看，我几乎开始了，但只是为了超级明确， 

1397
01:06:37,950 --> 01:06:39,180
我只是用char *。 

1398
01:06:39,180 --> 01:06:41,057
我不想要任何魔法，所以没有字符串， 

1399
01:06:41,057 --> 01:06:42,390
这里没有训练轮。 

1400
01:06:42,390 --> 01:06:45,300
但这在逻辑上与以前完全相同 - 

1401
01:06:45,300 --> 01:06:46,800
加上错误检查。 

1402
01:06:46,800 --> 01:06:47,850
这条线是新的。 

1403
01:06:47,850 --> 01:06:51,760
它看起来有点时髦，但让我们看看发生了什么。 

1404
01:06:51,760 --> 01:06:54,510
这行代码在这里，我在做什么？ 

1405
01:06:54,510 --> 01:06:57,510
左侧，更短，让我们从更简单的开始。 

1406
01:06:57,510 --> 01:07:02,780
Char * t，就像外行人的说法一样，那个表达是做什么的？字符*？ 

1407
01:07:02,780 --> 01:07:06,700
嘿电脑，做什么？ 

1408
01:07:06,700 --> 01:07:07,326
那是什么？ 

1409
01:07:07,326 --> 01:07:08,200
听众：[听不清] 

1410
01:07:08,200 --> 01:07:09,325
大卫马兰：还没有。 

1411
01:07:09,325 --> 01:07:10,557
不同的配方。 

1412
01:07:14,140 --> 01:07:17,110
嘿电脑，给我 - 

1413
01:07:17,110 --> 01:07:17,960
不完全的。 

1414
01:07:17,960 --> 01:07:19,953
更准确？ 

1415
01:07:19,953 --> 01:07:21,390
听众：一个阵列？ 

1416
01:07:21,390 --> 01:07:23,390
大卫·马兰：不仅仅是一个阵列，只是这一部分。 

1417
01:07:23,390 --> 01:07:25,520
所以让我隐瞒这一切。 

1418
01:07:25,520 --> 01:07:27,485
如果明星不存在 - 

1419
01:07:27,485 --> 01:07:28,860
我不能真的这么做。 

1420
01:07:28,860 --> 01:07:29,964
所以 - 是吗？ 

1421
01:07:29,964 --> 01:07:31,900
听众：[听不清]角色？ 

1422
01:07:31,900 --> 01:07:33,316
大卫马兰：好的，我会接受的。 

1423
01:07:33,316 --> 01:07:35,560
所以嘿电脑，给我一个指向角色的指针。 

1424
01:07:35,560 --> 01:07:37,960
或者更低级别，嘿电脑，给我

1425
01:07:37,960 --> 01:07:41,590
一块内存，我可以在其中存储一个角色的地址。 

1426
01:07:41,590 --> 01:07:42,820
我的意思是，这是平凡的。 

1427
01:07:42,820 --> 01:07:46,000
在屏幕上画一个方框，称之为 - 或者更确切地说， 

1428
01:07:46,000 --> 01:07:49,825
如你所说，叫它，但只是给我指针的空间。 

1429
01:07:49,825 --> 01:07:50,950
这就是所有这一切。 

1430
01:07:50,950 --> 01:07:54,310
它在屏幕上绘制一个框并调用它，它当前是空的。 

1431
01:07:54,310 --> 01:07:56,920
现在让我们来看看右侧更可怕的部分。 

1432
01:07:56,920 --> 01:07:58,780
malloc，今天的新功能。 

1433
01:07:58,780 --> 01:08:00,420
代表内存分配。 

1434
01:08:00,420 --> 01:08:03,420
这听起来很神秘，但它只是意味着给我一大块记忆。 

1435
01:08:03,420 --> 01:08:05,800
它准确地说出了你在功能方面所说的内容。 

1436
01:08:05,800 --> 01:08:07,990
然后它只需要你回答一个问题 - 

1437
01:08:07,990 --> 01:08:09,610
好的，你想要多少内存？ 

1438
01:08:09,610 --> 01:08:11,290
你想要几个字节？ 

1439
01:08:11,290 --> 01:08:15,250
而现在也许数学，即使乍一看神秘，也是有道理的。 

1440
01:08:15,250 --> 01:08:19,689
获取s的字符串长度，加1，然后乘以它

1441
01:08:19,689 --> 01:08:21,132
按角色的大小。 

1442
01:08:21,132 --> 01:08:23,590
我们以前没见过这个。 sizeof字面意思是这样的。 

1443
01:08:23,590 --> 01:08:26,170
它告诉你char是多少字节。 

1444
01:08:26,170 --> 01:08:28,300
恰好是1，事实上，这是定义的。 

1445
01:08:28,300 --> 01:08:32,649
因此，如果我们在C中简化它​​，则char总是1个字节， 

1446
01:08:32,649 --> 01:08:35,029
所以这等于只乘以1。 

1447
01:08:35,029 --> 01:08:37,352
从数学上来说，这是浪费时间， 

1448
01:08:37,352 --> 01:08:39,310
所以我们可以把它简化为更简单。 

1449
01:08:39,310 --> 01:08:41,120
我只是在彻底。 

1450
01:08:41,120 --> 01:08:45,430
所以现在，嘿计算机，给我分配这么多字节的内存。 

1451
01:08:45,430 --> 01:08:46,790
为什么加1？ 

1452
01:08:46,790 --> 01:08:48,470
听众：你需要空字符。 

1453
01:08:48,470 --> 01:08:50,136
大卫马兰：我需要那个空角色。 

1454
01:08:50,136 --> 01:08:54,310
正如他所说，Brian是1,2,3,4,5，但我需要第六个因为他的空角色， 

1455
01:08:54,310 --> 01:08:56,060
我只知道那将会在那里。 

1456
01:08:56,060 --> 01:08:59,710
那么在故事的这一点上，发生了什么？ 

1457
01:08:59,710 --> 01:09:04,300
malloc所做的就是它给了我这一盒记忆

1458
01:09:04,300 --> 01:09:07,863
包含多个字节的空间以Brian的名字命名。 

1459
01:09:07,863 --> 01:09:09,279
但它还没有填补它们。 

1460
01:09:09,279 --> 01:09:13,160
现在我需要用Brian的实际名称逻辑填充这些字节。 

1461
01:09:13,160 --> 01:09:15,550
所以，如果我们向下滚动到我的for循环， 

1462
01:09:15,550 --> 01:09:18,490
我们实际上可以将字符串复制到该空间中。 

1463
01:09:18,490 --> 01:09:21,700
它有点长，表达，但这里没有什么新东西。 

1464
01:09:21,700 --> 01:09:28,689
将i初始化为0，将n初始化为s的长度，i小于或等于n-- 

1465
01:09:28,689 --> 01:09:30,160
我们会回到那个，我++。 

1466
01:09:30,160 --> 01:09:32,260
所以它只是一个非常标准的循环。 

1467
01:09:32,260 --> 01:09:36,490
然后将s的第i个字符复制到t的第i个字符中。 

1468
01:09:36,490 --> 01:09:40,667
唯一让我有点紧张的是这件事。 

1469
01:09:40,667 --> 01:09:43,000
就像我每次做小于或等于的时候一样， 

1470
01:09:43,000 --> 01:09:45,250
我们上周创建了一个bug。 

1471
01:09:45,250 --> 01:09:46,486
但这是对的，为什么呢？ 

1472
01:09:50,770 --> 01:09:54,580
我为什么要这么做呢？ 

1473
01:09:54,580 --> 01:09:56,790
听众：是否添加了空字符 - 

1474
01:09:56,790 --> 01:09:57,360
大卫马兰：没错。 

1475
01:09:57,360 --> 01:09:58,610
因为空字符。 

1476
01:09:58,610 --> 01:10:02,130
我实际上不想停在s的strlen，所以我可以改变它。 

1477
01:10:02,130 --> 01:10:04,890
如果你只是更舒服地使用少于，因为你只是

1478
01:10:04,890 --> 01:10:08,460
让我的思绪缠绕在一起为什么我们这样做，那很好， 

1479
01:10:08,460 --> 01:10:11,440
我们只需要这样做。 

1480
01:10:11,440 --> 01:10:16,020
所以这是数学上的 - 如果你去strlen加1，同样的事情

1481
01:10:16,020 --> 01:10:18,789
不做那个数学但只是更进一步。 

1482
01:10:18,789 --> 01:10:20,830
无论你想要什么，都可以。 

1483
01:10:20,830 --> 01:10:22,621
但是你想要考虑它很好。 

1484
01:10:22,621 --> 01:10:25,020
好的，然后最后，只是一个快速检查，是长度

1485
01:10:25,020 --> 01:10:27,420
至少一个或多个字符？ 

1486
01:10:27,420 --> 01:10:29,910
因为否则没有什么可以资本化的，如果是的话， 

1487
01:10:29,910 --> 01:10:31,120
继续做吧。 

1488
01:10:31,120 --> 01:10:34,350
所以，如果我现在运行这个例子，make  -  oop，让我保存它。 

1489
01:10:34,350 --> 01:10:37,040
make copy1，编译。 

1490
01:10:37,040 --> 01:10:42,480
./copy1，现在让我们输入tj，小写的tj会回来， 

1491
01:10:42,480 --> 01:10:44,490
但现在是资本化的。 

1492
01:10:44,490 --> 01:10:49,140
让我们继续以小写的方式做Brian的名字，只有其中一个

1493
01:10:49,140 --> 01:10:51,100
现在资本化。 

1494
01:10:51,100 --> 01:10:54,450
那么现在发生了什么才有意义呢？ 

1495
01:10:54,450 --> 01:10:54,950
行。 

1496
01:10:54,950 --> 01:10:57,980
那么我们可以在哪里使用它？ 

1497
01:10:57,980 --> 01:11:00,647
事实证明 - 让我在这里打开最后一个例子， 

1498
01:11:00,647 --> 01:11:02,480
老实说，那令人难以置信的乏味， 

1499
01:11:02,480 --> 01:11:04,010
如果你没有人想要复制字符串

1500
01:11:04,010 --> 01:11:05,510
必须经历所有这些工作。 

1501
01:11:05,510 --> 01:11:08,990
事实证明存储副本存在。 

1502
01:11:08,990 --> 01:11:11,060
所以如有疑问，请查看手册页。 

1503
01:11:11,060 --> 01:11:12,710
如有疑问，请检查CS50参考。 

1504
01:11:12,710 --> 01:11:15,194
该功能是否存在于相关的位置

1505
01:11:15,194 --> 01:11:16,610
你想到的一些关键词？ 

1506
01:11:16,610 --> 01:11:18,650
像字符串副本一样，看看是否有东西回来了。 

1507
01:11:18,650 --> 01:11:22,490
事实上，我们有strlen，我们有strcmp，我们现在有strcpy， 

1508
01:11:22,490 --> 01:11:25,970
如果您阅读文档，这是故意逆转这样的。 

1509
01:11:25,970 --> 01:11:30,050
目标是此变量，源或原始字符串

1510
01:11:30,050 --> 01:11:32,680
是这一个，它从一端复制到另一端， 

1511
01:11:32,680 --> 01:11:35,150
然后我不需要那个for循环。 

1512
01:11:35,150 --> 01:11:37,590
它只是为我节省了几行代码。 

1513
01:11:37,590 --> 01:11:38,240
行。 

1514
01:11:38,240 --> 01:11:41,750
那么让我们在这里取消另一个细节。 

1515
01:11:41,750 --> 01:11:46,520
哦，你会注意到，实际上，让我做一个修复，一个修复在这里。 

1516
01:11:46,520 --> 01:11:50,690
事实证明，我在这里做的有点懒。 

1517
01:11:50,690 --> 01:11:54,260
事实证明，malloc确实有相反的结果。 

1518
01:11:54,260 --> 01:11:57,230
所以在技术上你随时分配内存

1519
01:11:57,230 --> 01:11:59,630
你也应该释放那段记忆。 

1520
01:11:59,630 --> 01:12:02,909
所以C允许你向计算机询问你想要的内存， 

1521
01:12:02,909 --> 01:12:06,200
但如果你永远不会回馈，你有没有经历过自己的Mac或PC， 

1522
01:12:06,200 --> 01:12:08,158
就像你的电脑运行一段时间后一样

1523
01:12:08,158 --> 01:12:10,700
或使用一些新的或臃肿的程序，如浏览器， 

1524
01:12:10,700 --> 01:12:13,100
它越来越慢，越来越慢？ 

1525
01:12:13,100 --> 01:12:16,610
在更糟糕的情况下它只是冻结或挂起或什么？ 

1526
01:12:16,610 --> 01:12:19,670
该程序很可能只是 - 由人类制造， 

1527
01:12:19,670 --> 01:12:20,240
当然 - 

1528
01:12:20,240 --> 01:12:21,840
只是有内存泄漏。 

1529
01:12:21,840 --> 01:12:25,400
所以有些人写了一行或多行使用malloc的代码

1530
01:12:25,400 --> 01:12:28,525
或者是另一种只保留内存的语言的等价物

1531
01:12:28,525 --> 01:12:29,400
为用户输入。 

1532
01:12:29,400 --> 01:12:31,310
你正在访问一个网页，两个网页， 

1533
01:12:31,310 --> 01:12:33,620
无论程序是什么，都需要内存。 

1534
01:12:33,620 --> 01:12:37,490
如果那个人从来没有调用相反的分配 - 释放， 

1535
01:12:37,490 --> 01:12:40,700
否则被称为自由，你永远不会回忆

1536
01:12:40,700 --> 01:12:41,840
到操作系统。 

1537
01:12:41,840 --> 01:12:45,129
因此它变得越来越慢，因为它越来越低

1538
01:12:45,129 --> 01:12:47,420
在内存上，它可能需要移动一些东西

1539
01:12:47,420 --> 01:12:50,390
为事物腾出空间，这就是所谓的内存泄漏。 

1540
01:12:50,390 --> 01:12:54,170
事实上，在这个程序中，我实际上应该稍微改进一下。 

1541
01:12:54,170 --> 01:12:58,250
如果我回到这个版本和第18行，回想一下， 

1542
01:12:58,250 --> 01:13:01,010
我分配这个内存只是为了制作我的副本， 

1543
01:13:01,010 --> 01:13:04,310
我应该在这个程序中做的最后一件事

1544
01:13:04,310 --> 01:13:05,977
这条线是免费的。 

1545
01:13:05,977 --> 01:13:08,810
您不必告诉计算机要释放多少字节， 

1546
01:13:08,810 --> 01:13:12,650
只要你只是传入指针，它就会为你记住 - 

1547
01:13:12,650 --> 01:13:16,790
存储大块内存地址的变量

1548
01:13:16,790 --> 01:13:18,890
你分配的。 

1549
01:13:18,890 --> 01:13:19,700
行。 

1550
01:13:19,700 --> 01:13:23,030
现在让我们看看为什么我们一直在使用get_string， 

1551
01:13:23,030 --> 01:13:25,430
因为它不仅仅是简化代码， 

1552
01:13:25,430 --> 01:13:28,640
这也是为了防范一些非常容易的问题。 

1553
01:13:28,640 --> 01:13:31,220
这是一个名为scanf0--的程序

1554
01:13:31,220 --> 01:13:35,070
扫描格式化文本，另一个神秘的声音功能， 

1555
01:13:35,070 --> 01:13:36,630
但它非常简单。 

1556
01:13:36,630 --> 01:13:39,952
该程序只是使用scanf从用户处获取。 

1557
01:13:39,952 --> 01:13:42,410
到目前为止，在过去三周内，您已经使用了get_int。 

1558
01:13:42,410 --> 01:13:45,050
所以这可以替代get_int 

1559
01:13:45,050 --> 01:13:48,320
几个星期前开始使用。 

1560
01:13:48,320 --> 01:13:51,430
给我一个名为x的int，打印出x冒号 - 

1561
01:13:51,430 --> 01:13:53,190
这只是对用户的提示。 

1562
01:13:53,190 --> 01:14:01,490
scanf％i，＆x;，无论是什么，然后使用％i打印出x的值。 

1563
01:14:01,490 --> 01:14:02,810
那么这里发生了什么？ 

1564
01:14:02,810 --> 01:14:06,140
今天我们实际上可以开始围绕get_int实际开始

1565
01:14:06,140 --> 01:14:06,639
确实。 

1566
01:14:06,639 --> 01:14:07,910
这实际上是get_int。 

1567
01:14:07,910 --> 01:14:11,034
如果你真的看一下get_int的源代码，那就更有点了。 

1568
01:14:11,034 --> 01:14:13,999
但实质上，get_int的作用是声明一个名为x的变量， 

1569
01:14:13,999 --> 01:14:16,040
并且它没有放任何东西，因为那是

1570
01:14:16,040 --> 01:14:17,630
应该来自你，人类。 

1571
01:14:17,630 --> 01:14:20,900
然后它会提示你传递给get_int的任何字符串， 

1572
01:14:20,900 --> 01:14:22,370
所以那些是前两行。 

1573
01:14:22,370 --> 01:14:24,570
这是唯一看起来奇怪的一个。 

1574
01:14:24,570 --> 01:14:26,630
Scanf就像printf的对立面。 

1575
01:14:26,630 --> 01:14:31,920
你仍然使用格式化的字符串 - ％s，％i，％f或其他， 

1576
01:14:31,920 --> 01:14:35,750
但是你不打算输出这个，你要输入它

1577
01:14:35,750 --> 01:14:37,220
人类的键盘。 

1578
01:14:37,220 --> 01:14:41,780
和％x是相反的 - 

1579
01:14:41,780 --> 01:14:49,160
是C中的特殊符号，说明，继续给我x的地址。 

1580
01:14:49,160 --> 01:14:52,370
所以不要传入x，给我x的地址。 

1581
01:14:52,370 --> 01:14:53,110
那为什么呢？ 

1582
01:14:53,110 --> 01:14:56,390
我们会看到，但这是你告诉电脑的方式， 

1583
01:14:56,390 --> 01:14:59,510
我为你做了一个名为x的变量，这里就是它。 

1584
01:14:59,510 --> 01:15:03,840
这是一张宝藏地图，引导您到x，为我提供一个价值。 

1585
01:15:03,840 --> 01:15:06,800
所以最终结果是我们确实最终获得了一个int。 

1586
01:15:06,800 --> 01:15:13,010
如果我做了scanf0，然后是./scanf0，我会输入42，好吗？ 

1587
01:15:13,010 --> 01:15:16,040
这不是一个有趣的程序，它只是吐出我所得到的， 

1588
01:15:16,040 --> 01:15:18,330
但这就是get_int的全部内容，当然， 

1589
01:15:18,330 --> 01:15:20,270
如果你然后打印出值，就会这样做。 

1590
01:15:20,270 --> 01:15:24,230
所以，如果我规定这是正确的，这就是你从用户那里得到一个int的方式， 

1591
01:15:24,230 --> 01:15:27,660
但老实说，我们在课程的第一周没有这样做的原因是， 

1592
01:15:27,660 --> 01:15:31,070
我的上帝，我们只是从用户那里得到了一个简单的数字

1593
01:15:31,070 --> 01:15:32,987
通过使用这些代码行和谁知道

1594
01:15:32,987 --> 01:15:35,486
这个符号是什么 - 我们不希望你考虑这个， 

1595
01:15:35,486 --> 01:15:36,800
我们希望你得到一个int。 

1596
01:15:36,800 --> 01:15:39,230
但今天这些训练轮已关闭，但我们是

1597
01:15:39,230 --> 01:15:41,990
要快速地遇到问题。 

1598
01:15:41,990 --> 01:15:44,540
让我们用字符串尝试相同的事情。 

1599
01:15:44,540 --> 01:15:49,680
如果我这样做，你会认为结果是一样的。 

1600
01:15:49,680 --> 01:15:52,070
或者让我们把它作为char *。 

1601
01:15:52,070 --> 01:15:54,020
但是会有一个调整。 

1602
01:15:54,020 --> 01:15:59,180
如果我继续为自己的角色地址留出空间， 

1603
01:15:59,180 --> 01:16:01,970
我现在不需要使用＆符号，因为scanf 

1604
01:16:01,970 --> 01:16:04,880
确实需要被告知内存块在哪里， 

1605
01:16:04,880 --> 01:16:08,630
但它已经是一个地址，所以我不需要这里的＆符号。 

1606
01:16:08,630 --> 01:16:11,960
回想一下，我声明了int x，它只是一个int。 

1607
01:16:11,960 --> 01:16:14,500
％x获取该int的地址。 

1608
01:16:14,500 --> 01:16:19,160
在这里，我从一开始就说，给我一个字母的地址。 

1609
01:16:19,160 --> 01:16:22,070
我不需要＆符号因为我已经有了char的地址

1610
01:16:22,070 --> 01:16:24,650
根据该星形符号的定义。 

1611
01:16:24,650 --> 01:16:26,580
那么这里发生了什么？ 

1612
01:16:26,580 --> 01:16:27,560
现在让我看看。 

1613
01:16:27,560 --> 01:16:30,420
如果我运行scanf1，会发生什么？ 

1614
01:16:30,420 --> 01:16:33,410
所以make scanf1和 - 

1615
01:16:33,410 --> 01:16:34,122
哦，让我们看看。 

1616
01:16:34,122 --> 01:16:35,330
这是我得到的警告。 

1617
01:16:35,330 --> 01:16:37,372
在此处使用时，变量s未初始化。 

1618
01:16:37,372 --> 01:16:38,330
好的，没关系。 

1619
01:16:38,330 --> 01:16:41,210
它希望我初始化它，因为这是一个非常常见的错误。 

1620
01:16:41,210 --> 01:16:43,168
那些提到分段错误的人

1621
01:16:43,168 --> 01:16:46,040
早些时候可能会遇到类似于此的东西。 

1622
01:16:46,040 --> 01:16:47,370
这样就压制了那个错误。 

1623
01:16:47,370 --> 01:16:49,330
让我继续并运行scanf1。 

1624
01:16:49,330 --> 01:16:51,961
好的，我们走了，TJ。 

1625
01:16:51,961 --> 01:16:52,460
嗯。 

1626
01:16:52,460 --> 01:16:54,495
那不是你的名字，但还可以。 

1627
01:16:54,495 --> 01:16:57,000
它至少没有崩溃，它只是有点奇怪。 

1628
01:16:57,000 --> 01:16:58,280
大卫。 

1629
01:16:58,280 --> 01:16:59,916
Null，好的，这有点奇怪。 

1630
01:16:59,916 --> 01:17:01,290
让我们再继续这样做。 

1631
01:17:01,290 --> 01:17:03,740
让我们输入一个非常长的名字。 

1632
01:17:06,280 --> 01:17:07,140
输入。 

1633
01:17:07,140 --> 01:17:09,060
该死，这没用。 

1634
01:17:09,060 --> 01:17:11,250
所以让我们尝试一个更长的名字。 

1635
01:17:16,350 --> 01:17:19,980
我打了很多贴纸。 

1636
01:17:19,980 --> 01:17:21,790
好的 - 该死的。 

1637
01:17:21,790 --> 01:17:23,920
太多次了。 

1638
01:17:23,920 --> 01:17:26,530
命令未找到，这绝对不是命令。 

1639
01:17:26,530 --> 01:17:27,310
哇，好的。 

1640
01:17:30,450 --> 01:17:32,004
那很有意思。 

1641
01:17:32,004 --> 01:17:32,670
哦，就是这样。 

1642
01:17:32,670 --> 01:17:33,610
空虚，同样的事情。 

1643
01:17:33,610 --> 01:17:36,260
好的，那实在是怎么回事？ 

1644
01:17:36,260 --> 01:17:38,370
那么null，这里全是小写的

1645
01:17:38,370 --> 01:17:41,742
这是一种美学的东西，它不起作用。 

1646
01:17:41,742 --> 01:17:42,450
它不起作用。 

1647
01:17:42,450 --> 01:17:44,010
那我到底在做什么？ 

1648
01:17:44,010 --> 01:17:49,470
在第一行代码中，当我说给我一个char *时， 

1649
01:17:49,470 --> 01:17:52,650
否则称为字符串，所有正在做的就是分配它。 

1650
01:17:52,650 --> 01:17:54,750
从技术上讲，它是指针的大小。 

1651
01:17:54,750 --> 01:17:57,330
一个指针，我们以前从未提及过，但现在我们可以。 

1652
01:17:57,330 --> 01:18:02,910
结果是64位或8字节。 

1653
01:18:02,910 --> 01:18:07,770
8位是1个字节，因此指针在许多计算机上都是定义的

1654
01:18:07,770 --> 01:18:11,610
天 - 大多数Mac，大多数PC，IDE，沙盒，实验室 - 

1655
01:18:11,610 --> 01:18:12,460
是64位。 

1656
01:18:12,460 --> 01:18:16,260
所以这只意味着这里有64位，但我们将其初始化为null， 

1657
01:18:16,260 --> 01:18:20,190
所以这意味着这里有64个点，点点式点。 

1658
01:18:20,190 --> 01:18:24,092
但是当我使用scanf获取字符串时，是什么

1659
01:18:24,092 --> 01:18:26,550
我告诉计算机这里有这行代码， 

1660
01:18:26,550 --> 01:18:31,930
注意，是嘿计算机，去那个地址并在那里放一个字符串。 

1661
01:18:31,930 --> 01:18:34,150
那真正发生了什么？ 

1662
01:18:34,150 --> 01:18:37,680
事实证明，没有足够的空间来输入TJ。 

1663
01:18:37,680 --> 01:18:38,722
没有足够的空间 - 

1664
01:18:38,722 --> 01:18:41,430
这有点白色谎言，因为我们可以让你适应64位， 

1665
01:18:41,430 --> 01:18:45,030
但是没有足够的空间来输入长句或段落的文字

1666
01:18:45,030 --> 01:18:46,140
我做了，对吧？ 

1667
01:18:46,140 --> 01:18:47,340
我们没做什么？ 

1668
01:18:47,340 --> 01:18:49,500
我们没有在这里分配任何空间。 

1669
01:18:49,500 --> 01:18:51,930
我们所分配的空间都是地址。 

1670
01:18:51,930 --> 01:18:55,770
所以每次我使用scanf说，给我一个字符串并把它放在这里， 

1671
01:18:55,770 --> 01:18:57,220
无处可去。 

1672
01:18:57,220 --> 01:19:00,070
所以价值只是非常防守地说，不，不，不， 

1673
01:19:00,070 --> 01:19:03,030
无法将此存储在任何地方。 

1674
01:19:03,030 --> 01:19:05,550
所以我实际上需要对此有点聪明。 

1675
01:19:05,550 --> 01:19:10,860
我实际上需要给自己一些空间，以便我可以存储一些东西

1676
01:19:10,860 --> 01:19:11,750
在正确的地方。 

1677
01:19:11,750 --> 01:19:12,670
我们这样做。 

1678
01:19:12,670 --> 01:19:15,420
让我继续创建一个新程序。 

1679
01:19:15,420 --> 01:19:17,280
我要继续打电话给这个scanf2。 

1680
01:19:21,370 --> 01:19:25,040
我们需要一些秘密代码来提醒我。 

1681
01:19:25,040 --> 01:19:27,180
哦，错误的文件名。 

1682
01:19:27,180 --> 01:19:30,650
所以我继续创建一个名为scanf2的文件。 

1683
01:19:30,650 --> 01:19:32,180
scanf2.c。 

1684
01:19:32,180 --> 01:19:37,310
我将快速重新创建这个stdio.h，int main void， 

1685
01:19:37,310 --> 01:19:39,950
然后在这里我会继续 - 你知道吗？ 

1686
01:19:39,950 --> 01:19:44,270
而不是字符串s，我今天知道它是一个字符串， 

1687
01:19:44,270 --> 01:19:45,549
这串真的是什么？ 

1688
01:19:45,549 --> 01:19:46,590
嗯，你早些时候说过。 

1689
01:19:46,590 --> 01:19:48,520
这串是什么？ 

1690
01:19:48,520 --> 01:19:49,840
这是一系列人物。 

1691
01:19:49,840 --> 01:19:51,210
让我从字面上理解你。 

1692
01:19:51,210 --> 01:19:54,570
请给我一个让我说五个字符的数组。 

1693
01:19:54,570 --> 01:19:58,980
大卫，或者还有一个，这很好，只够我的反斜杠0。 

1694
01:19:58,980 --> 01:20:01,330
让我创建一个字符串 - 非常低级别， 

1695
01:20:01,330 --> 01:20:03,676
但这次给自己留下了一大堆记忆。 

1696
01:20:03,676 --> 01:20:05,550
我不只想要一个角色的地址， 

1697
01:20:05,550 --> 01:20:08,290
我想要实际的角色本身。 

1698
01:20:08,290 --> 01:20:11,550
让我继续，只是用s来提示人类的字符串， 

1699
01:20:11,550 --> 01:20:12,510
就像以前那样。 

1700
01:20:12,510 --> 01:20:16,770
然后让我调用scanf并使用％s从用户处获取一个字符串然后传递

1701
01:20:16,770 --> 01:20:17,400
在s。 

1702
01:20:17,400 --> 01:20:18,720
这是一个小技巧。 

1703
01:20:18,720 --> 01:20:22,710
事实证明，因为一个字符串实际上只是一个数组， 

1704
01:20:22,710 --> 01:20:25,620
但是一个字符串也只是一个指针，你可以实际对待

1705
01:20:25,620 --> 01:20:28,440
一个数组，好像它是一个指针 - 

1706
01:20:28,440 --> 01:20:29,310
一个地址。 

1707
01:20:29,310 --> 01:20:33,900
所以尽管这是一个char *数组，但这没关系。 

1708
01:20:33,900 --> 01:20:37,710
在此上下文中，这仅仅是字符串的地址。 

1709
01:20:37,710 --> 01:20:41,880
因为字符串是数组，所以现在可以将数组视为指针。 

1710
01:20:41,880 --> 01:20:44,880
然后让我继续，打印出人类所输入的内容。 

1711
01:20:44,880 --> 01:20:46,470
S实际上就是这个。 

1712
01:20:46,470 --> 01:20:49,320
传递s ;,保存。 

1713
01:20:49,320 --> 01:20:49,987
是吗？ 

1714
01:20:49,987 --> 01:20:52,589
听众：那么[听不清] char *？ 

1715
01:20:52,589 --> 01:20:55,130
大卫·马兰：在这一点上，做char *是多余的， 

1716
01:20:55,130 --> 01:20:58,670
因为我字面上想要这个故事六个字。 

1717
01:20:58,670 --> 01:21:01,740
我想要空间，而不是六个字符。 

1718
01:21:01,740 --> 01:21:05,780
所以现在这是第2周的事情，没有涉及指针。 

1719
01:21:05,780 --> 01:21:08,810
但同样，现在只是展示这些想法的等同性。 

1720
01:21:08,810 --> 01:21:12,560
所以如果我现在进入这个，这是在我的另一个目录， 

1721
01:21:12,560 --> 01:21:19,760
make scanf2，Enter，。/ scanf2，s将输入 - 

1722
01:21:19,760 --> 01:21:22,864
我会输入我的名字，我知道我可以适应，我们又回来了。 

1723
01:21:22,864 --> 01:21:26,030
像现在这样工作，因为我不只是为字符串创建地址， 

1724
01:21:26,030 --> 01:21:27,488
我为字符串创建了空间。 

1725
01:21:27,488 --> 01:21:31,250
但是让我有点危险 - 

1726
01:21:31,250 --> 01:21:32,510
大卫马兰？ 

1727
01:21:32,510 --> 01:21:35,180
好的，那种方法很好。 

1728
01:21:35,180 --> 01:21:40,860
大卫马兰还是其他一些很长的名字？ 

1729
01:21:40,860 --> 01:21:42,230
好的，这也很有效。 

1730
01:21:42,230 --> 01:21:44,690
让我继续，再次运行它。 

1731
01:21:44,690 --> 01:21:48,077
让我再次尝试那个很长的字符串，看看会发生什么。 

1732
01:21:48,077 --> 01:21:49,910
我知道上次这种方法效果不佳。 

1733
01:21:49,910 --> 01:21:51,470
好的，完成了。 

1734
01:21:51,470 --> 01:21:53,090
哦，好的。 

1735
01:21:53,090 --> 01:21:57,470
所以现在我在那些有分段错误的人的俱乐部里。 

1736
01:21:57,470 --> 01:21:59,930
所以让我们了解这里发生了什么。 

1737
01:21:59,930 --> 01:22:01,970
我刚才宣称分段错误

1738
01:22:01,970 --> 01:22:05,420
正在触及一段，一段不是你自己的记忆。 

1739
01:22:05,420 --> 01:22:06,410
刚刚发生了什么？ 

1740
01:22:06,410 --> 01:22:09,230
好吧，这个简单的程序，我告诉电脑，嘿电脑， 

1741
01:22:09,230 --> 01:22:13,670
给我六个字符的空间，给我六个字节。 

1742
01:22:13,670 --> 01:22:18,170
使用scanf线，我告诉计算机，把以下用户

1743
01:22:18,170 --> 01:22:22,280
在该位置输入该字符数组。 

1744
01:22:22,280 --> 01:22:24,830
DAVID反斜杠0适合。 

1745
01:22:24,830 --> 01:22:27,890
大卫马兰并不是真的，但这似乎并不是什么大不了的事。 

1746
01:22:27,890 --> 01:22:33,000
大卫马兰或其他一些真正长的其他名字，也没有撞到电脑。 

1747
01:22:33,000 --> 01:22:36,365
但那是因为我们不知道，通常当你要求六个字节时， 

1748
01:22:36,365 --> 01:22:38,990
电脑有点像 - 它给你一些额外的东西。 

1749
01:22:38,990 --> 01:22:41,480
使用它们并不安全，但它足够了

1750
01:22:41,480 --> 01:22:44,870
你不一定会看到像分段错误这样的问题。 

1751
01:22:44,870 --> 01:22:47,310
但它通常只分配一些额外的字节， 

1752
01:22:47,310 --> 01:22:51,019
所以，如果你真的继续粘贴长，长，长，长的文字， 

1753
01:22:51,019 --> 01:22:53,060
最终你不仅会超过那六个人

1754
01:22:53,060 --> 01:22:55,634
字节，但远远超过特殊 - 

1755
01:22:55,634 --> 01:22:58,550
你得到的秘密字节，你不应该使用， 

1756
01:22:58,550 --> 01:23:00,675
那点电脑就放弃了，说， 

1757
01:23:00,675 --> 01:23:03,080
你在触摸记忆，你不应该，也就是说

1758
01:23:03,080 --> 01:23:04,040
分段故障。 

1759
01:23:04,040 --> 01:23:06,510
听众：[听不清]如果电脑给你

1760
01:23:06,510 --> 01:23:10,462
几个额外的字节，那么为什么不打印任何其他东西？ 

1761
01:23:10,462 --> 01:23:14,154
在你说[听不清]之后，它只是印了大卫。 

1762
01:23:14,154 --> 01:23:15,570
DAVID MALAN：非常好的问题。 

1763
01:23:15,570 --> 01:23:18,230
所以即使我得到这些额外的字节， 

1764
01:23:18,230 --> 01:23:20,720
为什么我在大卫之后没有见到他们？ 

1765
01:23:20,720 --> 01:23:21,920
我可能很幸运。 

1766
01:23:21,920 --> 01:23:24,560
长话短说，当你第一次运行程序时， 

1767
01:23:24,560 --> 01:23:28,370
默认情况下，程序可以访问的大部分内存都是默认初始化的

1768
01:23:28,370 --> 01:23:29,710
到0。 

1769
01:23:29,710 --> 01:23:33,590
0与反斜杠0相同，所以我很幸运。 

1770
01:23:33,590 --> 01:23:37,250
当我有大卫，然后在那个数组中有多余的空间， 

1771
01:23:37,250 --> 01:23:39,830
其中很多都已初始化为0， 

1772
01:23:39,830 --> 01:23:43,150
并且字符串正在为我秘密终止。 

1773
01:23:43,150 --> 01:23:46,880
或者更好的答案是，它是未定义的行为。 

1774
01:23:46,880 --> 01:23:49,160
就像你不应该触摸不属于你自己的记忆。 

1775
01:23:49,160 --> 01:23:52,820
之后发生的是你的风险。 

1776
01:23:52,820 --> 01:23:55,490
但这是为什么会发生这种情况的猜想。 

1777
01:23:55,490 --> 01:23:58,460
好吧，那么get_int的基本特征是什么

1778
01:23:58,460 --> 01:23:59,750
是为我们提供的？ 

1779
01:23:59,750 --> 01:24:02,480
所有这些时间get_int实际上都在处理

1780
01:24:02,480 --> 01:24:04,417
对我们来说这一切都令人头痛。 

1781
01:24:04,417 --> 01:24:07,250
老实说，即使我在思考，谈论也感到无聊

1782
01:24:07,250 --> 01:24:09,530
关于你如何从用户那里得到一个该死的字符串， 

1783
01:24:09,530 --> 01:24:12,197
因为你需要弄清楚，你需要多少字节？ 

1784
01:24:12,197 --> 01:24:15,071
如果人类比你期望的更多地咬一口怎么办？ 

1785
01:24:15,071 --> 01:24:17,300
然后你需要做一个切换器并获得更多的内存。 

1786
01:24:17,300 --> 01:24:20,059
get_string正在为我们解决所有这些问题。 

1787
01:24:20,059 --> 01:24:22,100
而这并不是说你需要永远使用它， 

1788
01:24:22,100 --> 01:24:23,933
确实有训练轮，但那是

1789
01:24:23,933 --> 01:24:27,569
只是因为当你使用C或许多编程语言时， 

1790
01:24:27,569 --> 01:24:29,610
计算机只会做你告诉它做的事情。 

1791
01:24:29,610 --> 01:24:31,927
事实证明，甚至要求用户输入， 

1792
01:24:31,927 --> 01:24:34,010
如果你不知道他或她是多少个人物

1793
01:24:34,010 --> 01:24:37,144
要从一开始就输入，你必须处理它。 

1794
01:24:37,144 --> 01:24:40,310
所以在引擎盖下面 - 欢迎你来看看来源

1795
01:24:40,310 --> 01:24:44,090
CS50库的代码，我将在今天晚些时候在主页上发布， 

1796
01:24:44,090 --> 01:24:48,050
事实证明，按照我们正在做的方式，get_string正在采取措施。 

1797
01:24:48,050 --> 01:24:50,780
我们确实喜欢一次获得一个角色

1798
01:24:50,780 --> 01:24:54,369
来自用户，我们去的道路。 

1799
01:24:54,369 --> 01:24:56,660
如果我们没有足够的空间，我们会问电脑， 

1800
01:24:56,660 --> 01:24:58,659
给我一些更多的字节，这样我就可以得到更多的字节， 

1801
01:24:58,659 --> 01:25:01,130
我们一次只得到一个角色

1802
01:25:01,130 --> 01:25:04,520
我们可以恶意或不小心打字方式处理用户

1803
01:25:04,520 --> 01:25:08,460
比我们实际期望的更多输入。 

1804
01:25:08,460 --> 01:25:10,640
那么让我们将所有这些都置于语境中。 

1805
01:25:10,640 --> 01:25:12,950
回想一下，过去几周我们一直在画这些照片。 

1806
01:25:12,950 --> 01:25:15,560
让我们直截了当地说明发生了什么。 

1807
01:25:15,560 --> 01:25:17,870
这是计算机中的内存模块。 

1808
01:25:17,870 --> 01:25:20,600
它只是一块绿板，在这里被吹得太大了， 

1809
01:25:20,600 --> 01:25:24,620
它很容易就像你的Mac或PC笔记本电脑或台式机一样大， 

1810
01:25:24,620 --> 01:25:25,880
虽然大小不一。 

1811
01:25:25,880 --> 01:25:28,501
其中一个黑色芯片是实际内存或字节

1812
01:25:28,501 --> 01:25:29,750
我们一直指的是。 

1813
01:25:29,750 --> 01:25:32,300
如果我们放大一下，回想一下我上周提出的建议

1814
01:25:32,300 --> 01:25:35,097
您可以将其视为网格，数组。 

1815
01:25:35,097 --> 01:25:38,180
而且它不一定是矩形，这只是一个艺术家的演绎， 

1816
01:25:38,180 --> 01:25:41,120
但是我们声称，每个方块代表一个字节。 

1817
01:25:41,120 --> 01:25:44,880
并且每个字节都可以用数字以某种方式寻址。 

1818
01:25:44,880 --> 01:25:49,250
而这个数字只是它的位置，也称为地址。 

1819
01:25:49,250 --> 01:25:52,590
实际上，我们可以看到这一点，如下所示。 

1820
01:25:52,590 --> 01:25:54,677
让我继续，在这里打开这个例子。 

1821
01:25:54,677 --> 01:25:57,260
或者实际上，你知道，让我们从头开始写这个。 

1822
01:25:57,260 --> 01:26:01,930
让我编写一个名为addresses.c的程序。 

1823
01:26:01,930 --> 01:26:09,230
这将使用我们的老朋友，CS50库和stdio.h和int 

1824
01:26:09,230 --> 01:26:11,090
主要空白。 

1825
01:26:11,090 --> 01:26:13,580
让我继续前进吧。 

1826
01:26:13,580 --> 01:26:15,307
我要继续拿一根绳子 - 

1827
01:26:15,307 --> 01:26:15,890
你知道吗？ 

1828
01:26:15,890 --> 01:26:21,420
没有更多的字符串char *来自用户，get_string，询问用户s。 

1829
01:26:21,420 --> 01:26:23,050
我们得到另一个字符串，又名

1830
01:26:23,050 --> 01:26:26,630
char *，get_string，从用户调用它。 

1831
01:26:26,630 --> 01:26:31,580
然后，我想打印出不像以前那样的字符串， 

1832
01:26:31,580 --> 01:26:32,550
打印出来的。 

1833
01:26:32,550 --> 01:26:37,360
我想打印出真正的指针，即地址。 

1834
01:26:37,360 --> 01:26:42,380
结果％p指针将打印出不是该内存位置的字符串， 

1835
01:26:42,380 --> 01:26:45,620
它将为你打印实际的内存位置。 

1836
01:26:45,620 --> 01:26:50,480
我可以在这里做同样的事情，％p，反斜杠0，粘贴在t。 

1837
01:26:50,480 --> 01:26:52,940
就这样我知道哪个是哪个，让我加上前缀

1838
01:26:52,940 --> 01:26:55,460
有一些文字 - 结肠和结肠。 

1839
01:26:55,460 --> 01:26:58,846
现在让我继续在这里做地址。 

1840
01:26:58,846 --> 01:27:02,390
哦，我搞砸了，错过了分号。 

1841
01:27:02,390 --> 01:27:03,500
让我再说一遍。 

1842
01:27:03,500 --> 01:27:07,940
制作地址。 

1843
01:27:07,940 --> 01:27:09,830
并摆脱这一点。 

1844
01:27:09,830 --> 01:27:14,390
那编译好了./addresses，我们走了。 

1845
01:27:14,390 --> 01:27:18,210
让我们输入 - 让我们像以前一样做Brian和Veronica。 

1846
01:27:18,210 --> 01:27:18,970
输入。 

1847
01:27:18,970 --> 01:27:23,290
这有点时髦，但它证明了Mac中的IDE 

1848
01:27:23,290 --> 01:27:25,430
你的电脑有很多内存。 

1849
01:27:25,430 --> 01:27:26,600
所以这是地址。 

1850
01:27:26,600 --> 01:27:30,070
它不像100那么小，它不像900那么小。 

1851
01:27:30,070 --> 01:27:31,750
它实际上有点大。 

1852
01:27:31,750 --> 01:27:36,245
这是奇怪的0x，它是2331010。 

1853
01:27:36,245 --> 01:27:38,370
事实证明，这只是一个人类的惯例。 

1854
01:27:38,370 --> 01:27:40,510
在第0周，我们讨论了小数和我们所有人

1855
01:27:40,510 --> 01:27:43,030
从小数点开始，从0到9的10位数。 

1856
01:27:43,030 --> 01:27:46,060
谈了二进制0和1的一点点。 

1857
01:27:46,060 --> 01:27:48,700
结果发现有无数的基础系统 - 

1858
01:27:48,700 --> 01:27:53,350
decimal / dec，binary / bi只是无限多种可能性中的两种。 

1859
01:27:53,350 --> 01:27:57,370
结果发现另一个超级常见的称为十六进制。 

1860
01:27:57,370 --> 01:27:59,890
Hexa在这种情况下意味着16。 

1861
01:27:59,890 --> 01:28:03,940
因此base-16实际上在其字母表中有16个字母。 

1862
01:28:03,940 --> 01:28:11,560
0,1,2,3,4,5,6,7,8,9，a，b，c，d，e，f。 

1863
01:28:11,560 --> 01:28:15,990
事实证明，基本系统需要计数超过10个字符

1864
01:28:15,990 --> 01:28:18,430
按惯例开始使用字母表的字母。 

1865
01:28:18,430 --> 01:28:19,840
人类刚刚决定这一点。 

1866
01:28:19,840 --> 01:28:22,620
所以我们在这种情况下只得到数字， 

1867
01:28:22,620 --> 01:28:24,640
但如果这些地址更大，我们

1868
01:28:24,640 --> 01:28:30,434
实际上可能会在a和f之间看到一些字母。 

1869
01:28:30,434 --> 01:28:32,350
坦率地说，我不知道这是什么地址， 

1870
01:28:32,350 --> 01:28:34,308
但谷歌通常都很擅长这个东西， 

1871
01:28:34,308 --> 01:28:39,000
所以让我实际打开另一个浏览器窗口。 

1872
01:28:39,000 --> 01:28:39,300
所以谷歌是你的朋友，所以让我实际打开另一个浏览器窗口。 

1873
01:28:39,300 --> 01:28:41,340
所以谷歌就是你的朋友， 

1874
01:28:41,340 --> 01:28:42,570
或任何数量的计算器。 

1875
01:28:42,570 --> 01:28:47,000
请输入十进制的0x2331010。 

1876
01:28:47,000 --> 01:28:48,300
谷歌已经翻译过了。 

1877
01:28:48,300 --> 01:28:51,020
所以布赖恩，我 - 有点早一点。 

1878
01:28:51,020 --> 01:28:54,240
他不在地址0，他实际上

1879
01:28:54,240 --> 01:28:58,890
在我的电脑里面的第3600万字节

1880
01:28:58,890 --> 01:29:02,760
现在，位置36,900,880。 

1881
01:29:02,760 --> 01:29:05,100
所以地址比100高一点。 

1882
01:29:05,100 --> 01:29:09,090
然后是Veronica，如果你真的想进入这里的杂草， 

1883
01:29:09,090 --> 01:29:12,400
我们可以说“十进制”，让谷歌为我们翻译。 

1884
01:29:12,400 --> 01:29:16,140
她在36,900,944。 

1885
01:29:16,140 --> 01:29:16,740
为什么？ 

1886
01:29:16,740 --> 01:29:17,430
谁在乎？ 

1887
01:29:17,430 --> 01:29:22,200
计算机正在为我们管理所有这些，但是当get_string使用malloc时， 

1888
01:29:22,200 --> 01:29:26,160
这些字面意思是返回的数字， 

1889
01:29:26,160 --> 01:29:28,980
你可以使用这块记忆。 

1890
01:29:28,980 --> 01:29:30,980
为什么人类使用十六进制？ 

1891
01:29:30,980 --> 01:29:39,030
就像它只是稍微更紧凑一样说0x2331050，那么36900944-- 

1892
01:29:39,030 --> 01:29:41,640
就像你只保存几个数字，所以这只是传统的。 

1893
01:29:41,640 --> 01:29:43,090
就是这样，那里没有魔力。 

1894
01:29:43,090 --> 01:29:44,580
但是，回想一下。 

1895
01:29:44,580 --> 01:29:47,400
你还记得当我早先打开调试器时， 

1896
01:29:47,400 --> 01:29:51,820
你在我的名字变量旁边看到了一个隐含的0x0值吗？ 

1897
01:29:51,820 --> 01:29:53,910
然后有另一个我不记得的价值 - 

1898
01:29:53,910 --> 01:29:55,320
0X-什么？ 

1899
01:29:55,320 --> 01:30:00,270
那只是我十六进制名字的数字地址。 

1900
01:30:00,270 --> 01:30:06,170
而0x0只是null使用的技术地址。 

1901
01:30:06,170 --> 01:30:06,950
是吗？ 

1902
01:30:06,950 --> 01:30:12,710
听众：你说打印出来的地址是变量s的[听不清] x 

1903
01:30:12,710 --> 01:30:13,210
和 - 

1904
01:30:13,210 --> 01:30:13,960
大卫马兰：对不起，你能再说一遍吗？ 

1905
01:30:13,960 --> 01:30:17,530
听众：你说屏幕上打印的地址是x， 

1906
01:30:17,530 --> 01:30:20,150
但是x是[听不清] 

1907
01:30:20,150 --> 01:30:21,780
大卫马兰：啊，我应该澄清一下。 

1908
01:30:21,780 --> 01:30:24,990
0x，人类几年前决定你什么时候看到任何东西

1909
01:30:24,990 --> 01:30:29,040
使用0x，这意味着下一步是十六进制。 

1910
01:30:29,040 --> 01:30:30,250
只是大会。 

1911
01:30:30,250 --> 01:30:35,010
如果它以0开头也是常见的，它是一个八进制，它是base-8。 

1912
01:30:35,010 --> 01:30:37,460
如果在末尾看到小写的b，则表示二进制。 

1913
01:30:37,460 --> 01:30:39,210
所以人类刚刚提出了符号系统

1914
01:30:39,210 --> 01:30:41,850
至于那种与读者沟通的方式，就是这样。 

1915
01:30:41,850 --> 01:30:42,930
不属于价值的一部分。 

1916
01:30:42,930 --> 01:30:45,840
事实证明，我们实际上可以自己做这个数学。 

1917
01:30:45,840 --> 01:30:47,760
而且我们不会真正深入研究这种杂草

1918
01:30:47,760 --> 01:30:50,010
因为它不是特别有用的生活

1919
01:30:50,010 --> 01:30:52,310
技能，能够转换为各种基础系统， 

1920
01:30:52,310 --> 01:30:54,480
但是，让我们举一个例子，以便我们看到它。 

1921
01:30:54,480 --> 01:30:56,070
只是为了表明这里没有魔力， 

1922
01:30:56,070 --> 01:30:59,060
这只是思考数字与小学的不同方式。 

1923
01:30:59,060 --> 01:31:01,470
所以，如果当天我们有三个十进制数字 - 

1924
01:31:01,470 --> 01:31:06,750
255,216，然后另一个255，如果我们倒回第0周， 

1925
01:31:06,750 --> 01:31:09,310
我们可以通过将其转换为二进制的数学运算。 

1926
01:31:09,310 --> 01:31:12,480
即使它可能需要你一段时间，这是二进制等价物。 

1927
01:31:12,480 --> 01:31:15,590
坦率地说，第一个也是最后一个很容易。 

1928
01:31:15,590 --> 01:31:19,350
255是一种特殊值，因为有8位，所有这些都是

1929
01:31:19,350 --> 01:31:21,690
是1，这就是给你255的东西。 

1930
01:31:21,690 --> 01:31:23,500
所以唯一困难的就是这个。 

1931
01:31:23,500 --> 01:31:25,410
但是今天谁在乎数学。 

1932
01:31:25,410 --> 01:31:28,350
我们从几周前就知道，如果我们真的尝试过，我们可以做到这一点。 

1933
01:31:28,350 --> 01:31:35,760
但请注意，字节是8位，当然，8是一对4， 

1934
01:31:35,760 --> 01:31:36,720
如果你愿意的话。 

1935
01:31:36,720 --> 01:31:40,800
那么十六进制真正的好处是它从0开始

1936
01:31:40,800 --> 01:31:41,560
并结束于f。 

1937
01:31:41,560 --> 01:31:46,100
那是0,1,2,3,4,5,6,7,8,9-- 

1938
01:31:46,100 --> 01:31:47,560
等等 - 是的，那是10。 

1939
01:31:47,560 --> 01:31:48,060
好。 

1940
01:31:48,060 --> 01:31:51,240
然后a，b，c，d，e，f。 

1941
01:31:51,240 --> 01:31:54,840
我总共举起了16个手指，因此是十六进制的。 

1942
01:31:54,840 --> 01:32:00,630
base-16的优点是我需要从0开始计算多少位

1943
01:32:00,630 --> 01:32:02,010
至 - 

1944
01:32:02,010 --> 01:32:03,120
一二三四 - 

1945
01:32:03,120 --> 01:32:05,400
15？ 

1946
01:32:05,400 --> 01:32:06,510
只是4，对吗？ 

1947
01:32:06,510 --> 01:32:09,510
所以如果我有0位，那就是0。 

1948
01:32:09,510 --> 01:32:13,010
如果我有4个1位，那么 - 

1949
01:32:13,010 --> 01:32:13,560
让我们来看看。 

1950
01:32:13,560 --> 01:32:18,940
这是一个8加4加2加1给我15。 

1951
01:32:18,940 --> 01:32:22,830
长话短说，十六进制的超级便利，因为0到f 

1952
01:32:22,830 --> 01:32:25,230
巧妙地将地图清晰地映射到4位。 

1953
01:32:25,230 --> 01:32:28,110
因此，这只是一种不以8为单位思考世界的好方法

1954
01:32:28,110 --> 01:32:29,670
但在4中。 

1955
01:32:29,670 --> 01:32:31,800
所以我在这里所做的就是我接受了我的价值观

1956
01:32:31,800 --> 01:32:33,720
添加了一点空格来表达清楚

1957
01:32:33,720 --> 01:32:35,970
8位就像一对4位。 

1958
01:32:35,970 --> 01:32:40,760
事实证明，由于我先前列举的原因，1 1 1 1是f。 

1959
01:32:40,760 --> 01:32:44,700
所有1都是f，也称为15。 

1960
01:32:44,700 --> 01:32:47,100
所有1都是f，也称为15。 

1961
01:32:47,100 --> 01:32:55,470
如果我们进行数学计算，1 1 0 1是d，1 0 0 0是8，然后所有1都是f和f。 

1962
01:32:55,470 --> 01:32:58,710
长话短说，有一种方法可以从十进制转换

1963
01:32:58,710 --> 01:33:01,390
二进制，十六进制，任意数量的其他基本系统。 

1964
01:33:01,390 --> 01:33:03,600
这一切只是归结为你关心的数字。 

1965
01:33:03,600 --> 01:33:05,640
你写这个的方式，早些时候你的问题， 

1966
01:33:05,640 --> 01:33:06,720
是按人类惯例。 

1967
01:33:06,720 --> 01:33:12,510
不只是FFDAFF，而是0xFF0xD80xFF只是因为。 

1968
01:33:12,510 --> 01:33:14,430
然后用户清楚它是什么。 

1969
01:33:14,430 --> 01:33:16,740
所以现在有点轻浮。 

1970
01:33:16,740 --> 01:33:19,260
我很抱歉这样对你，但现在你们都希望如此

1971
01:33:19,260 --> 01:33:21,120
了解这个着名的漫画。 

1972
01:33:26,560 --> 01:33:29,610
好的，欢迎来到那些理解这样的人的俱乐部。 

1973
01:33:29,610 --> 01:33:34,830
所以现在让我们发现最后一个问题， 

1974
01:33:34,830 --> 01:33:36,920
我们将把它带回家

1975
01:33:36,920 --> 01:33:41,180
一个非常性感的取证领域，所有这些积木

1976
01:33:41,180 --> 01:33:42,190
会发挥作用。 

1977
01:33:42,190 --> 01:33:43,740
但首先让我们从问题开始。 

1978
01:33:43,740 --> 01:33:47,300
假设我想在这里实现一个名为swap的函数，其目的就是生命

1979
01:33:47,300 --> 01:33:49,160
只是交换两个值，a和b。 

1980
01:33:49,160 --> 01:33:50,660
我只想做一个切换器。 

1981
01:33:50,660 --> 01:33:54,800
让我们首先用至少一种中期讲座小吃来做这件事

1982
01:33:54,800 --> 01:33:55,400
一个人。 

1983
01:33:55,400 --> 01:33:56,880
有人会为 - 

1984
01:33:56,880 --> 01:33:57,680
好的，那很快。 

1985
01:33:57,680 --> 01:34:00,080
志愿者，来吧。 

1986
01:34:00,080 --> 01:34:01,160
你叫什么名字？ 

1987
01:34:01,160 --> 01:34:02,580
好吧，好吧。 

1988
01:34:02,580 --> 01:34:04,210
谢谢你突然做志愿者。 

1989
01:34:07,880 --> 01:34:09,720
凯莉，大卫，很高兴认识你。 

1990
01:34:09,720 --> 01:34:11,900
好的，手头的任务非常简单。 

1991
01:34:11,900 --> 01:34:16,080
我这里有两个空杯子，我们有一些橙汁。 

1992
01:34:19,480 --> 01:34:22,400
好的，把它放在这里。 

1993
01:34:22,400 --> 01:34:26,890
我们这里有一些牛奶。 

1994
01:34:26,890 --> 01:34:29,870
这应该是突出的，非常不同的颜色。 

1995
01:34:29,870 --> 01:34:34,830
好吧，我想你，凯利，如果可以的话，交换这两个值。 

1996
01:34:34,830 --> 01:34:37,000
橙子进入牛奶，牛奶变成橙色。 

1997
01:34:42,450 --> 01:34:44,390
那是作弊，好吗？ 

1998
01:34:44,390 --> 01:34:45,840
不，我的意思是杯子。 

1999
01:34:45,840 --> 01:34:47,430
我把它们放在错误的杯子里，我更喜欢我的牛奶

2000
01:34:47,430 --> 01:34:50,130
在另一个杯子和另一个杯子里我的橙汁，我很抱歉。 

2001
01:34:53,190 --> 01:34:54,640
听众：把它倒进来。 

2002
01:34:54,640 --> 01:34:56,730
大卫马兰：不，你无法使用，好吗？ 

2003
01:34:56,730 --> 01:34:57,860
[笑声] 

2004
01:34:57,860 --> 01:34:59,280
好的，所以你在挣扎。 

2005
01:34:59,280 --> 01:35:00,240
你为什么挣扎？ 

2006
01:35:00,240 --> 01:35:01,830
凯莉：因为我要把它们混在一起。 

2007
01:35:01,830 --> 01:35:03,080
然后它就不一样了。 

2008
01:35:03,080 --> 01:35:03,870
大卫马兰：对。 

2009
01:35:03,870 --> 01:35:06,570
所以我的意思是，这显然是一种失败的主张。 

2010
01:35:06,570 --> 01:35:07,320
你真的不能这样做。 

2011
01:35:07,320 --> 01:35:09,300
除了把它们放回去之外，什么会让你更容易

2012
01:35:09,300 --> 01:35:10,110
在瓶子里？ 

2013
01:35:10,110 --> 01:35:10,870
凯莉：还有另一个容器。 

2014
01:35:10,870 --> 01:35:11,620
大卫马兰：是的。 

2015
01:35:11,620 --> 01:35:14,490
所以你需要一个临时的存储空间。 

2016
01:35:14,490 --> 01:35:15,240
你知道，让我 - 

2017
01:35:15,240 --> 01:35:18,560
塔拉，我们可以在这里再喝一些杯子吗？ 

2018
01:35:18,560 --> 01:35:20,700
啊，这会让事情变得更容易。 

2019
01:35:20,700 --> 01:35:22,760
好吧，如果我给你一些临时空间 - 

2020
01:35:22,760 --> 01:35:24,970
你走了 - 你能解决这个问题吗？ 

2021
01:35:28,330 --> 01:35:30,370
啊，非常好。 

2022
01:35:30,370 --> 01:35:35,150
有点污染，但没关系。 

2023
01:35:35,150 --> 01:35:37,270
但我需要为Tara提供临时杯。 

2024
01:35:37,270 --> 01:35:38,830
是的，好的。 

2025
01:35:38,830 --> 01:35:39,790
谢谢。 

2026
01:35:39,790 --> 01:35:42,250
好吧，如果我们可以在这里为凯利赢得一阵掌声。 

2027
01:35:42,250 --> 01:35:44,090
[掌声] 

2028
01:35:44,090 --> 01:35:44,890
好吧，我们走了。 

2029
01:35:44,890 --> 01:35:47,230
我猜你不想要温牛奶，而是橙汁？ 

2030
01:35:47,230 --> 01:35:47,720
好。 

2031
01:35:47,720 --> 01:35:48,490
非常感谢。 

2032
01:35:48,490 --> 01:35:50,350
好的，那么这里有什么意义呢？ 

2033
01:35:50,350 --> 01:35:51,260
这很简单。 

2034
01:35:51,260 --> 01:35:53,350
就像你有一些临时存储

2035
01:35:53,350 --> 01:35:57,140
space--一个变量，如果你愿意，就像交换两个值一样没问题。 

2036
01:35:57,140 --> 01:36:00,080
所以，让我继续这样做，如下所示。 

2037
01:36:00,080 --> 01:36:02,740
我将继续执行此交换功能

2038
01:36:02,740 --> 01:36:05,760
并且看到凯利最终刚刚实施了它。 

2039
01:36:05,760 --> 01:36:09,430
如果目标是交换a和b，我不能只做一个完整的切换器， 

2040
01:36:09,430 --> 01:36:10,090
它似乎。 

2041
01:36:10,090 --> 01:36:13,600
我需要将其中一个值（如牛奶）放入另一个容器中， 

2042
01:36:13,600 --> 01:36:15,100
然后交换然后交换。 

2043
01:36:15,100 --> 01:36:17,170
所以它需要三个步骤，而不仅仅是一个步骤。 

2044
01:36:17,170 --> 01:36:19,810
好吧，所以我可以称这个额外的变量或杯子

2045
01:36:19,810 --> 01:36:22,270
塔拉给了我们任何我们想要的东西 -  tmp。 

2046
01:36:22,270 --> 01:36:25,210
所以我只想把它放入tmp。 

2047
01:36:25,210 --> 01:36:28,540
然后我要把b放进去，因为现在是空的。 

2048
01:36:28,540 --> 01:36:31,050
然后我要将tmp放入b，然后我不会

2049
01:36:31,050 --> 01:36:33,760
关心tmp会发生什么 - 事实上，它仍然只是坐在那里， 

2050
01:36:33,760 --> 01:36:35,690
但现在这项工作已经完成。 

2051
01:36:35,690 --> 01:36:39,610
所以让我们继续看看这个程序的实际应用，因为很明显

2052
01:36:39,610 --> 01:36:40,990
应该很简单。 

2053
01:36:40,990 --> 01:36:44,260
所以，让我继续开放这个计划

2054
01:36:44,260 --> 01:36:47,920
在主函数的上下文中，我们可以实际运行它。 

2055
01:36:47,920 --> 01:36:51,030
在这里的代码中，我将演示如下。 

2056
01:36:51,030 --> 01:36:52,030
这是我的主要功能。 

2057
01:36:52,030 --> 01:36:55,120
我要调用变量x，给它1，调用变量y， 

2058
01:36:55,120 --> 01:36:58,470
给它2，继续打印出来只是为了快速进行健全检查 - 

2059
01:36:58,470 --> 01:37:00,580
x是这个，是的。 

2060
01:37:00,580 --> 01:37:04,390
然后我将调用这个超级简单的交换函数x，y。 

2061
01:37:04,390 --> 01:37:08,050
然后我要打印完全相同的东西 -  x是这个，是的，是的， 

2062
01:37:08,050 --> 01:37:09,650
只是这样我可以看到那些变量 - 

2063
01:37:09,650 --> 01:37:12,250
我也可以使用debug50，但这是一个完整的解决方案， 

2064
01:37:12,250 --> 01:37:13,600
我想在屏幕上看到它。 

2065
01:37:13,600 --> 01:37:14,410
这是交换。 

2066
01:37:14,410 --> 01:37:16,360
我从以前复制粘贴。 

2067
01:37:16,360 --> 01:37:18,610
这感觉就像一个简单明了，超级直白， 

2068
01:37:18,610 --> 01:37:23,770
让我们进入我的目录并编译这个程序，这是一个轻微的扰流板， 

2069
01:37:23,770 --> 01:37:26,590
noswap就是这个名字。 

2070
01:37:26,590 --> 01:37:29,730
./noswap。 

2071
01:37:29,730 --> 01:37:32,180
钱币。 

2072
01:37:32,180 --> 01:37:33,830
我们放大一下。 

2073
01:37:33,830 --> 01:37:35,630
不，这不是我想要的，对吧？ 

2074
01:37:35,630 --> 01:37:38,380
我真打算牛奶成为OJ，OJ成为牛奶， 

2075
01:37:38,380 --> 01:37:41,950
或者x变成y，y变成x，这似乎不起作用。 

2076
01:37:41,950 --> 01:37:44,750
再一次，唯一的魔力是这一次调用交换。 

2077
01:37:44,750 --> 01:37:46,750
好吧，也许它只是在某些时候有效。 

2078
01:37:46,750 --> 01:37:49,050
所以不，不，好吧。 

2079
01:37:49,050 --> 01:37:50,350
现在是调试器的时候了。 

2080
01:37:50,350 --> 01:37:52,390
我不明白我的节目里发生了什么， 

2081
01:37:52,390 --> 01:37:54,430
printf在这里并不是很有启发性。 

2082
01:37:54,430 --> 01:37:58,530
所以让我继续运行debug50 ./noswap。 

2083
01:37:58,530 --> 01:38:00,660
小调试面板在侧面打开， 

2084
01:38:00,660 --> 01:38:02,440
但是等等，我需要一个断点。 

2085
01:38:02,440 --> 01:38:05,660
我将在最顶端开始一个断点，这是我关心的第一条线。 

2086
01:38:05,660 --> 01:38:08,050
我真的不关心超级顶级的所有东西。 

2087
01:38:08,050 --> 01:38:12,330
现在我要继续并重新运行debug50 ./noswap，好吗？ 

2088
01:38:12,330 --> 01:38:15,680
现在我看到这里，第一行9突出显示。 

2089
01:38:15,680 --> 01:38:17,640
请注意右侧，也许这可能

2090
01:38:17,640 --> 01:38:19,890
以前通过例子回答你的问题。 

2091
01:38:19,890 --> 01:38:23,490
方便地使用x和y，但仅仅因为我们初始化为0-- 

2092
01:38:23,490 --> 01:38:26,500
不是我，我不应该在所有情况下都相信这一点， 

2093
01:38:26,500 --> 01:38:28,160
但这就是为什么他们有价值观。 

2094
01:38:28,160 --> 01:38:31,500
他们被称为垃圾价值，但我很幸运0。 

2095
01:38:31,500 --> 01:38:34,500
让我继续走过那条线，如果你看，尽管很小， 

2096
01:38:34,500 --> 01:38:39,070
在右侧，x应该突然取值1。 

2097
01:38:39,070 --> 01:38:43,170
如果我跨过一行，y应该取值2。 

2098
01:38:43,170 --> 01:38:45,930
好的，所以我非常有信心这个程序到目前为止是正确的。 

2099
01:38:45,930 --> 01:38:48,390
我要继续前进并跳过printf。 

2100
01:38:48,390 --> 01:38:51,460
注意蓝色终端窗口，我看到一个输出。 

2101
01:38:51,460 --> 01:38:53,010
现在事情变得有趣了。 

2102
01:38:53,010 --> 01:38:56,700
如果我继续踩过线路，它就会完成运行

2103
01:38:56,700 --> 01:38:58,020
这还不够。 

2104
01:38:58,020 --> 01:39:01,890
所以请注意这次我要将鼠标悬停在第三个图标Step Into上。 

2105
01:39:01,890 --> 01:39:03,670
现在我可以走下兔子洞， 

2106
01:39:03,670 --> 01:39:07,110
可以这么说，进入交换功能，注意， 

2107
01:39:07,110 --> 01:39:09,430
调试器跳转到其他功能。 

2108
01:39:09,430 --> 01:39:11,400
所以现在，情况发生了变化。 

2109
01:39:11,400 --> 01:39:15,570
我的局部变量现在是a，b和tmp，这真的很奇怪。 

2110
01:39:15,570 --> 01:39:21,000
A是1，b是2，正如预期的那样，因为我通过了x，y。 

2111
01:39:21,000 --> 01:39:25,380
在这个函数的上下文中，我只是称它们为a，b因为。 

2112
01:39:25,380 --> 01:39:29,450
但为什么是tmp 32,767？ 

2113
01:39:29,450 --> 01:39:31,950
这只是因为它不可信，它是一个垃圾值。 

2114
01:39:31,950 --> 01:39:35,760
如果你只是给自己一个临时价值，谁知道那里有什么？ 

2115
01:39:35,760 --> 01:39:38,250
我们很幸运，Tara在这个杯子里没有任何东西， 

2116
01:39:38,250 --> 01:39:41,370
但它可能有垃圾价值，也许它有一些百事可乐， 

2117
01:39:41,370 --> 01:39:44,100
然后我们不得不以某种方式替换该值。 

2118
01:39:44,100 --> 01:39:47,130
所以要明确的是，当你在程序中声明变量时， 

2119
01:39:47,130 --> 01:39:50,430
他们经常有垃圾价值，只是虚假价值 - 

2120
01:39:50,430 --> 01:39:53,620
那个筹码中引擎盖下面的0和1， 

2121
01:39:53,620 --> 01:39:55,020
但是你没有自己设定。 

2122
01:39:55,020 --> 01:39:59,550
但那没关系，因为我明确地在下一行设置tmp等于a。 

2123
01:39:59,550 --> 01:40:03,990
因此它的原始奇怪值是什么并不重要，所以如果我单击Next， 

2124
01:40:03,990 --> 01:40:06,160
tmp现在是1，又名

2125
01:40:06,160 --> 01:40:07,500
一个。 

2126
01:40:07,500 --> 01:40:11,230
现在注意，如果你看右手边，它会变成b。 

2127
01:40:11,230 --> 01:40:15,480
现在我似乎有一个是2，b是2，这有点令人担忧，但不是那么糟糕， 

2128
01:40:15,480 --> 01:40:18,570
因为我有单独的变量tmp，所以我仍然有一个。 

2129
01:40:18,570 --> 01:40:22,770
所以现在b即将成为1，我已经完成了切换器。 

2130
01:40:22,770 --> 01:40:27,870
好的，在故事的第22行，我的代码似乎是正确的。 

2131
01:40:27,870 --> 01:40:30,750
b已成为a，a已成为b，且值已交换 - 

2132
01:40:30,750 --> 01:40:34,650
并且调试器在视觉上确认了这一点。 

2133
01:40:34,650 --> 01:40:39,900
那么现在，让我们迈出一步 - 

2134
01:40:39,900 --> 01:40:42,560
该死。 

2135
01:40:42,560 --> 01:40:43,990
丢失。 

2136
01:40:43,990 --> 01:40:45,820
到底是怎么回事？ 

2137
01:40:45,820 --> 01:40:46,600
直觉？ 

2138
01:40:46,600 --> 01:40:53,010
即使你以前从未见过或做过这样的事情，就像显然有一个错误一样。 

2139
01:40:53,010 --> 01:40:55,170
那是什么bug？ 

2140
01:40:55,170 --> 01:40:56,130
必须发生什么？ 

2141
01:40:56,130 --> 01:40:57,090
是吗？ 

2142
01:40:57,090 --> 01:41:01,830
听众：[听不清]一个新值[听不清] 

2143
01:41:01,830 --> 01:41:03,830
第一个地址没有相同的地址？ 

2144
01:41:03,830 --> 01:41:04,580
大卫马兰：是的。 

2145
01:41:04,580 --> 01:41:07,480
这里似乎发生的事情是肯定的，你传递的是x和y 

2146
01:41:07,480 --> 01:41:12,190
并称它为a和b，但a和b似乎是x和y的副本。 

2147
01:41:12,190 --> 01:41:16,060
我非常成功，非常正确地交换a和b， 

2148
01:41:16,060 --> 01:41:20,170
但因为它们是副本，它对原始的x和y没有影响。 

2149
01:41:20,170 --> 01:41:22,810
因此，我们对果汁的比喻并不恰当

2150
01:41:22,810 --> 01:41:27,250
因为我没有通过OJ和牛奶的Kelly副本， 

2151
01:41:27,250 --> 01:41:31,630
我递给她实际的OJ和牛奶，她能够改变价值观。 

2152
01:41:31,630 --> 01:41:35,290
但是在C和代码的上下文中，当您将参数传递给函数时， 

2153
01:41:35,290 --> 01:41:38,300
你将这些参数的副本传递给函数。 

2154
01:41:38,300 --> 01:41:40,930
直观地说，解决方案是什么？ 

2155
01:41:40,930 --> 01:41:44,980
如果我们，我们显然无法从一个函数传递到另一个值的副本

2156
01:41:44,980 --> 01:41:47,920
期待功能交换，或称

2157
01:41:47,920 --> 01:41:50,720
凯利，为我们做出一些有益的改变。 

2158
01:41:50,720 --> 01:41:55,090
我们需要传递给函数或者Kelly呢？ 

2159
01:41:55,090 --> 01:41:57,370
那些价值观的地址，对吧？ 

2160
01:41:57,370 --> 01:41:59,950
我告诉她牛奶和OJ在哪里。 

2161
01:41:59,950 --> 01:42:02,710
我没有给她复印件，我告诉她，这是牛奶， 

2162
01:42:02,710 --> 01:42:04,740
这是OJ，交换那些。 

2163
01:42:04,740 --> 01:42:06,580
在这个版本的代码中，我刚才说过， 

2164
01:42:06,580 --> 01:42:10,570
这里是x的副本，这里是y的副本，你可以称它们为a和b--嗯 -  mmm。 

2165
01:42:10,570 --> 01:42:14,660
我们现在需要使用＆符号或类似的东西来传递地图， 

2166
01:42:14,660 --> 01:42:15,160
如果你愿意的话。 

2167
01:42:15,160 --> 01:42:20,020
这些值的宝藏图使交换可以改变原始值。 

2168
01:42:20,020 --> 01:42:22,660
而我们这样做的方式有点奇怪， 

2169
01:42:22,660 --> 01:42:27,640
但是我们要做的就是在这里做一点补充

2170
01:42:27,640 --> 01:42:29,830
看起来如下。 

2171
01:42:29,830 --> 01:42:33,320
它必须看起来像这样。 

2172
01:42:33,320 --> 01:42:35,170
所以这是破碎的版本。 

2173
01:42:35,170 --> 01:42:39,070
或者说它虽然有效，却没有我们想要的效果。 

2174
01:42:39,070 --> 01:42:41,530
这是我们需要做的事情，而这是最后一件事

2175
01:42:41,530 --> 01:42:42,990
今天的新符号系统。 

2176
01:42:42,990 --> 01:42:44,950
我们在几个不同的地方见过明星

2177
01:42:44,950 --> 01:42:47,920
之前，现在我们在最后一个环境中使用它。 

2178
01:42:47,920 --> 01:42:53,080
当你在这里和函数的参数中指定一个星时，那个

2179
01:42:53,080 --> 01:42:55,120
就是你告诉电脑的方式，我

2180
01:42:55,120 --> 01:42:57,820
期望不是int，而是int的地址。 

2181
01:42:57,820 --> 01:43:00,320
我期待这里不是int，而是int的地址。 

2182
01:43:00,320 --> 01:43:03,520
所以有两个指针，两个整数地址。 

2183
01:43:03,520 --> 01:43:05,860
在这里，tmp仍然只是一个int。 

2184
01:43:05,860 --> 01:43:08,630
我不需要过度思考tmp，那只是一个空杯子。 

2185
01:43:08,630 --> 01:43:11,410
从第1周开始给我一个名为tmp的整数。 

2186
01:43:11,410 --> 01:43:14,230
但是，我想在tmp中存储什么？ 

2187
01:43:14,230 --> 01:43:17,140
此版本中的a和b都是地址。 

2188
01:43:17,140 --> 01:43:22,370
我想记住地址a和地址b吗？ 

2189
01:43:22,370 --> 01:43:25,460
不，我想记住OJ的体积，牛奶的体积， 

2190
01:43:25,460 --> 01:43:29,780
我想记住1和2，我不在乎它们在记忆中的位置。 

2191
01:43:29,780 --> 01:43:34,460
因此，在没有提及数据类型的情况下明星

2192
01:43:34,460 --> 01:43:37,110
只有一颗星和一个变量名。 

2193
01:43:37,110 --> 01:43:39,410
该变量是一个指针，它不是乘法， 

2194
01:43:39,410 --> 01:43:40,960
没有数学可循。 

2195
01:43:40,960 --> 01:43:46,340
该明星是解除引用的运营商，说到这个地址

2196
01:43:46,340 --> 01:43:48,030
并获得价值。 

2197
01:43:48,030 --> 01:43:52,070
所以，如果这个地址是在位置，我不知道，100就像布莱恩一样， 

2198
01:43:52,070 --> 01:43:55,400
这个地址b就像Veronica那样位于900处， 

2199
01:43:55,400 --> 01:44:01,160
* a表示转到内存中的第100个字节并获取该值，即1。 

2200
01:44:01,160 --> 01:44:05,990
这意味着，在这里，转到地址b，在地址900处获取该值， 

2201
01:44:05,990 --> 01:44:07,580
这是2。 

2202
01:44:07,580 --> 01:44:10,670
并继续在tmp中存储1。 

2203
01:44:10,670 --> 01:44:13,490
来吧，去那个地址，把任何东西

2204
01:44:13,490 --> 01:44:17,300
在b的地址 - 所以得到那个地址并把它翻过来 - 得到那个地址， 

2205
01:44:17,300 --> 01:44:20,840
获取值，并通过解除引用将其放在该地址。 

2206
01:44:20,840 --> 01:44:26,310
最后，转到内存中的b，就像在那里一样，将tmp值放在那里。 

2207
01:44:26,310 --> 01:44:28,910
因此，在前面的例子中，＆符号表示， 

2208
01:44:28,910 --> 01:44:32,690
告诉我变量的地址是什么，明星是相反的。 

2209
01:44:32,690 --> 01:44:35,360
如果你有一个地址，它说，去那个地址。 

2210
01:44:35,360 --> 01:44:39,410
按照藏宝图，X标记记忆中该位置的斑点， 

2211
01:44:39,410 --> 01:44:40,950
并获得它的价值。 

2212
01:44:40,950 --> 01:44:42,850
那么这里的净效果是什么？ 

2213
01:44:42,850 --> 01:44:46,850
如果我现在实际上打开的不是这个例子，而是swap.c-- 

2214
01:44:46,850 --> 01:44:50,030
剧透，这个实际上会起作用。 

2215
01:44:50,030 --> 01:44:55,490
如果我打开swap.c，我们现在将看到以下内容。 

2216
01:44:55,490 --> 01:44:58,600
除了我粘贴它之外，代码几乎相同

2217
01:44:58,600 --> 01:45:01,160
在这个新的绿色版本的功能。 

2218
01:45:01,160 --> 01:45:03,200
请注意，这有变化。 

2219
01:45:03,200 --> 01:45:11,860
为什么我现在输入％x和％y而不是x和y？ 

2220
01:45:11,860 --> 01:45:17,200
听众：[听不清]地址[听不清]功能[听不清] .. 

2221
01:45:17,200 --> 01:45:18,190
大卫马兰：没错。 

2222
01:45:18,190 --> 01:45:20,140
交换功能现在，新的改进版本

2223
01:45:20,140 --> 01:45:22,840
预计有两个地址 - 星星。 

2224
01:45:22,840 --> 01:45:25,840
每颗星，又名指针，不仅仅是价值。 

2225
01:45:25,840 --> 01:45:29,800
所以这意味着我知道x和y实际上是第1周的整数。 

2226
01:45:29,800 --> 01:45:31,990
现在我需要x的地址和y的地址

2227
01:45:31,990 --> 01:45:35,270
所以交换可以跟随那些宝藏地图， 

2228
01:45:35,270 --> 01:45:37,580
可以这么说，去那些地址。 

2229
01:45:37,580 --> 01:45:42,250
所以现在，当我运行这个程序时，这更像是凯莉的比喻

2230
01:45:42,250 --> 01:45:44,290
我告诉她牛奶和OJ在哪里。 

2231
01:45:44,290 --> 01:45:48,760
现在交换并转到这些位置，如下所示。交换。 

2232
01:45:48,760 --> 01:45:51,950
让我继续，然后做./swap，Enter-- 

2233
01:45:51,950 --> 01:45:52,630
啊！ 

2234
01:45:52,630 --> 01:45:54,460
现在它似乎正在起作用。 

2235
01:45:54,460 --> 01:45:56,380
我们甚至可以通过调试器看到它​​。 

2236
01:45:56,380 --> 01:45:59,650
即使它似乎没有错误，我仍然可以使用debug50 

2237
01:45:59,650 --> 01:46:03,040
看到并理解我的节目，如果不是很明显 - 哦， 

2238
01:46:03,040 --> 01:46:04,180
我还需要一个断点。 

2239
01:46:04,180 --> 01:46:05,890
让我们像以前一样设置一个断点。 

2240
01:46:05,890 --> 01:46:07,870
让我们重新运行debug50。 

2241
01:46:07,870 --> 01:46:11,110
右侧面板将自动打开。 

2242
01:46:11,110 --> 01:46:14,590
让我们继续看看，如果我开始踩到这个， 

2243
01:46:14,590 --> 01:46:23,280
现在我看到x是1，y是2，printf在屏幕上打印得那么多。 

2244
01:46:23,280 --> 01:46:25,980
现在我要继续进入交换， 

2245
01:46:25,980 --> 01:46:28,760
而现在注意到，它看起来有点奇怪， 

2246
01:46:28,760 --> 01:46:32,420
因为现在a是地址，b是地址， 

2247
01:46:32,420 --> 01:46:36,530
但是tmp仍然是一个带有垃圾值的int，但我可以解决这个问题。 

2248
01:46:36,530 --> 01:46:41,700
现在tmp是1，但注意，a和b的值没有变化， 

2249
01:46:41,700 --> 01:46:43,910
但是每个代码的变化是什么？ 

2250
01:46:46,660 --> 01:46:48,760
所以请注意，这很奇怪而且神秘。 

2251
01:46:48,760 --> 01:46:50,740
a是这个0x值。 

2252
01:46:50,740 --> 01:46:54,550
这是一个很大的十六进制地址，就像在内存中的地址一样。 

2253
01:46:54,550 --> 01:46:55,300
但你知道吗？ 

2254
01:46:55,300 --> 01:46:58,620
如果我点击小三角形，我可以按照那个指针

2255
01:46:58,620 --> 01:46:59,350
然后去吧。 

2256
01:46:59,350 --> 01:47:01,120
调试器很聪明。 

2257
01:47:01,120 --> 01:47:06,820
所以* a，转到a是2;和* b此刻是2，但如果我继续前进， 

2258
01:47:06,820 --> 01:47:11,240
现在我做了一个切换器，你可以看到这些值已经改变了。 

2259
01:47:11,240 --> 01:47:13,330
而且，我们不关心这些地址是什么， 

2260
01:47:13,330 --> 01:47:15,010
我不在乎实际的地址是什么。 

2261
01:47:15,010 --> 01:47:17,630
我确实关心它给了我这个功能，因为现在什么时候

2262
01:47:17,630 --> 01:47:20,050
我以印刷方式回到这里，现在的价值确实如此

2263
01:47:20,050 --> 01:47:23,350
改变了，就像我预期的那样。 

2264
01:47:23,350 --> 01:47:24,070
行。 

2265
01:47:24,070 --> 01:47:30,520
这很复杂，但希望清楚地说明为什么它现在可以工作，即使我们已经

2266
01:47:30,520 --> 01:47:33,150
使这段代码看起来更加神秘。 

2267
01:47:33,150 --> 01:47:34,990
如果没有，欢迎提出任何问题。 

2268
01:47:34,990 --> 01:47:35,640
是吗？ 

2269
01:47:35,640 --> 01:47:39,610
听众：那是来自[听不清]的地方

2270
01:47:39,610 --> 01:47:40,450
大卫马兰：嗯嗯。 

2271
01:47:40,450 --> 01:47:44,880
听众：[听不清]明星[听不清]指针？ 

2272
01:47:44,880 --> 01:47:46,010
大卫马兰：好问题。 

2273
01:47:46,010 --> 01:47:49,960
我们真的需要在这里使用这些＆符号，因为我们已经

2274
01:47:49,960 --> 01:47:50,920
这里有星星吗？ 

2275
01:47:50,920 --> 01:47:52,630
简单回答，是的，对称性。 

2276
01:47:52,630 --> 01:47:55,660
这告诉功能在路上会发生什么; 

2277
01:47:55,660 --> 01:48:00,600
这就是告诉计算机实际上要发送什么的东西。 

2278
01:48:00,600 --> 01:48:03,420
那么该功能的实际输入是什么？ 

2279
01:48:03,420 --> 01:48:05,370
它必须是对称的。 

2280
01:48:05,370 --> 01:48:05,960
是吗？ 

2281
01:48:05,960 --> 01:48:11,530
听众：[听不清]值正在交换地址。 

2282
01:48:11,530 --> 01:48:16,110
大卫马兰：我们正在交换地址。 

2283
01:48:16,110 --> 01:48:24,870
听众：那么如果你更改[听不清]的地址怎么办？ 

2284
01:48:24,870 --> 01:48:25,530
大卫马兰：好的。 

2285
01:48:25,530 --> 01:48:29,000
听众：我们会交换地址，说2是200和1 

2286
01:48:29,000 --> 01:48:31,830
是[听不清]可能会改变。 

2287
01:48:31,830 --> 01:48:35,970
大卫马兰：简短的回答，你不能因为以下原因。 

2288
01:48:35,970 --> 01:48:41,220
所以从技术上讲，当你执行％x和％y时，它们会转换为地址

2289
01:48:41,220 --> 01:48:42,540
x的地址，y的地址。 

2290
01:48:42,540 --> 01:48:46,770
技术上交换是获得某些东西的副本，C没有改变。 

2291
01:48:46,770 --> 01:48:49,740
但是C现在正在获取地址的副本

2292
01:48:49,740 --> 01:48:53,940
x的地址副本，称为a和b。 

2293
01:48:53,940 --> 01:48:57,030
当然，您可以交换地址，但出于与以前相同的原因， 

2294
01:48:57,030 --> 01:48:58,860
它没有根本的影响。 

2295
01:48:58,860 --> 01:49:01,770
这里的区别是因为我在地图中传递，可以这么说

2296
01:49:01,770 --> 01:49:03,420
到x和y，他们的地址。 

2297
01:49:03,420 --> 01:49:04,830
而且，一个地址就像 - 

2298
01:49:04,830 --> 01:49:08,490
我现在在昆西街45号，我想 - 

2299
01:49:08,490 --> 01:49:10,470
剑桥，马萨诸塞州02138，美国。 

2300
01:49:10,470 --> 01:49:12,150
这唯一标识建筑物。 

2301
01:49:12,150 --> 01:49:15,820
这些0x十六进制数唯一地标识内存中的位置。 

2302
01:49:15,820 --> 01:49:19,350
所以这就像现在说的，给我x的地址，给我y的地址， 

2303
01:49:19,350 --> 01:49:22,680
我在技术上传递了这些地址的副本，但没关系， 

2304
01:49:22,680 --> 01:49:25,920
因为现在用星号表示法，我说要去那些地址

2305
01:49:25,920 --> 01:49:30,450
和交换谁在这个建筑物和其他人身体。 

2306
01:49:30,450 --> 01:49:31,170
行。 

2307
01:49:31,170 --> 01:49:34,380
所以，让我们现在把它放到其他的上下文中

2308
01:49:34,380 --> 01:49:36,180
你的电脑实际上只有你自己

2309
01:49:36,180 --> 01:49:39,340
在计算机的记忆中看到了一些术语。 

2310
01:49:39,340 --> 01:49:41,700
所以这是在其上面布置网格的芯片

2311
01:49:41,700 --> 01:49:44,700
只是为了传达这里有字节，我们可以给它们编号。 

2312
01:49:44,700 --> 01:49:47,160
但让我们现在更抽象地思考这个问题， 

2313
01:49:47,160 --> 01:49:49,890
让我透露一下，事实证明计算机可以对待

2314
01:49:49,890 --> 01:49:53,910
不同的字节，不同的方格只是按照惯例。 

2315
01:49:53,910 --> 01:49:56,040
事实证明，在你电脑的记忆中 - 

2316
01:49:56,040 --> 01:49:58,590
而这只是艺术家的代表 - 

2317
01:49:58,590 --> 01:50:01,390
在那个记忆芯片的顶部，可以这么说

2318
01:50:01,390 --> 01:50:03,130
是所谓的程序文本。 

2319
01:50:03,130 --> 01:50:05,250
这是一种奇特而非显而易见的说法

2320
01:50:05,250 --> 01:50:09,540
您的代码已经编译成0和1。 

2321
01:50:09,540 --> 01:50:12,530
程序的文本是你用二进制编写的代码， 

2322
01:50:12,530 --> 01:50:14,080
那就是它从内存中加载的地方。 

2323
01:50:14,080 --> 01:50:16,290
所以在macOS和Windows中，双击一个图标， 

2324
01:50:16,290 --> 01:50:18,540
我上周说过，该程序被加载到内存中。 

2325
01:50:18,540 --> 01:50:22,920
它从字面上理解为装载到计算机内存的顶部。 

2326
01:50:22,920 --> 01:50:23,610
还有什么？ 

2327
01:50:23,610 --> 01:50:29,460
那么堆是给予内存块的奇特名称

2328
01:50:29,460 --> 01:50:31,140
是来自你打电话给malloc的时候。 

2329
01:50:31,140 --> 01:50:34,740
所以当我早些时候打电话给malloc为一些角色获得一堆空间时， 

2330
01:50:34,740 --> 01:50:37,800
它只是来自这个叫做堆的大开放区域。 

2331
01:50:37,800 --> 01:50:41,220
这就是get_string正在使用的内容以及其他功能。 

2332
01:50:41,220 --> 01:50:44,940
事实证明，我们遇到问题的原因

2333
01:50:44,940 --> 01:50:48,400
是因为内存的底部是所谓的堆栈。 

2334
01:50:48,400 --> 01:50:52,650
堆栈是调用它们时使用的内存区域。 

2335
01:50:52,650 --> 01:50:57,640
这实际上与以下非常简单的noswap示例相关。 

2336
01:50:57,640 --> 01:51:01,800
如果我们现在假设你调用一个函数，它所使用的内存

2337
01:51:01,800 --> 01:51:04,700
来自那块大块记忆的底部， 

2338
01:51:04,700 --> 01:51:07,500
你可以在哪里绘制，例如，在屏幕上， 

2339
01:51:07,500 --> 01:51:10,560
因为事实证明，无论何时你调用一个函数，该函数都会得到

2340
01:51:10,560 --> 01:51:12,060
一片自己的记忆。 

2341
01:51:12,060 --> 01:51:15,660
所以例如，main始终是函数调用的第一个程序， 

2342
01:51:15,660 --> 01:51:20,910
所以它在这里得到了屏幕底部的第一片内存。 

2343
01:51:20,910 --> 01:51:25,030
因此，如果main有两个变量x和y，那就像说， 

2344
01:51:25,030 --> 01:51:29,770
好的，给我一块名为x的内存并将值1放入其中; 

2345
01:51:29,770 --> 01:51:33,690
给我另一块记忆，称之为y，在这里放一个值。 

2346
01:51:33,690 --> 01:51:38,850
但请记住，从第一个noswap示例中，调用了swap函数。 

2347
01:51:38,850 --> 01:51:40,430
这是字面意义上的堆栈。 

2348
01:51:40,430 --> 01:51:44,140
你进入一个餐厅，一个自助餐厅，一个托盘作为食物，另一个， 

2349
01:51:44,140 --> 01:51:46,770
继续下去，继续下去，以便人类可以接受它

2350
01:51:46,770 --> 01:51:48,240
把食物和盘子放在上面。 

2351
01:51:48,240 --> 01:51:51,270
同样在这个模型中，当你调用一个函数时， 

2352
01:51:51,270 --> 01:51:55,200
它有自己的内存片段，但从概念上讲，字面上是

2353
01:51:55,200 --> 01:51:58,230
堆栈上的现有帧。 

2354
01:51:58,230 --> 01:52:01,620
所以这是swap函数自己的内存块， 

2355
01:52:01,620 --> 01:52:03,650
它也有一些空间。 

2356
01:52:03,650 --> 01:52:06,030
它为一个名为a的变量获得了一些空间。 

2357
01:52:06,030 --> 01:52:08,670
它为一个名为b的变量获得了一些空间。 

2358
01:52:08,670 --> 01:52:11,700
并猜猜第一个例子的内容是什么？ 

2359
01:52:11,700 --> 01:52:15,210
x的副本和y的副本。 

2360
01:52:15,210 --> 01:52:15,960
你知道吗？ 

2361
01:52:15,960 --> 01:52:19,140
它有一个临时变量，所以这里必须有一些空间。 

2362
01:52:19,140 --> 01:52:20,940
所以我称之为tmp。 

2363
01:52:20,940 --> 01:52:24,720
并记得我将tmp设为等于a，因此得到1。 

2364
01:52:24,720 --> 01:52:25,750
然后发生了什么？ 

2365
01:52:25,750 --> 01:52:27,970
那么我做了什么 - 

2366
01:52:27,970 --> 01:52:30,730
我做了什么？ 

2367
01:52:30,730 --> 01:52:33,630
让我做对了。 

2368
01:52:33,630 --> 01:52:36,180
我们得到了一个b。 

2369
01:52:36,180 --> 01:52:38,920
那发生了什么？ 

2370
01:52:38,920 --> 01:52:43,440
因此，在此示例中，a获取值b，以便更改。 

2371
01:52:43,440 --> 01:52:46,770
然后在这里发生的事情，b得到10的值，所以改变了。 

2372
01:52:46,770 --> 01:52:49,890
所以交换工作的意义在于交换价值， 

2373
01:52:49,890 --> 01:52:53,280
但问题是，当一个函数返回时，这块内存就是它

2374
01:52:53,280 --> 01:52:58,900
以前使用被回收，以便其他人现在可以使用它， 

2375
01:52:58,900 --> 01:52:59,710
另一个功能。 

2376
01:52:59,710 --> 01:53:03,000
所以我们做了所有艰苦的工作，没有交换，我们做得正确， 

2377
01:53:03,000 --> 01:53:05,980
我们只是在错误的地方做到了。 

2378
01:53:05,980 --> 01:53:11,210
相比之下，我们做的下一个例子是swap.c， 

2379
01:53:11,210 --> 01:53:13,260
只是对待记忆有点不同。 

2380
01:53:13,260 --> 01:53:18,210
这次主要还有两个叫x的变量，这个是1， 

2381
01:53:18,210 --> 01:53:21,300
然后另一个叫y，这是一个2。 

2382
01:53:21,300 --> 01:53:23,760
然后再次调用一次交换

2383
01:53:23,760 --> 01:53:26,520
有一个名为a的变量和一个名为的变量

2384
01:53:26,520 --> 01:53:29,790
b，但是什么存储在a和b中？ 

2385
01:53:29,790 --> 01:53:30,920
那么现在他们是地址。 

2386
01:53:30,920 --> 01:53:34,390
我不知道它是什么，但让我随便说出这个

2387
01:53:34,390 --> 01:53:37,240
是位置100，这是位置 - 

2388
01:53:37,240 --> 01:53:39,280
让我们说104。 

2389
01:53:39,280 --> 01:53:41,740
但它可能是任何东西，我们只是不在乎这一点， 

2390
01:53:41,740 --> 01:53:44,590
如果计算机向我们展示，它在技术上会有0x。 

2391
01:53:44,590 --> 01:53:49,750
这里的内容是100，这里b的内容是104。 

2392
01:53:49,750 --> 01:53:54,040
那些是x和y的地址，以及代码

2393
01:53:54,040 --> 01:53:56,410
我们使用了所有这些新星说的， 

2394
01:53:56,410 --> 01:54:04,030
转到地址100并存储tmp中地址100处的任何内容。 

2395
01:54:04,030 --> 01:54:07,450
然后转到b或104中的地址， 

2396
01:54:07,450 --> 01:54:12,850
并存储在int * a的位置，无论是什么。 

2397
01:54:12,850 --> 01:54:15,430
然后就是说，顺便说一下，去那个第10个值

2398
01:54:15,430 --> 01:54:20,500
并继续把它放在这里，所以现在我们做到了

2399
01:54:20,500 --> 01:54:23,300
在不同的地方不同的工作。 

2400
01:54:23,300 --> 01:54:25,870
所以现在当交换完成运行时，它没有

2401
01:54:25,870 --> 01:54:31,520
如果它的记忆消失，因为它现在已经发生变异或改变了

2402
01:54:31,520 --> 01:54:32,260
另一个记忆。 

2403
01:54:32,260 --> 01:54:35,560
就像凯利改变或改变杯子一样传递它

2404
01:54:35,560 --> 01:54:39,680
我实际上指的是她而不是副本。 

2405
01:54:39,680 --> 01:54:43,300
现在，除此之外，还有其他实际使用的内存块。 

2406
01:54:43,300 --> 01:54:45,760
如果程序中有全局变量， 

2407
01:54:45,760 --> 01:54:48,040
事实证明，在文本和堆之间

2408
01:54:48,040 --> 01:54:51,310
如果用值初始化，则内存是全局变量

2409
01:54:51,310 --> 01:54:54,740
或者它们没有用值来初始化，正如等号所发生的那样， 

2410
01:54:54,740 --> 01:54:56,710
但是对于今天的目的，我们并不太关心这一点。 

2411
01:54:56,710 --> 01:54:58,510
如果您听说过环境变量，那么

2412
01:54:58,510 --> 01:55:01,030
我们将在进行网络编程时，他们也是

2413
01:55:01,030 --> 01:55:02,950
存储在内存中。 

2414
01:55:02,950 --> 01:55:04,780
但最有趣的记忆块

2415
01:55:04,780 --> 01:55:07,910
堆栈和堆，就像这里的情况一样。 

2416
01:55:07,910 --> 01:55:10,560
但不幸的是，事情很容易出错 - 

2417
01:55:10,560 --> 01:55:13,060
我的意思是，你们中的一些人已经经历过分段错误

2418
01:55:13,060 --> 01:55:15,200
让我们考虑为什么会发生这种情况。 

2419
01:55:15,200 --> 01:55:18,940
所以这是一个设计错误的代码示例， 

2420
01:55:18,940 --> 01:55:21,820
但是，让我们用英语谈谈这些线路正在做什么。 

2421
01:55:21,820 --> 01:55:25,390
这一行，int * x，是说，嘿，电脑， 

2422
01:55:25,390 --> 01:55:31,140
给我一个存储整数地址的变量。 

2423
01:55:31,140 --> 01:55:34,570
所以给我一个指向int的指针是更随意的说法。 

2424
01:55:34,570 --> 01:55:37,940
嘿电脑，给我另一个变量

2425
01:55:37,940 --> 01:55:40,250
将存储int的地址并将其称为y。 

2426
01:55:40,250 --> 01:55:42,170
所以x和y，就是这样。 

2427
01:55:42,170 --> 01:55:44,000
这条线是新的。 

2428
01:55:44,000 --> 01:55:48,510
嘿计算机，分配足够的空间，适合int。 

2429
01:55:48,510 --> 01:55:51,560
因此sizeof int是我们之前看到的用于解决问题的新语法

2430
01:55:51,560 --> 01:55:52,640
int是多少字节。 

2431
01:55:52,640 --> 01:55:56,550
在大多数计算机中，这可能会以4或32位的形式返回。 

2432
01:55:56,550 --> 01:55:59,520
所以这只是说，嘿浏览器，给我4个字节的内存

2433
01:55:59,520 --> 01:56:02,750
并将其存储在此位置。 

2434
01:56:02,750 --> 01:56:06,140
或者更确切地说，将此存储在此变量中，存储该变量。 

2435
01:56:06,140 --> 01:56:09,650
所以也许它会说，好的，这是位置100处的四个字节， 

2436
01:56:09,650 --> 01:56:11,390
或者这里是位置900处的四个字节。 

2437
01:56:11,390 --> 01:56:15,670
或者在任何地方，我们都不在乎，我们只是记住x中的那个地址。 

2438
01:56:15,670 --> 01:56:18,460
* x说，去那个地址 - 

2439
01:56:18,460 --> 01:56:22,430
100或900，不管它是什么，把数字42放在那里。 

2440
01:56:22,430 --> 01:56:26,760
下一行说，转到y中的地址并输入不幸的数字 - 提示， 

2441
01:56:26,760 --> 01:56:27,320
暗示 - 

2442
01:56:27,320 --> 01:56:30,530
13那里。 

2443
01:56:30,530 --> 01:56:32,220
你的地址是什么？ 

2444
01:56:35,820 --> 01:56:36,950
我还没有分配它。 

2445
01:56:36,950 --> 01:56:38,540
x中的地址是什么？ 

2446
01:56:38,540 --> 01:56:41,420
这是malloc告诉我使用空间的地方。 

2447
01:56:41,420 --> 01:56:44,450
这是安全的，就像100,900，无论价值如何， 

2448
01:56:44,450 --> 01:56:46,550
但是我为y分配了空间吗？ 

2449
01:56:46,550 --> 01:56:49,570
那么它包含什么样的价值，可以这么说呢？ 

2450
01:56:49,570 --> 01:56:50,660
垃圾值。 

2451
01:56:50,660 --> 01:56:53,640
也许是0，也许是32,000--我们不知道， 

2452
01:56:53,640 --> 01:56:55,850
因为如果你没有指定值，那就是

2453
01:56:55,850 --> 01:56:59,280
信任它或做任何事情是不安全的。 

2454
01:56:59,280 --> 01:57:02,510
这可能会给我一个分段错误。 

2455
01:57:02,510 --> 01:57:04,550
事实上，如果我运行这样的程序， 

2456
01:57:04,550 --> 01:57:08,510
我很可能会看到那种问题。 

2457
01:57:08,510 --> 01:57:10,810
但是，以某种方式看待这一点可能更好

2458
01:57:10,810 --> 01:57:14,040
将描绘一幅更令人难忘的画面，为此，我们想到 - 

2459
01:57:14,040 --> 01:57:16,340
在我们剩下的10分钟内，请使用这些分钟

2460
01:57:16,340 --> 01:57:18,460
看看我们在斯坦福大学的朋友

2461
01:57:18,460 --> 01:57:20,070
放在一起粘土。 

2462
01:57:20,070 --> 01:57:22,390
它大约三分钟，非常值得

2463
01:57:22,390 --> 01:57:24,650
画出一幅确切出错的画面

2464
01:57:24,650 --> 01:57:27,250
当你不正确使用内存时。 

2465
01:57:27,250 --> 01:57:29,130
如果你可以调暗灯光。 

2466
01:57:29,130 --> 01:57:29,790
[视频回放] 

2467
01:57:29,790 --> 01:57:32,640
[音乐播放] 

2468
01:57:32,640 --> 01:57:33,410
- 嘿，Binky。 

2469
01:57:33,410 --> 01:57:34,220
醒来！ 

2470
01:57:34,220 --> 01:57:36,650
这是指针有趣的时候！ 

2471
01:57:36,650 --> 01:57:37,930
- 那是什么？ 

2472
01:57:37,930 --> 01:57:39,080
了解指针？ 

2473
01:57:39,080 --> 01:57:41,300
哦，好的！ 

2474
01:57:41,300 --> 01:57:44,320
- 好了开始，我想我们需要几个指针。 

2475
01:57:44,320 --> 01:57:45,140
- 好。 

2476
01:57:45,140 --> 01:57:48,660
此代码分配两个指针，指向整数。 

2477
01:57:48,660 --> 01:57:49,160
- 好。 

2478
01:57:49,160 --> 01:57:52,880
好吧，我看到了两个指针，但它们似乎并没有指向任何东西。 

2479
01:57:52,880 --> 01:57:53,720
- 那就对了。 

2480
01:57:53,720 --> 01:57:55,850
最初指针不指向任何东西。 

2481
01:57:55,850 --> 01:57:58,100
他们指向的东西叫做指责， 

2482
01:57:58,100 --> 01:58:00,050
并将它们设置为单独的步骤。 

2483
01:58:00,050 --> 01:58:00,950
- 哦，对，对。 

2484
01:58:00,950 --> 01:58:01,700
我知道。 

2485
01:58:01,700 --> 01:58:03,470
这些人是分开的。 

2486
01:58:03,470 --> 01:58:05,980
那么你如何分配一个指针？ 

2487
01:58:05,980 --> 01:58:06,680
- 好。 

2488
01:58:06,680 --> 01:58:09,740
那么这段代码会分配一​​个新的整数指针， 

2489
01:58:09,740 --> 01:58:12,890
而这部分设置x指向它。 

2490
01:58:12,890 --> 01:58:14,060
- 嘿，看起来更好。 

2491
01:58:14,060 --> 01:58:15,510
所以让它做点什么吧。 

2492
01:58:15,510 --> 01:58:16,300
- 好。 

2493
01:58:16,300 --> 01:58:21,340
如何引用指针x将数字42存储到其指针中？ 

2494
01:58:21,340 --> 01:58:24,880
对于这个技巧，我需要我的魔杖解除引用。 

2495
01:58:24,880 --> 01:58:27,930
- 你的解除引用的魔杖？ 

2496
01:58:27,930 --> 01:58:30,040
那 - 那很好。 

2497
01:58:30,040 --> 01:58:31,840
- 这就是代码的样子。 

2498
01:58:31,840 --> 01:58:33,590
我只是设置数字和 - 

2499
01:58:33,590 --> 01:58:34,770
[POP] 

2500
01:58:34,770 --> 01:58:35,440
- 你看！ 

2501
01:58:35,440 --> 01:58:36,880
它去了。 

2502
01:58:36,880 --> 01:58:41,740
因此，对x进行取消引用会跟随箭头访问其指针。 

2503
01:58:41,740 --> 01:58:43,900
在这种情况下，在那里存储42。 

2504
01:58:43,900 --> 01:58:48,520
嘿，尝试使用它来存储数字13到另一个指针y。 

2505
01:58:48,520 --> 01:58:49,510
- 好。 

2506
01:58:49,510 --> 01:58:54,010
我将在这里转到y并设置13号码， 

2507
01:58:54,010 --> 01:58:58,020
然后拿取解除引用的魔杖 - 

2508
01:58:58,020 --> 01:58:59,560
[BUZZING]哇！ 

2509
01:58:59,560 --> 01:59:01,780
- 哦，嘿，那没用。 

2510
01:59:01,780 --> 01:59:05,420
说，Binky，我不认为解除引用y是一个好主意， 

2511
01:59:05,420 --> 01:59:08,690
因为设置指针是一个单独的步骤

2512
01:59:08,690 --> 01:59:10,490
而且我认为我们从未这样做过。 

2513
01:59:10,490 --> 01:59:12,230
- 嗯，好点。 

2514
01:59:12,230 --> 01:59:12,730
- 是的

2515
01:59:12,730 --> 01:59:17,120
我们分配了指针y，但我们从未将其设置为指向一个指针。 

2516
01:59:17,120 --> 01:59:19,490
- 嗯，非常敏锐。 

2517
01:59:19,490 --> 01:59:21,160
- 嘿，你在那里看起来很好，Binky。 

2518
01:59:21,160 --> 01:59:24,200
你能解决它，以便y指向与x相同的指针吗？ 

2519
01:59:24,200 --> 01:59:24,700
- 当然。 

2520
01:59:24,700 --> 01:59:27,520
我将使用我的魔棒指针分配。 

2521
01:59:27,520 --> 01:59:29,810
- 这会像以前一样成为一个问题吗？ 

2522
01:59:29,810 --> 01:59:31,540
- 不，这不会触及指责者。 

2523
01:59:31,540 --> 01:59:35,110
它只是将一个指针更改为指向另一个指针。 

2524
01:59:35,110 --> 01:59:36,190
- 原来如此。 

2525
01:59:36,190 --> 01:59:38,770
现在y指向与x相同的位置。 

2526
01:59:38,770 --> 01:59:40,790
等等，现在我已经修好了。 

2527
01:59:40,790 --> 01:59:41,860
它有一个指针。 

2528
01:59:41,860 --> 01:59:46,360
所以你可以再次试用解除引用的魔杖来发送13。 

2529
01:59:46,360 --> 01:59:47,050
- 好。 

2530
01:59:47,050 --> 01:59:48,830
开始。 

2531
01:59:48,830 --> 01:59:50,080
- 嘿，看看那个。 

2532
01:59:50,080 --> 01:59:51,790
现在解除引用在y上工作。 

2533
01:59:51,790 --> 01:59:55,920
而且因为指针正在共享一个指针，他们都看到13。 

2534
01:59:55,920 --> 01:59:57,610
- 是的，分享，等等。 

2535
01:59:57,610 --> 01:59:59,520
所以我们现在要转换位置？ 

2536
01:59:59,520 --> 02:00:01,490
- 哦，看，我们没时间了。 

2537
02:00:01,490 --> 02:00:02,060
- 但是 - 

2538
02:00:02,060 --> 02:00:02,740
[结束播放] 

2539
02:00:02,740 --> 02:00:03,700
大卫马兰：好的。 

2540
02:00:03,700 --> 02:00:07,780
所以希望这会让一些观点更具视觉效果， 

2541
02:00:07,780 --> 02:00:12,190
但现在让我们在一个可能的域中对此进行语境化

2542
02:00:12,190 --> 02:00:13,940
在几个方面比较熟悉。 

2543
02:00:13,940 --> 02:00:16,030
所以，有些人可能已经知道，特别是

2544
02:00:16,030 --> 02:00:18,370
如果你有一个非常受欢迎的网站以前的编程经验

2545
02:00:18,370 --> 02:00:20,320
称为Stack Overflow，其中有很多程序员

2546
02:00:20,320 --> 02:00:24,350
发布问题并希望解答常见的技术问题。 

2547
02:00:24,350 --> 02:00:26,650
如果你想知道为什么它被称为Stack Overflow， 

2548
02:00:26,650 --> 02:00:29,290
事实证明它在这里缩小到这个图片。 

2549
02:00:29,290 --> 02:00:33,150
这不是一个错误，我从堆中向下画了一个箭头， 

2550
02:00:33,150 --> 02:00:34,960
从堆栈中长出一个箭头。 

2551
02:00:34,960 --> 02:00:38,160
正如你的malloc，malloc，malloc空间越来越大， 

2552
02:00:38,160 --> 02:00:41,020
从这里开始，可以说，你只是获得越来越多的空间

2553
02:00:41,020 --> 02:00:42,780
这是朝这个方向发展的。 

2554
02:00:42,780 --> 02:00:45,160
但是你调用的函数越多 - 函数后的函数

2555
02:00:45,160 --> 02:00:47,030
在函数之后的函数之后，每个函数

2556
02:00:47,030 --> 02:00:50,380
获得自己的片段或内存框架，这也正在成长。 

2557
02:00:50,380 --> 02:00:54,280
所以这感觉就像一个非常糟糕的设计，但老实说，它并不是真的可以避免

2558
02:00:54,280 --> 02:00:56,200
因为如果你的内存有限， 

2559
02:00:56,200 --> 02:00:58,510
你无法永远避免彼此。 

2560
02:00:58,510 --> 02:01:03,010
所以存在堆栈溢出的基本风险， 

2561
02:01:03,010 --> 02:01:06,110
甚至在反方向溢出堆。 

2562
02:01:06,110 --> 02:01:09,520
因此，Stack Overflow也是一种暗示，例如，调用

2563
02:01:09,520 --> 02:01:12,190
许多 - 许多，许多，许多，许多，许多，许多，许多，许多功能， 

2564
02:01:12,190 --> 02:01:15,760
这么多，以至于它与其他块或内存段重叠， 

2565
02:01:15,760 --> 02:01:19,800
从而引起分段错误，缓冲堆溢出

2566
02:01:19,800 --> 02:01:21,760
反方向，这些更多

2567
02:01:21,760 --> 02:01:26,620
通常称为缓冲区溢出，我们将在几周内看到更多这些

2568
02:01:26,620 --> 02:01:27,340
来。 

2569
02:01:27,340 --> 02:01:29,710
但现在我们有能力讨论指针， 

2570
02:01:29,710 --> 02:01:33,490
让我们介绍一个最后的功能，然后是一个熟悉的面孔。 

2571
02:01:33,490 --> 02:01:38,440
事实证明，你实际上可以提出自己的自定义变量

2572
02:01:38,440 --> 02:01:42,370
有点像我们用字符串做的，但更复杂。 

2573
02:01:42,370 --> 02:01:46,120
例如，如果我想实现一个程序

2574
02:01:46,120 --> 02:01:49,480
涉及多个学生，我可能会做这样的事情。 

2575
02:01:49,480 --> 02:01:52,810
询问用户什么是课程中的注册，然后继续

2576
02:01:52,810 --> 02:01:55,130
给自己一个字符串数组，又名

2577
02:01:55,130 --> 02:01:59,650
char * s今天这么大，然后我还可以有另一组宿舍。 

2578
02:01:59,650 --> 02:02:03,240
我可以有两个数组，其中一个包含学生的名字， 

2579
02:02:03,240 --> 02:02:05,990
一个学生的宿舍，我可以跟踪其他事情。 

2580
02:02:05,990 --> 02:02:08,900
另一个电子邮件阵列，另一个电话号码阵列 - 

2581
02:02:08,900 --> 02:02:11,230
但这很快就会变得混乱，因为你可以想象， 

2582
02:02:11,230 --> 02:02:15,430
如果我需要姓名和宿舍以及电子邮件和电话， 

2583
02:02:15,430 --> 02:02:17,710
开始变成很多复制粘贴。 

2584
02:02:17,710 --> 02:02:20,800
我只有这个设计，我有很多很多的数组

2585
02:02:20,800 --> 02:02:24,160
每个支架位置 - 如支架0，支架1 

2586
02:02:24,160 --> 02:02:28,420
大概是指所有这些阵列中的同一个学生，比如mmm！ 

2587
02:02:28,420 --> 02:02:30,370
凌乱，凌乱，凌乱的设计。 

2588
02:02:30,370 --> 02:02:32,350
所以，挥挥手，实际上让我

2589
02:02:32,350 --> 02:02:36,040
通过引入新功能将问题立即解决。 

2590
02:02:36,040 --> 02:02:38,170
我可以发明自己的数据类型。 

2591
02:02:38,170 --> 02:02:40,240
让我继续并声明一个数组

2592
02:02:40,240 --> 02:02:46,480
这个学生有很多学生，但是数据类学生。 

2593
02:02:46,480 --> 02:02:51,400
C带有float，bool，char，int，而不是字符串，绝对不是学生。 

2594
02:02:51,400 --> 02:02:54,020
所以你可以制作自己的自定义数据类型， 

2595
02:02:54,020 --> 02:02:57,160
你可以将它们放在你自己的头文件中，我们也没有这样做。 

2596
02:02:57,160 --> 02:03:00,870
但我可以看一下，你会在下一个问题集中看到更多。 

2597
02:03:00,870 --> 02:03:02,620
所以如果感觉非常简短，不要担心

2598
02:03:02,620 --> 02:03:04,800
它只是想成为一个预告片。 

2599
02:03:04,800 --> 02:03:09,580
struct.h是您声明或定义自己类型的方式。 

2600
02:03:09,580 --> 02:03:13,690
对于结构或数据结构，关键字实际上是typedef结构

2601
02:03:13,690 --> 02:03:14,740
更完整。 

2602
02:03:14,740 --> 02:03:18,430
数据结构的名称在一些花括号后结束。 

2603
02:03:18,430 --> 02:03:20,620
然后在你刚才指定的花括号内， 

2604
02:03:20,620 --> 02:03:22,280
那么你想要一个学生拥有什么？ 

2605
02:03:22,280 --> 02:03:25,690
我希望他们有一个名字，一个宿舍，也许是一个电话号码，也许

2606
02:03:25,690 --> 02:03:27,140
电子邮件地址，我想要的任何东西。 

2607
02:03:27,140 --> 02:03:28,510
我可以在这里添加。 

2608
02:03:28,510 --> 02:03:34,690
现在，在我的实际代码中，我可以拥有一系列实际的学生， 

2609
02:03:34,690 --> 02:03:37,960
我可以用这样的新符号来访问它们。 

2610
02:03:37,960 --> 02:03:40,990
您知道可以使用括号表示法索引数组。 

2611
02:03:40,990 --> 02:03:45,070
你可能直到现在才知道的是，如果在那个地方

2612
02:03:45,070 --> 02:03:46,900
是一个结构，又名

2613
02:03:46,900 --> 02:03:51,100
结构，你可以得到名称，宿舍，电话，或电子邮件， 

2614
02:03:51,100 --> 02:03:54,160
或其他任何东西只是使用点符号，这是

2615
02:03:54,160 --> 02:03:56,320
我们今天的最后一段新语法。 

2616
02:03:56,320 --> 02:03:58,040
其他一切都是一样的。 

2617
02:03:58,040 --> 02:04:01,450
我可以写一个程序，说这样一个宿舍就是这样的

2618
02:04:01,450 --> 02:04:05,410
只是说得到第i个学生的名字和第i个学生的宿舍。 

2619
02:04:05,410 --> 02:04:09,190
我甚至可以更加高兴，如果我不想只打印这些价值观， 

2620
02:04:09,190 --> 02:04:13,060
我现在甚至可以看到没有理解的指针 - 

2621
02:04:13,060 --> 02:04:15,340
或者我已经看过指针，我们很快就会理解它们

2622
02:04:15,340 --> 02:04:19,090
通过问题集和实践，我实际上可以做到这一点。 

2623
02:04:19,090 --> 02:04:21,760
这只是一行代码的预览

2624
02:04:21,760 --> 02:04:23,920
它使用一个名为fopen的新函数。 

2625
02:04:23,920 --> 02:04:27,130
打开此文件，它将打开要打开的文件的名称。 

2626
02:04:27,130 --> 02:04:29,800
您可能知道CSV文件，它们就像简单的电子表格， 

2627
02:04:29,800 --> 02:04:31,660
逗号分隔值。 

2628
02:04:31,660 --> 02:04:33,610
并且引用 - 不引用“w”表示写。 

2629
02:04:33,610 --> 02:04:37,150
所以这就说在写模式下打开名为students.csv的文件， 

2630
02:04:37,150 --> 02:04:38,320
所以我可以写这个文件。 

2631
02:04:38,320 --> 02:04:40,840
因为在这个例子中，正如你将在未来的日子看到的， 

2632
02:04:40,840 --> 02:04:42,800
我想写出一个文件。 

2633
02:04:42,800 --> 02:04:45,940
但结果是使用文件，我需要知道指针是什么， 

2634
02:04:45,940 --> 02:04:47,740
它有点奇怪，它都是帽子， 

2635
02:04:47,740 --> 02:04:51,770
但是在C中有一个名为“file”的数据类型，它是一个指针。 

2636
02:04:51,770 --> 02:04:54,650
长话短说，你将在下一个问题集中看到什么

2637
02:04:54,650 --> 02:04:56,950
因为我们探索取证的世界就是能力

2638
02:04:56,950 --> 02:05:00,260
使用指针和一些新函数来打开文件并返回

2639
02:05:00,260 --> 02:05:04,490
内存中该文件的地址，以便您可以转到该地址， 

2640
02:05:04,490 --> 02:05:07,430
更改文件的内容，并将其保存回来。 

2641
02:05:07,430 --> 02:05:10,640
这些天我们所有人都认为你可以去File，Open和File， 

2642
02:05:10,640 --> 02:05:13,270
保存，但实际发生了什么，指针涉及， 

2643
02:05:13,270 --> 02:05:15,440
东西被装入内存和计算机

2644
02:05:15,440 --> 02:05:17,960
正在解除引用或转到那些地址

2645
02:05:17,960 --> 02:05:20,720
并改变内存中那些位置的内容。 

2646
02:05:20,720 --> 02:05:22,140
现在为什么你想要这样做？ 

2647
02:05:22,140 --> 02:05:23,600
那么，当然，这是扎米拉 - 你可能

2648
02:05:23,600 --> 02:05:26,060
从一些问题集和演练中回忆起来。 

2649
02:05:26,060 --> 02:05:30,320
原来我们可以尝试通过放大来增强她的这张照片， 

2650
02:05:30,320 --> 02:05:33,660
而这里的保真度和她眼中的保真度一样多。 

2651
02:05:33,660 --> 02:05:38,090
就像我没有看到任何犯罪标志的闪光

2652
02:05:38,090 --> 02:05:40,730
在Zamila眼中闪烁的夹克上。 

2653
02:05:40,730 --> 02:05:43,580
如果从第0周开始放大图像和图像，请调用

2654
02:05:43,580 --> 02:05:47,580
只是一个像素或点的网格，这就是你得到的。 

2655
02:05:47,580 --> 02:05:50,690
你可以稍微平滑一下或清理颜色， 

2656
02:05:50,690 --> 02:05:53,390
但你不能只是“增强”，引用 - 不引用， 

2657
02:05:53,390 --> 02:05:55,760
看到更多Zamila眼中的闪光， 

2658
02:05:55,760 --> 02:05:59,600
因为一天结束时的图像只是一个位图，一张地图 - 

2659
02:05:59,600 --> 02:06:01,670
自上而下，左右 - 像素。 

2660
02:06:01,670 --> 02:06:03,140
例如，这是一个笑脸。 

2661
02:06:03,140 --> 02:06:06,650
如果你有点回顾，你可以看到一个黑色的笑脸

2662
02:06:06,650 --> 02:06:08,390
面对白色背景。 

2663
02:06:08,390 --> 02:06:11,390
如果我们只是决定作为人类，让我们代表白点

2664
02:06:11,390 --> 02:06:15,350
1和黑点加0，这可能是文件中的内容， 

2665
02:06:15,350 --> 02:06:16,790
这是人类所看到的。 

2666
02:06:16,790 --> 02:06:21,140
因此，如果我们能够从文件中打开它，将其存储在内存中， 

2667
02:06:21,140 --> 02:06:24,420
然后使用指针转到内存中的那些位置， 

2668
02:06:24,420 --> 02:06:27,800
例如，我们甚至可以将笑脸改为不快乐的脸，或者将其改色

2669
02:06:27,800 --> 02:06:29,990
或做任何事情。 

2670
02:06:29,990 --> 02:06:32,660
现在快速浏览一下，文件中有很多内容， 

2671
02:06:32,660 --> 02:06:37,010
因为文件是一组人类决定的约定

2672
02:06:37,010 --> 02:06:40,130
人类几年前刚在一个位图文件中决定的地方， 

2673
02:06:40,130 --> 02:06:44,960
BMP文件 - 这是一种较旧但仍然流行的图像文件格式，人类

2674
02:06:44,960 --> 02:06:48,170
刚刚决定，我们会提出一些特殊的价值观

2675
02:06:48,170 --> 02:06:50,150
在文件的第一个字节，然后更多

2676
02:06:50,150 --> 02:06:55,990
特殊值比文件其余部分的实际RGB像素。 

2677
02:06:55,990 --> 02:06:58,040
所以这看起来很神秘乍一看

2678
02:06:58,040 --> 02:07:00,530
下一个家庭作业将引导你完成这个， 

2679
02:07:00,530 --> 02:07:04,340
但它只是0和1的意思的惯例

2680
02:07:04,340 --> 02:07:05,780
在这些不同的地方。 

2681
02:07:05,780 --> 02:07:08,460
事实上，未来的挑战将是做很多事情。 

2682
02:07:08,460 --> 02:07:10,190
一个是首先要弄清楚 - 

2683
02:07:10,190 --> 02:07:10,990
谁做了？ 

2684
02:07:10,990 --> 02:07:14,360
一种谋杀之谜，其中隐藏着图像中的线索， 

2685
02:07:14,360 --> 02:07:16,310
但是你的图像有点吵

2686
02:07:16,310 --> 02:07:18,850
将不得不弄清楚图像中的秘密消息

2687
02:07:18,850 --> 02:07:22,490
通过加载该图像，调整它，放置一种红色滤镜

2688
02:07:22,490 --> 02:07:25,940
在它上面，看到秘密信息，但都是数字化的;二， 

2689
02:07:25,940 --> 02:07:29,800
实际上调整图像大小并在这个大的像素中占据这么多像素

2690
02:07:29,800 --> 02:07:32,130
一个笑脸或其他东西，并使其更大， 

2691
02:07:32,130 --> 02:07:34,400
或者如果更舒服，使它更小

2692
02:07:34,400 --> 02:07:36,680
并弄清楚如何进行锻炼; 

2693
02:07:36,680 --> 02:07:39,980
最后，我们一直在拍摄所有CS50员工的照片

2694
02:07:39,980 --> 02:07:41,450
在剑桥和纽黑文。 

2695
02:07:41,450 --> 02:07:45,440
不幸的是我们意外损坏或丢失了存储卡， 

2696
02:07:45,440 --> 02:07:49,060
但我们制作了它的法医形象，所有0和1的副本

2697
02:07:49,060 --> 02:07:50,900
工作人员的照片，我们将需要

2698
02:07:50,900 --> 02:07:53,880
你编写实际恢复所有JPEG的代码

2699
02:07:53,880 --> 02:07:57,640
或通过打开文件从该数字卡拍摄的照片， 

2700
02:07:57,640 --> 02:08:00,020
阅读那些0和1，了解它们是什么

2701
02:08:00,020 --> 02:08:01,720
它们在哪里，只是写它们

2702
02:08:01,720 --> 02:08:05,210
使用我们将在问题中向您介绍的函数返回磁盘

2703
02:08:05,210 --> 02:08:06,080
自己设定。 

2704
02:08:06,080 --> 02:08:09,350
但当然，所有这一切都是理所当然的，我们可以做到这一点， 

2705
02:08:09,350 --> 02:08:10,590
你只能做这么多。 

2706
02:08:10,590 --> 02:08:13,460
事实上，本周就解决这些问题同样重要

2707
02:08:13,460 --> 02:08:16,200
因为它意识到计算机的局限性， 

2708
02:08:16,200 --> 02:08:19,340
所以我们认为我们最后几秒就会结束

2709
02:08:19,340 --> 02:08:21,940
Futurama的真实例子。 

2710
02:08:21,940 --> 02:08:22,720
[视频回放] 

2711
02:08:22,720 --> 02:08:24,360
- 放大死亡范围。 

2712
02:08:27,000 --> 02:08:28,450
为什么它仍然模糊？ 

2713
02:08:28,450 --> 02:08:30,450
- 这就是我们所拥有的所有决议。 

2714
02:08:30,450 --> 02:08:32,790
使它变得更大并不会使它更清晰。 

2715
02:08:32,790 --> 02:08:34,500
- 它在CSI迈阿密。 

2716
02:08:34,500 --> 02:08:35,170
- 呃。 

2717
02:08:35,170 --> 02:08:35,760
[结束播放] 

2718
02:08:35,760 --> 02:08:38,400
DAVID MALAN：这就是CS50，我们下次再见。 

2719
02:08:38,400 --> 02:08:39,790
[掌声] 

