1
00:00:00,000 --> 00:00:26,039
[音乐] 

2
00:00:30,050 --> 00:00:43,299
[音乐] 

3
00:00:46,040 --> 00:00:50,289
[掌声] 

4
00:00:47,200 --> 00:00:50,289
[音乐] 

5
00:00:50,480 --> 00:00:57,809
好吧 这是cs50， 这 是一周 

6
00:00:54,600 --> 00:01:00,210
一，到 今天 结束 ，你会 

7
00:00:57,809 --> 00:01:02,519
知道如何创建外观的程序 

8
00:01:00,210 --> 00:01:04,110
像这样， 所以这当然是 二元的 

9
00:01:02,519 --> 00:01:06,479
这是唯一的机器 语言 

10
00:01:04,110 --> 00:01:08,520
最终理解， 但谢天谢地 / 

11
00:01:06,479 --> 00:01:09,479
上周有很多抽象 

12
00:01:08,520 --> 00:01:10,950
有这么多的人有 

13
00:01:09,479 --> 00:01:12,659
来到我们面前， 我们实际上并没有 

14
00:01:10,950 --> 00:01:14,460
我们必须在这个级别 写 任何东西 

15
00:01:12,659 --> 00:01:16,110
可以像我们一样在它上面抽象 

16
00:01:14,460 --> 00:01:18,509
已经和我们一样 

17
00:01:16,110 --> 00:01:20,390
今天从C开始，但 有人 

18
00:01:18,509 --> 00:01:24,110
尽管如此，还是想猜一下 

19
00:01:20,390 --> 00:01:30,720
该程序 在送入Mac 或PC时 

20
00:01:24,110 --> 00:01:32,460
实际上有人认出任何人 

21
00:01:30,720 --> 00:01:34,950
想冒险猜测也许 是 

22
00:01:32,460 --> 00:01:38,640
最简单的 程序，你可以写它 

23
00:01:34,950 --> 00:01:41,100
确实是在喂养大脑的时候 

24
00:01:38,640 --> 00:01:43,560
你的电脑 所谓的CPU只需打印 

25
00:01:41,100 --> 00:01:45,149
那么我们如何实现这 一点 

26
00:01:43,560 --> 00:01:46,590
请记得我们开始这个的地方 

27
00:01:45,149 --> 00:01:48,119
谈话最后 一次谈论 

28
00:01:46,590 --> 00:01:49,890
计算机 科学更 普遍 和 

29
00:01:48,119 --> 00:01:51,420
解决 问题我们 建议可以 

30
00:01:49,890 --> 00:01:53,310
蒸馏真的是这就像你有 

31
00:01:51,420 --> 00:01:54,570
一些输入你想要一些输出和 

32
00:01:53,310 --> 00:01:57,270
你需要在中间的某个地方

33
00:01:54,570 --> 00:01:59,340
与这些投入有关的东西

34
00:01:57,270 --> 00:02:01,049
到那时我们必须代表 

35
00:01:59,340 --> 00:02:03,180
我们只需要那些投入和产出

36
00:02:01,049 --> 00:02:04,530
作为人类决定我们是怎样的 

37
00:02:03,180 --> 00:02:06,180
将代表我们的所有输入 

38
00:02:04,530 --> 00:02:08,250
有 时间的问题

39
00:02:06,180 --> 00:02:09,899
计算机实际上处理它们和 

40
00:02:08,250 --> 00:02:11,940
所有的手机和一天结束

41
00:02:09,899 --> 00:02:13,470
我们都只使用的电脑

42
00:02:11,940 --> 00:02:15,060
在一天结束时插入墙壁 

43
00:02:13,470 --> 00:02:16,680
获得他们的物质资源 

44
00:02:15,060 --> 00:02:18,720
电，他们可能存储

45
00:02:16,680 --> 00:02:20,430
暂时在电池，但真的 

46
00:02:18,720 --> 00:02:24,090
是我们唯一的输入，它是插入的 

47
00:02:20,430 --> 00:02:26,040
或者它不是1 或 0都是真的 

48
00:02:24,090 --> 00:02:28,380
或假， 所以世界真的减少到 

49
00:02:26,040 --> 00:02:30,060
这两个国家可以这么说， 所以你 

50
00:02:28,380 --> 00:02:31,530
可以认为这些国家那么 这 

51
00:02:30,060 --> 00:02:33,150
就像 打开或 关闭 灯泡一样 

52
00:02:31,530 --> 00:02:35,609
或者我上次拿起手机 

53
00:02:33,150 --> 00:02:37,109
打开或关闭手电筒1或0 

54
00:02:35,609 --> 00:02:38,970
是真还是 假 

55
00:02:37,109 --> 00:02:42,030
当然，如果你只有一盏灯 

56
00:02:38,970 --> 00:02:43,410
灯泡你只能算 从0到1但是 

57
00:02:42,030 --> 00:02:44,430
如果你开始 有一群人 

58
00:02:43,410 --> 00:02:46,530
背靠背 背靠背 

59
00:02:44,430 --> 00:02:51,239
你可以像我一样置换它们

60
00:02:46,530 --> 00:02:53,459
我的 手指0 1 2 3 等等 等等 

61
00:02:51,239 --> 00:02:56,350
我们开始谈论二进制更多 

62
00:02:53,459 --> 00:02:58,870
通常，因此这里例如 价值 

63
00:02:56,350 --> 00:03:01,510
零和一 的 三个序列 和 

64
00:02:58,870 --> 00:03:03,160
每个人代表的东西， 但 

65
00:03:01,510 --> 00:03:04,990
我们不需要考虑这个世界 

66
00:03:03,160 --> 00:03:06,130
在那个级别，我们可以 抽象 

67
00:03:04,990 --> 00:03:08,320
我们 所有的 人都这么多 熟悉的 

68
00:03:06,130 --> 00:03:11,950
当然还有十进制 

69
00:03:08,320 --> 00:03:14,080
这只是 72 73和33如果 

70
00:03:11,950 --> 00:03:15,610
有人回想起你使用ASCII时的情况 

71
00:03:14,080 --> 00:03:17,400
这是映射的全球标准 

72
00:03:15,610 --> 00:03:19,810
数字到字母我们得到了什么消息

73
00:03:17,400 --> 00:03:22,480
是的，它只是高资本H资本 

74
00:03:19,810 --> 00:03:25,150
我感叹号 ，所以这是一个 

75
00:03:22,480 --> 00:03:26,950
除此之外的抽象

76
00:03:25,150 --> 00:03:29,740
二进制数，但我们没有 

77
00:03:26,950 --> 00:03:31,540
模型只是最后使用数字的文本 

78
00:03:29,740 --> 00:03:33,130
当天我们唯一的资源仍在 

79
00:03:31,540 --> 00:03:34,540
那电和我们唯一的方式 

80
00:03:33,130 --> 00:03:36,130
以数字方式思考它仍然是零 

81
00:03:34,540 --> 00:03:40,270
而且如果我们采取 这些相同的 

82
00:03:36,130 --> 00:03:41,950
价值72 73 33并对待他们 

83
00:03:40,270 --> 00:03:43,870
类似Photoshop 或类似的上下文

84
00:03:41,950 --> 00:03:45,490
照片程序或图形程序我们 

85
00:03:43,870 --> 00:03:47,200
艾玛可能不会像其他人一样 

86
00:03:45,490 --> 00:03:48,850
红量一些绿色的一些 

87
00:03:47,200 --> 00:03:51,070
上次给我们的蓝色量

88
00:03:48,850 --> 00:03:53,380
现在 我们 回想起这种淡黄色 

89
00:03:51,070 --> 00:03:55,870
在二进制文件上有另一个抽象 

90
00:03:53,380 --> 00:03:57,280
颜色，这只是一个像素 是什么 

91
00:03:55,870 --> 00:04:00,730
一旦你有 一个 以上，你能做到吗？ 

92
00:03:57,280 --> 00:04:02,350
像素， 你能代表什么， 是的 

93
00:04:00,730 --> 00:04:03,910
右侧的 图像权利，使我们 的 排序 

94
00:04:02,350 --> 00:04:05,140
继续谈话

95
00:04:03,910 --> 00:04:06,820
我们可以代表 一些东西 

96
00:04:05,140 --> 00:04:08,470
就像屏幕上的图形表情符号一样

97
00:04:06,820 --> 00:04:09,760
这已经 不仅仅是一个黄点 以上 

98
00:04:08,470 --> 00:04:11,920
它有一大堆黄点 

99
00:04:09,760 --> 00:04:14,050
和其他颜色也回忆起来 

100
00:04:11,920 --> 00:04:15,760
如果我们想要动画的话是否 

101
00:04:14,050 --> 00:04:17,650
它是通过像表情符号这样的愚蠢的东西

102
00:04:15,760 --> 00:04:20,830
在电话上或只是更合适的视频

103
00:04:17,650 --> 00:04:22,570
和电影 那些只是序列 

104
00:04:20,830 --> 00:04:24,730
飞过你人眼的图像 

105
00:04:22,570 --> 00:04:26,260
真的很快， 所以这就是我们的地方 

106
00:04:24,730 --> 00:04:28,090
从上次开始时就离开了 

107
00:04:26,260 --> 00:04:29,620
基准水平和抽象掉 ，从而 

108
00:04:28,090 --> 00:04:32,470
我们可以这样 规定 

109
00:04:29,620 --> 00:04:34,600
此后 我们可以代表投入和 

110
00:04:32,470 --> 00:04:36,250
我们可以代表任何产出的产出

111
00:04:34,600 --> 00:04:37,660
恰好在这里我们没有 

112
00:04:36,250 --> 00:04:39,730
需要在那个层面思考我们可以 

113
00:04:37,660 --> 00:04:41,500
假设我们都知道如何做到这一点 

114
00:04:39,730 --> 00:04:43,750
即使 它最终成为一种 

115
00:04:41,500 --> 00:04:45,310
遥远的记忆我们知道有人可以 

116
00:04:43,750 --> 00:04:48,130
确实这样做，那就是价值 

117
00:04:45,310 --> 00:04:49,810
抽象但这个黑盒子 内 

118
00:04:48,130 --> 00:04:51,370
我们所谓的算法 就是那种 

119
00:04:49,810 --> 00:04:53,530
秘密酱这些，但这 是在哪里 

120
00:04:51,370 --> 00:04:55,960
问题实际上已经解决了，我们 

121
00:04:53,530 --> 00:04:57,850
不仅谈到了这些 

122
00:04:55,960 --> 00:04:59,800
算法只是 如何 

123
00:04:57,850 --> 00:05:02,080
高效他们是如此回忆 这一点 

124
00:04:59,800 --> 00:05:03,790
红线代表一个非常简单 

125
00:05:02,080 --> 00:05:05,680
算法只是转动电话簿 

126
00:05:03,790 --> 00:05:06,910
一页一页，一页一页 

127
00:05:05,680 --> 00:05:07,990
原因这是一个直线 

128
00:05:06,910 --> 00:05:10,090
因为这就像是一对一的 

129
00:05:07,990 --> 00:05:11,590
多少页之间的对应关系 

130
00:05:10,090 --> 00:05:13,449
书中有多少页

131
00:05:11,590 --> 00:05:15,610
转过来有一页多一页 

132
00:05:13,449 --> 00:05:17,889
如果我飞， 再转一圈 等等 

133
00:05:15,610 --> 00:05:20,560
通过它两倍的 速度 两 四 

134
00:05:17,889 --> 00:05:23,590
六， 八 我可以做得更好 

135
00:05:20,560 --> 00:05:24,970
现在召回的黄线较低了 

136
00:05:23,590 --> 00:05:26,800
图表，如果你只是看看任何 

137
00:05:24,970 --> 00:05:29,050
两点黄色和红色黄色是

138
00:05:26,800 --> 00:05:30,340
红色下面说它花费的时间更少但是 

139
00:05:29,050 --> 00:05:32,380
这不太 正确 

140
00:05:30,340 --> 00:05:35,470
曾经有一段时间我一直在寻找一个错误

141
00:05:32,380 --> 00:05:38,290
迈克两个网页 同时 那是什么 

142
00:05:35,470 --> 00:05:39,669
问题是的，我可能会想念他

143
00:05:38,290 --> 00:05:41,620
不小心被夹在中间

144
00:05:39,669 --> 00:05:43,780
两页不是 什么大不了的 因为我 

145
00:05:41,620 --> 00:05:45,130
可以修复它，但我必须要修好它， 我有 

146
00:05:43,780 --> 00:05:46,540
应用那个额外的逻辑和 

147
00:05:45,130 --> 00:05:48,610
如果我去的话 ，至少会翻回页面 

148
00:05:46,540 --> 00:05:50,470
太快但当然是那种 

149
00:05:48,610 --> 00:05:52,360
最后的算法，坦率地说 ，我们 所有 的 

150
00:05:50,470 --> 00:05:54,460
最初的直觉可能是

151
00:05:52,360 --> 00:05:55,990
划分和征服大致打开它 

152
00:05:54,460 --> 00:05:57,729
中间向下看，然后向左走

153
00:05:55,990 --> 00:05:59,470
和向右走，只是重复 

154
00:05:57,729 --> 00:06:01,450
过程因为问题变得如此重要 

155
00:05:59,470 --> 00:06:03,270
对于这个大到 大这个大到公正 

156
00:06:01,450 --> 00:06:06,430
剩下一页，这就是全部 

157
00:06:03,270 --> 00:06:07,720
效率，但去 这一点我们 

158
00:06:06,430 --> 00:06:09,130
需要更多地表达自己

159
00:06:07,720 --> 00:06:11,320
正是因此我们介绍了 

160
00:06:09,130 --> 00:06:12,910
伪代码没有正式的定义 

161
00:06:11,320 --> 00:06:14,470
它可以是英语英语，就像它一样 

162
00:06:12,910 --> 00:06:16,419
意思 是简洁 而且明白了 

163
00:06:14,470 --> 00:06:18,220
穿过 并回想起 我们 一路走来 

164
00:06:16,419 --> 00:06:19,990
介绍了一大堆概念 

165
00:06:18,220 --> 00:06:21,910
其中许多你 可能已经尝试过 

166
00:06:19,990 --> 00:06:25,030
与划痕像循环和

167
00:06:21,910 --> 00:06:27,160
条件布尔表达式变量 

168
00:06:25,030 --> 00:06:28,930
等等，那些正在建设中

169
00:06:27,160 --> 00:06:31,389
那种说出来 的这 一点块

170
00:06:28,930 --> 00:06:33,280
这是一种示范，但老实说 

171
00:06:31,389 --> 00:06:34,930
甚至 在这个 演示中 

172
00:06:33,280 --> 00:06:36,669
伪代码有一大堆 

173
00:06:34,930 --> 00:06:38,139
如果您阅读这些 假设就是正确的 

174
00:06:36,669 --> 00:06:40,030
一次一个指令，你是 

175
00:06:38,139 --> 00:06:41,770
拿着电话簿自己的赔率是 

176
00:06:40,030 --> 00:06:44,289
你可以执行伪代码 

177
00:06:41,770 --> 00:06:47,620
算法，但 它 真正意味着 什么 

178
00:06:44,289 --> 00:06:49,450
说打开到手机中间 

179
00:06:47,620 --> 00:06:51,490
预订我们所有人都有一个直观的 

180
00:06:49,450 --> 00:06:52,930
了解这 意味着 什么 但是 

181
00:06:51,490 --> 00:06:54,520
老实说，如果你有点解释

182
00:06:52,930 --> 00:06:55,780
对于 一个孩子或正在 学习的人 

183
00:06:54,520 --> 00:06:57,460
英语或其他任何语言 

184
00:06:55,780 --> 00:06:59,260
第一次 打开到中间 

185
00:06:57,460 --> 00:07:01,060
你应该提出的电话簿

186
00:06:59,260 --> 00:07:03,220
一些假设好 了 

187
00:07:01,060 --> 00:07:05,979
你面前有一千页 

188
00:07:03,220 --> 00:07:07,810
纸张转到第 500页和 

189
00:07:05,979 --> 00:07:09,490
让我们称之为中间偏右 的 这 

190
00:07:07,810 --> 00:07:10,900
会很快变得乏味 

191
00:07:09,490 --> 00:07:12,940
如果我们所有人都在谈论这个问题 

192
00:07:10,900 --> 00:07:15,430
详细程度，所以我们抽象了 

193
00:07:12,940 --> 00:07:16,360
随着更开放的声明， 如开放 

194
00:07:15,430 --> 00:07:18,580
到了电话簿的中间但是 

195
00:07:16,360 --> 00:07:20,320
这是一种抽象而且并不完全 

196
00:07:18,580 --> 00:07:22,120
尽可能精确 

197
00:07:20,320 --> 00:07:23,680
特别是把这个算法喂给 了 

198
00:07:22,120 --> 00:07:25,840
新手 或机器人 

199
00:07:23,680 --> 00:07:28,330
计算机，但它是有用的， 因为我们 可以 

200
00:07:25,840 --> 00:07:30,729
做一个12步骤而不是20步 

201
00:07:28,330 --> 00:07:32,350
步骤程序通过详细阐述和 

202
00:07:30,729 --> 00:07:34,150
比如整个这里 - 我们有 

203
00:07:32,350 --> 00:07:35,919
我们的循环和条件等等 

204
00:07:34,150 --> 00:07:38,350
但 即使打电话给迈克也是如此 

205
00:07:35,919 --> 00:07:39,639
如果你想象人类，那就意味着好

206
00:07:38,350 --> 00:07:41,229
我知道如何使用这些手机 

207
00:07:39,639 --> 00:07:43,060
不说，但如果他或她也 

208
00:07:41,229 --> 00:07:44,680
需要编程 使用 手机 

209
00:07:43,060 --> 00:07:46,539
你必须解释 你 知道选择它 

210
00:07:44,680 --> 00:07:49,000
点击此按钮键入此序列

211
00:07:46,539 --> 00:07:50,979
按钮等等所以叫 迈克是 

212
00:07:49,000 --> 00:07:53,320
这些也是一种抽象 

213
00:07:50,979 --> 00:07:56,349
抽象是有用的，但他们可以

214
00:07:53,320 --> 00:07:59,380
有时会 妨碍特别是如果 

215
00:07:56,349 --> 00:08:02,470
你的编程 不够 准确 

216
00:07:59,380 --> 00:08:06,009
正确的计算机和油漆 

217
00:08:02,470 --> 00:08:07,690
这张照片以为我们 开始了一点 

218
00:08:06,009 --> 00:08:09,070
在这里轻松地带来了一些

219
00:08:07,690 --> 00:08:11,349
早餐，如果你没有做到 这一点 

220
00:08:09,070 --> 00:08:13,060
隔壁超出 需要一 对夫妇 

221
00:08:11,349 --> 00:08:15,190
贵公司出现的志愿者

222
00:08:13,060 --> 00:08:16,930
阶段和在互联网上这里让 

223
00:08:15,190 --> 00:08:18,639
我在这里有很多灯 

224
00:08:16,930 --> 00:08:21,340
怎么样那边 的 左边和 

225
00:08:18,639 --> 00:08:22,930
在前面就在这里，就在那里 

226
00:08:21,340 --> 00:08:25,720
我觉得 你的手已经 下降了 

227
00:08:22,930 --> 00:08:29,740
和 高达布莱恩，你 介意借给我们一 

228
00:08:25,720 --> 00:08:31,780
亲自动手- 谢谢你 

229
00:08:29,740 --> 00:08:35,140
你想控制在这里让我走吧 

230
00:08:31,780 --> 00:08:37,900
提前并切换 到另一个程序 

231
00:08:35,140 --> 00:08:39,190
对你来说好吧你的 名字 是什么 基因 大卫 

232
00:08:37,900 --> 00:08:41,409
很高兴见到你对 上 一席 

233
00:08:39,190 --> 00:08:42,729
Abby很喜欢你名字的最左边

234
00:08:41,409 --> 00:08:44,920
如果你和你见面也是最右边的 

235
00:08:42,729 --> 00:08:46,300
你可以这样基因和艾比你想要吗？ 

236
00:08:44,920 --> 00:08:50,260
说点什么

237
00:08:46,300 --> 00:08:52,510
你自己快速基因 马萨诸塞州 

238
00:08:50,260 --> 00:08:54,339
本地人，我正在服用两个是的 

239
00:08:52,510 --> 00:08:56,170
第一次这是我的第一次编码或 

240
00:08:54,339 --> 00:08:57,820
什么， 所以我这样做，我 

241
00:08:56,170 --> 00:08:58,029
享受它很高兴有你 

242
00:08:57,820 --> 00:09:01,540
我们 

243
00:08:58,029 --> 00:09:03,490
艾比，我是艾比， 我把它作为一个 

244
00:09:01,540 --> 00:09:05,050
大二，我对此一无所知 

245
00:09:03,490 --> 00:09:07,360
计算机或计算机科学，所以我 

246
00:09:05,050 --> 00:09:09,430
可能在发病时 很好 

247
00:09:07,360 --> 00:09:10,750
很高兴有你 这么 好 

248
00:09:09,430 --> 00:09:12,250
我们面前是一大堆 

249
00:09:10,750 --> 00:09:13,660
配料，希望我们可以种 

250
00:09:12,250 --> 00:09:14,800
轻轻地开始学期 ，如果 

251
00:09:13,660 --> 00:09:16,660
我们成功的确实 有一个 

252
00:09:14,800 --> 00:09:18,339
快点咬在这里，但我们以为我们会 

253
00:09:16,660 --> 00:09:20,170
在这里和布莱恩的观众一样

254
00:09:18,339 --> 00:09:22,120
要抄写员，因为我们去和所有我们想要 

255
00:09:20,170 --> 00:09:24,130
今天早上做一个花生 

256
00:09:22,120 --> 00:09:25,779
黄油 和果冻 三明治 之一 

257
00:09:24,130 --> 00:09:27,610
一次指导我们每个人 

258
00:09:25,779 --> 00:09:28,029
将 只执行我们听到的是如何 

259
00:09:27,610 --> 00:09:29,980
那个声音

260
00:09:28,029 --> 00:09:31,360
好吧，如果 有人可以做志愿者 

261
00:09:29,980 --> 00:09:33,779
第一条指令和Brian将 

262
00:09:31,360 --> 00:09:33,779
键入下来 

263
00:09:36,210 --> 00:09:39,670
打开面包，我们听到开口面包是

264
00:09:38,589 --> 00:09:47,860
第一条指令，如果你需要你 

265
00:09:39,670 --> 00:09:52,570
喜欢执行开面包 不要 看 

266
00:09:47,860 --> 00:09:58,570
我 还可以， 所以我们有点兴奋 

267
00:09:52,570 --> 00:10:00,700
我的方式没关系， 我认为Abby做得更好 

268
00:09:58,570 --> 00:10:02,410
当然，但我们做得 正确 

269
00:10:00,700 --> 00:10:06,010
可以说是让我们继续前进到第二步 

270
00:10:02,410 --> 00:10:15,339
并看看我们是否无法改善 取出 

271
00:10:06,010 --> 00:10:20,980
面包好的欢迎 来到 团队 现在 很好 

272
00:10:15,339 --> 00:10:24,390
好的 第三步是的，两个地方 

273
00:10:20,980 --> 00:10:24,390
桌上的面包片

274
00:10:25,920 --> 00:10:31,350
没关系板块还可以第四步 

275
00:10:34,080 --> 00:10:49,330
拧开果冻盖直到它打开谢谢 

276
00:10:37,300 --> 00:10:52,120
你 迈出第五 步， 谢谢你 

277
00:10:49,330 --> 00:10:56,730
将 盖子放在 我拿了一些 的侧面 

278
00:10:52,120 --> 00:10:56,730
自由自己的步骤拿刀 

279
00:11:00,890 --> 00:11:14,490
剥掉果冻的盖子没有 

280
00:11:06,750 --> 00:11:22,890
盖上我们的棍子刀进入视频 

281
00:11:14,490 --> 00:11:26,420
从顶部的瓶子 好吧 

282
00:11:22,890 --> 00:11:26,420
第9步

283
00:11:27,800 --> 00:11:34,730
转动手，所以果冻结束好吧 

284
00:11:35,570 --> 00:11:45,140
好的 

285
00:11:37,160 --> 00:11:45,140
快步十步是第10步 

286
00:11:45,290 --> 00:11:58,100
拿出刀好吧 

287
00:11:48,980 --> 00:11:58,100
步骤11果冻面朝下面包

288
00:12:01,649 --> 00:12:21,899
好吧 步骤第12步第12步任何人都是 

289
00:12:11,819 --> 00:12:21,899
谢谢第13步将果冻倒在面包上 

290
00:12:22,769 --> 00:12:29,259
当然

291
00:12:24,899 --> 00:12:39,420
倒入果冻果冻现在 好 了 

292
00:12:29,259 --> 00:12:39,420
你只是搞砸了我们步骤14 

293
00:12:39,779 --> 00:12:48,999
把果冻放下来谢谢你

294
00:12:42,209 --> 00:12:51,480
15拿起 花生酱盖上盖子 

295
00:12:48,999 --> 00:12:51,480
谢谢 

296
00:12:52,230 --> 00:13:03,089
剥掉盖子谢谢你第18步拿起 

297
00:13:00,819 --> 00:13:03,089
刀

298
00:13:03,899 --> 00:13:21,220
bye blunt end scoop okay scoop step 20 

299
00:13:17,279 --> 00:13:25,089
把粉红色的花生酱 放在面包上 

300
00:13:21,220 --> 00:13:27,549
[笑声] 

301
00:13:25,089 --> 00:13:30,829
21:21 

302
00:13:27,549 --> 00:13:45,159
向上移动刀从左向右移动

303
00:13:30,829 --> 00:13:45,159
请从左到右步骤 22 谢谢 

304
00:13:46,599 --> 00:13:51,849
23:24那是什么 

305
00:13:53,559 --> 00:13:58,639
吃三明治好吧我想我们没事 

306
00:13:57,229 --> 00:14:00,109
以及怎么样，为什么我们不采取每一个 

307
00:13:58,639 --> 00:14:11,629
如果我们的话，就会有一阵掌声 

308
00:14:00,109 --> 00:14:13,429
可以为我们的志愿者谢谢你 

309
00:14:11,629 --> 00:14:18,349
如果你愿意的话可以带一些皮毛 

310
00:14:13,429 --> 00:14:23,499
谢谢你，谢谢Brian，好吧 

311
00:14:18,349 --> 00:14:27,319
现在我需要一分钟，所以 非常感谢你 

312
00:14:23,499 --> 00:14:29,509
这显然足以说明这一点 

313
00:14:27,319 --> 00:14:31,339
表现得甚至比 

314
00:14:29,509 --> 00:14:33,739
电话簿的例子在哪里肯定 

315
00:14:31,339 --> 00:14:35,149
假设是我们的抽象 

316
00:14:33,739 --> 00:14:36,499
诚实地，几乎所有的时间 

317
00:14:35,149 --> 00:14:37,969
那些是有用的 ，当然我们很友好 

318
00:14:36,499 --> 00:14:39,139
火腿的东西，我 认为 

319
00:14:37,969 --> 00:14:41,179
说明有点帮助 

320
00:14:39,139 --> 00:14:42,949
在这里，但到了时候到了 

321
00:14:41,179 --> 00:14:45,229
程序与 划痕，当然与 

322
00:14:42,949 --> 00:14:46,309
C本周开始 你不能真的 

323
00:14:45,229 --> 00:14:48,349
做出尽可能多的假设 

324
00:14:46,309 --> 00:14:49,879
不再是因为如果你不处理 

325
00:14:48,349 --> 00:14:51,499
这些角落案件，如果你 

326
00:14:49,879 --> 00:14:53,209
不要考虑那个指令 

327
00:14:51,499 --> 00:14:54,919
意味着你 会得到 众所周知的 

328
00:14:53,209 --> 00:14:56,089
旋转沙滩球或沙漏 

329
00:14:54,919 --> 00:14:57,499
您在 Mac或Mac上 熟悉的 

330
00:14:56,089 --> 00:14:59,329
PC可能程序会崩溃 

331
00:14:57,499 --> 00:15:02,749
只是因为 某些事情会出错 

332
00:14:59,329 --> 00:15:06,339
你错过了一些特异性或精确性 

333
00:15:02,749 --> 00:15:08,749
不 ，随着时间的推移， 我们都是 花生酱 

334
00:15:06,339 --> 00:15:10,489
我们会发现它 很像 

335
00:15:08,749 --> 00:15:12,109
从头开始， 我们 能够自己创造 

336
00:15:10,489 --> 00:15:13,969
你可能还记得那些积木

337
00:15:12,109 --> 00:15:16,189
我们用 COFF 做的简短例子

338
00:15:13,969 --> 00:15:17,569
例如，我有咖啡排然后 

339
00:15:16,189 --> 00:15:19,459
抓住了一个并 咳嗽到我所在的地方 

340
00:15:17,569 --> 00:15:21,409
制作中 我自己的 拼图 

341
00:15:19,459 --> 00:15:23,299
从头开始 ，这 是有用的，因为后 

342
00:15:21,409 --> 00:15:25,429
那个例子从理论上说我再也不会

343
00:15:23,299 --> 00:15:27,499
需要 思考或担心如何 

344
00:15:25,429 --> 00:15:29,449
实施咖啡， 我可以使用它 

345
00:15:27,499 --> 00:15:31,519
抽象，但有人必须实施 

346
00:15:29,449 --> 00:15:32,929
他们有时它 会 是其他的 

347
00:15:31,519 --> 00:15:34,729
有时 来到我们面前的人 

348
00:15:32,929 --> 00:15:36,409
这将 是 我们所以这不是说 

349
00:15:34,729 --> 00:15:36,950
编程 最终会如此 

350
00:15:36,409 --> 00:15:38,450
乏味

351
00:15:36,950 --> 00:15:40,820
你必须指出每一点点 

352
00:15:38,450 --> 00:15:43,040
事情，但你 或某人 必须做 

353
00:15:40,820 --> 00:15:45,680
这种精度 水平 至少一次 

354
00:15:43,040 --> 00:15:48,170
麻省理工学院做得很好 

355
00:15:45,680 --> 00:15:49,280
大部分跑腿的你 我们都 

356
00:15:48,170 --> 00:15:51,020
要构建的构建块 

357
00:15:49,280 --> 00:15:52,850
我们自己的动画或游戏或艺术品或 

358
00:15:51,020 --> 00:15:54,710
之类的， 但即便如此，你可能也有过 

359
00:15:52,850 --> 00:15:56,960
连接 数十个拼图 

360
00:15:54,710 --> 00:15:59,300
甚至更多 来获得那些基本面 

361
00:15:56,960 --> 00:16:01,070
做它是什么，你 把它想 

362
00:15:59,300 --> 00:16:03,020
今天这样做，我们要开始 

363
00:16:01,070 --> 00:16:04,790
从头开始过渡这个图形 

364
00:16:03,020 --> 00:16:06,320
编程语言，虽然有针对性 

365
00:16:04,790 --> 00:16:08,090
通常情况下 ，年轻学生

366
00:16:06,320 --> 00:16:09,560
代表很多相同的 

367
00:16:08,090 --> 00:16:11,240
现在要标记ace的概念

368
00:16:09,560 --> 00:16:13,130
整个学期， 但我们会 

369
00:16:11,240 --> 00:16:14,660
今天介绍一个更老的 

370
00:16:13,130 --> 00:16:16,760
传统语言就是这样 

371
00:16:14,660 --> 00:16:18,260
基于文本，因此它更多 

372
00:16:16,760 --> 00:16:20,000
强大但 乍一看它是 

373
00:16:18,260 --> 00:16:22,430
实际上看起来会 更加神秘 

374
00:16:20,000 --> 00:16:24,260
事实上，而不是写零和 

375
00:16:22,430 --> 00:16:26,690
从今天开始我们反而会

376
00:16:24,260 --> 00:16:28,430
写信 这样的事情 ，如果你已经 

377
00:16:26,690 --> 00:16:30,110
从来没有编程在赔率之前 

378
00:16:28,430 --> 00:16:32,060
乍一看这看起来很漂亮 

379
00:16:30,110 --> 00:16:33,950
神秘而且有很多符号 

380
00:16:32,060 --> 00:16:35,720
在键盘的标点符号内 

381
00:16:33,950 --> 00:16:38,120
可能 有 一些熟悉的英语 

382
00:16:35,720 --> 00:16:40,070
喜欢说话，坦率地说 甚至做完之后 

383
00:16:38,120 --> 00:16:41,570
事先没有任何 划痕 ，甚至 

384
00:16:40,070 --> 00:16:43,940
背景可能会导致猜测 

385
00:16:41,570 --> 00:16:45,710
至于这个程序写的是什么 

386
00:16:43,940 --> 00:16:49,160
其他语言称为C，当你 

387
00:16:45,710 --> 00:16:50,630
运行它，它只是 打印Hello World 现在 

388
00:16:49,160 --> 00:16:52,940
授予了相当 数量的 

389
00:16:50,630 --> 00:16:54,530
句法上有一堆 

390
00:16:52,940 --> 00:16:56,570
你 必须输入的东西 才能做到 这一点 

391
00:16:54,530 --> 00:16:58,310
程序做你想做的事，但在 

392
00:16:56,570 --> 00:17:00,500
这一天的结束就是它的全部 

393
00:16:58,310 --> 00:17:02,720
要做，这是最简单的 

394
00:17:00,500 --> 00:17:04,970
我们将要添加到我们的拼图中的程序 

395
00:17:02,720 --> 00:17:06,560
件可以这么说今天 在看到一些 

396
00:17:04,970 --> 00:17:09,050
我们上次看到的那些概念 

397
00:17:06,560 --> 00:17:11,240
时间也是如此， 让我们先做 

398
00:17:09,050 --> 00:17:13,820
虽然让我花一点时间来 

399
00:17:11,240 --> 00:17:15,440
有点比较划痕，因为 

400
00:17:13,820 --> 00:17:16,820
今天最重要的事情是 

401
00:17:15,440 --> 00:17:18,740
即使语法也会如此 

402
00:17:16,820 --> 00:17:20,720
看起来并不那么明显 和坦率 

403
00:17:18,740 --> 00:17:22,430
如果你的第一分钟或几小时 

404
00:17:20,720 --> 00:17:24,320
用C编写自己的代码

405
00:17:22,430 --> 00:17:26,000
令人沮丧，因为该死像你 离开 

406
00:17:24,320 --> 00:17:27,589
分号或 哦我有一个 

407
00:17:26,000 --> 00:17:29,210
括号在错误的地方有一个 

408
00:17:27,589 --> 00:17:30,920
很多这些愚蠢的句法挂断 

409
00:17:29,210 --> 00:17:32,630
这 让你 经常 感觉到 你 

410
00:17:30,920 --> 00:17:34,310
真的没有得到它， 但事实并非如此 

411
00:17:32,630 --> 00:17:36,650
重要的东西很多语法 

412
00:17:34,310 --> 00:17:37,970
是 最不重要的 ，根本不是 

413
00:17:36,650 --> 00:17:40,760
从根本上说在理智上很有趣

414
00:17:37,970 --> 00:17:42,110
所以试着看看过去 ，并尝试采取 

415
00:17:40,760 --> 00:17:43,970
它是舒适的事实 

416
00:17:42,110 --> 00:17:45,740
这 是 要去的重要原则

417
00:17:43,970 --> 00:17:47,660
老老实实只是通过 肌肉记忆 

418
00:17:45,740 --> 00:17:49,850
并练习所有其他的东西 

419
00:17:47,660 --> 00:17:50,840
它首先是 偶尔的 

420
00:17:49,850 --> 00:17:53,270
沮丧只是 

421
00:17:50,840 --> 00:17:55,580
当你开始 看到它时 离开 

422
00:17:53,270 --> 00:17:58,309
是什么， 而不仅仅是语法 

423
00:17:55,580 --> 00:18:01,850
你乍一看就是这样的 

424
00:17:58,309 --> 00:18:03,620
说这个程序在C右边是 

425
00:18:01,850 --> 00:18:05,390
相当于我们 一周 所做的 事情 

426
00:18:03,620 --> 00:18:07,370
以前有两个拼图 

427
00:18:05,390 --> 00:18:09,710
现在不会 有绿旗 

428
00:18:07,370 --> 00:18:10,610
我们继续前进，我的Mac或我的电脑 

429
00:18:09,710 --> 00:18:11,990
你可以点击我们必须的 

430
00:18:10,610 --> 00:18:13,610
运行这些程序有点不同 

431
00:18:11,990 --> 00:18:15,440
方式但在 右边的所有代码

432
00:18:13,610 --> 00:18:16,700
正在做与等效的代码 

433
00:18:15,440 --> 00:18:17,960
左边让我们再来一次 

434
00:18:16,700 --> 00:18:19,190
再次 仅针对其中一些概念 

435
00:18:17,960 --> 00:18:21,529
从上次开始，然后我们将开始 

436
00:18:19,190 --> 00:18:23,539
写一些我们自己的程序 就这样吧 

437
00:18:21,529 --> 00:18:28,100
这是紫色块的一个例子

438
00:18:23,539 --> 00:18:29,539
编程中的概念ya函数所以它 

439
00:18:28,100 --> 00:18:30,740
是一个动词，这是一个行动，我们是

440
00:18:29,539 --> 00:18:32,360
要称那些通常是功能

441
00:18:30,740 --> 00:18:34,370
他们只是内置了功能

442
00:18:32,360 --> 00:18:35,570
他们 如何 在C中 做到这一点 你好 

443
00:18:34,370 --> 00:18:37,520
可能还记得刚才 

444
00:18:35,570 --> 00:18:39,770
因为其中一行 代码是 

445
00:18:37,520 --> 00:18:41,510
代表这有一些 

446
00:18:39,770 --> 00:18:43,190
这句法所以其实如果我是 

447
00:18:41,510 --> 00:18:44,929
翻译左边 的 块 

448
00:18:43,190 --> 00:18:46,820
抓到这个中的等价代码 

449
00:18:44,929 --> 00:18:48,620
其他基于文本的语言称为C我

450
00:18:46,820 --> 00:18:50,179
然后从写作打印开始 

451
00:18:48,620 --> 00:18:52,250
打开括号 然后关闭 

452
00:18:50,179 --> 00:18:54,320
括号和 那些括号 类型 

453
00:18:52,250 --> 00:18:56,419
代表 椭圆形 的白色椭圆形 

454
00:18:54,320 --> 00:18:58,700
我们输入的hello world 成左

455
00:18:56,419 --> 00:19:01,070
在C之前，它并不完全如此 

456
00:18:58,700 --> 00:19:02,690
字面意思是函数或动词 

457
00:19:01,070 --> 00:19:04,940
实际上并没有被称为打印它被称为

458
00:19:02,690 --> 00:19:06,919
打印F和F代表格式化 

459
00:19:04,940 --> 00:19:08,480
它只是意味着在C中你可以 

460
00:19:06,919 --> 00:19:10,279
实际上格式化您的文本不同

461
00:19:08,480 --> 00:19:12,260
所以我们会在不久之后看到这些 

462
00:19:10,279 --> 00:19:14,000
事实证明，你不只是写 

463
00:19:12,260 --> 00:19:16,100
这些括号 之间的你好世界

464
00:19:14,000 --> 00:19:17,779
就像我们在抓 你居然还 

465
00:19:16,100 --> 00:19:19,940
必须用双 引号括起来 

466
00:19:17,779 --> 00:19:20,960
在C好吧我不是那么大的 但是 

467
00:19:19,940 --> 00:19:23,690
以前你不需要做的事情 

468
00:19:20,960 --> 00:19:25,880
但 你知道在C中你会发生什么 

469
00:19:23,690 --> 00:19:27,409
一般都想超级具体 

470
00:19:25,880 --> 00:19:29,630
电脑和你想要的时间 

471
00:19:27,409 --> 00:19:31,640
光标移动屏幕上的文字 

472
00:19:29,630 --> 00:19:33,409
下到你需要告诉 的下一 行 

473
00:19:31,640 --> 00:19:35,330
通过字面输入的计算机

474
00:19:33,409 --> 00:19:37,309
反斜杠n中的人是不会 

475
00:19:35,330 --> 00:19:39,140
看到反斜杠和N他或她 

476
00:19:37,309 --> 00:19:40,309
实际上会 看到 光标移动到 

477
00:19:39,140 --> 00:19:42,350
就像你 在 屏幕 的下一行 

478
00:19:40,309 --> 00:19:44,409
在Google Docs或Microsoft中都知道 

479
00:19:42,350 --> 00:19:46,940
喜欢的话，但这只是说 

480
00:19:44,409 --> 00:19:48,470
你需要的 精确度 

481
00:19:46,940 --> 00:19:50,510
在这个级别与 计算机交谈 

482
00:19:48,470 --> 00:19:51,799
不只是 拼图 然后 

483
00:19:50,510 --> 00:19:52,909
最后一件事，我 提到了它 

484
00:19:51,799 --> 00:19:55,520
早些时候因为它有点祸害 

485
00:19:52,909 --> 00:19:58,429
许多程序员早期在大多数行上 

486
00:19:55,520 --> 00:20:00,409
C中的代码必须以分号结尾

487
00:19:58,429 --> 00:20:02,360
这是一种相当于a的代码 

488
00:20:00,409 --> 00:20:04,460
英语或其他一段时间

489
00:20:02,360 --> 00:20:05,660
语言句子就是这样 

490
00:20:04,460 --> 00:20:07,190
我们花了一些时间来 样 

491
00:20:05,660 --> 00:20:08,960
建立起来， 但这就是 全部 

492
00:20:07,190 --> 00:20:11,120
说左边的想法是 

493
00:20:08,960 --> 00:20:13,880
在C中用同样的东西打印 

494
00:20:11,120 --> 00:20:15,380
这个函数调用printf 和之前 

495
00:20:13,880 --> 00:20:17,420
我和其他人一起开拓进取

496
00:20:15,380 --> 00:20:22,250
比较任何有关此问题的问题

497
00:20:17,420 --> 00:20:24,200
你怎么写反斜杠n 

498
00:20:22,250 --> 00:20:26,300
这样看起来很好

499
00:20:24,200 --> 00:20:28,880
难以 逐字地表现出来 

500
00:20:26,300 --> 00:20:31,040
用户反斜杠，事实证明 

501
00:20:28,880 --> 00:20:32,870
这反斜杠 因为它不是 

502
00:20:31,040 --> 00:20:34,490
非常普遍的性格 

503
00:20:32,870 --> 00:20:36,260
编程世界将它用作什么 

504
00:20:34,490 --> 00:20:38,240
叫做逃脱角色就是那个 

505
00:20:36,260 --> 00:20:39,770
你想要逃避时使用 

506
00:20:38,240 --> 00:20:41,720
信息并稍微显示一下

507
00:20:39,770 --> 00:20:44,180
不同的方式，所以你会表现出来的方式 

508
00:20:41,720 --> 00:20:46,460
字面意思是人类的实际 

509
00:20:44,180 --> 00:20:50,690
反斜杠n实际上是在 你的代码中 

510
00:20:46,460 --> 00:20:52,580
做反斜杠反斜杠因为

511
00:20:50,690 --> 00:20:54,200
第二个反斜杠就像说对待

512
00:20:52,580 --> 00:20:56,000
下一个角色特别而且实际上 

513
00:20:54,200 --> 00:20:58,070
把它展示给人类，还有其他的 

514
00:20:56,000 --> 00:21:00,050
这样的例子如此 

515
00:20:58,070 --> 00:21:03,800
一个此橙色块是 的 一个例子 

516
00:21:00,050 --> 00:21:05,930
什么概念在刮擦是啊所以这是 

517
00:21:03,800 --> 00:21:07,550
一个像x和y和代数的变量

518
00:21:05,930 --> 00:21:09,470
这只是数据和占位符

519
00:21:07,550 --> 00:21:11,060
你可以存储数字原来你 

520
00:21:09,470 --> 00:21:13,310
可以存储您可以存储其他的单词 

521
00:21:11,060 --> 00:21:14,900
事情 太多其他语言使用 C 

522
00:21:13,310 --> 00:21:16,370
我们要这样做， 我们会说 

523
00:21:14,900 --> 00:21:18,050
字面上我们 变量的名称 

524
00:21:16,370 --> 00:21:20,870
想要例如反击，但我们可以 

525
00:21:18,050 --> 00:21:22,550
如果， 我们想要的任何东西 等于0 

526
00:21:20,870 --> 00:21:24,860
我们将它设置为最初等于0 

527
00:21:22,550 --> 00:21:26,240
但是看得更迂腐 

528
00:21:24,860 --> 00:21:28,340
你还要告诉电脑 

529
00:21:26,240 --> 00:21:31,160
我想要的这种变量是 

530
00:21:28,340 --> 00:21:33,170
专门为一个整数，否则 

531
00:21:31,160 --> 00:21:34,430
缩写为int所以你必须告诉它 

532
00:21:33,170 --> 00:21:35,840
计算机提前提供什么类型的数据 

533
00:21:34,430 --> 00:21:37,760
你要存放在它里面然后拿一个 

534
00:21:35,840 --> 00:21:39,590
猜你要完成这个想法 

535
00:21:37,760 --> 00:21:42,350
看看我们还需要添加什么 

536
00:21:39,590 --> 00:21:44,030
对于是的只是一个分号，那就是 

537
00:21:42,350 --> 00:21:46,850
它看起来有点神秘，但是 

538
00:21:44,030 --> 00:21:48,530
这个想法基本上是相同的 ，所以 

539
00:21:46,850 --> 00:21:50,900
如果我们想要在头上做这件事怎么办？ 

540
00:21:48,530 --> 00:21:53,990
将计数器改为 1这 相当于 

541
00:21:50,900 --> 00:21:55,520
递增或加1到计数器 

542
00:21:53,990 --> 00:21:57,080
好吧，让我继续前进 并提出建议 

543
00:21:55,520 --> 00:22:01,160
你真的可以 在C中做到这一点 

544
00:21:57,080 --> 00:22:04,370
设置计数器等于任何计数器

545
00:22:01,160 --> 00:22:05,720
目前加1，这似乎 是 

546
00:22:04,370 --> 00:22:07,700
一种正确的 直觉和 现在 

547
00:22:05,720 --> 00:22:10,100
注意这里要注意的关键 是 

548
00:22:07,700 --> 00:22:13,040
这个等号不是这么说的 

549
00:22:10,100 --> 00:22:15,470
计数器等于计数器加1，因为 

550
00:22:13,040 --> 00:22:17,120
如果这似乎是 不可能的 

551
00:22:15,470 --> 00:22:17,840
你选择计数器的任何值 ，如 

552
00:22:17,120 --> 00:22:20,690
1号

553
00:22:17,840 --> 00:22:23,210
一个肯定不等于一个 

554
00:22:20,690 --> 00:22:24,830
加一个是 两个 ，一个不是 

555
00:22:23,210 --> 00:22:27,440
等于 二，你可以想出一个 

556
00:22:24,830 --> 00:22:29,840
无数个 令人担忧的错误 

557
00:22:27,440 --> 00:22:30,980
比较所以 C中 的等号 就好了 

558
00:22:29,840 --> 00:22:33,140
我们会在很多语言中看到 

559
00:22:30,980 --> 00:22:35,660
class实际上意味着赋值 复制 

560
00:22:33,140 --> 00:22:38,180
价值在右边的价值上 

561
00:22:35,660 --> 00:22:40,160
左， 所以设置计数器等于它 

562
00:22:38,180 --> 00:22:40,610
是 我们完成 的 一个 加号 

563
00:22:40,160 --> 00:22:43,490
思想

564
00:22:40,610 --> 00:22:46,190
所以我们需要一个分号，但我不需要 

565
00:22:43,490 --> 00:22:47,500
需要ream int int和为什么可能 

566
00:22:46,190 --> 00:22:50,030
那是

567
00:22:47,500 --> 00:22:51,290
是的我已经告诉电脑 它是一个 

568
00:22:50,030 --> 00:22:52,670
整数， 你不需要重复 

569
00:22:51,290 --> 00:22:54,350
你再次 提到 int 

570
00:22:52,670 --> 00:22:55,550
尽管如此，假设在 这种情况下 

571
00:22:54,350 --> 00:22:58,760
我们只是在 幻灯片上看它 

572
00:22:55,550 --> 00:23:00,050
实际上是 在创建 之前 创建的 

573
00:22:58,760 --> 00:23:02,210
就像你通过说make做的那样 

574
00:23:00,050 --> 00:23:04,010
一个变量， 所以事实证明 你可以是一个 

575
00:23:02,210 --> 00:23:05,750
在 C和很多中 更 简洁 

576
00:23:04,010 --> 00:23:07,340
语言， 如果你发现这一点 

577
00:23:05,750 --> 00:23:08,540
输入很乏味，你知道它是一个 

578
00:23:07,340 --> 00:23:10,130
小啰嗦它是一堆 

579
00:23:08,540 --> 00:23:12,590
击键你实际上可以缩写 

580
00:23:10,130 --> 00:23:15,350
它只是这样加上等于它 

581
00:23:12,590 --> 00:23:17,060
只是作为程序员的语法糖 

582
00:23:15,350 --> 00:23:19,070
会说它只是一个不错的花哨功能 

583
00:23:17,060 --> 00:23:20,540
这可以让你写更少的单词或 

584
00:23:19,070 --> 00:23:22,130
人物，但 做同样的事情 

585
00:23:20,540 --> 00:23:23,510
坦白说，我们可以做得更好，如果 

586
00:23:22,130 --> 00:23:25,340
你正在服用你可能已经看过的APC 

587
00:23:23,510 --> 00:23:27,320
这在Java中你也 可以 

588
00:23:25,340 --> 00:23:30,680
简化这一点只是为了反击 

589
00:23:27,320 --> 00:23:32,480
再加上分号，这就是全部 

590
00:23:30,680 --> 00:23:33,320
相当于这 只是多一点 

591
00:23:32,480 --> 00:23:34,790
有效率， 随着你得到 更多 

592
00:23:33,320 --> 00:23:36,890
舒适的编程节省 

593
00:23:34,790 --> 00:23:38,060
按键刚才这可以节省您的时间

594
00:23:36,890 --> 00:23:41,330
当然是一个例子 

595
00:23:38,060 --> 00:23:43,010
相反的划痕， 是的，我们称之为 

596
00:23:41,330 --> 00:23:44,870
一个条件，它有一个布尔值

597
00:23:43,010 --> 00:23:46,400
我们问的表达方式

598
00:23:44,870 --> 00:23:48,410
在这种情况下的问题在哪里 

599
00:23:46,400 --> 00:23:51,350
显然在头上问是X少

600
00:23:48,410 --> 00:23:53,330
比如 Y ，如果是这样在 屏幕上这么说 

601
00:23:51,350 --> 00:23:55,100
我们怎么可能把它翻译成C呢呢 

602
00:23:53,330 --> 00:23:57,110
结果我们可以 简单地 翻译 

603
00:23:55,100 --> 00:23:58,730
我们已经看到了这个

604
00:23:57,110 --> 00:24:00,470
几乎所有 的积木从而 

605
00:23:58,730 --> 00:24:02,600
远， 但我们必须介绍 一点 

606
00:24:00,470 --> 00:24:05,090
这里有新的东西注意到了 

607
00:24:02,600 --> 00:24:06,620
printf 线 几乎 与什么相同 

608
00:24:05,090 --> 00:24:08,300
我 之前用过 的只是你好世界 

609
00:24:06,620 --> 00:24:10,040
显然只是改变了中的词 

610
00:24:08,300 --> 00:24:11,780
它但我仍然有反斜杠 我 

611
00:24:10,040 --> 00:24:13,820
仍然有报价仍然有 

612
00:24:11,780 --> 00:24:16,640
分号，使剩下的这些是 

613
00:24:13,820 --> 00:24:18,680
现在如果是新的，但这是一个 

614
00:24:16,640 --> 00:24:20,030
如果 C ， 一个翻译划痕调用它 

615
00:24:18,680 --> 00:24:21,620
如果和唯一的补充，它会调用它

616
00:24:20,030 --> 00:24:23,180
你在C 中 需要的是 括号 

617
00:24:21,620 --> 00:24:24,890
围绕布尔表达式，所以 

618
00:24:23,180 --> 00:24:27,560
什么取代 了小绿 

619
00:24:24,890 --> 00:24:29,300
阻止然后假设x和y 

620
00:24:27,560 --> 00:24:30,520
确实是我们创造的变量

621
00:24:29,300 --> 00:24:32,110
早些时候你可以 

622
00:24:30,520 --> 00:24:33,700
像这样配对它们就可以使用了 

623
00:24:32,110 --> 00:24:35,230
为 大于其它符号 

624
00:24:33,700 --> 00:24:36,580
比较也有 

625
00:24:35,230 --> 00:24:38,530
一些 有趣和最有趣的 东西 

626
00:24:36,580 --> 00:24:40,600
我们经常没有偶然的机会 

627
00:24:38,530 --> 00:24:42,490
在我们的键盘上使用这些键卷曲 

628
00:24:40,600 --> 00:24:44,110
他们倾向于 使用美式 键盘 上的支架

629
00:24:42,490 --> 00:24:47,140
在你的上方右上方 

630
00:24:44,110 --> 00:24:50,170
输入密钥 这些只是 C的 一种 

631
00:24:47,140 --> 00:24:51,700
这种形状 的通知， 所有的等价

632
00:24:50,170 --> 00:24:53,020
大多数黄色块的黄色 

633
00:24:51,700 --> 00:24:55,660
有点像这样的

634
00:24:53,020 --> 00:24:57,550
拥抱或拥抱这种形状 

635
00:24:55,660 --> 00:24:58,990
他们你可以在C中模拟它 

636
00:24:57,550 --> 00:25:01,180
拥有所谓的开放式 花括号 

637
00:24:58,990 --> 00:25:03,910
然后封闭 大括号 所以这 

638
00:25:01,180 --> 00:25:05,470
现在同样的想法就是抛开 你 

639
00:25:03,910 --> 00:25:06,850
从技术上讲，总是不需要这些

640
00:25:05,470 --> 00:25:08,980
如果你刚刚得到一个花括号

641
00:25:06,850 --> 00:25:10,900
像 这样 的单行 你可以省略它们 

642
00:25:08,980 --> 00:25:12,040
你可能会在网上或教科书中看到但是 

643
00:25:10,900 --> 00:25:13,930
我们总是 把它们画出来 

644
00:25:12,040 --> 00:25:18,400
一致性，以便C代码始终 

645
00:25:13,930 --> 00:25:21,280
看起来像这样，如果你想 

646
00:25:18,400 --> 00:25:24,010
如果X 小于Y则表达这一点

647
00:25:21,280 --> 00:25:26,620
然后说X小于Y，否则说X是 

648
00:25:24,010 --> 00:25:29,160
不 小于 Y以及原来这 

649
00:25:26,620 --> 00:25:31,720
是前四行几乎相同

650
00:25:29,160 --> 00:25:33,040
完全 和以前一样但是它 

651
00:25:31,720 --> 00:25:35,590
结果，所以你可以字面上说 

652
00:25:33,040 --> 00:25:37,450
在那之后关闭大括号 和 

653
00:25:35,590 --> 00:25:39,430
然后只是打印出来 

654
00:25:37,450 --> 00:25:41,290
无论你想说什么，这都是 

655
00:25:39,430 --> 00:25:43,390
像在岔路口，如果你去一个 

656
00:25:41,290 --> 00:25:46,360
方式说这你走另一 条路说 

657
00:25:43,390 --> 00:25:53,050
对于这些问题还有其他问题 

658
00:25:46,360 --> 00:25:54,940
到目前为止的比较是非常好的 

659
00:25:53,050 --> 00:25:56,980
问题你能把你或者你做 

660
00:25:54,940 --> 00:25:58,480
把 花括号放在同一条线上 

661
00:25:56,980 --> 00:25:59,710
如果你能，我们会谈谈

662
00:25:58,480 --> 00:26:01,870
关于这一点 在 接下来 的几周内 

663
00:25:59,710 --> 00:26:04,030
这种风格的问题有所不同 

664
00:26:01,870 --> 00:26:06,490
我可以表达完全相同的方式 

665
00:26:04,030 --> 00:26:09,400
代码坦率地说，我可以写出所有的 

666
00:26:06,490 --> 00:26:11,560
这段代码没有任何空格 

667
00:26:09,400 --> 00:26:13,630
事实上，如果我去，就是为了说明这一点 

668
00:26:11,560 --> 00:26:15,880
提前并打开 一个简单的文字 

669
00:26:13,630 --> 00:26:18,010
编辑在这里不是为了实际 编程而是 

670
00:26:15,880 --> 00:26:22,000
只是键入 我可以实际的东西 

671
00:26:18,010 --> 00:26:25,630
如果X小于Y，则 执行 类似的操作 

672
00:26:22,000 --> 00:26:29,020
然后继续打印 X更少 

673
00:26:25,630 --> 00:26:31,810
比Y反斜杠n分号花括号

674
00:26:29,020 --> 00:26:33,430
否则完全打印等等 

675
00:26:31,810 --> 00:26:34,720
在一天结束时不可读或

676
00:26:33,430 --> 00:26:36,670
特别是代码时不可维护

677
00:26:34,720 --> 00:26:38,830
变得复杂，但 空白 没有 

678
00:26:36,670 --> 00:26:40,390
往往对计算机很重要但它 

679
00:26:38,830 --> 00:26:42,280
没有关系 的人，当你是 

680
00:26:40,390 --> 00:26:44,210
它暗指某些语言 

681
00:26:42,280 --> 00:26:46,369
实际上常规做

682
00:26:44,210 --> 00:26:47,840
你实际上保持大括号的地方 

683
00:26:46,369 --> 00:26:50,570
在同一条线上，你的确可能 

684
00:26:47,840 --> 00:26:52,580
看课本做到这一点，以及一些 

685
00:26:50,570 --> 00:26:54,289
人们甚至 会这样做 

686
00:26:52,580 --> 00:26:56,629
长话短小的风格和问题

687
00:26:54,289 --> 00:26:57,860
cs50在课程的最早几周 

688
00:26:56,629 --> 00:26:59,779
我们要坚持每个人

689
00:26:57,860 --> 00:27:01,999
遵循相同的风格，以便 我们拥有 

690
00:26:59,779 --> 00:27:03,499
一些比较的基础， 但最终 

691
00:27:01,999 --> 00:27:04,789
这是 喜欢的东西 

692
00:27:03,499 --> 00:27:07,039
你自己的英文 写作或其他什么 

693
00:27:04,789 --> 00:27:08,869
你倾向于写的语言

694
00:27:07,039 --> 00:27:11,600
你自己的风格或语言 

695
00:27:08,869 --> 00:27:23,450
它的天赋代码也有其他 

696
00:27:11,600 --> 00:27:25,580
问题是什么时候真的好问题 

697
00:27:23,450 --> 00:27:27,350
你声明一个变量创建一个变量 

698
00:27:25,580 --> 00:27:28,879
你必须把它设置得相等吗？ 

699
00:27:27,350 --> 00:27:30,710
马上回答简短的回答没有 

700
00:27:28,879 --> 00:27:32,240
我们之前会看到这方面的例子 

701
00:27:30,710 --> 00:27:34,700
很久你可以说给我 

702
00:27:32,240 --> 00:27:36,139
给我一个 名为counter 的变量 但是 

703
00:27:34,700 --> 00:27:38,809
实际上并不等于某些 

704
00:27:36,139 --> 00:27:40,519
价值 又回到了一点 

705
00:27:38,809 --> 00:27:42,590
正确的 ，所以如果我们要 添加这个 东西 

706
00:27:40,519 --> 00:27:44,869
坦率而且从头开始 

707
00:27:42,590 --> 00:27:46,580
看起来有点压倒性但是这个 

708
00:27:44,869 --> 00:27:50,179
仅仅是一个 岔路口 ，如果 三路 

709
00:27:46,580 --> 00:27:54,470
如果X是X，则 X 小于 Y 

710
00:27:50,179 --> 00:27:57,110
如果x等于y，则 大于Y表示否则 

711
00:27:54,470 --> 00:27:58,759
然后继续前进，并 说他们是平等的 ， 

712
00:27:57,110 --> 00:28:00,769
在C中我们可以做到这一点 

713
00:27:58,759 --> 00:28:02,720
翻译很直接，以及在 

714
00:28:00,769 --> 00:28:05,600
事实上现在的前八 行代码 

715
00:28:02,720 --> 00:28:07,429
是相同的，除了之前这 

716
00:28:05,600 --> 00:28:09,049
在这里，我正在添加一个

717
00:28:07,429 --> 00:28:11,629
第二个布尔表达式是X 更大 

718
00:28:09,049 --> 00:28:14,840
比Y 然后我有第三个 

719
00:28:11,629 --> 00:28:17,299
条件否则如果x 等于y但在那里 

720
00:28:14,840 --> 00:28:20,090
似乎也许是一个错字或其他东西 

721
00:28:17,299 --> 00:28:24,110
异常在这里做任何事都会跳出来 

722
00:28:20,090 --> 00:28:26,090
是的，你有一个双 等号 

723
00:28:24,110 --> 00:28:27,740
这可能只是一个排版 

724
00:28:26,090 --> 00:28:31,129
我的错误但事实证明并非如此 

725
00:28:27,740 --> 00:28:32,450
这 是故意的，但为什么会这样 

726
00:28:31,129 --> 00:28:34,070
比如我们的第一个例子 

727
00:28:32,450 --> 00:28:36,639
划痕对于fect lee并不重要

728
00:28:34,070 --> 00:28:36,639
看是的

729
00:28:40,320 --> 00:28:45,970
我们刚刚决定了

730
00:28:43,029 --> 00:28:47,649
正如人类 真正 多年前一样平等 

731
00:28:45,970 --> 00:28:49,480
实际上在C的背景下

732
00:28:47,649 --> 00:28:51,490
赋值从 右边 复制值 

733
00:28:49,480 --> 00:28:53,230
到左边的值，所以我们很友好 

734
00:28:51,490 --> 00:28:55,090
把 自己 画 成一个角落我们 

735
00:28:53,230 --> 00:28:56,260
仍然像程序员想要的那样 

736
00:28:55,090 --> 00:28:58,630
能够表达 的概念 

737
00:28:56,260 --> 00:28:59,919
平等和比较，但如果我们

738
00:28:58,630 --> 00:29:02,139
已经使用了等号 

739
00:28:59,919 --> 00:29:04,330
我们需要另一种模式

740
00:29:02,139 --> 00:29:06,309
代表 平等的符号和它 

741
00:29:04,330 --> 00:29:08,710
原来人类只选择了两个相等的 

742
00:29:06,309 --> 00:29:10,360
标志反而略有不同 

743
00:29:08,710 --> 00:29:11,710
划伤最近的划痕这样做

744
00:29:10,360 --> 00:29:13,330
方式是因为你真的不想 

745
00:29:11,710 --> 00:29:14,649
必须要进入那些杂草 

746
00:29:13,330 --> 00:29:15,700
当你了解目标受众时

747
00:29:14,649 --> 00:29:17,440
八岁的孩子正在学习 编程 

748
00:29:15,700 --> 00:29:19,120
首先，它并不重要 

749
00:29:17,440 --> 00:29:21,750
它对我们来说也不是很重要

750
00:29:19,120 --> 00:29:24,309
对我们来说， 这将是合乎逻辑的 

751
00:29:21,750 --> 00:29:25,690
距离， 因为如果我们使用错误的 

752
00:29:24,309 --> 00:29:27,250
行为将 是 错误的，如果 我们 

753
00:29:25,690 --> 00:29:29,470
我们只有一个相同的标志 

754
00:29:27,250 --> 00:29:32,350
字面意思是将X改为等于Y. 

755
00:29:29,470 --> 00:29:40,870
而不仅仅是比较它是怎么回事 

756
00:29:32,350 --> 00:29:42,399
他们的手在这里是的好问题， 如果 

757
00:29:40,870 --> 00:29:44,289
你想表达大于或

758
00:29:42,399 --> 00:29:46,330
等于 你做了多少才转过来 

759
00:29:44,289 --> 00:29:48,190
有 办法做到 这一点，如果我 

760
00:29:46,330 --> 00:29:50,350
继续前进 ， 给自己一些地方 

761
00:29:48,190 --> 00:29:54,130
你可以 在这里画 一会儿 

762
00:29:50,350 --> 00:29:56,380
实际上确实做得少于或等于或 

763
00:29:54,130 --> 00:29:58,330
大于或 等于没有办法 

764
00:29:56,380 --> 00:29:59,620
一个典型的键盘，将它们放在每个上面 

765
00:29:58,330 --> 00:30:00,850
其他就像你可能 从数学中 回忆一下 

766
00:29:59,620 --> 00:30:06,639
类，所以 你只要把它们并排 

767
00:30:00,850 --> 00:30:08,289
其他 井取决于我想要的 

768
00:30:06,639 --> 00:30:11,980
等于这里的双等号

769
00:30:08,289 --> 00:30:15,070
因为我想明确检查一下 

770
00:30:11,980 --> 00:30:17,139
第三种情况并说X等于Y所以 

771
00:30:15,070 --> 00:30:18,639
这是我的 目标，但幸运的是，这不是 

772
00:30:17,139 --> 00:30:21,610
必要的权利让我们制定一个程序 

773
00:30:18,639 --> 00:30:23,799
更好的设计有多少可能 

774
00:30:21,610 --> 00:30:27,130
在比较两个案例时有案例

775
00:30:23,799 --> 00:30:29,710
整数x和 y 大于更 小 

776
00:30:27,130 --> 00:30:32,710
小于或平等 可我只回答 

777
00:30:29,710 --> 00:30:35,080
今晚的问题是有 三个 

778
00:30:32,710 --> 00:30:37,149
X 有三种 情况 

779
00:30:35,080 --> 00:30:39,370
小于或大于或 

780
00:30:37,149 --> 00:30:44,230
等于，我很难 思考 

781
00:30:39,370 --> 00:30:47,710
第四，这样我需要这个量 

782
00:30:44,230 --> 00:30:49,690
特殊性我能做些什么来给予 

783
00:30:47,710 --> 00:30:51,070
我自己略微优化改进了

784
00:30:49,690 --> 00:30:52,480
代码只是为了节省一点点

785
00:30:51,070 --> 00:30:53,170
我自己的一点点 时间写它 

786
00:30:52,480 --> 00:30:54,850
有可能 

787
00:30:53,170 --> 00:30:57,430
在电脑上运行一段时间 

788
00:30:54,850 --> 00:30:58,780
是的，我不需要最后一个 

789
00:30:57,430 --> 00:31:00,790
因为如果我们都同意的话 

790
00:30:58,780 --> 00:31:03,850
从逻辑上讲， X小于Y. 

791
00:31:00,790 --> 00:31:05,530
或大于Y或 可能 等于Y. 

792
00:31:03,850 --> 00:31:07,240
好吧，如果只有第三个和最后一个 

793
00:31:05,530 --> 00:31:09,010
可能只是我 所谓的其他情况 

794
00:31:07,240 --> 00:31:11,770
只是让那就是 所谓的默认 

795
00:31:09,010 --> 00:31:13,060
案件， 事实上 即使这样 

796
00:31:11,770 --> 00:31:15,010
大多数人 会 称之为结束 

797
00:31:13,060 --> 00:31:17,290
优化您正在保存计算机

798
00:31:15,010 --> 00:31:19,330
一段时间，因为假设X确实在

799
00:31:17,290 --> 00:31:22,870
事实上等于Y，它们都是 价值 

800
00:31:19,330 --> 00:31:25,510
号1，因此是 大于 1时这个 少1 

801
00:31:22,870 --> 00:31:27,970
行代码被 执行 真实的 或将是 

802
00:31:25,510 --> 00:31:30,160
或者不，不， 显然不是 1不少 

803
00:31:27,970 --> 00:31:32,050
超过1所以这个代码不会执行 但是 

804
00:31:30,160 --> 00:31:34,060
布尔表达式是这样评估的 

805
00:31:32,050 --> 00:31:34,950
要问的问题是1 

806
00:31:34,060 --> 00:31:38,170
大于 1 

807
00:31:34,950 --> 00:31:39,790
不，所以这段代码 没有被执行但是 

808
00:31:38,170 --> 00:31:42,010
这个布尔表达式是我们的 

809
00:31:39,790 --> 00:31:44,410
花 了一步或两秒或其他什么 

810
00:31:42,010 --> 00:31:47,560
然而，计算机的速度是 1 

811
00:31:44,410 --> 00:31:49,000
到1是的， 这实际上是打印的 

812
00:31:47,560 --> 00:31:50,530
但是到了你的观点，你不需要问 

813
00:31:49,000 --> 00:31:53,200
这个 问题， 事实上你只是 

814
00:31:50,530 --> 00:31:55,180
增加 了50％的数量 

815
00:31:53,200 --> 00:31:57,220
你问的问题，所以你只是 

816
00:31:55,180 --> 00:31:59,320
浪费一点点时间现在 为 

817
00:31:57,220 --> 00:32:00,520
除了Mac，PC和手机这些 

818
00:31:59,320 --> 00:32:02,590
天我的意思是他们再次操作它 

819
00:32:00,520 --> 00:32:05,530
像千兆赫速度10亿的东西 

820
00:32:02,590 --> 00:32:07,030
每秒钟，所以在实践中谁在乎 

821
00:32:05,530 --> 00:32:08,530
你问第三个问题和 

822
00:32:07,030 --> 00:32:11,320
坦率地说， 如果它使你的代码更多 

823
00:32:08,530 --> 00:32:13,060
可读或您的教学研究员或 

824
00:32:11,320 --> 00:32:14,650
对于正在工作的同事或朋友 

825
00:32:13,060 --> 00:32:16,360
在你的节目上，那 很棒 

826
00:32:14,650 --> 00:32:18,430
如果从代码中更清楚的是什么

827
00:32:16,360 --> 00:32:20,410
继续这样离开，但这些都是 

828
00:32:18,430 --> 00:32:22,900
我们将 做出的各种设计决策 

829
00:32:20,410 --> 00:32:24,430
知道我制作并且可以说是 这个版本的 

830
00:32:22,900 --> 00:32:26,080
临时程序和这个 版本 的 

831
00:32:24,430 --> 00:32:28,090
C代码稍微好一些 

832
00:32:26,080 --> 00:32:30,130
设计因为正确为什么要写更多代码 

833
00:32:28,090 --> 00:32:33,310
比你需要表达的确切 

834
00:32:30,130 --> 00:32:35,890
同样的想法没事 所以你看 这个 

835
00:32:33,310 --> 00:32:37,240
这是一个循环，这是一个 

836
00:32:35,890 --> 00:32:39,430
无限循环， 因为 它 只是 

837
00:32:37,240 --> 00:32:41,740
永远 在C中 说你好 世界 

838
00:32:39,430 --> 00:32:43,630
得到一点点直接翻译 

839
00:32:41,740 --> 00:32:46,450
事实证明，C使用关键词 

840
00:32:43,630 --> 00:32:48,460
所以在C中没有永远的关键字但是 

841
00:32:46,450 --> 00:32:50,860
当然还有这个词

842
00:32:48,460 --> 00:32:52,450
我要用我的花括号 做coor 

843
00:32:50,860 --> 00:32:54,340
大括号大括号来样 

844
00:32:52,450 --> 00:32:56,260
包含以下代码行

845
00:32:54,340 --> 00:32:57,940
它想要的代码行 

846
00:32:56,260 --> 00:33:00,250
只是另一个printf， 所以这是确切的 

847
00:32:57,940 --> 00:33:02,320
和以前一样，但还不够 

848
00:33:00,250 --> 00:33:05,050
只是 说，而事实证明， 

849
00:33:02,320 --> 00:33:06,490
虽然希望你问一个问题 

850
00:33:05,050 --> 00:33:08,440
每一次

851
00:33:06,490 --> 00:33:10,390
循环执行 ，它会检查 

852
00:33:08,440 --> 00:33:11,920
问题，如果答案是肯定的， 那就是 

853
00:33:10,390 --> 00:33:15,220
要运行循环， 但如果 答案 

854
00:33:11,920 --> 00:33:17,230
在C中被问到是永远没有或是错误的 

855
00:33:15,220 --> 00:33:18,760
它不会执行 代码和 

856
00:33:17,230 --> 00:33:20,920
我们将继续前进 

857
00:33:18,760 --> 00:33:22,450
行代码下向下在文件中，以便 

858
00:33:20,920 --> 00:33:24,190
在C你实际上需要一对

859
00:33:22,450 --> 00:33:27,040
关键字 while和 后面的括号 

860
00:33:24,190 --> 00:33:29,650
那么你需要问一个你需要的问题 

861
00:33:27,040 --> 00:33:31,570
问一个像X小于Y的问题 

862
00:33:29,650 --> 00:33:34,179
或类似的问题是X大于Y. 

863
00:33:31,570 --> 00:33:36,220
或者X等于Y但不是那些 

864
00:33:34,179 --> 00:33:37,660
场景适用因为整体 

865
00:33:36,220 --> 00:33:40,240
这个临时块的目的是 

866
00:33:37,660 --> 00:33:43,120
从字面上做一些事情永远这样 

867
00:33:40,240 --> 00:33:48,130
什么是问题，我们可能会 问 到 

868
00:33:43,120 --> 00:33:49,450
一个人平等 ，答案肯定是正确的 

869
00:33:48,130 --> 00:33:51,250
我们可以设计一个 

870
00:33:49,450 --> 00:33:52,809
任意但非常数学 

871
00:33:51,250 --> 00:33:55,150
我们可以说的正确方案

872
00:33:52,809 --> 00:33:57,340
一个相等的一个，但事实 证明你 

873
00:33:55,150 --> 00:33:59,740
可以 更加简洁因为在C 

874
00:33:57,340 --> 00:34:02,170
其中一个关键词就是其中之一 

875
00:33:59,740 --> 00:34:04,660
是真的，其中一个是虚假的 

876
00:34:02,170 --> 00:34:06,040
单词true 根据定义始终为真 

877
00:34:04,660 --> 00:34:07,480
而“假”这个词就是 定义 

878
00:34:06,040 --> 00:34:09,700
总是假的， 所以你不需要 

879
00:34:07,480 --> 00:34:12,250
设想一些任意但正确的想法 

880
00:34:09,700 --> 00:34:14,230
喜欢做一个等于 一个或做 

881
00:34:12,250 --> 00:34:16,060
50等于等于50你不需要 

882
00:34:14,230 --> 00:34:18,879
想出 一些随意的解决方案 

883
00:34:16,060 --> 00:34:21,369
真的可以说是真的，因为那样 

884
00:34:18,879 --> 00:34:22,990
关键字true永远不会改变值甚至是 

885
00:34:21,369 --> 00:34:25,119
虽然这 看起来有点奇怪 

886
00:34:22,990 --> 00:34:27,879
这是你如何诱导某些事情 发生的 

887
00:34:25,119 --> 00:34:29,470
你 永远 再次 问同样的问题 

888
00:34:27,879 --> 00:34:31,540
并假设问题始终存在 

889
00:34:29,470 --> 00:34:37,409
有任何相同的答案 

890
00:34:31,540 --> 00:34:37,409
关于那一个的问题是的，然后回来 

891
00:34:39,919 --> 00:34:45,570
好的问题，空间很重要 

892
00:34:43,290 --> 00:34:48,149
回答否， 在这种情况下你可以添加 

893
00:34:45,570 --> 00:34:49,560
其实导致所有的空间 在这里 

894
00:34:48,149 --> 00:34:51,330
除了一个 在英文词组 

895
00:34:49,560 --> 00:34:53,880
它仍然是功能性的

896
00:34:51,330 --> 00:34:55,440
更正你甚至可以在任何地方添加空格 

897
00:34:53,880 --> 00:34:56,850
你希望你可以让这个更高 

898
00:34:55,440 --> 00:34:59,130
点击进入 一堆时间 标签 

899
00:34:56,850 --> 00:35:00,960
这个词周围的空间是真实 的 

900
00:34:59,130 --> 00:35:02,640
这些例子今天都在这里展示，你会 

901
00:35:00,960 --> 00:35:04,320
在未来 几周看到的是那种 

902
00:35:02,640 --> 00:35:05,910
更好的做事方式， 因为他们是 

903
00:35:04,320 --> 00:35:07,050
更可读，但随着你的更多 

904
00:35:05,910 --> 00:35:08,460
舒适的代码或如果你 

905
00:35:07,050 --> 00:35:09,810
有 一些先前的经验你来 

906
00:35:08,460 --> 00:35:11,700
可能已经有了自己的意见 和 

907
00:35:09,810 --> 00:35:13,440
坦率地说， 这只是一场宗教辩论 

908
00:35:11,700 --> 00:35:15,150
在程序员中这是正确的方式

909
00:35:13,440 --> 00:35:16,260
编写你的代码，这很好 

910
00:35:15,150 --> 00:35:18,120
只要你这样，你就会舒服

911
00:35:16,260 --> 00:35:19,620
一致是最重要的 事情 

912
00:35:18,120 --> 00:35:21,690
你不需要坚持一个人的 

913
00:35:19,620 --> 00:35:23,400
或者其他如此代码如何工作 

914
00:35:21,690 --> 00:35:25,410
在逻辑上第一件事 

915
00:35:23,400 --> 00:35:26,730
计算机你的Mac 或PC 或手机 或 

916
00:35:25,410 --> 00:35:29,310
无论是打算 做它 会 

917
00:35:26,730 --> 00:35:30,810
问这个问题真的是真实的

918
00:35:29,310 --> 00:35:32,790
总是如此， 所以它将 继续 

919
00:35:30,810 --> 00:35:34,830
执行代码行但在它之后 

920
00:35:32,790 --> 00:35:36,300
的确，因为这是 的 全部 

921
00:35:34,830 --> 00:35:37,860
代码大括号 之间 在 

922
00:35:36,300 --> 00:35:40,320
我们可以有更多的线路，这些 都只是 

923
00:35:37,860 --> 00:35:43,200
计算机将要执行的简短程序

924
00:35:40,320 --> 00:35:44,850
检查没关系是真的 仍然如此 

925
00:35:43,200 --> 00:35:46,140
它会再次 执行 它然后它 

926
00:35:44,850 --> 00:35:48,300
要问这个问题 是真的 

927
00:35:46,140 --> 00:35:50,160
仍然是的，所以它 会 执行 

928
00:35:48,300 --> 00:35:53,460
再次编码，这 将重复 

929
00:35:50,160 --> 00:35:54,750
字面上永远， 但如果你不这样做 

930
00:35:53,460 --> 00:35:56,640
想要永远重复一些事情

931
00:35:54,750 --> 00:35:58,140
如果你 只想重复 它50 怎么办？ 

932
00:35:56,640 --> 00:36:00,090
时间划痕不会让你思考 

933
00:35:58,140 --> 00:36:02,970
很难了解这个它 只是图 

934
00:36:00,090 --> 00:36:04,440
如何跟踪 1把2 3 4 5它 

935
00:36:02,970 --> 00:36:06,270
一直到50 然后停止 

936
00:36:04,440 --> 00:36:09,210
这很好它可以很容易地 使用 

937
00:36:06,270 --> 00:36:12,000
块见，很多语言 都没有 

938
00:36:09,210 --> 00:36:13,290
想象中 的那么用户友好，你会看到 

939
00:36:12,000 --> 00:36:15,240
后来在学期那个更新 

940
00:36:13,290 --> 00:36:17,700
语言更接近于什么 

941
00:36:15,240 --> 00:36:19,110
划痕提供但在C中我们需要 

942
00:36:17,700 --> 00:36:20,100
更明确，但这是一个机会 

943
00:36:19,110 --> 00:36:22,680
使用 其中一些 更原始的 

944
00:36:20,100 --> 00:36:24,960
在C中构建块相当于 

945
00:36:22,680 --> 00:36:28,950
重复将成为介词

946
00:36:24,960 --> 00:36:31,020
仅仅是因为现在和 刚刚 

947
00:36:28,950 --> 00:36:32,850
像以前一样，如果我们想 做某事 

948
00:36:31,020 --> 00:36:34,470
我们在这个循环中一次又一次地 

949
00:36:32,850 --> 00:36:36,780
要使用类似的花括号

950
00:36:34,470 --> 00:36:38,610
小橙块那里，然后 

951
00:36:36,780 --> 00:36:41,190
我该怎么办我会这样做的

952
00:36:38,610 --> 00:36:43,410
每次 50 次希望打印出来 

953
00:36:41,190 --> 00:36:45,840
你好世界 所以现在我只需要 想象 

954
00:36:43,410 --> 00:36:48,780
出来，看看如何表达的数量 

955
00:36:45,840 --> 00:36:51,120
倍具体50，使其变为出 

956
00:36:48,780 --> 00:36:51,680
C 你 再次 使用括号 

957
00:36:51,120 --> 00:36:53,070
会变得非常普遍 

958
00:36:51,680 --> 00:36:54,720
很多的特点

959
00:36:53,070 --> 00:36:57,000
代码的功能重写和 

960
00:36:54,720 --> 00:36:58,650
那么你需要做三件事

961
00:36:57,000 --> 00:37:01,500
负担现在将在我们身上

962
00:36:58,650 --> 00:37:04,590
程序员要跟踪 多少 

963
00:37:01,500 --> 00:37:06,630
有时 ，我们要 执行这个代码 -如何 

964
00:37:04,590 --> 00:37:08,670
很多 时候我们 已经执行了 这个 

965
00:37:06,630 --> 00:37:10,590
代码，然后不断确保 

966
00:37:08,670 --> 00:37:13,230
一个不 超过 另一个所以我们停止 

967
00:37:10,590 --> 00:37:15,390
一旦我们达到50，那就是那种 

968
00:37:13,230 --> 00:37:18,870
我们用来保持的基本合同

969
00:37:15,390 --> 00:37:20,700
轨道的任何 一个程序计数器 

970
00:37:18,870 --> 00:37:22,380
这是一个变量的例子，所以我们 

971
00:37:20,700 --> 00:37:23,970
只是现在 需要 使用一个变量 是 

972
00:37:22,380 --> 00:37:25,530
实际上会 在里面 

973
00:37:23,970 --> 00:37:27,570
这次括号所以它 不在它上面 

974
00:37:25,530 --> 00:37:29,370
我们拥有它只是在不久 之前， 但是 

975
00:37:27,570 --> 00:37:31,080
语法是 一样的 ，我可以 把它 

976
00:37:29,370 --> 00:37:32,910
反击， 但现实是 它 

977
00:37:31,080 --> 00:37:34,620
编程中的惯例就是使用 

978
00:37:32,910 --> 00:37:35,880
你刚刚做的时候变量较短

979
00:37:34,620 --> 00:37:38,550
一些 世俗的 东西 ，如果你只是 

980
00:37:35,880 --> 00:37:40,590
做是循环 我代表整数是 

981
00:37:38,550 --> 00:37:42,060
许多程序员都会变量 

982
00:37:40,590 --> 00:37:43,680
名字而不是更冗长 但是 

983
00:37:42,060 --> 00:37:45,870
正确的反击或其他 

984
00:37:43,680 --> 00:37:49,020
所以这说嘿电脑给我一个 

985
00:37:45,870 --> 00:37:51,870
变量调用 我让我存储整数 

986
00:37:49,020 --> 00:37:54,570
或者在其中设置 intz 并设置初始 值 

987
00:37:51,870 --> 00:37:56,460
0 以及为什么几乎所有人都在这 

988
00:37:54,570 --> 00:37:58,230
房间可能从一开始计算 

989
00:37:56,460 --> 00:38:00,570
电脑只是倾向于汽车启动 

990
00:37:58,230 --> 00:38:01,950
从零开始计算， 但 为什么是这样的 

991
00:38:00,570 --> 00:38:07,470
开始计算的理由

992
00:38:01,950 --> 00:38:08,910
零可能基于上周为什么 

993
00:38:07,470 --> 00:38:14,430
那种 有道理的看你是 什么 

994
00:38:08,910 --> 00:38:15,630
我想是的，这只是一个而且 

995
00:38:14,430 --> 00:38:17,250
零和 喜欢最小的 

996
00:38:15,630 --> 00:38:18,780
数字负值决定你 

997
00:38:17,250 --> 00:38:21,570
可以用二进制表示它只是

998
00:38:18,780 --> 00:38:23,910
零零零一堆零 ，为什么呢 

999
00:38:21,570 --> 00:38:25,410
你会浪费那种代表吗？ 

1000
00:38:23,910 --> 00:38:27,690
比特的排列让我们刚刚开始 

1001
00:38:25,410 --> 00:38:30,210
在零处计数然后再添加到那 

1002
00:38:27,690 --> 00:38:31,950
你可以 从 安全的一个 开始 计数 

1003
00:38:30,210 --> 00:38:33,480
但大多数语言的惯例是

1004
00:38:31,950 --> 00:38:35,040
从零开始算，所以我们就可以了 

1005
00:38:33,480 --> 00:38:37,770
脚也是，你甚至可以回想起来 

1006
00:38:35,040 --> 00:38:39,150
在我们的 PBJ花生代码中 

1007
00:38:37,770 --> 00:38:42,000
黄油和 果冻口足够了 

1008
00:38:39,150 --> 00:38:43,680
用于电话簿的PBJ代码 

1009
00:38:42,000 --> 00:38:45,390
伪代码 我其实 故意 

1010
00:38:43,680 --> 00:38:48,090
开始将行从 零编号到 

1011
00:38:45,390 --> 00:38:49,740
因为同样的直觉所以 一 到 两个 

1012
00:38:48,090 --> 00:38:52,230
这是你怎么对电脑说的

1013
00:38:49,740 --> 00:38:54,060
检查你是否会减少

1014
00:38:52,230 --> 00:38:55,380
现在已经 超过 五十，显然 

1015
00:38:54,060 --> 00:38:57,360
将小于 50， 因为 0 更少 

1016
00:38:55,380 --> 00:38:59,340
50但相同的条件下 会 

1017
00:38:57,360 --> 00:39:01,860
一次又一次地检查 

1018
00:38:59,340 --> 00:39:05,520
这个循环执行然后从中回忆

1019
00:39:01,860 --> 00:39:06,760
在我们可以加上加一个变量之前 

1020
00:39:05,520 --> 00:39:08,890
我们可以添加一个 

1021
00:39:06,760 --> 00:39:11,470
我们可以说， 我们 更详细 

1022
00:39:08,890 --> 00:39:13,930
我等于我加 一，但它只是更多 

1023
00:39:11,470 --> 00:39:15,940
常规写I加上 刚才 

1024
00:39:13,930 --> 00:39:17,710
更 简洁地说同样的事情 

1025
00:39:15,940 --> 00:39:18,880
接下来发生的事情在逻辑上是这样的 

1026
00:39:17,710 --> 00:39:21,940
代码我写了什么电脑 

1027
00:39:18,880 --> 00:39:23,980
做得好，它 把 我 初始化 为零 

1028
00:39:21,940 --> 00:39:26,140
并准备 将整数存储在 其中 

1029
00:39:23,980 --> 00:39:27,760
检查条件以防你 

1030
00:39:26,140 --> 00:39:29,140
将它初始化为太大的值 

1031
00:39:27,760 --> 00:39:31,540
可能 不希望循环执行 

1032
00:39:29,140 --> 00:39:34,600
除了明显为零 之外，其余都不 到50 

1033
00:39:31,540 --> 00:39:37,260
所以这行代码执行需要一个

1034
00:39:34,600 --> 00:39:39,670
猜猜接下来会发生什么 

1035
00:39:37,260 --> 00:39:41,500
是的你可能想做 我加上加号 

1036
00:39:39,670 --> 00:39:43,000
因为你已经完成了 所有的执行 

1037
00:39:41,500 --> 00:39:44,710
卷曲之间的代码行

1038
00:39:43,000 --> 00:39:46,420
牙套即使只是一个如此 

1039
00:39:44,710 --> 00:39:49,330
让我们继续增加我，所以我是 

1040
00:39:46,420 --> 00:39:52,570
现在1让我们现在确保比1少1 

1041
00:39:49,330 --> 00:39:56,140
50显然执行代码I plus 

1042
00:39:52,570 --> 00:39:58,990
加是2小于 50 明显执行 

1043
00:39:56,140 --> 00:40:01,600
代码I plus plus 是3小于 50 

1044
00:39:58,990 --> 00:40:03,640
显然现在继续 执行 

1045
00:40:01,600 --> 00:40:06,220
代码和 一次又一次 和 

1046
00:40:03,640 --> 00:40:09,840
在某些时候我们就要起床 我 

1047
00:40:06,220 --> 00:40:11,890
等于49 ，小于49 

1048
00:40:09,840 --> 00:40:15,460
显然我们打印出你好世界 

1049
00:40:11,890 --> 00:40:19,510
然后我再加上踢，然后 

1050
00:40:15,460 --> 00:40:21,130
它是小于50 50 没有那么 等待那 

1051
00:40:19,510 --> 00:40:22,600
虽然没有，但感觉像是一个逻辑 错误 

1052
00:40:21,130 --> 00:40:26,230
我应该检查一下我是不是 

1053
00:40:22,600 --> 00:40:28,030
或等于 50 耶，因为如果我开始 

1054
00:40:26,230 --> 00:40:30,040
从0 我已经花了 那一个 

1055
00:40:28,030 --> 00:40:33,430
额外的周期，所以我可以从0开始计算 

1056
00:40:30,040 --> 00:40:35,650
通过49 这似乎 工作或从1 

1057
00:40:33,430 --> 00:40:37,660
通过50但是在会议上 

1058
00:40:35,650 --> 00:40:39,220
诚实地编程通常是

1059
00:40:37,660 --> 00:40:42,430
开始计算某个值， 然后 

1060
00:40:39,220 --> 00:40:44,800
数到但 不是通过一些价值 

1061
00:40:42,430 --> 00:40:46,090
只是因为但逻辑上你可以 

1062
00:40:44,800 --> 00:40:48,730
在六个不同的实现这个 

1063
00:40:46,090 --> 00:40:50,230
方式最有可能 没事了 ，让我们来看看 

1064
00:40:48,730 --> 00:40:52,600
允许我们 进行的 最后一个 例子 

1065
00:40:50,230 --> 00:40:54,310
实际上是从头开始获取用户输入 

1066
00:40:52,600 --> 00:40:56,740
回想一下，我们使用这个块来 

1067
00:40:54,310 --> 00:40:58,570
实际上得到了某人的名字 

1068
00:40:56,740 --> 00:41:00,490
讲座，我们也在 动画 

1069
00:40:58,570 --> 00:41:02,530
与姜饼屋用它 

1070
00:41:00,490 --> 00:41:03,550
得到是或否你想要蛋糕还是蛋糕？ 

1071
00:41:02,530 --> 00:41:05,350
Apple 等 

1072
00:41:03,550 --> 00:41:08,170
所以这是一个函数的例子 

1073
00:41:05,350 --> 00:41:09,610
实际上需要输入的划痕

1074
00:41:08,170 --> 00:41:12,520
这个句子叫什么名字 

1075
00:41:09,610 --> 00:41:14,230
但它也返回一个值

1076
00:41:12,520 --> 00:41:16,210
这个案子 只是 在头上 硬编码 

1077
00:41:14,230 --> 00:41:18,070
麻省理工学院被称为答案，所以它就像

1078
00:41:16,210 --> 00:41:20,480
一个叫做答案的特殊变量 但是 

1079
00:41:18,070 --> 00:41:23,180
实际上它被交还给了 

1080
00:41:20,480 --> 00:41:26,420
用户因此我们如何 看待这个 在 

1081
00:41:23,180 --> 00:41:28,010
事实 证明你可以表达这一点 

1082
00:41:26,420 --> 00:41:29,780
代码行多一点幽灵 

1083
00:41:28,010 --> 00:41:32,270
比以前使用新功能 

1084
00:41:29,780 --> 00:41:33,619
叫做 getstring， 所以得到下划线 

1085
00:41:32,270 --> 00:41:35,810
string是函数的名称

1086
00:41:33,619 --> 00:41:36,980
如果你的话，下划线是C中的约定 

1087
00:41:35,810 --> 00:41:38,660
我想拥有一个你无法拥有的空间

1088
00:41:36,980 --> 00:41:39,980
函数名称中的空格

1089
00:41:38,660 --> 00:41:42,440
人们刚开始 使用下划线 

1090
00:41:39,980 --> 00:41:43,700
就像你 自己喜欢社交一样 

1091
00:41:42,440 --> 00:41:45,140
媒体 用户名等是 

1092
00:41:43,700 --> 00:41:48,050
那里的约定

1093
00:41:45,140 --> 00:41:49,880
这是我想要显示 的 句子 

1094
00:41:48,050 --> 00:41:51,859
我 会开始更多地打电话给 我 

1095
00:41:49,880 --> 00:41:53,570
正式字符串中的字符串

1096
00:41:51,859 --> 00:41:55,280
编程语言 只是 一个序列 

1097
00:41:53,570 --> 00:41:56,990
喜欢 它 的 字符 是它的一个字 

1098
00:41:55,280 --> 00:41:58,880
短语它是一个字符，它是一个段落 

1099
00:41:56,990 --> 00:42:00,410
这 是一个双字母之间的字符串 

1100
00:41:58,880 --> 00:42:02,750
引号是C和C中的字符串

1101
00:42:00,410 --> 00:42:04,580
反斜杠n只是 行尾 

1102
00:42:02,750 --> 00:42:06,920
在我们还没有之前

1103
00:42:04,580 --> 00:42:08,930
分号但这并不 完全 是字面 

1104
00:42:06,920 --> 00:42:12,530
翻译正在 发生的 事情 

1105
00:42:08,930 --> 00:42:14,510
因为我现在也需要做点什么 

1106
00:42:12,530 --> 00:42:16,730
如果getstring是一个答案，所以答案 

1107
00:42:14,510 --> 00:42:18,890
实际上从中输入的函数

1108
00:42:16,730 --> 00:42:21,770
用户 只需 通过他或她的键盘 

1109
00:42:18,890 --> 00:42:23,450
就像C中的蓝色块一样

1110
00:42:21,770 --> 00:42:26,119
需要更 明确一点

1111
00:42:23,450 --> 00:42:27,680
我们在哪里放回值 

1112
00:42:26,119 --> 00:42:30,530
从那个功能来看它是什么 

1113
00:42:27,680 --> 00:42:32,119
交还，所以我可以存储在一个 

1114
00:42:30,530 --> 00:42:34,130
变量叫做 答案，我可以 称之为 

1115
00:42:32,119 --> 00:42:36,800
我想要的 只是为了保持一致 

1116
00:42:34,130 --> 00:42:39,260
会划伤让我们称之为答案但是 

1117
00:42:36,800 --> 00:42:41,750
回想一下我们要做什么和看到什么 

1118
00:42:39,260 --> 00:42:45,050
我们随时创建一个变量 ， 我们必须 

1119
00:42:41,750 --> 00:42:46,609
更确切， 如果我们必须 

1120
00:42:45,050 --> 00:42:48,140
定义它所以让我 称之为类型或 

1121
00:42:46,609 --> 00:42:50,180
如果你参加了以前的课程

1122
00:42:48,140 --> 00:42:51,859
分类它的类型， 它不会 

1123
00:42:50,180 --> 00:42:53,510
一个int 因为可能是单词 

1124
00:42:51,859 --> 00:42:55,010
在打字或没有数字这会是 

1125
00:42:53,510 --> 00:42:57,740
这次我称之为字符串 

1126
00:42:55,010 --> 00:42:59,540
所以事实上 ，我们将宣布 

1127
00:42:57,740 --> 00:43:02,680
左边的变量说给我一个 

1128
00:42:59,540 --> 00:43:04,760
字符串称它为答案并分配给它 

1129
00:43:02,680 --> 00:43:06,260
什么是正确的 井什么是什么 

1130
00:43:04,760 --> 00:43:08,510
右边的权利是 

1131
00:43:06,260 --> 00:43:10,670
无论这个函数 得到字符串 来 

1132
00:43:08,510 --> 00:43:15,440
返回并 从右到右 存储 

1133
00:43:10,670 --> 00:43:17,900
离开让 我怎么现在说这个人的 

1134
00:43:15,440 --> 00:43:19,550
我只是说出来并且说得好 

1135
00:43:17,900 --> 00:43:21,619
然后我拖放答案变量 

1136
00:43:19,550 --> 00:43:22,940
结束是完成 C中 的 功能 

1137
00:43:21,619 --> 00:43:25,730
有了它我们可以说某 知道 

1138
00:43:22,940 --> 00:43:26,960
屏幕是啊所以printf 打印一个 

1139
00:43:25,730 --> 00:43:28,760
格式化字符串， 即使 我们没有 

1140
00:43:26,960 --> 00:43:32,690
真的看到 它到现在为止的格式化 

1141
00:43:28,760 --> 00:43:34,070
事实证明，你必须要实际 

1142
00:43:32,690 --> 00:43:37,270
告诉打印

1143
00:43:34,070 --> 00:43:40,250
如果你没有通过硬编码 

1144
00:43:37,270 --> 00:43:43,010
你必须传递的 字符串或句子 

1145
00:43:40,250 --> 00:43:46,700
printf 调用格式代码或 

1146
00:43:43,010 --> 00:43:48,440
format string 这 是printf的 第一个输入 

1147
00:43:46,700 --> 00:43:50,690
现在printf显然似乎需要两个

1148
00:43:48,440 --> 00:43:52,730
第一件事就是这之前 的事情

1149
00:43:50,690 --> 00:43:54,470
逗号第二个是后面的东西 

1150
00:43:52,730 --> 00:43:57,800
常见的我们还没有见过这个但在 

1151
00:43:54,470 --> 00:44:00,820
C所以printf被告知要继续 

1152
00:43:57,800 --> 00:44:03,980
打印出一个看起来像这样的字符串 

1153
00:44:00,820 --> 00:44:05,540
％s是占位符 ，S代表 

1154
00:44:03,980 --> 00:44:07,940
对于字符串，字面上是一个

1155
00:44:05,540 --> 00:44:11,330
占位符说printf我要给 

1156
00:44:07,940 --> 00:44:13,940
你首先插入一个字符串

1157
00:44:11,330 --> 00:44:15,860
输入什么是字符串字面 

1158
00:44:13,940 --> 00:44:17,120
回答变量现在感觉就像我们一样 

1159
00:44:15,860 --> 00:44:18,350
在这里跳过篮球吧 

1160
00:44:17,120 --> 00:44:20,030
如果说printf本来会很高兴 

1161
00:44:18,350 --> 00:44:22,160
打开 括号回答关闭 

1162
00:44:20,030 --> 00:44:23,690
括号分号， 并完成 

1163
00:44:22,160 --> 00:44:25,760
它 这只是 没有办法的办法printf的作品 

1164
00:44:23,690 --> 00:44:27,080
在旧版本中你可以做到 

1165
00:44:25,760 --> 00:44:28,640
像这样 简单的东西 

1166
00:44:27,080 --> 00:44:30,440
但老实说， 我们通常不会去 

1167
00:44:28,640 --> 00:44:31,880
要打印出正是人 

1168
00:44:30,440 --> 00:44:33,740
输入毕竟这是一种类型 

1169
00:44:31,880 --> 00:44:35,180
我正在打字 的那一刻愚蠢的例子 

1170
00:44:33,740 --> 00:44:36,620
总而言之， 你只是在说 

1171
00:44:35,180 --> 00:44:38,600
屏幕我们已经决定了 

1172
00:44:36,620 --> 00:44:40,670
那是一种跛脚它会是不错的 ，在 

1173
00:44:38,600 --> 00:44:43,340
至少有程序不只是说 

1174
00:44:40,670 --> 00:44:46,370
大卫或任何名字，但什么 

1175
00:44:43,340 --> 00:44:48,650
我们上次做过你好逗号吗？ 

1176
00:44:46,370 --> 00:44:51,470
大卫，但这似乎给了我们 

1177
00:44:48,650 --> 00:44:53,360
那个能力就在我现在 

1178
00:44:51,470 --> 00:44:56,450
字面上只是打印出人类的 

1179
00:44:53,360 --> 00:44:58,190
C中的名字， 但让我改变这一点 

1180
00:44:56,450 --> 00:45:01,850
就像我们在头上做的那样 

1181
00:44:58,190 --> 00:45:04,460
回想一下，在C中我们做了这个绿色块 

1182
00:45:01,850 --> 00:45:06,710
加入的地方，我真的得到了加入 

1183
00:45:04,460 --> 00:45:09,470
两个论点 ，第 一个是你好 

1184
00:45:06,710 --> 00:45:11,030
逗号空间第二个是答案 

1185
00:45:09,470 --> 00:45:13,610
这个连接结合起来 

1186
00:45:11,030 --> 00:45:16,250
在C中 背靠背那两个字符串 

1187
00:45:13,610 --> 00:45:17,950
感谢printf， 我们也可以这样做 

1188
00:45:16,250 --> 00:45:21,410
这只是 一种不同的语法 

1189
00:45:17,950 --> 00:45:23,750
printf仍然首先获得一个参数 

1190
00:45:21,410 --> 00:45:26,450
这是您要格式化的字符串 

1191
00:45:23,750 --> 00:45:28,610
打印出f中的F， 但这次我是 

1192
00:45:26,450 --> 00:45:34,040
打算 直接说出你好的逗号 

1193
00:45:28,610 --> 00:45:35,840
空格％ s4字符串然后打印出来 

1194
00:45:34,040 --> 00:45:37,370
第二个论点就是 它 

1195
00:45:35,840 --> 00:45:39,740
指示继续并插入 

1196
00:45:37,370 --> 00:45:44,000
无论这个变量是什么 

1197
00:45:39,740 --> 00:45:45,800
这个占位符是，所以我们在这里 

1198
00:45:44,000 --> 00:45:47,480
现在有效地加入了两个字符串 

1199
00:45:45,800 --> 00:45:51,890
因此是

1200
00:45:47,480 --> 00:45:59,270
出生在一个我们的第一个格式化字符串的任何 

1201
00:45:51,890 --> 00:46:01,339
那么问题就是如果你

1202
00:45:59,270 --> 00:46:02,900
想跟你说些额外的 话 

1203
00:46:01,339 --> 00:46:04,910
当然可以继续这样的逻辑 

1204
00:46:02,900 --> 00:46:07,190
你不必结束这个引用 

1205
00:46:04,910 --> 00:46:10,190
你能说出的百分比表达式

1206
00:46:07,190 --> 00:46:12,920
你好逗号％s逗号 很高兴见到 

1207
00:46:10,190 --> 00:46:14,900
你和那个printf会做的是它

1208
00:46:12,920 --> 00:46:17,569
只会替换那个变量 

1209
00:46:14,900 --> 00:46:19,670
被称为答案的百分比s是和 

1210
00:46:17,569 --> 00:46:21,440
如果你想要 百分之 二 是你 

1211
00:46:19,670 --> 00:46:22,970
可以在这里添加另一个逗号 

1212
00:46:21,440 --> 00:46:25,010
传递另一个变量和第三个变量 

1213
00:46:22,970 --> 00:46:27,710
变量，甚至更多的格式 

1214
00:46:25,010 --> 00:46:28,430
字符串甚至更详细的问题 

1215
00:46:27,710 --> 00:46:35,390
在这里

1216
00:46:28,430 --> 00:46:36,940
其他问题是的，回来你怎么样 

1217
00:46:35,390 --> 00:46:38,660
区分

1218
00:46:36,940 --> 00:46:39,230
如果你有不同的占位符

1219
00:46:38,660 --> 00:46:41,420
变量

1220
00:46:39,230 --> 00:46:42,650
这是从左到右的排序

1221
00:46:41,420 --> 00:46:44,450
在这种情况下，这是一个微不足道的 例子 

1222
00:46:42,650 --> 00:46:46,400
因为只有一个变量和

1223
00:46:44,450 --> 00:46:47,990
一个占位符，但如果你是

1224
00:46:46,400 --> 00:46:49,790
暗示我有多重 百分比 

1225
00:46:47,990 --> 00:46:51,500
什么东西％s 

1226
00:46:49,790 --> 00:46:53,720
什么东西我会 

1227
00:46:51,500 --> 00:46:56,359
只要确保 我通过printf 

1228
00:46:53,720 --> 00:46:58,220
第一个变量逗号 是第二个变量 

1229
00:46:56,359 --> 00:47:00,410
逗号第三个变量等等 

1230
00:46:58,220 --> 00:47:06,200
从左到右的其他问题

1231
00:47:00,410 --> 00:47:07,309
是的因为我搞砸了 没有 

1232
00:47:06,200 --> 00:47:13,329
包括那个 ，我会解决它 

1233
00:47:07,309 --> 00:47:13,329
下课后很快就会发现 它是一个bug，是的 

1234
00:47:17,190 --> 00:47:22,930
确定相同的确切的事情逗号回答 逗号 

1235
00:47:20,619 --> 00:47:24,609
如果你愿意，可以用2 ％ ss回答

1236
00:47:22,930 --> 00:47:26,260
把两个相同的变量说两次

1237
00:47:24,609 --> 00:47:28,359
无论出于什么原因两个地方

1238
00:47:26,260 --> 00:47:33,390
占位符然后回答逗号 

1239
00:47:28,359 --> 00:47:33,390
回答插入其他两次快速 

1240
00:47:34,950 --> 00:47:38,349
不，我们会看到其他人 

1241
00:47:37,210 --> 00:47:40,750
只是有点它原来还有其他人 

1242
00:47:38,349 --> 00:47:42,220
它的百分比 是整数，而且是 

1243
00:47:40,750 --> 00:47:44,319
甚至 超过 百分之百 

1244
00:47:42,220 --> 00:47:45,839
看一个字符以及更多 

1245
00:47:44,319 --> 00:47:53,140
其他 问题 

1246
00:47:45,839 --> 00:47:54,940
如果我 有的 话，是的好问题 

1247
00:47:53,140 --> 00:47:56,770
正确，如果这不是PDF我 

1248
00:47:54,940 --> 00:47:58,270
如果我没有，我会在飞行中进行编辑

1249
00:47:56,770 --> 00:48:01,210
如果我想要，如果我有 

1250
00:47:58,270 --> 00:48:03,069
百分比，它总是必须 进入 

1251
00:48:01,210 --> 00:48:05,890
第一个参数中的格式化字符串

1252
00:48:03,069 --> 00:48:08,589
所以印刷后唯一的东西 

1253
00:48:05,890 --> 00:48:10,660
˚F星揆男人任选 一 辩 

1254
00:48:08,589 --> 00:48:14,890
变量来变量变量

1255
00:48:10,660 --> 00:48:17,829
逗号变量其他问题都可以 

1256
00:48:14,890 --> 00:48:19,450
所以让我们继续前进吧 

1257
00:48:17,829 --> 00:48:21,220
有代码的东西我要继续 

1258
00:48:19,450 --> 00:48:23,710
并打开 另一个 窗口，这是一个 

1259
00:48:21,220 --> 00:48:26,049
工具名为cs50 sandbox ，这是一个 

1260
00:48:23,710 --> 00:48:28,119
工具将生成网络，您可以通过它 

1261
00:48:26,049 --> 00:48:29,349
实际上玩代码， 我会展示 

1262
00:48:28,119 --> 00:48:31,150
我是如何做到这一点的 

1263
00:48:29,349 --> 00:48:33,250
特别的位置， 但让我先 

1264
00:48:31,150 --> 00:48:34,480
像我们一样解释用户界面 

1265
00:48:33,250 --> 00:48:36,160
开始我们的 谈话 

1266
00:48:34,480 --> 00:48:38,049
划伤所以我需要一个地方来编写代码 

1267
00:48:36,160 --> 00:48:40,809
现实 是我可以 使用自己的 

1268
00:48:38,049 --> 00:48:42,400
Mac我可以 坦率地 使用我 自己的电脑 

1269
00:48:40,809 --> 00:48:44,260
甚至可以使用某些移动设备 

1270
00:48:42,400 --> 00:48:46,299
这些天，但我们会有 

1271
00:48:44,260 --> 00:48:47,349
班上有数百名其他人

1272
00:48:46,299 --> 00:48:49,329
一切都略有不同 

1273
00:48:47,349 --> 00:48:51,280
他们的Mac和他们的配置

1274
00:48:49,329 --> 00:48:52,869
PC和他们的电话等等 等等 

1275
00:48:51,280 --> 00:48:54,040
每个人都会 有所不同 

1276
00:48:52,869 --> 00:48:55,690
软件和不同的设置 和那 

1277
00:48:54,040 --> 00:48:56,650
只是从来没有很好地 工作过 

1278
00:48:55,690 --> 00:48:58,359
我们 刚刚 开始 课程 

1279
00:48:56,650 --> 00:49:00,099
实际上标准化了一切 

1280
00:48:58,359 --> 00:49:02,710
使用基于Web的环境就像 

1281
00:49:00,099 --> 00:49:05,829
划痕，我们都可以访问 

1282
00:49:02,710 --> 00:49:07,809
到 完全相同的 计算机，但 

1283
00:49:05,829 --> 00:49:09,339
如果在所谓的 云中虚拟化

1284
00:49:07,809 --> 00:49:11,440
你曾经想过云是 什么 

1285
00:49:09,339 --> 00:49:12,790
它只是意味着其他人的服务器 

1286
00:49:11,440 --> 00:49:15,339
人们在互联网上的某个地方

1287
00:49:12,790 --> 00:49:17,049
可以 免费 使用 或租用 现在我 

1288
00:49:15,339 --> 00:49:19,540
必须托管这些物理服务器

1289
00:49:17,049 --> 00:49:22,150
自己这么cs50沙盒 就像 

1290
00:49:19,540 --> 00:49:24,190
scratch是一个基于云的应用程序

1291
00:49:22,150 --> 00:49:26,079
其他人写的是托管的 

1292
00:49:24,190 --> 00:49:28,000
互联网和用户界面 

1293
00:49:26,079 --> 00:49:29,970
乍一看就像这样

1294
00:49:28,000 --> 00:49:32,250
只有两个组件 它 在 

1295
00:49:29,970 --> 00:49:34,590
cs50 用户界面 的顶部 

1296
00:49:32,250 --> 00:49:36,599
沙盒只是一个代码编辑器 非常 

1297
00:49:34,590 --> 00:49:38,609
简单的文本编辑器在精神上类似 

1298
00:49:36,599 --> 00:49:40,050
Google Docs和Microsoft Word等 

1299
00:49:38,609 --> 00:49:41,790
但更简单但没有 

1300
00:49:40,050 --> 00:49:43,470
格式化没有大胆的面孔和

1301
00:49:41,790 --> 00:49:46,320
以你为中心， 你可以输入单词 

1302
00:49:43,470 --> 00:49:47,580
这里的 文字 是一个所谓的终端 

1303
00:49:46,320 --> 00:49:49,500
窗口，但我们会回到 那里 

1304
00:49:47,580 --> 00:49:51,810
只是 片刻 让 我继续写下来 

1305
00:49:49,500 --> 00:49:57,960
我的 第一个项目让我继续前进 

1306
00:49:51,810 --> 00:50:02,160
write包括标准的 i / o dot H int 

1307
00:49:57,960 --> 00:50:06,090
main void open curly brace printf你好 

1308
00:50:02,160 --> 00:50:08,970
世界反斜杠n分号 没问题 

1309
00:50:06,090 --> 00:50:11,040
现在知道这个房间里的人很少 

1310
00:50:08,970 --> 00:50:12,180
可能会打造一个父程序 

1311
00:50:11,040 --> 00:50:13,920
很快，除非你事先有 

1312
00:50:12,180 --> 00:50:15,930
背景，如果你确实服用APC或 

1313
00:50:13,920 --> 00:50:18,240
其他东西看起来有点 像Java 

1314
00:50:15,930 --> 00:50:20,550
但不完全相同，但这是我的 

1315
00:50:18,240 --> 00:50:22,440
第一个节目从现在回想前面 

1316
00:50:20,550 --> 00:50:24,480
这是我们的黑白计划 

1317
00:50:22,440 --> 00:50:26,490
不久前在幻灯片上看到了

1318
00:50:24,480 --> 00:50:28,650
即使你不太 欣赏 

1319
00:50:26,490 --> 00:50:30,420
所有时髦的语法 都在做什么 

1320
00:50:28,650 --> 00:50:32,490
我们可能 对什么 有 直觉 

1321
00:50:30,420 --> 00:50:33,780
这个程序只是打印 

1322
00:50:32,490 --> 00:50:36,150
在一天结束时说出来的话

1323
00:50:33,780 --> 00:50:38,160
你好世界， 我们将分开 

1324
00:50:36,150 --> 00:50:39,990
只是所有这些不同的线条 

1325
00:50:38,160 --> 00:50:41,490
正在做但有趣的部分是 

1326
00:50:39,990 --> 00:50:43,440
这里 以绿色突出显示的是什么

1327
00:50:41,490 --> 00:50:46,710
这只是cs50的一个特性 

1328
00:50:43,440 --> 00:50:48,720
沙箱它将颜色代码不同 

1329
00:50:46,710 --> 00:50:50,130
代码中的概念，以便 它们 

1330
00:50:48,720 --> 00:50:51,450
只是 有点跳出你的颜色 

1331
00:50:50,130 --> 00:50:54,960
实际上并不是你没有必要的 

1332
00:50:51,450 --> 00:50:56,790
颜色代码你自己做的事情

1333
00:50:54,960 --> 00:50:58,530
它会自动 显示出来 

1334
00:50:56,790 --> 00:51:00,510
不同的组件就像MIT 颜色一样 

1335
00:50:58,530 --> 00:51:04,859
EISE的 各种划痕拼图 

1336
00:51:00,510 --> 00:51:07,080
同样这是一个叫做的程序 

1337
00:51:04,859 --> 00:51:09,780
我想打个招呼它在一个文件中

1338
00:51:07,080 --> 00:51:10,920
这只是一个名为hello.c的选项卡

1339
00:51:09,780 --> 00:51:13,109
因为你写的时候结果是

1340
00:51:10,920 --> 00:51:16,260
程序在 C中 你将它保存在文件中 

1341
00:51:13,109 --> 00:51:19,950
人类惯例，无论点C如何 

1342
00:51:16,260 --> 00:51:22,680
文件扩展名可以说我喜欢什么 

1343
00:51:19,950 --> 00:51:25,680
运行这个程序 就没有绿色 

1344
00:51:22,680 --> 00:51:27,990
标记单击哪个刮痕 

1345
00:51:25,680 --> 00:51:30,720
我们如何实际 运行该程序 

1346
00:51:27,990 --> 00:51:31,800
而且 你坦率地知道 绿色 

1347
00:51:30,720 --> 00:51:33,540
国旗似乎是我的最小的 

1348
00:51:31,800 --> 00:51:35,369
关注任何语言是什么 

1349
00:51:33,540 --> 00:51:37,050
电脑了解它是否是我的Mac 

1350
00:51:35,369 --> 00:51:40,680
这里或云服务器在哪里 

1351
00:51:37,050 --> 00:51:42,210
事情是0和对，我们 

1352
00:51:40,680 --> 00:51:43,320
从那种压倒性的开始 

1353
00:51:42,210 --> 00:51:45,000
许多幻灯片

1354
00:51:43,320 --> 00:51:47,250
零和一，这就是 

1355
00:51:45,000 --> 00:51:48,480
我们 需要达到这 一点 ，但希望我们能够 

1356
00:51:47,250 --> 00:51:51,350
我们自己不必写那个 

1357
00:51:48,480 --> 00:51:54,840
乏味的水平，所以我们需要一些方法 

1358
00:51:51,350 --> 00:51:57,000
将此代码从C转换为 

1359
00:51:54,840 --> 00:51:58,950
开始调用源代码 

1360
00:51:57,000 --> 00:52:01,320
我们在 屏幕上 看到的 英文 代码 

1361
00:51:58,950 --> 00:52:03,600
这写起来有点令人愉快 

1362
00:52:01,320 --> 00:52:04,950
反对只有零和一个， 但我们 

1363
00:52:03,600 --> 00:52:07,770
但仍然需要以某种方式转换它

1364
00:52:04,950 --> 00:52:09,900
以零和的， 所以我们 能 方式 

1365
00:52:07,770 --> 00:52:13,050
如果我们这样做基本上如下 

1366
00:52:09,900 --> 00:52:15,720
有什么我们会开始称呼我们的来源 

1367
00:52:13,050 --> 00:52:18,630
可以在我们的案例中编写的代码

1368
00:52:15,720 --> 00:52:21,420
C但你可以用Java编写源代码 

1369
00:52:18,630 --> 00:52:22,890
和C ++和Python 以及其他几十个 

1370
00:52:21,420 --> 00:52:24,300
语言源代码一个通用术语

1371
00:52:22,890 --> 00:52:26,250
这只是 我们人类的代码 

1372
00:52:24,300 --> 00:52:29,190
写了我们需要一些方法 

1373
00:52:26,250 --> 00:52:30,690
将其转换为零和哪些 

1374
00:52:29,190 --> 00:52:32,430
从此以后我们就会打电话给机器

1375
00:52:30,690 --> 00:52:34,070
代码感觉像一个合理的名字 

1376
00:52:32,430 --> 00:52:36,300
它是机器的零 和 零 

1377
00:52:34,070 --> 00:52:38,280
了解机器是如何知道的 

1378
00:52:36,300 --> 00:52:39,870
什么零和要理解的好

1379
00:52:38,280 --> 00:52:42,240
这就是背后的全部理由

1380
00:52:39,870 --> 00:52:44,550
CPU中央处理单元的大脑

1381
00:52:42,240 --> 00:52:46,020
他们只是硬连线的电脑

1382
00:52:44,550 --> 00:52:47,940
工厂这么说你就知道了 

1383
00:52:46,020 --> 00:52:50,310
英特尔的 工厂了解一定 

1384
00:52:47,940 --> 00:52:52,770
零和 的 ，但问题 的模式

1385
00:52:50,310 --> 00:52:54,960
对我们来说，现在我们需要采取消息来源 

1386
00:52:52,770 --> 00:52:56,370
像C程序的代码我写了一下 

1387
00:52:54,960 --> 00:53:00,290
那之前应该打印你好 世界 

1388
00:52:56,370 --> 00:53:03,120
并以某种方式将其转换为机器代码 

1389
00:53:00,290 --> 00:53:04,890
所以事实证明这是 迈出的一步 

1390
00:53:03,120 --> 00:53:07,080
来到我们面前的人已经解决了 

1391
00:53:04,890 --> 00:53:09,030
对于我们其他人已经 写过 

1392
00:53:07,080 --> 00:53:11,700
我们即将开始的计划 

1393
00:53:09,030 --> 00:53:14,460
调用允许我们 的编译器 

1394
00:53:11,700 --> 00:53:16,110
源代码转换成 机器代码， 它是 

1395
00:53:14,460 --> 00:53:17,760
这一步只做了一步 

1396
00:53:16,110 --> 00:53:20,250
不是在划痕中存在但我们会去 

1397
00:53:17,760 --> 00:53:24,590
运行一个 通常称为a 的程序 

1398
00:53:20,250 --> 00:53:28,440
我们将 程序 传递 给as的编译器

1399
00:53:24,590 --> 00:53:30,570
输入，我们得到机器的 输出 

1400
00:53:28,440 --> 00:53:32,460
代码从而完美地带给我们 

1401
00:53:30,570 --> 00:53:34,650
围绕着计算机科学的发展方向 

1402
00:53:32,460 --> 00:53:36,540
现在编程输入的上下文

1403
00:53:34,650 --> 00:53:38,430
源代码输出机器码

1404
00:53:36,540 --> 00:53:40,200
算法或我们 的 特殊软件 

1405
00:53:38,430 --> 00:53:41,970
要在短短的时刻使用被称为 

1406
00:53:40,200 --> 00:53:43,230
只将一个转换 为的编译器

1407
00:53:41,970 --> 00:53:45,240
其他 以致我们都不得 

1408
00:53:43,230 --> 00:53:47,790
思考或写入零和一个 

1409
00:53:45,240 --> 00:53:49,710
所以这是一个 小老派你怎么做 

1410
00:53:47,790 --> 00:53:51,690
这很划清楚你明显只是打了 

1411
00:53:49,710 --> 00:53:53,910
绿旗 和麻省理工学院 以及所有这些 

1412
00:53:51,690 --> 00:53:56,239
人们为我们 照顾好了 

1413
00:53:53,910 --> 00:53:58,219
对此更加谨慎一点 

1414
00:53:56,239 --> 00:54:00,229
这就是第二部分的地方

1415
00:53:58,219 --> 00:54:02,359
cs50沙箱用户界面进入

1416
00:54:00,229 --> 00:54:04,339
播放通知我有一个闪烁的提示 

1417
00:54:02,359 --> 00:54:05,899
这里左边有一个美元符号 

1418
00:54:04,339 --> 00:54:08,719
只是美元的常见惯例

1419
00:54:05,899 --> 00:54:10,849
标志往往在这些类型的 

1420
00:54:08,719 --> 00:54:12,379
计算机代表一个提示， 这是 

1421
00:54:10,849 --> 00:54:14,059
等我 输入一些东西 

1422
00:54:12,379 --> 00:54:15,859
事实上它确实在等待着

1423
00:54:14,059 --> 00:54:18,139
对我来说， 这是一个 

1424
00:54:15,859 --> 00:54:20,419
终端窗口的例子和你的 

1425
00:54:18,139 --> 00:54:22,399
自己的Mac和你自己的电脑实际上有或

1426
00:54:20,419 --> 00:54:23,869
可以拥有这个完全相同的功能 

1427
00:54:22,399 --> 00:54:25,549
我们所有人都有同样的经营方式 

1428
00:54:23,869 --> 00:54:26,869
这些天的图形用户界面

1429
00:54:25,549 --> 00:54:28,819
我们有按钮，菜单和东西 

1430
00:54:26,869 --> 00:54:31,249
拖动并单击但在当天返回 

1431
00:54:28,819 --> 00:54:33,319
通常在编程中你 不会 

1432
00:54:31,249 --> 00:54:34,879
打扰你这些美学 

1433
00:54:33,319 --> 00:54:37,669
实际上你的手弄脏 了 

1434
00:54:34,879 --> 00:54:39,349
只是键盘单独键入任何东西 

1435
00:54:37,669 --> 00:54:41,149
你想做什么， 起初它可能会 

1436
00:54:39,349 --> 00:54:42,949
觉得自己像一个 回归一样，为什么我们 

1437
00:54:41,149 --> 00:54:45,079
为什么 我们放弃 所有这些 

1438
00:54:42,949 --> 00:54:47,089
现代计算机的美丽设施

1439
00:54:45,079 --> 00:54:49,159
但它更 强大 ，而且更多 

1440
00:54:47,089 --> 00:54:50,989
明确它可以让你完全按照你的方式行事 

1441
00:54:49,159 --> 00:54:53,089
想通过发送命令给做 

1442
00:54:50,989 --> 00:54:54,619
电脑 所以这是我的终端 我 

1443
00:54:53,089 --> 00:54:56,569
可以创建其他只是为了拥有多个 

1444
00:54:54,619 --> 00:54:59,449
Windows， 但这让 我访问 

1445
00:54:56,569 --> 00:55:02,419
我现在拥有的底层服务器 

1446
00:54:59,449 --> 00:55:04,069
如果有人在我们来的时候访问

1447
00:55:02,419 --> 00:55:05,659
第一个问题集的 登录时间

1448
00:55:04,069 --> 00:55:07,419
你不都相同的工具有 

1449
00:55:05,659 --> 00:55:10,549
同样的环境你们都拥有自己的环境 

1450
00:55:07,419 --> 00:55:13,159
相同软件的隔离副本但是 

1451
00:55:10,549 --> 00:55:16,729
你自己的存储空间可以这么说我 

1452
00:55:13,159 --> 00:55:19,399
需要以某种方式将hello dot C转换为 

1453
00:55:16,729 --> 00:55:22,549
零和一个以及我要做的方式 

1454
00:55:19,399 --> 00:55:29,539
这就像这个铿锵声 

1455
00:55:22,549 --> 00:55:31,849
C 语言hello dot C 输入和 

1456
00:55:29,539 --> 00:55:33,769
事实上，我认为没有发生任何事情

1457
00:55:31,849 --> 00:55:34,759
实际上是一个了不起的事情 ，因为 

1458
00:55:33,769 --> 00:55:36,139
有无数的东西 

1459
00:55:34,759 --> 00:55:37,819
坦率地说，可以去错 了， 

1460
00:55:36,139 --> 00:55:39,469
电脑会高兴地对你大喊大叫

1461
00:55:37,819 --> 00:55:41,179
它的神秘错误消息，如果

1462
00:55:39,469 --> 00:55:43,309
任何这些事情都会出错 

1463
00:55:41,179 --> 00:55:44,779
只看到另一个闪烁的东西 

1464
00:55:43,309 --> 00:55:45,559
实际上，提示美元符号

1465
00:55:44,779 --> 00:55:47,509
一件好事 

1466
00:55:45,559 --> 00:55:50,569
我的代码已经以某种方式转换为

1467
00:55:47,509 --> 00:55:53,209
零和那些零和零 

1468
00:55:50,569 --> 00:55:55,159
根据惯例，它们是存储的 

1469
00:55:53,209 --> 00:55:57,829
在一个文件，该文件古怪和 

1470
00:55:55,159 --> 00:55:59,299
历史上只是称为dot alt和 

1471
00:55:57,829 --> 00:56:02,739
我们可以看到， 如果我点击 这个文件夹 

1472
00:55:59,299 --> 00:56:05,689
图标在这里你实际上会看到我的文件 

1473
00:56:02,739 --> 00:56:08,029
hello dot C和另一个现在调用的文件 

1474
00:56:05,689 --> 00:56:09,430
dot out代表装配输出但是 

1475
00:56:08,029 --> 00:56:11,470
由于历史原因 

1476
00:56:09,430 --> 00:56:13,000
现在，如果我让我关闭 文件夹图标 

1477
00:56:11,470 --> 00:56:15,340
因为我们一般都不会用 

1478
00:56:13,000 --> 00:56:17,080
图形用户界面我该怎么做 

1479
00:56:15,340 --> 00:56:18,610
运行该程序我不能 只 加倍 

1480
00:56:17,080 --> 00:56:21,490
点击 图标 这不是 Mac 

1481
00:56:18,610 --> 00:56:23,230
不是PC，这是一个基于云的Linux 

1482
00:56:21,490 --> 00:56:24,880
环境Linux是一个超级流行的 

1483
00:56:23,230 --> 00:56:26,410
操作系统碰巧被使用 

1484
00:56:24,880 --> 00:56:28,180
很多计算机科学家 

1485
00:56:26,410 --> 00:56:29,920
网站 实际上 几乎 都是 服务器 

1486
00:56:28,180 --> 00:56:32,590
你现在访问的每个网站都是

1487
00:56:29,920 --> 00:56:35,050
如果不是由Linux和Windows驱动的

1488
00:56:32,590 --> 00:56:37,240
其变体称为UNIX等 

1489
00:56:35,050 --> 00:56:38,890
味道仍然只是一个非常受欢迎的 

1490
00:56:37,240 --> 00:56:41,800
和通常是 免费的操作系统 

1491
00:56:38,890 --> 00:56:45,250
cs50沙箱本身用于运行文件

1492
00:56:41,800 --> 00:56:46,780
在这个文件夹中称为一个点 

1493
00:56:45,250 --> 00:56:48,400
可以这么说，即使你没有看到 

1494
00:56:46,780 --> 00:56:51,910
你字面上的图形版本 

1495
00:56:48,400 --> 00:56:54,190
只需键入点斜线即可 完全删除 

1496
00:56:51,910 --> 00:56:56,470
不明显 和有点 愚蠢的名字 

1497
00:56:54,190 --> 00:56:58,270
对于该 计划，但这是 

1498
00:56:56,470 --> 00:57:00,460
相当于你的Mac 或PC的双倍 

1499
00:56:58,270 --> 00:57:02,140
点击一个图标 让我继续前进 

1500
00:57:00,460 --> 00:57:05,680
点击进入，当我这样做时，我应该 

1501
00:57:02,140 --> 00:57:09,580
希望看到什么问候世界和这里

1502
00:57:05,680 --> 00:57:11,620
我们哇哇这是 我们的第一个 节目 

1503
00:57:09,580 --> 00:57:13,540
它没有做那么 多，但它是在 

1504
00:57:11,620 --> 00:57:15,250
至少做我们承诺会做的事情 

1505
00:57:13,540 --> 00:57:17,560
而这是相当于划伤的 

1506
00:57:15,250 --> 00:57:18,880
只是在屏幕上问好世界 

1507
00:57:17,560 --> 00:57:20,830
现在公平地说，有更多的步骤 

1508
00:57:18,880 --> 00:57:23,200
参与，上帝知道还有更多 

1509
00:57:20,830 --> 00:57:24,910
神秘的代码写，但在 

1510
00:57:23,200 --> 00:57:31,930
在一天结束时我们所做的是现在 

1511
00:57:24,910 --> 00:57:33,460
重新实现了我们的 安抚，但在C 但是 

1512
00:57:31,930 --> 00:57:35,440
首先让我们解决这种轻微问题 

1513
00:57:33,460 --> 00:57:37,720
头疼我真的不想那样 

1514
00:57:35,440 --> 00:57:40,060
告诉朋友，嘿大家都喜欢来

1515
00:57:37,720 --> 00:57:41,680
像我们一样给我一个点出来的程序

1516
00:57:40,060 --> 00:57:43,240
它是一个真实的名字，假设我只是 想 

1517
00:57:41,680 --> 00:57:44,590
像你一样打电话给我的程序你好

1518
00:57:43,240 --> 00:57:47,500
从App Store 或 Google下载

1519
00:57:44,590 --> 00:57:49,540
Play商店 的程序有名称， 所以如何 

1520
00:57:47,500 --> 00:57:51,970
我做得好，结果证明了这一点 

1521
00:57:49,540 --> 00:57:53,980
终端窗口这个所谓的命令 

1522
00:57:51,970 --> 00:57:55,540
线条环境，这只是一种幻想 

1523
00:57:53,980 --> 00:57:57,340
说你写行的方式 

1524
00:57:55,540 --> 00:58:00,310
你可以用键盘命令

1525
00:57:57,340 --> 00:58:03,040
实际上传递了所谓的命令 

1526
00:58:00,310 --> 00:58:05,260
行参数附加输入 

1527
00:58:03,040 --> 00:58:07,300
这 只是程序的话，你 

1528
00:58:05,260 --> 00:58:09,070
在键盘上键入，告诉它如何 

1529
00:58:07,300 --> 00:58:12,850
这样做而不仅仅是 跑步 

1530
00:58:09,070 --> 00:58:14,440
你好， 我已经开始了 

1531
00:58:12,850 --> 00:58:17,650
要更明确 ，我要告诉 

1532
00:58:14,440 --> 00:58:20,980
铿锵请输出 暗示 

1533
00:58:17,650 --> 00:58:22,050
字面上打字 -  o4l把 一个文件叫做 

1534
00:58:20,980 --> 00:58:24,270
你好 

1535
00:58:22,050 --> 00:58:26,910
相反， 所以它更冗长一点 

1536
00:58:24,270 --> 00:58:30,300
你好 - 哦，你好哦对不起 

1537
00:58:26,910 --> 00:58:32,670
铿锵- 哦你好 你好点C但是什么 

1538
00:58:30,300 --> 00:58:34,350
现在要做的仍然是转换 

1539
00:58:32,670 --> 00:58:36,960
机器码的源代码， 但它是 

1540
00:58:34,350 --> 00:58:38,940
将其保存在名为hello的文件中 

1541
00:58:36,960 --> 00:58:42,390
事实上，现在我打招呼圆点C 点 

1542
00:58:38,940 --> 00:58:45,030
如小图所示出来和你好 

1543
00:58:42,390 --> 00:58:47,910
图形文件夹那里现在我可以

1544
00:58:45,030 --> 00:58:51,270
而是运行点斜杠你好 应该是什么 

1545
00:58:47,910 --> 00:58:51,930
它说 希望 同样 如此 

1546
00:58:51,270 --> 00:58:53,340
而已

1547
00:58:51,930 --> 00:58:54,900
那些被称为 命令行参数 

1548
00:58:53,340 --> 00:58:57,240
它只是一种老式的 方式 

1549
00:58:54,900 --> 00:58:58,590
告诉基于文本的命令 如何 

1550
00:58:57,240 --> 00:59:00,450
表现得 与它 有点 不同 

1551
00:58:58,590 --> 00:59:02,370
默认但坦率地说这是 

1552
00:59:00,450 --> 00:59:04,050
像 我们不那样 快速地变得乏味 

1553
00:59:02,370 --> 00:59:05,550
想要 编写我们的代码然后 

1554
00:59:04,050 --> 00:59:07,290
每个我们想要将 其 转换 为的时间 

1555
00:59:05,550 --> 00:59:08,820
零和一个 实际 运行它 

1556
00:59:07,290 --> 00:59:12,270
记住这些神奇的东西 

1557
00:59:08,820 --> 00:59:14,130
命令的咒语和人类

1558
00:59:12,270 --> 00:59:15,990
把这些抽象出来了- 它转过来了 

1559
00:59:14,130 --> 00:59:17,190
如果你想 制作一个节目 

1560
00:59:15,990 --> 00:59:19,170
从源代码到机器代码 

1561
00:59:17,190 --> 00:59:22,170
你可以使用另一个命令 

1562
00:59:19,170 --> 00:59:23,670
你可以在字面上输入make Hello 

1563
00:59:22,170 --> 00:59:26,820
Hello 是 您的程序 名称 

1564
00:59:23,670 --> 00:59:29,310
想要 制作这个名为的程序 

1565
00:59:26,820 --> 00:59:33,150
make默认会查找文件

1566
00:59:29,310 --> 00:59:35,880
叫做hello dot C 因此可以节省你的时间 

1567
00:59:33,150 --> 00:59:38,460
指定它的时间命中立即进入 

1568
00:59:35,880 --> 00:59:42,720
哦，我的上帝看看它刚刚做了什么 

1569
00:59:38,460 --> 00:59:45,030
有更多的配置选项 

1570
00:59:42,720 --> 00:59:47,280
在cs50工作人员的周内被烘烤

1571
00:59:45,030 --> 00:59:48,840
配置cs50沙箱来拥有这些

1572
00:59:47,280 --> 00:59:50,880
各种功能，即使我们是 

1573
00:59:48,840 --> 00:59:52,080
现在不打算 详细 介绍它们 

1574
00:59:50,880 --> 00:59:52,710
我要向他们挥手示意 

1575
00:59:52,080 --> 00:59:54,090
实际上 

1576
00:59:52,710 --> 00:59:55,980
他们只是制作其他功能

1577
00:59:54,090 --> 00:59:57,900
可能会 最终到达 但是 

1578
00:59:55,980 --> 00:59:59,850
否则这将是命令 

1579
00:59:57,900 --> 01:00:02,430
你们都必须输入两个 

1580
00:59:59,850 --> 01:00:04,320
三到 三周或四周时间 没有 

1581
01:00:02,430 --> 01:00:06,960
人们 永远 记得我当然 

1582
01:00:04,320 --> 01:00:09,690
不能这么做只是为了自动化

1583
01:00:06,960 --> 01:00:12,690
你，但是当你运行make化妆是不是 

1584
01:00:09,690 --> 01:00:14,490
编译器make不是中的东西 

1585
01:00:12,690 --> 01:00:16,680
中间在这里将源代码转换为 

1586
01:00:14,490 --> 01:00:19,770
机器码它只是 第二个程序 

1587
01:00:16,680 --> 01:00:23,190
有些人写 年前 

1588
01:00:19,770 --> 01:00:25,470
使用clang以自动化的方式实现 

1589
01:00:23,190 --> 01:00:26,880
人们厌倦了同样的输出 

1590
01:00:25,470 --> 01:00:29,340
像这样所以有人打字 的 东西 

1591
01:00:26,880 --> 01:00:31,960
制作了一个名为make的程序 

1592
01:00:29,340 --> 01:00:34,819
对我们任何问题 

1593
01:00:31,960 --> 01:00:36,829
好吧，让我们再添加一点 

1594
01:00:34,819 --> 01:00:38,839
这个程序而不是这个版本的 

1595
01:00:36,829 --> 01:00:40,970
你好，让我得到一些用户输入 和 

1596
01:00:38,839 --> 01:00:42,559
实际上用 它做点什么

1597
01:00:40,970 --> 01:00:44,420
假设我真的想得到

1598
01:00:42,559 --> 01:00:45,980
用户的名字，然后打印出来 

1599
01:00:44,420 --> 01:00:47,569
我们只看到了扰流板 

1600
01:00:45,980 --> 01:00:49,400
片刻之前， 让我继续前进并添加 

1601
01:00:47,569 --> 01:00:51,380
这个程序现在我有一个 

1602
01:00:49,400 --> 01:00:53,720
第二行代码， 我想得到一个 

1603
01:00:51,380 --> 01:00:54,980
来自用户的字符串以及我如何使用 

1604
01:00:53,720 --> 01:00:55,750
我从什么函数得到一个字符串

1605
01:00:54,980 --> 01:00:58,339
用户

1606
01:00:55,750 --> 01:01:01,190
它得到的字符串是1并回忆起我 

1607
01:00:58,339 --> 01:01:03,109
可以做下划线打开

1608
01:01:01,190 --> 01:01:05,630
括号 然后我必须传入 

1609
01:01:03,109 --> 01:01:07,190
一个论据可以说就像给我一样 

1610
01:01:05,630 --> 01:01:10,099
你的名字这实际上是我们做的 

1611
01:01:07,190 --> 01:01:12,890
在我 认为 你的名字之前说出来

1612
01:01:10,099 --> 01:01:14,450
现在提示反斜杠n分号 

1613
01:01:12,890 --> 01:01:15,759
仅仅获得字符串是 不够 的 

1614
01:01:14,450 --> 01:01:18,289
我该怎么办呢

1615
01:01:15,759 --> 01:01:21,859
是的，它存储在一个变量是什么类型的 

1616
01:01:18,289 --> 01:01:23,450
变量 一个字符串所以我只需要去 

1617
01:01:21,859 --> 01:01:25,730
这条线 的左侧 

1618
01:01:23,450 --> 01:01:28,009
代码并 说 好吧给 我一个字符串 

1619
01:01:25,730 --> 01:01:30,140
我叫它名字，但我可以称之为X. 

1620
01:01:28,009 --> 01:01:32,180
或Y或任何名称感觉像是一个 

1621
01:01:30,140 --> 01:01:33,890
使用单个相等的良好描述符 

1622
01:01:32,180 --> 01:01:36,859
标志从右到左 复制 ，现在 

1623
01:01:33,890 --> 01:01:39,619
我有一个现在是不够 的 

1624
01:01:36,859 --> 01:01:42,920
只需将值存储在变量I中 

1625
01:01:39,619 --> 01:01:45,230
需要打印出来让我开始吧 

1626
01:01:42,920 --> 01:01:46,789
这样 你 就没有了 

1627
01:01:45,230 --> 01:01:48,380
自动保存沙箱，所以我甚至没有

1628
01:01:46,789 --> 01:01:50,680
必须去保存文件 或任何东西 

1629
01:01:48,380 --> 01:01:54,680
让我继续，现在做 你好 

1630
01:01:50,680 --> 01:01:57,440
哦 - 哦，我的上帝看看 所有 这些错误 

1631
01:01:54,680 --> 01:01:59,029
已经如此明显地出了问题 

1632
01:01:57,440 --> 01:02:00,680
计算机以此 告诉我 的 

1633
01:01:59,029 --> 01:02:01,880
红色，坦率地说，这就是你的所在

1634
01:02:00,680 --> 01:02:03,230
他们很快就出轨了

1635
01:02:01,880 --> 01:02:05,089
吓坏了，因为哦， 我的上帝，我 只 

1636
01:02:03,230 --> 01:02:08,390
写了两行代码我怎么会有20行代码 

1637
01:02:05,089 --> 01:02:10,279
错误的行， 所以计算机 

1638
01:02:08,390 --> 01:02:11,720
有点像你 和 你一样困惑 

1639
01:02:10,279 --> 01:02:13,160
当你面对这个时最重要的事情

1640
01:02:11,720 --> 01:02:15,289
它 只是一种情况 

1641
01:02:13,160 --> 01:02:17,210
神秘的错误输出开始于 

1642
01:02:15,289 --> 01:02:18,440
顶部，即使你的窗户很小 

1643
01:02:17,210 --> 01:02:20,299
因此有很多东西 

1644
01:02:18,440 --> 01:02:22,009
屏幕上的滚动快速向上滚动 

1645
01:02:20,299 --> 01:02:23,960
到顶部 因为赔率是有一个 

1646
01:02:22,009 --> 01:02:25,700
在最顶端和那个错误 

1647
01:02:23,960 --> 01:02:27,650
错误只会 产生连锁效应 

1648
01:02:25,700 --> 01:02:28,880
它上的编译器上的计算机

1649
01:02:27,650 --> 01:02:30,410
真的很困惑， 只是 

1650
01:02:28,880 --> 01:02:32,329
不停地吐出消息，因为它 

1651
01:02:30,410 --> 01:02:36,049
早点绊倒了让我们滚动吧 

1652
01:02:32,329 --> 01:02:38,420
备份 到这里的顶部，这里的 

1653
01:02:36,049 --> 01:02:39,980
我说的很长的命令

1654
01:02:38,420 --> 01:02:42,200
为你自动化，所以不是 

1655
01:02:39,980 --> 01:02:45,230
这里的错误似乎是 第一个 

1656
01:02:42,200 --> 01:02:47,570
错误，它仍然有点神秘 

1657
01:02:45,230 --> 01:02:50,570
但是我们在这里收集一些信息

1658
01:02:47,570 --> 01:02:52,430
一个熟悉的短语 hello dot C让我走了 

1659
01:02:50,570 --> 01:02:54,230
提前并 放大底部这里 

1660
01:02:52,430 --> 01:02:57,020
你记得你好， 我 记得你的名字 

1661
01:02:54,230 --> 01:02:59,780
档案虽然 没有明显的铿锵声 

1662
01:02:57,020 --> 01:03:01,880
告诉我看看第5行，然后是你的 

1663
01:02:59,780 --> 01:03:04,070
第五个字符所以这个 冒号 

1664
01:03:01,880 --> 01:03:05,330
东西意味着行号字符或

1665
01:03:04,070 --> 01:03:07,250
如果你从寻找列数

1666
01:03:05,330 --> 01:03:09,250
从左到右错误意味着错误然后 

1667
01:03:07,250 --> 01:03:11,869
这是事情变得有点的地方

1668
01:03:09,250 --> 01:03:15,619
熟练使用未申报的 

1669
01:03:11,869 --> 01:03:19,070
标识符字符串你的意思是标准 

1670
01:03:15,619 --> 01:03:21,619
现在我没有，但我确实认识到了

1671
01:03:19,070 --> 01:03:23,420
标准在或更确切地说它似乎相似 

1672
01:03:21,619 --> 01:03:25,270
标准的 i / o但不是我不是故意的 

1673
01:03:23,420 --> 01:03:27,680
我很确定这段代码是对的 

1674
01:03:25,270 --> 01:03:30,920
好吧，为什么我 得到这个错误 

1675
01:03:27,680 --> 01:03:33,980
它听起来像第 5 行第 5 行的字符串 

1676
01:03:30,920 --> 01:03:35,930
人物右边有不妥 好 

1677
01:03:33,980 --> 01:03:39,350
事实证明， 没有这样的事情 

1678
01:03:35,930 --> 01:03:41,780
字符串看到 语言有整数和 

1679
01:03:39,350 --> 01:03:43,730
它有布尔值，它结果，它有

1680
01:03:41,780 --> 01:03:46,130
它和其他一些东西

1681
01:03:43,730 --> 01:03:47,570
实际上没有 字符串字符串 

1682
01:03:46,130 --> 01:03:49,700
一个词是 非常有用的描述 

1683
01:03:47,570 --> 01:03:52,280
字符序列段落词 

1684
01:03:49,700 --> 01:03:55,010
但字符串不是一种类型，它不是一种类型

1685
01:03:52,280 --> 01:03:58,010
变量，除非你这样做 

1686
01:03:55,010 --> 01:03:59,690
事实上，这是简化之一 

1687
01:03:58,010 --> 01:04:00,890
我们做的只是在最初几周 的 

1688
01:03:59,690 --> 01:04:04,040
让我们离开地面的课程

1689
01:04:00,890 --> 01:04:07,220
事实证明我们需要添加一个 

1690
01:04:04,040 --> 01:04:09,320
这里的代码行我们不仅要做 

1691
01:04:07,220 --> 01:04:13,130
包括我们将解释的标准i / o 

1692
01:04:09,320 --> 01:04:16,130
片刻而且所谓的cs50 

1693
01:04:13,130 --> 01:04:17,450
图书馆所以cs50有很多 人 

1694
01:04:16,130 --> 01:04:19,280
参与其中， 随着时间的推移，我们已经 

1695
01:04:17,450 --> 01:04:21,470
决定你知道我们能做什么

1696
01:04:19,280 --> 01:04:22,880
cs50的第一个小时更容易一点 

1697
01:04:21,470 --> 01:04:25,280
这些种类的 上匝道一点点 

1698
01:04:22,880 --> 01:04:27,440
没有背景 的人的清洁工

1699
01:04:25,280 --> 01:04:29,090
我们自己发明了一些功能

1700
01:04:27,440 --> 01:04:30,770
例如从中获取字符串的能力

1701
01:04:29,090 --> 01:04:32,420
用户所以结果是getstring是 

1702
01:04:30,770 --> 01:04:34,340
也没有随 C中的函数

1703
01:04:32,420 --> 01:04:37,100
这是一个定制的拼图 

1704
01:04:34,340 --> 01:04:40,010
说cs50和我们在哪里 

1705
01:04:37,100 --> 01:04:42,920
创建该函数基本上是在 

1706
01:04:40,010 --> 01:04:45,950
一个名为cs50.h的文件，所以包括 

1707
01:04:42,920 --> 01:04:47,600
cs50.h 你现在可以访问更多拼图 

1708
01:04:45,950 --> 01:04:49,730
如果你愿意我们创造的 

1709
01:04:47,600 --> 01:04:51,290
为你而且事实证明这一行 

1710
01:04:49,730 --> 01:04:54,170
以前的代码

1711
01:04:51,290 --> 01:04:55,850
也给你写功能

1712
01:04:54,170 --> 01:04:57,619
我们只是在做什么， 每个人都 在 

1713
01:04:55,850 --> 01:04:58,190
编程解决问题 

1714
01:04:57,619 --> 01:05:00,410
曾经和 

1715
01:04:58,190 --> 01:05:03,410
让其他人使用该解决方案 

1716
01:05:00,410 --> 01:05:05,330
猜猜实际上是什么功能 

1717
01:05:03,410 --> 01:05:08,840
在名为standard的文件中实现

1718
01:05:05,330 --> 01:05:10,370
i / o输入 输出点H这只是一个 

1719
01:05:08,840 --> 01:05:12,740
文件在服务器上的某个地方 

1720
01:05:10,370 --> 01:05:14,090
实际上确实带有C和它 

1721
01:05:12,740 --> 01:05:18,410
为您提供方便的功能，如

1722
01:05:14,090 --> 01:05:21,650
什么再说一遍 

1723
01:05:18,410 --> 01:05:24,020
printf 事实证明，虽然意味着 

1724
01:05:21,650 --> 01:05:26,420
你可以使用一个 函数 

1725
01:05:24,020 --> 01:05:28,790
这里叫printf你 是必须的 

1726
01:05:26,420 --> 01:05:31,400
包括声明它 的文件 

1727
01:05:28,790 --> 01:05:33,410
所以有些人几年前写道 

1728
01:05:31,400 --> 01:05:34,880
一个叫做printf的拼图游戏 

1729
01:05:33,410 --> 01:05:36,800
他们想出了如何 实际 

1730
01:05:34,880 --> 01:05:38,960
然后在屏幕上绘制字符

1731
01:05:36,800 --> 01:05:40,850
存储有关该功能的 信息 

1732
01:05:38,960 --> 01:05:43,550
在一个名为标准IOH的文件中

1733
01:05:40,850 --> 01:05:45,260
如果 我没有 包括那个看似 

1734
01:05:43,550 --> 01:05:47,600
隐藏在最顶端的代码行

1735
01:05:45,260 --> 01:05:49,070
我 以前的程序 甚至打招呼 

1736
01:05:47,600 --> 01:05:51,650
世界计划不会 奏效 

1737
01:05:49,070 --> 01:05:53,150
因为编译器不会有clang 

1738
01:05:51,650 --> 01:05:55,520
知道我在说什么 

1739
01:05:53,150 --> 01:05:57,740
printf 我不知道那 是 什么， 除非 

1740
01:05:55,520 --> 01:06:00,140
你告诉它 也包括这个文件 

1741
01:05:57,740 --> 01:06:02,270
几年前人类写的那个 

1742
01:06:00,140 --> 01:06:04,220
printf已创建，现在如果我 

1743
01:06:02,270 --> 01:06:07,250
想要使用getstring 和new 

1744
01:06:04,220 --> 01:06:09,980
关键词我需要告诉铿锵的 

1745
01:06:07,250 --> 01:06:11,900
编译器也继续查看 cs50 

1746
01:06:09,980 --> 01:06:14,810
点H用于更多功能，例如

1747
01:06:11,900 --> 01:06:17,810
字符串和 getstring让 我继续前进 

1748
01:06:14,810 --> 01:06:20,000
现在 再试一次我会清楚的 

1749
01:06:17,810 --> 01:06:25,070
我的终端在这里尝试一下 

1750
01:06:20,000 --> 01:06:27,320
命令再次让 Hello输入 dammit 

1751
01:06:25,070 --> 01:06:30,410
现在我有另一个错误 ，但是但是 

1752
01:06:27,320 --> 01:06:32,840
进展顺利，没有那么多 

1753
01:06:30,410 --> 01:06:35,510
以前的错误不同但不同 

1754
01:06:32,840 --> 01:06:38,630
有人 注意到现在好好等待 

1755
01:06:35,510 --> 01:06:40,040
哦，不，我很抱歉 它少了 

1756
01:06:38,630 --> 01:06:42,380
错误在这里我运行命令a 

1757
01:06:40,040 --> 01:06:45,260
片刻之前，现在我得到了这个 

1758
01:06:42,380 --> 01:06:47,240
错误反而没关系，所以现在我的进步 

1759
01:06:45,260 --> 01:06:50,180
错误 不在第5行第6行 

1760
01:06:47,240 --> 01:06:52,100
虽然有趣的事实我的6曾经是第5行 

1761
01:06:50,180 --> 01:06:54,230
所以它显然仍然参与其中 

1762
01:06:52,100 --> 01:06:56,900
问题 所以让我们阅读错误信息 

1763
01:06:54,230 --> 01:06:59,000
问题是在第6行，而不是 

1764
01:06:56,900 --> 01:07:00,770
令人惊讶的是那里有 一个 但是这个 

1765
01:06:59,000 --> 01:07:04,490
时间 它是不同的错误未使用 

1766
01:07:00,770 --> 01:07:05,900
变量名称好吧，我有点 

1767
01:07:04,490 --> 01:07:08,450
即使不是 一个人也能理解

1768
01:07:05,900 --> 01:07:12,130
程序员是什么 主题， 又有什么 

1769
01:07:08,450 --> 01:07:12,130
意思是的 

1770
01:07:12,680 --> 01:07:17,309
也许在使用之前声明但 转身 

1771
01:07:15,269 --> 01:07:22,170
这是你如何宣布它但我是 

1772
01:07:17,309 --> 01:07:24,180
实际是的，是的，我只是一点点

1773
01:07:22,170 --> 01:07:26,160
浪费计算机的我创建时间 

1774
01:07:24,180 --> 01:07:28,079
所以 左边 第六行 是正确的 

1775
01:07:26,160 --> 01:07:30,150
嘿计算机给我一个字符串变量 

1776
01:07:28,079 --> 01:07:32,309
并将其命名并 在其中添加一个值 

1777
01:07:30,150 --> 01:07:34,200
但 如果 这项 运动有 什么意义 呢 

1778
01:07:32,309 --> 01:07:36,089
你永远不会像你说的那样做任何事情 

1779
01:07:34,200 --> 01:07:37,740
用它， 然后称之为 完美召回 

1780
01:07:36,089 --> 01:07:39,630
刚才从幻灯片中 我该 怎么 做 

1781
01:07:37,740 --> 01:07:41,400
东西好 它 ，这 不是如何 

1782
01:07:39,630 --> 01:07:43,230
如果我继续， 你会用它做点什么 

1783
01:07:41,400 --> 01:07:45,410
并 成功运行此程序 

1784
01:07:43,230 --> 01:07:48,269
我会在屏幕上看到什么？ 

1785
01:07:45,410 --> 01:07:51,089
喜欢字面意思你好名字你好

1786
01:07:48,269 --> 01:07:53,010
逗号空间和AME 显然不是 

1787
01:07:51,089 --> 01:07:56,579
这是正确的，我如何插入变量 

1788
01:07:53,010 --> 01:07:58,769
什么是呀百分之百的诀窍

1789
01:07:56,579 --> 01:08:00,869
字符串格式代码因此可以说 

1790
01:07:58,769 --> 01:08:03,390
名称printf ，然后我需要通过 

1791
01:08:00,869 --> 01:08:05,160
printf和我这样做的第二个论点

1792
01:08:03,390 --> 01:08:06,960
用逗号 然后命名 

1793
01:08:05,160 --> 01:08:08,640
变量 现在 我 要插上 

1794
01:08:06,960 --> 01:08:10,680
请注意，这里有两个逗号

1795
01:08:08,640 --> 01:08:12,240
如果我放大注意那里就行了 

1796
01:08:10,680 --> 01:08:15,359
两个逗号，但 只有两个 

1797
01:08:12,240 --> 01:08:17,219
打印输入的参数或输入

1798
01:08:15,359 --> 01:08:19,170
通常只调用一个函数

1799
01:08:17,219 --> 01:08:22,739
参数或也称为参数 

1800
01:08:19,170 --> 01:08:24,989
所以有两个逗号，但这个是 

1801
01:08:22,739 --> 01:08:27,150
英语逗号只是将你好 

1802
01:08:24,989 --> 01:08:29,580
这个人的名字是这个白色的逗号 

1803
01:08:27,150 --> 01:08:31,529
这里的颜色编码，因为沙箱是 

1804
01:08:29,580 --> 01:08:34,290
为 我做这件事实际上 是 在分离 

1805
01:08:31,529 --> 01:08:37,109
请原谅我的第一个论点 

1806
01:08:34,290 --> 01:08:40,920
第二个论点 现在是 第三次 

1807
01:08:37,109 --> 01:08:43,109
使你好进入我的 上帝啊 ，现在 谢谢 

1808
01:08:40,920 --> 01:08:45,120
它仍然工作， 它 仍然 吐出这 漂亮 

1809
01:08:43,109 --> 01:08:47,159
白色的长期神秘命令， 但那是 

1810
01:08:45,120 --> 01:08:49,770
好的，这又是自动命令 

1811
01:08:47,159 --> 01:08:51,480
这让我们成为可能，但是 

1812
01:08:49,770 --> 01:08:53,520
事实上，我看到没有红色没有错误 

1813
01:08:51,480 --> 01:08:55,560
只是另一个闪烁的提示意味着 

1814
01:08:53,520 --> 01:08:57,839
我的节目已经制作 好让 我走了 

1815
01:08:55,560 --> 01:09:01,949
如果，我将如何运行程序 

1816
01:08:57,839 --> 01:09:03,330
它被称为hello yeah dot slash 你好 

1817
01:09:01,949 --> 01:09:04,650
我们会明白为什么你有愚蠢的

1818
01:09:03,330 --> 01:09:06,060
从本质上开始点

1819
01:09:04,650 --> 01:09:08,639
意味着运行名为hello的程序 

1820
01:09:06,060 --> 01:09:11,250
就在你当前的文件夹中 

1821
01:09:08,639 --> 01:09:15,299
在服务器上点斜杠你好是什么 

1822
01:09:11,250 --> 01:09:15,900
你的 名字非常好大卫进入你好 

1823
01:09:15,299 --> 01:09:18,179
大卫

1824
01:09:15,900 --> 01:09:19,859
有趣的是让我们做一个调整因为

1825
01:09:18,179 --> 01:09:22,199
我早先意外地做到了这一点

1826
01:09:19,859 --> 01:09:23,739
注意如果我离开了怎么办 

1827
01:09:22,199 --> 01:09:25,659
其中一个反斜杠结束了 

1828
01:09:23,739 --> 01:09:27,519
这实际上现在没有告诉 

1829
01:09:25,659 --> 01:09:30,039
计算机将 光标移动到另一个 

1830
01:09:27,519 --> 01:09:33,159
因此，让 我继续前进并重新运行 

1831
01:09:30,039 --> 01:09:36,279
程序 等待一分钟看起来 

1832
01:09:33,159 --> 01:09:37,869
同样我只是 改变了代码， 但它是 

1833
01:09:36,279 --> 01:09:41,079
仍然表现得完全 一样 

1834
01:09:37,869 --> 01:09:42,849
哪里是我的困惑， 是的，我没有 

1835
01:09:41,079 --> 01:09:43,869
重新编译它不同于刮痕 

1836
01:09:42,849 --> 01:09:45,730
是惊人的，因为你刚刚击中了 

1837
01:09:43,869 --> 01:09:47,559
绿旗 ，它 再次 运行代码 我们 

1838
01:09:45,730 --> 01:09:50,049
我有第二个中间步骤

1839
01:09:47,559 --> 01:09:51,609
现在 重新运行代码 你怎么离开 

1840
01:09:50,049 --> 01:09:53,769
一个程序 ，我可以只需 点击进入 你 

1841
01:09:51,609 --> 01:09:54,940
也可以点击 control-c取消和 

1842
01:09:53,769 --> 01:09:56,829
这会让你 摆脱任何困境 

1843
01:09:54,940 --> 01:10:00,219
你在混乱中让我继续前进 

1844
01:09:56,829 --> 01:10:03,940
重新运行化妆 打招呼似乎 是 好 点 

1845
01:10:00,219 --> 01:10:06,280
斜线你好 进入 没关系这就是我的原因 

1846
01:10:03,940 --> 01:10:08,440
所有这些反斜杠结束让我 放大 

1847
01:10:06,280 --> 01:10:11,349
在发生什么事情上我的意思是它没有 

1848
01:10:08,440 --> 01:10:12,969
看起来很可怕，但坦率地说，它有点像 

1849
01:10:11,349 --> 01:10:14,199
如果是这样的话，我会用错误的方式蹭我

1850
01:10:12,969 --> 01:10:15,670
我的节目看起来像什么 

1851
01:10:14,199 --> 01:10:17,590
输入用户输入我的意思是这个 

1852
01:10:15,670 --> 01:10:19,659
我应该最低限度地看起来很愚蠢 

1853
01:10:17,590 --> 01:10:20,829
添加一个空格也许我可以反斜杠n 

1854
01:10:19,659 --> 01:10:22,239
移动他们应该的角色 

1855
01:10:20,829 --> 01:10:24,610
用户界面现在这不是真的 

1856
01:10:22,239 --> 01:10:26,559
逻辑它只是美学而我想 

1857
01:10:24,610 --> 01:10:27,820
这看起来很愚蠢， 所以这就是我的原因 

1858
01:10:26,559 --> 01:10:30,039
反斜杠一直在那里结束 

1859
01:10:27,820 --> 01:10:31,809
但这就是他们需要去那里的原因 

1860
01:10:30,039 --> 01:10:33,610
告诉电脑 实际放 东西 

1861
01:10:31,809 --> 01:10:35,530
在哪里你想要他们或 你 

1862
01:10:33,610 --> 01:10:37,840
知道什么，我不喜欢 那个 ctrl C. 

1863
01:10:35,530 --> 01:10:40,059
4取消让我把这个放回去 了 

1864
01:10:37,840 --> 01:10:42,280
发生，如果我摆脱这一个 ，让 

1865
01:10:40,059 --> 01:10:46,210
我继续并重新编译代码 

1866
01:10:42,280 --> 01:10:47,320
当你注意点斜线你好输入确定 

1867
01:10:46,210 --> 01:10:51,519
我已经清理了那个错过了 

1868
01:10:47,320 --> 01:10:54,219
审美头痛输入好吧我的意思是它 

1869
01:10:51,519 --> 01:10:56,050
不太 一样的问题，但这个 

1870
01:10:54,219 --> 01:10:57,519
因为美元符号也看起来很愚蠢

1871
01:10:56,050 --> 01:10:58,989
只是代表我的提示我在哪里

1872
01:10:57,519 --> 01:11:01,389
应该键入命令然后你好

1873
01:10:58,989 --> 01:11:03,280
逗号大卫提示 他们只是凌乱如此 

1874
01:11:01,389 --> 01:11:04,570
这就是为什么我们有所有 这些新 的 

1875
01:11:03,280 --> 01:11:06,099
现在行你刚才问你什么 

1876
01:11:04,570 --> 01:11:08,110
将换行符放在字符串中的其他位置 

1877
01:11:06,099 --> 01:11:10,389
好吧，假设我这样做，假设我放了一个

1878
01:11:08,110 --> 01:11:12,460
他们夫妇让我做到这一点 ，并 指出 

1879
01:11:10,389 --> 01:11:14,590
现在看来没有任何空间 

1880
01:11:12,460 --> 01:11:16,119
有点怪异 ，但 计算机 只是 

1881
01:11:14,590 --> 01:11:19,480
要解释这个字面打印 

1882
01:11:16,119 --> 01:11:21,579
你好逗号换行替换 

1883
01:11:19,480 --> 01:11:23,800
％s的字符串然后是另一个 新行 

1884
01:11:21,579 --> 01:11:30,760
那么这是多少行输出 

1885
01:11:23,800 --> 01:11:32,769
要显示 我听到其他四个值 

1886
01:11:30,760 --> 01:11:36,130
让我们看看让我们继续前进 并 打招呼 

1887
01:11:32,769 --> 01:11:37,600
然后 运行点斜杠你好是什么 

1888
01:11:36,130 --> 01:11:40,660
你的名字和以前一样 

1889
01:11:37,600 --> 01:11:42,550
输入你好逗号换行大卫这么 四 

1890
01:11:40,660 --> 01:11:44,470
总行当然或只是两行 

1891
01:11:42,550 --> 01:11:47,410
来自电脑本身

1892
01:11:44,470 --> 01:11:47,950
所以只是用代码来回顾一下

1893
01:11:47,410 --> 01:11:51,850
这个

1894
01:11:47,950 --> 01:11:59,860
我在这里使用了多少功能

1895
01:11:51,850 --> 01:12:01,330
特别是程序有多少功能如此 

1896
01:11:59,860 --> 01:12:02,800
这是我们一直 在使用的两个printf 

1897
01:12:01,330 --> 01:12:06,640
和getstring是新的 

1898
01:12:02,800 --> 01:12:09,100
其中getstring声明为cs50.h 

1899
01:12:06,640 --> 01:12:11,020
printf同时以标准声明 

1900
01:12:09,100 --> 01:12:13,600
i / o dot H标准输入/输出 

1901
01:12:11,020 --> 01:12:15,820
同时串起这个数据类型

1902
01:12:13,600 --> 01:12:17,650
来自cs50本身，然后我们 

1903
01:12:15,820 --> 01:12:19,360
使用格式代码，我们已经使用过 

1904
01:12:17,650 --> 01:12:20,560
变量实现相同的结果和 

1905
01:12:19,360 --> 01:12:22,180
让我们只是锤击这个 家可以 听到 

1906
01:12:20,560 --> 01:12:25,510
布莱恩和奶油你介意突然出现吗？ 

1907
01:12:22,180 --> 01:12:28,060
只是一秒钟或谁是 艾琳来 

1908
01:12:25,510 --> 01:12:30,400
上了这么只是为了明确这一点 ，因为 

1909
01:12:28,060 --> 01:12:32,470
现在有一些术语， 我们 

1910
01:12:30,400 --> 01:12:34,780
想要使用让我们看看你想成为谁 

1911
01:12:32,470 --> 01:12:36,550
你会好好的，所以我们有 一些 

1912
01:12:34,780 --> 01:12:40,990
这里的名称标签就像你得到它 

1913
01:12:36,550 --> 01:12:43,420
所以空气中的事件应该得到强调 

1914
01:12:40,990 --> 01:12:47,080
字符串， 如果你想继续和 放 

1915
01:12:43,420 --> 01:12:50,680
这个没关系， Brian 想要 

1916
01:12:47,080 --> 01:12:52,300
打印F所以我们不会全部采取行动 

1917
01:12:50,680 --> 01:12:53,890
我们的实际计划，因为这会

1918
01:12:52,300 --> 01:12:57,340
布莱恩很快就变得明显了

1919
01:12:53,890 --> 01:12:58,900
printf 所以这一点虽然仍然存在 

1920
01:12:57,340 --> 01:13:00,490
我喜欢这样的很好

1921
01:12:58,900 --> 01:13:02,500
和 我一起工作的 同事， 因为 

1922
01:13:00,490 --> 01:13:04,630
我真的不 希望做的所有 的 

1923
01:13:02,500 --> 01:13:06,430
努力让事情 发生 

1924
01:13:04,630 --> 01:13:07,810
所以， 如果我是程序员或者 

1925
01:13:06,430 --> 01:13:09,400
一种整体 的协调 者 

1926
01:13:07,810 --> 01:13:11,230
一堆事情发生我实际上可以 

1927
01:13:09,400 --> 01:13:13,150
现在更多地 实现此 代码 

1928
01:13:11,230 --> 01:13:14,650
身体上，让我们专注于

1929
01:13:13,150 --> 01:13:17,890
只是在排序键的什么 时刻 

1930
01:13:14,650 --> 01:13:20,200
外卖是一个功能可以采取 

1931
01:13:17,890 --> 01:13:23,170
输入这些输入称为参数 

1932
01:13:20,200 --> 01:13:25,090
或参数 和功能可以返回 

1933
01:13:23,170 --> 01:13:29,520
他们可以拥有回报价值的东西

1934
01:13:25,090 --> 01:13:33,690
例如， printf 是否需要输入 

1935
01:13:29,520 --> 01:13:36,400
例如，printf的输入是什么 

1936
01:13:33,690 --> 01:13:38,380
是的，你好，不管是你的世界

1937
01:13:36,400 --> 01:13:41,350
想要打印是按照定义输入的 

1938
01:13:38,380 --> 01:13:45,280
to printf printf返回一个值

1939
01:13:41,350 --> 01:13:47,020
到目前为止， 它确实做了一些事情 

1940
01:13:45,280 --> 01:13:48,550
屏幕肯定像打印的东西 

1941
01:13:47,020 --> 01:13:50,830
屏幕， 但我们没有 看到它返回 

1942
01:13:48,550 --> 01:13:51,219
因为我们还没有看到 它 

1943
01:13:50,830 --> 01:13:53,110
同 

1944
01:13:51,219 --> 01:13:54,760
等号 左边 的 ，现在事实证明 

1945
01:13:53,110 --> 01:13:56,890
printf确实返回的东西 不是 

1946
01:13:54,760 --> 01:13:58,420
通常有用，但我们 只是 

1947
01:13:56,890 --> 01:13:59,949
目前看到的打印机正在服用

1948
01:13:58,420 --> 01:14:01,960
在另一个时间输入更多

1949
01:13:59,949 --> 01:14:07,570
getstring同时带来了

1950
01:14:01,960 --> 01:14:09,610
只输入一个输入

1951
01:14:07,570 --> 01:14:11,170
提示您 想要的人看 

1952
01:14:09,610 --> 01:14:11,560
我用的第一个提示是你的 

1953
01:14:11,170 --> 01:14:13,000
名称

1954
01:14:11,560 --> 01:14:14,260
我可以提出任何提示，但是

1955
01:14:13,000 --> 01:14:15,520
这就是问题所在 

1956
01:14:14,260 --> 01:14:18,310
因为 在回归期间得到了 

1957
01:14:15,520 --> 01:14:20,469
这当然是值得的 

1958
01:14:18,310 --> 01:14:22,390
划伤称为答案硬编码 他的 

1959
01:14:20,469 --> 01:14:23,800
回答我们可以将它存储在任何变量中 

1960
01:14:22,390 --> 01:14:26,530
我们想要让我继续前进 

1961
01:14:23,800 --> 01:14:27,940
执行这个程序 Aaron去找我一个 

1962
01:14:26,530 --> 01:14:40,120
串起来问那个人他们 是 什么 

1963
01:14:27,940 --> 01:14:42,550
这么说，所以她写下了伊丽莎白 

1964
01:14:40,120 --> 01:14:44,140
现在，但亚伦接受了 我的意见 

1965
01:14:42,550 --> 01:14:45,100
亚伦去找某人的名字并问他们 

1966
01:14:44,140 --> 01:14:48,070
他们的名字是什么， 现在你已经 

1967
01:14:45,100 --> 01:14:49,420
为我产生的输出谢谢你 

1968
01:14:48,070 --> 01:14:50,650
存储值 的返回 值 

1969
01:14:49,420 --> 01:14:52,270
伊丽莎白和我 要继续前进 

1970
01:14:50,650 --> 01:14:53,650
把它塞进名为name的变量中 

1971
01:14:52,270 --> 01:14:55,390
就像 这张纸一样 

1972
01:14:53,650 --> 01:14:58,199
好的Bri​​an 你可以继续说 

1973
01:14:55,390 --> 01:14:58,199
你好， 伊丽莎白 

1974
01:15:08,619 --> 01:15:14,449
好吧那么 这里 发生的事情 我只是 

1975
01:15:12,289 --> 01:15:16,010
做得少就像我一样 

1976
01:15:14,449 --> 01:15:17,239
一直在写这个程序亚伦去得到 

1977
01:15:16,010 --> 01:15:18,739
有人的名字布莱恩可以 打印 

1978
01:15:17,239 --> 01:15:20,570
这就像 我一直在 做的那样 

1979
01:15:18,739 --> 01:15:22,579
做的是编程 只是委托 

1980
01:15:20,570 --> 01:15:23,929
功能到其他功能或在 

1981
01:15:22,579 --> 01:15:25,669
这种情况下其他 知道 如何 做的人 

1982
01:15:23,929 --> 01:15:27,679
这样做，说实话， 我不知道 

1983
01:15:25,669 --> 01:15:29,749
要知道亚伦是如何得到这个名字的

1984
01:15:27,679 --> 01:15:31,669
得到它我不必知道布莱恩 

1985
01:15:29,749 --> 01:15:33,649
以那种特殊的风格写道

1986
01:15:31,669 --> 01:15:36,079
英语的 屏幕 上 我只知道 

1987
01:15:33,649 --> 01:15:38,209
他能做到，现在我的计划是 

1988
01:15:36,079 --> 01:15:41,269
完成非常感谢你 到 两个 

1989
01:15:38,209 --> 01:15:44,030
这两个 将继续 只是一个 

1990
01:15:41,269 --> 01:15:45,709
所以这一刻我们一直如此 

1991
01:15:44,030 --> 01:15:48,019
对一直以来 深信不疑的是，我们 有一个 

1992
01:15:45,709 --> 01:15:50,149
我们可以执行的实际计算机

1993
01:15:48,019 --> 01:15:51,739
代码，我一直说Intel Inside cuz 

1994
01:15:50,149 --> 01:15:54,679
那是你那种愚蠢的口号 

1995
01:15:51,739 --> 01:15:56,329
看看大多数Mac和PC的内部 

1996
01:15:54,679 --> 01:15:58,399
他们有硬件，但CPU只是 

1997
01:15:56,329 --> 01:16:00,260
计算机的大脑和 

1998
01:15:58,399 --> 01:16:01,909
一天结束时回想起目​​标是 

1999
01:16:00,260 --> 01:16:04,550
实际上有计算机转 

2000
01:16:01,909 --> 01:16:07,429
像这个 源代码的 东西 

2001
01:16:04,550 --> 01:16:10,129
实际的机器代码零和一个和 

2002
01:16:07,429 --> 01:16:11,599
所有 clang实际上都 在为此而努力 

2003
01:16:10,129 --> 01:16:13,369
我们当然只是抓了

2004
01:16:11,599 --> 01:16:14,479
现在我们可以做到的表面 

2005
01:16:13,369 --> 01:16:16,550
事实证明那不仅仅是 

2006
01:16:14,479 --> 01:16:19,789
这些命令 我们可以运行，但其他 

2007
01:16:16,550 --> 01:16:21,590
C的特征， 特别是cs50 

2008
01:16:19,789 --> 01:16:23,119
图书馆我们 到目前为止 只看到 了如何 

2009
01:16:21,590 --> 01:16:24,619
得到一个字符串， 但你可以得到整数 

2010
01:16:23,119 --> 01:16:26,269
和人物和时髦的东西

2011
01:16:24,619 --> 01:16:28,219
实际打开的浮动和双打

2012
01:16:26,269 --> 01:16:30,199
可作为两个问题的蠕虫病毒 ，可以 

2013
01:16:28,219 --> 01:16:31,909
发生在电脑 和原来 

2014
01:16:30,199 --> 01:16:33,709
你可以存储不同 类型的 

2015
01:16:31,909 --> 01:16:36,499
变量不仅仅是整数和字符串 

2016
01:16:33,709 --> 01:16:38,090
但布尔和布尔的布尔为 

2017
01:16:36,499 --> 01:16:40,459
你可以格式化这些字符

2018
01:16:38,090 --> 01:16:42,649
printf中的东西我们只见过％ I a 

2019
01:16:40,459 --> 01:16:45,169
％s 我提到了 我之前的 百分比 

2020
01:16:42,649 --> 01:16:46,820
但还有其他几个，但我们已经

2021
01:16:45,169 --> 01:16:48,469
这里有很多可能性但是 

2022
01:16:46,820 --> 01:16:49,879
让我们继续，然后说 5分钟吧 

2023
01:16:48,469 --> 01:16:51,530
打破给大家 一点喘息的机会 

2024
01:16:49,879 --> 01:16:53,179
打开一些 音乐，然后 五 点回来 

2025
01:16:51,530 --> 01:16:58,639
并深入到更复杂的潜水

2026
01:16:53,179 --> 01:17:01,280
C中的程序好吧所以回想起我们开始了 

2027
01:16:58,639 --> 01:17:02,719
通过比较一些刮擦块

2028
01:17:01,280 --> 01:17:05,030
相应的C代码，但我们没有 

2029
01:17:02,719 --> 01:17:07,070
实际上在C中使用了大多数这些块 

2030
01:17:05,030 --> 01:17:09,109
然而，让我们 尝试一些 

2031
01:17:07,070 --> 01:17:11,030
其中一些我将写在上面的例子 

2032
01:17:09,109 --> 01:17:12,559
飞 码打字代码自己出去 

2033
01:17:11,030 --> 01:17:13,760
键盘其中一些我们已经拥有 

2034
01:17:12,559 --> 01:17:15,829
在课程网站上 ，我们可以 

2035
01:17:13,760 --> 01:17:17,179
打开它们以节省一些时间， 但让我 

2036
01:17:15,829 --> 01:17:17,870
只是提请你注意 cs50 

2037
01:17:17,179 --> 01:17:19,400
砂箱

2038
01:17:17,870 --> 01:17:21,680
因为这是我跳过的步骤 

2039
01:17:19,400 --> 01:17:24,050
在早期的 cs50沙箱可以用来 

2040
01:17:21,680 --> 01:17:25,760
一串语言的程序将 

2041
01:17:24,050 --> 01:17:28,820
最初在学期使用它为C 

2042
01:17:25,760 --> 01:17:30,500
但如果您之前 或 之前编写过PI Java 

2043
01:17:28,820 --> 01:17:33,230
Python 或任何 数量 的语言 时 

2044
01:17:30,500 --> 01:17:34,640
你去沙盘 关于cs50点 IO你 

2045
01:17:33,230 --> 01:17:35,990
可以简单地选择你想要的语言 

2046
01:17:34,640 --> 01:17:38,180
写入然后写入底部 

2047
01:17:35,990 --> 01:17:40,280
你会看到 ，你可以指定的名称 

2048
01:17:38,180 --> 01:17:42,530
您要预先创建的文件 

2049
01:17:40,280 --> 01:17:44,810
我之前做过的就是我 

2050
01:17:42,530 --> 01:17:47,090
在顶部 选择 C，然后在底部 选择 C. 

2051
01:17:44,810 --> 01:17:48,710
我输入了hello dot C，因为那是 

2052
01:17:47,090 --> 01:17:50,270
我想要的文件的名称然后我 

2053
01:17:48,710 --> 01:17:52,580
点击开始，这是什么导致我

2054
01:17:50,270 --> 01:17:55,190
正是我们的界面

2055
01:17:52,580 --> 01:17:57,290
刚刚写了一个hello dot C. 

2056
01:17:55,190 --> 01:17:59,480
我的代码编辑器出现在顶部 

2057
01:17:57,290 --> 01:18:01,100
这里我的终端窗口 出现在 

2058
01:17:59,480 --> 01:18:03,170
底部，然后我被允许 

2059
01:18:01,100 --> 01:18:04,910
开始编写代码， 这样我们 就得到了 

2060
01:18:03,170 --> 01:18:06,200
我们 在 哪里 ，如果你想 

2061
01:18:04,910 --> 01:18:08,090
现在跟着 其中的一些 

2062
01:18:06,200 --> 01:18:10,070
示例请注意课程 

2063
01:18:08,090 --> 01:18:12,140
网站，我们所有的 人 都 预先制作 和 

2064
01:18:10,070 --> 01:18:14,120
你可以实际 点击这个链接 

2065
01:18:12,140 --> 01:18:16,130
在课程网站上打开你的 

2066
01:18:14,120 --> 01:18:17,690
拥有该代码的沙盒的副本 

2067
01:18:16,130 --> 01:18:19,250
如果Wi-Fi合作，欢迎你 

2068
01:18:17,690 --> 01:18:21,140
修补，玩耍和运行相同 

2069
01:18:19,250 --> 01:18:22,850
命令， 但一切也在 

2070
01:18:21,140 --> 01:18:24,890
之后的课程 网站 ，所以你不需要 

2071
01:18:22,850 --> 01:18:26,360
输入所有内容， 让我们继续吧 

2072
01:18:24,890 --> 01:18:28,820
我只想做一个 简单的例子 

2073
01:18:26,360 --> 01:18:31,310
这样称为int dot C就是这样我们可以 

2074
01:18:28,820 --> 01:18:33,770
强化我们做的一些事情 

2075
01:18:31,310 --> 01:18:35,720
片刻之前，而不是 像 一个字符串 

2076
01:18:33,770 --> 01:18:39,230
我们用Hello示例做了让我 走了 

2077
01:18:35,720 --> 01:18:41,240
领先，只是说一个整数和 

2078
01:18:39,230 --> 01:18:43,460
然后打印出来 ， 就像 我们没有打印 

2079
01:18:41,240 --> 01:18:44,900
这个名字所以我必须继续 前进 

2080
01:18:43,460 --> 01:18:46,670
只是通过肌肉 记忆 我有点 

2081
01:18:44,900 --> 01:18:49,460
记住我需要标准的i / o 点H 

2082
01:18:46,670 --> 01:18:53,180
在顶部然后是int main void和

2083
01:18:49,460 --> 01:18:55,460
然后花括号然后 我可以做 

2084
01:18:53,180 --> 01:18:56,810
实际得到 输入的行为

2085
01:18:55,460 --> 01:18:58,520
在调用之前有一个函数 

2086
01:18:56,810 --> 01:19:00,170
在那里，另一个是另一回事 

2087
01:18:58,520 --> 01:19:01,880
如果你愿意，可以 调用get int函数

2088
01:19:00,170 --> 01:19:03,680
得到一个整数， 所以 我可以实际调用 

2089
01:19:01,880 --> 01:19:05,720
得到int 我可以说类似的东西 

2090
01:19:03,680 --> 01:19:06,890
整数是嘿人类的提示 

2091
01:19:05,720 --> 01:19:08,870
请给我一个整数

2092
01:19:06,890 --> 01:19:11,090
我需要一个分号在 本月底 

2093
01:19:08,870 --> 01:19:14,780
行，然后我如何实际存储 

2094
01:19:11,090 --> 01:19:16,880
get 中的get int的返回值

2095
01:19:14,780 --> 01:19:18,530
就像 亚伦递给我一张纸一样 

2096
01:19:16,880 --> 01:19:19,790
用字符串的纸如何，如果 我 

2097
01:19:18,530 --> 01:19:23,420
递了一张带有号码的纸

2098
01:19:19,790 --> 01:19:27,010
我该怎么把它存放在应该的地方 

2099
01:19:23,420 --> 01:19:29,540
我在字面上输入第5行int 

2100
01:19:27,010 --> 01:19:30,680
空间和数字或其他所以我 

2101
01:19:29,540 --> 01:19:31,760
我会 称它为因为它是一个 

2102
01:19:30,680 --> 01:19:33,830
整数，但我可以称之为num 

2103
01:19:31,760 --> 01:19:36,590
或其他什么， 然后我会去 

2104
01:19:33,830 --> 01:19:39,760
进取， 打印出来，以便让我们的printf的 

2105
01:19:36,590 --> 01:19:43,550
说一下像你好我反斜杠n 

2106
01:19:39,760 --> 01:19:44,990
分号好吧 不太 正确吧 

2107
01:19:43,550 --> 01:19:47,300
这将打字打招呼 

2108
01:19:44,990 --> 01:19:48,650
逗号我怎么实际替代 

2109
01:19:47,300 --> 01:19:50,390
好东西，我们只看到了如何 

2110
01:19:48,650 --> 01:19:53,450
用两根弦代替， 但我想我 

2111
01:19:50,390 --> 01:19:55,640
早些时候被宠坏了我的那个答案

2112
01:19:53,450 --> 01:19:57,530
嘿计算机 在这里放一个整数 

2113
01:19:55,640 --> 01:20:00,890
然后我需要第二个参数 

2114
01:19:57,530 --> 01:20:04,850
printf的，就像我们递交 的 布赖恩 

2115
01:20:00,890 --> 01:20:07,280
参数，以及和我说 我 我要 

2116
01:20:04,850 --> 01:20:09,410
我在这里说，但这个程序 并不完全 

2117
01:20:07,280 --> 01:20:11,690
正确但它在一个名为dot的文件中 

2118
01:20:09,410 --> 01:20:14,240
C我已经包含了标准IO点H. 

2119
01:20:11,690 --> 01:20:15,650
在主要的，所以今天做得很好

2120
01:20:14,240 --> 01:20:18,710
我们在很大程度上会挥手

2121
01:20:15,650 --> 01:20:20,510
那个但是主要的虚空也许是 

2122
01:20:18,710 --> 01:20:22,250
最神秘的方式，你可以说

2123
01:20:20,510 --> 01:20:24,050
相当于点击绿色标志时 

2124
01:20:22,250 --> 01:20:25,850
就像这一切，我们会来 

2125
01:20:24,050 --> 01:20:27,980
在接下来的几个星期里，为什么会这样 

2126
01:20:25,850 --> 01:20:29,960
为什么它是五月， 为什么 它是无效的但是 

2127
01:20:27,980 --> 01:20:31,010
现在人类几年前就决定了 

2128
01:20:29,960 --> 01:20:33,080
当你写在C 程序 

2129
01:20:31,010 --> 01:20:35,450
而要启动的程序 关闭 

2130
01:20:33,080 --> 01:20:37,340
你必须 要输入int main void 

2131
01:20:35,450 --> 01:20:38,870
那些卷曲的括号 

2132
01:20:37,340 --> 01:20:40,880
大括号， 它等同 于 

2133
01:20:38,870 --> 01:20:43,070
点击绿旗时划伤但是

2134
01:20:40,880 --> 01:20:44,510
这个程序不会编译而且我 

2135
01:20:43,070 --> 01:20:45,740
甚至 不想诱发压力 

2136
01:20:44,510 --> 01:20:48,800
喜欢看到那些错误我该如何避免 

2137
01:20:45,740 --> 01:20:52,070
是的我需要教电脑 

2138
01:20:48,800 --> 01:20:54,080
是那些 获得INT存在，我知道该怎么做 

2139
01:20:52,070 --> 01:20:56,510
从 之前 包括 

2140
01:20:54,080 --> 01:20:59,210
所谓的cs50库技术上是cs50 

2141
01:20:56,510 --> 01:21:01,730
点H是头文件点H的意思 

2142
01:20:59,210 --> 01:21:03,590
标题，它只是一个包含C的文件 

2143
01:21:01,730 --> 01:21:05,540
创建函数的代码

2144
01:21:03,590 --> 01:21:07,640
更多关于另一次，但那 只是 

2145
01:21:05,540 --> 01:21:09,170
如果我有，我们可以访问printf 

2146
01:21:07,640 --> 01:21:11,030
我不应该做任何错别字 

2147
01:21:09,170 --> 01:21:15,500
通过运行什么来编译这个程序

2148
01:21:11,030 --> 01:21:17,870
命令make int 我可以做clang I 

2149
01:21:15,500 --> 01:21:19,790
可以做铿锵 - 但是现在我是 

2150
01:21:17,870 --> 01:21:22,460
要做得更简单只会使int 

2151
01:21:19,790 --> 01:21:24,890
让使自动化的过程 

2152
01:21:22,460 --> 01:21:27,770
编译此程序没有错误消息 

2153
01:21:24,890 --> 01:21:29,750
很好，让我继续前进， 放大点 

2154
01:21:27,770 --> 01:21:30,830
slash int我认为会运行该程序 

2155
01:21:29,750 --> 01:21:34,490
整数 

2156
01:21:30,830 --> 01:21:36,080
怎么样42你好42 并注意到我可以 

2157
01:21:34,490 --> 01:21:37,970
现在节省时间，如果我想运行它 

2158
01:21:36,080 --> 01:21:39,530
我又没有做点 斜线 成 

2159
01:21:37,970 --> 01:21:41,780
一直以来都 证明了这一点 

2160
01:21:39,530 --> 01:21:43,460
这种操作的Linux环境 

2161
01:21:41,780 --> 01:21:45,620
系统称为 Linux你 真的可以去 

2162
01:21:43,460 --> 01:21:46,880
上下，看看上一个命令 

2163
01:21:45,620 --> 01:21:48,710
你输入的和其他一些有 

2164
01:21:46,880 --> 01:21:50,660
啜饮是 系统特定的 

2165
01:21:48,710 --> 01:21:52,640
如果你只是按了然后输入就可以了 

2166
01:21:50,660 --> 01:21:54,710
再次运行它 输入 50这个时间 

2167
01:21:52,640 --> 01:21:56,780
另见输出 

2168
01:21:54,710 --> 01:22:00,530
好吧所以任何问题然后 只是一个 

2169
01:21:56,780 --> 01:22:02,180
像这样的例子让我走了 

2170
01:22:00,530 --> 01:22:03,770
未来， 我将节省 时间 

2171
01:22:02,180 --> 01:22:06,320
环境我 实际上可以创建文件 

2172
01:22:03,770 --> 01:22:08,840
如果我想点击该文件夹在这里

2173
01:22:06,320 --> 01:22:10,280
图标点击 加号，然后我可以 

2174
01:22:08,840 --> 01:22:11,870
实际上说给 我一个名为float的文件 

2175
01:22:10,280 --> 01:22:13,610
点保存所以这相当于去 

2176
01:22:11,870 --> 01:22:14,630
回到 主菜单 ，并在打字 

2177
01:22:13,610 --> 01:22:16,010
我要做的文件的 名称 

2178
01:22:14,630 --> 01:22:17,540
现在更快 一点了 

2179
01:22:16,010 --> 01:22:19,550
图形环境，我想打电话

2180
01:22:17,540 --> 01:22:21,590
它 漂浮点 C它有点奇怪 

2181
01:22:19,550 --> 01:22:23,270
因为至少上升你的名字

2182
01:22:21,590 --> 01:22:25,640
可能学到了关于整数的知识 

2183
01:22:23,270 --> 01:22:27,500
你可能已经 了解了实数 

2184
01:22:25,640 --> 01:22:28,790
数字可以有小数点和 

2185
01:22:27,500 --> 01:22:30,200
然后在小数点后的事情

2186
01:22:28,790 --> 01:22:32,480
用十进制计算机那些东西

2187
01:22:30,200 --> 01:22:34,580
点称为浮点值 

2188
01:22:32,480 --> 01:22:36,440
或漂浮，你可以把它想象成 

2189
01:22:34,580 --> 01:22:37,850
小数点可以种浮到 

2190
01:22:36,440 --> 01:22:39,560
左边或右边 取决于多大 

2191
01:22:37,850 --> 01:22:41,510
或者数字 是多少或多精确 

2192
01:22:39,560 --> 01:22:43,610
小数点后面的数字是 

2193
01:22:41,510 --> 01:22:45,880
这是一个浮动，所以让我继续前进 ， 

2194
01:22:43,610 --> 01:22:50,660
实现一个 非常类似的程序包括 

2195
01:22:45,880 --> 01:22:52,730
cs50.h包括标准的IOH int main 

2196
01:22:50,660 --> 01:22:54,020
这是经过20年的努力 

2197
01:22:52,730 --> 01:22:56,960
这样你就可以这么快就完成 

2198
01:22:54,020 --> 01:22:59,330
现在让我换个浮子 

2199
01:22:56,960 --> 01:23:01,190
用户如此真实的数字可能 非常好 

2200
01:22:59,330 --> 01:23:03,380
有一个小数点我会 做的 

2201
01:23:01,190 --> 01:23:05,330
有点不同我会 放大 

2202
01:23:03,380 --> 01:23:08,300
我会说嘿电脑 给我一个 

2203
01:23:05,330 --> 01:23:10,940
float as是名为not int的数据类型 

2204
01:23:08,300 --> 01:23:12,500
不是字符串而是浮动我会称之为F 

2205
01:23:10,940 --> 01:23:15,670
因为这听起来像浮动而且它是 

2206
01:23:12,500 --> 01:23:18,290
漂亮而简洁的等于浮动和 

2207
01:23:15,670 --> 01:23:20,000
然后我就会说漂浮就是那个 

2208
01:23:18,290 --> 01:23:21,830
提示我可以提示和绿色 

2209
01:23:20,000 --> 01:23:26,360
我想要的任何东西，现在我要打印 

2210
01:23:21,830 --> 01:23:27,920
它打印F你好F但我不想要FI 

2211
01:23:26,360 --> 01:23:29,750
想要实际打印 一个占位符 

2212
01:23:27,920 --> 01:23:32,740
你 现在 可能猜到了 什么 

2213
01:23:29,750 --> 01:23:38,060
模式是浮点数的百分比F. 

2214
01:23:32,740 --> 01:23:40,100
newline逗号F分号所以这是 

2215
01:23:38,060 --> 01:23:41,960
现在三次像同一个程序一样

2216
01:23:40,100 --> 01:23:43,490
带有int和 float 的字符串 

2217
01:23:41,960 --> 01:23:45,050
但同样只是为了一些肌肉记忆 

2218
01:23:43,490 --> 01:23:46,640
并通过模式，但让我们 

2219
01:23:45,050 --> 01:23:49,430
看看会发生什么不同，让我来吧 

2220
01:23:46,640 --> 01:23:52,250
继续 ，输入make float 输入 ok 

2221
01:23:49,430 --> 01:23:58,880
好没有错误让我放大并运行 

2222
01:23:52,250 --> 01:24:00,230
现在就像点斜线浮动一样 

2223
01:23:58,880 --> 01:24:03,320
让我继续，输入一个数字 

2224
01:24:00,230 --> 01:24:05,120
我只会说42但是电脑 

2225
01:24:03,320 --> 01:24:06,830
现在有能力储存更多 

2226
01:24:05,120 --> 01:24:09,440
精度在它只是 一个整数之前 

2227
01:24:06,830 --> 01:24:11,510
根据int的定义现在它是一个流程 

2228
01:24:09,440 --> 01:24:14,750
即使它非常精确是 40 

2229
01:24:11,510 --> 01:24:17,330
2.000 现在确实是一个真实的数字 

2230
01:24:14,750 --> 01:24:19,969
在那里存储一些精度

2231
01:24:17,330 --> 01:24:22,310
所以事实证明 我们可以 做到 

2232
01:24:19,969 --> 01:24:24,560
更有趣的数学让我继续前进 

2233
01:24:22,310 --> 01:24:26,929
并 提前 打开这个例子 

2234
01:24:24,560 --> 01:24:28,489
这个 将在统计中调用 

2235
01:24:26,929 --> 01:24:31,670
看到我没有必要 输入所有内容 

2236
01:24:28,489 --> 01:24:34,219
在 我们将要看到的 统计数据中 

2237
01:24:31,670 --> 01:24:36,320
一些用我预先编写的代码编写的数学

2238
01:24:34,219 --> 01:24:38,120
创建只是为了强化 你可以 

2239
01:24:36,320 --> 01:24:40,040
实际上在做一些基本的算术 

2240
01:24:38,120 --> 01:24:41,989
程序我可以看到更多的代码 

2241
01:24:40,040 --> 01:24:43,760
这里只需 向下滚动即可让我 

2242
01:24:41,989 --> 01:24:45,620
向上滚动，以便我们可以专注于主要 

2243
01:24:43,760 --> 01:24:48,380
让我放大 最初几 

2244
01:24:45,620 --> 01:24:49,969
第一行的线路我就是这样 

2245
01:24:48,380 --> 01:24:51,469
获得一个int，我称之为X. 

2246
01:24:49,969 --> 01:24:52,820
我们没有使用 名为X 的变量 

2247
01:24:51,469 --> 01:24:55,310
最近但现在我们不是 

2248
01:24:52,820 --> 01:24:57,050
比以前这里不同逻辑

2249
01:24:55,310 --> 01:24:58,550
给我另一个变量，所以我们可以看到 

2250
01:24:57,050 --> 01:24:59,989
既然你可以得到 多个变量 

2251
01:24:58,550 --> 01:25:04,280
来自用户 就像在刮擦和 

2252
01:24:59,989 --> 01:25:06,110
现在在这些绿色的线条中只是 

2253
01:25:04,280 --> 01:25:08,750
一些格式字符串就是我想要的 

2254
01:25:06,110 --> 01:25:10,760
printf 来显示我的 字面意思 

2255
01:25:08,750 --> 01:25:14,780
高亮线在这里想给的printf 

2256
01:25:10,760 --> 01:25:15,500
显示X加 y等于什么 

2257
01:25:14,780 --> 01:25:17,870
是那样的 

2258
01:25:15,500 --> 01:25:21,290
请注意printf有什么好玩的 

2259
01:25:17,870 --> 01:25:23,120
在输入之前传递给你 

2260
01:25:21,290 --> 01:25:24,380
可以执行简单的算术 运算 

2261
01:25:23,120 --> 01:25:26,960
所以如果你想把x和y加在一起

2262
01:25:24,380 --> 01:25:28,550
字面上做X加y然后总和 

2263
01:25:26,960 --> 01:25:30,980
这些数字是得到的 

2264
01:25:28,550 --> 01:25:32,870
交给的printf作为其输入，就像 

2265
01:25:30,980 --> 01:25:35,570
我把亚伦的那张纸交给布莱恩 

2266
01:25:32,870 --> 01:25:38,300
作为输入我不是把x和y 交给 

2267
01:25:35,570 --> 01:25:40,639
Brian在这种情况下，但X加y或一些

2268
01:25:38,300 --> 01:25:43,130
同样 重视实际 总和 

2269
01:25:40,639 --> 01:25:45,469
减法是键盘上的- 

2270
01:25:43,130 --> 01:25:46,400
对于乘法， 它不是X 

2271
01:25:45,469 --> 01:25:49,130
这会不会很奇怪 

2272
01:25:46,400 --> 01:25:51,230
xx Y代替星号或星号 

2273
01:25:49,130 --> 01:25:53,030
键盘划分是 单斜杠 

2274
01:25:51,230 --> 01:25:54,290
然后这个人有点笨拙但是 

2275
01:25:53,030 --> 01:25:56,360
我们会为此提出一些用途 

2276
01:25:54,290 --> 01:25:59,360
你实际上可以进行模运算 

2277
01:25:56,360 --> 01:26:04,820
如果你这样做，或者只是更简单的剩余 

2278
01:25:59,360 --> 01:26:07,040
X ％Y你会得到剩余的 

2279
01:26:04,820 --> 01:26:11,050
将X除以Y ，其余是什么 

2280
01:26:07,040 --> 01:26:14,860
所以如果螺母是X是20而Y是 

2281
01:26:11,050 --> 01:26:16,690
那么20/10 完全进入两次 

2282
01:26:14,860 --> 01:26:18,489
例如，余数为零 

2283
01:26:16,690 --> 01:26:21,369
一会儿就注意到 了 什么是好奇的 

2284
01:26:18,489 --> 01:26:22,900
在这种情况下， 百分比不是 一个 

2285
01:26:21,369 --> 01:26:24,760
占位符不是百分比，因为它不是 

2286
01:26:22,900 --> 01:26:27,579
％i  - 它不是百分比F 注意到它 

2287
01:26:24,760 --> 01:26:30,099
不在printf格式字符串里面这个 

2288
01:26:27,579 --> 01:26:32,050
只是 数学上的数学运算符 

2289
01:26:30,099 --> 01:26:32,739
正如 不同颜色 所 暗示的那样 

2290
01:26:32,050 --> 01:26:34,449
蓝色那里 

2291
01:26:32,739 --> 01:26:36,670
所以如果实际运行这个让我们继续吧 

2292
01:26:34,449 --> 01:26:38,559
并运行这个程序我会继续 

2293
01:26:36,670 --> 01:26:40,929
和门，使int 复数，因为 

2294
01:26:38,559 --> 01:26:44,440
那是输入dot的文件名

2295
01:26:40,929 --> 01:26:48,130
斜线int 并让我放大并清除 

2296
01:26:44,440 --> 01:26:55,000
屏幕输入 给我一个二号我 

2297
01:26:48,130 --> 01:26:57,579
听到了另外 10个 没有听到的，因此10月10日 

2298
01:26:55,000 --> 01:27:03,579
a 2加10是12 2减10是负数 

2299
01:26:57,579 --> 01:27:07,059
8 2次10 是20 2除以10到 

2300
01:27:03,579 --> 01:27:09,190
mod y或2然后 取余数 

2301
01:27:07,059 --> 01:27:12,670
当除以y时 ，mod意味着什么 

2302
01:27:09,190 --> 01:27:18,210
2分，所以我得到了5分中的4分 

2303
01:27:12,670 --> 01:27:18,210
正确性这里有点时髦 

2304
01:27:18,329 --> 01:27:26,800
是的，这就像2/10，就像我很漂亮 

2305
01:27:23,980 --> 01:27:28,989
确定这就像是2/10或者可能是1/5或者 

2306
01:27:26,800 --> 01:27:31,360
第二点我的意思是我会 采取任何数量 

2307
01:27:28,989 --> 01:27:33,309
答案但不是零，所以发生了什么 

2308
01:27:31,360 --> 01:27:35,110
这是一个代表问题 

2309
01:27:33,309 --> 01:27:37,570
事实证明， 我们在计算机程序中

2310
01:27:35,110 --> 01:27:39,790
事先决定我要存储 intz 

2311
01:27:37,570 --> 01:27:41,860
好的 ，没有的 东西 

2312
01:27:39,790 --> 01:27:44,559
一个小数点 ，但我在这里，而 

2313
01:27:41,860 --> 01:27:46,989
肆无忌惮地试图去做 

2314
01:27:44,559 --> 01:27:49,000
整数除以10 和整数和 

2315
01:27:46,989 --> 01:27:51,909
期待除整数以外的东西

2316
01:27:49,000 --> 01:27:54,219
知道我确实在做整数 

2317
01:27:51,909 --> 01:27:56,500
算术 那么什么是电脑 

2318
01:27:54,219 --> 01:27:59,860
显然只做直觉的原因

2319
01:27:56,500 --> 01:28:02,020
当我将X 除以Y时

2320
01:27:59,860 --> 01:28:04,000
在这里或特别是在这里 

2321
01:28:02,020 --> 01:28:09,250
例如你 建议 除以10 

2322
01:28:04,000 --> 01:28:10,570
我的2/10在哪里，是的，是的 

2323
01:28:09,250 --> 01:28:13,389
虽然它在技术上是什么样的

2324
01:28:10,570 --> 01:28:14,920
应该是点2或0.2 好吧 

2325
01:28:13,389 --> 01:28:17,349
实际上这个 解决方案是正确的 

2326
01:28:14,920 --> 01:28:18,909
因为如果它是0.2但整数不能 

2327
01:28:17,349 --> 01:28:21,550
存储小数点或之后的任何内容 

2328
01:28:18,909 --> 01:28:24,130
他们做些什么呢，你已经离开只是 在0 

2329
01:28:21,550 --> 01:28:24,909
开头所以整数运算是 

2330
01:28:24,130 --> 01:28:25,929
好的，如果你的 

2331
01:28:24,909 --> 01:28:27,999
有整数， 但如果你想 

2332
01:28:25,929 --> 01:28:30,400
浮点运算你要去的 

2333
01:28:27,999 --> 01:28:32,349
需要做一些改变，所以我可以 

2334
01:28:30,400 --> 01:28:34,780
事实上让我继续前进 

2335
01:28:32,349 --> 01:28:36,669
在这里 写 一个不同的 程序让我走 

2336
01:28:34,780 --> 01:28:40,329
进取 ， 从课程打通 

2337
01:28:36,669 --> 01:28:43,539
网站浮动 点 C，那将是 

2338
01:28:40,329 --> 01:28:45,820
给我这个例子 

2339
01:28:43,539 --> 01:28:48,550
使用浮点值实现 

2340
01:28:45,820 --> 01:28:49,809
相反，一旦这个加载，我会看到 

2341
01:28:48,550 --> 01:28:51,459
我事先写的一个程序是一个 

2342
01:28:49,809 --> 01:28:53,889
一点点因为现在我只关心 

2343
01:28:51,459 --> 01:28:56,499
关于一个问题 和通知 

2344
01:28:53,889 --> 01:28:58,150
现在x和y 现在浮动而 不是 

2345
01:28:56,499 --> 01:28:59,409
存在的另一种数据类型， 我是 

2346
01:28:58,150 --> 01:29:01,809
使用get浮动也来自 

2347
01:28:59,409 --> 01:29:04,209
cs50 的库然后这行 

2348
01:29:01,809 --> 01:29:05,469
几乎相同，但你知道是什么让我 

2349
01:29:04,209 --> 01:29:08,260
让我调整 一下，让我 来做吧 

2350
01:29:05,469 --> 01:29:09,939
我现在完全一样的 这条线 

2351
01:29:08,260 --> 01:29:12,309
高亮显示的是完全一样的 

2352
01:29:09,939 --> 01:29:13,959
如果我输入 这些相同的话 

2353
01:29:12,309 --> 01:29:18,489
数字，所以让我们继续前进 ， 放大 

2354
01:29:13,959 --> 01:29:19,119
并使浮点数复数和点斜线 

2355
01:29:18,489 --> 01:29:21,369
彩车

2356
01:29:19,119 --> 01:29:25,090
我会给它两个和十个，我应该 

2357
01:29:21,369 --> 01:29:26,590
希望看到现在的零点二

2358
01:29:25,090 --> 01:29:30,939
是的，这很漂亮 

2359
01:29:26,590 --> 01:29:35,559
确切但你知道 我 不想 告诉你 

2360
01:29:30,939 --> 01:29:37,300
你，但让我们看看远一点 它 

2361
01:29:35,559 --> 01:29:39,999
当您执行 百分比 时 ，默认情况下会结果

2362
01:29:37,300 --> 01:29:42,070
你只看到几个小数点 

2363
01:29:39,999 --> 01:29:44,709
它默认看起来只有五个让我 

2364
01:29:42,070 --> 01:29:48,489
再看几点，这就是其中之一 

2365
01:29:44,709 --> 01:29:49,989
这是一个二三四五六 

2366
01:29:48,489 --> 01:29:51,699
小数点后的点，所以你 

2367
01:29:49,989 --> 01:29:53,530
知道我会说什么嘿电脑 

2368
01:29:51,699 --> 01:29:55,300
这看起来 给我 七个小数点 

2369
01:29:53,530 --> 01:29:56,739
完全神秘 ，你只需要 

2370
01:29:55,300 --> 01:29:59,439
有点记住这个，或者查找一下 

2371
01:29:56,739 --> 01:30:01,479
如果你加 点和数字， 你会忘记 

2372
01:29:59,439 --> 01:30:03,159
在 百分比和 F 之间 

2373
01:30:01,479 --> 01:30:05,199
告诉 计算机 的神秘方式 

2374
01:30:03,159 --> 01:30:07,059
给 我看 一个漂浮，但有这么多 

2375
01:30:05,199 --> 01:30:09,099
请小数点，以便 给出 

2376
01:30:07,059 --> 01:30:11,739
我七个小数点的地方很奇怪 

2377
01:30:09,099 --> 01:30:13,389
表达看起来好吗 希望 我 

2378
01:30:11,739 --> 01:30:15,760
只是要看一些零，所以让 我 

2379
01:30:13,389 --> 01:30:17,439
继续做浮漂让我走 

2380
01:30:15,760 --> 01:30:22,650
提前并 放大 并做点斜线 

2381
01:30:17,439 --> 01:30:26,469
漂浮 到十进入还行还是正确的 

2382
01:30:22,650 --> 01:30:29,199
让我有点好奇让我们看看 

2383
01:30:26,469 --> 01:30:31,869
很多像他们中的50个零让我走了 

2384
01:30:29,199 --> 01:30:36,609
在这里， 做浮动，因为 我 

2385
01:30:31,869 --> 01:30:40,749
更改代码点斜线漂浮 太 

2386
01:30:36,609 --> 01:30:45,820
哈哈你的小学老师说谎了 

2387
01:30:40,749 --> 01:30:49,599
对你来说2/10显然不是指向 的 

2388
01:30:45,820 --> 01:30:52,659
零零零零零无限 

2389
01:30:49,599 --> 01:30:55,179
它显然是 0.2零零零 

2390
01:30:52,659 --> 01:30:57,099
零零零二九八 零二 

2391
01:30:55,179 --> 01:30:59,589
三二二三八七 六九 

2392
01:30:57,099 --> 01:31:02,879
五三一二五然后将所有的 

2393
01:30:59,589 --> 01:31:05,739
那些 零到底 是怎么回事 

2394
01:31:02,879 --> 01:31:10,629
哪里是我的错误的错误 

2395
01:31:05,739 --> 01:31:14,530
哪里是我的误解 是什么 

2396
01:31:10,629 --> 01:31:17,139
如果我 说的 话，这个解释很好 

2397
01:31:14,530 --> 01:31:19,809
你的计算机 内部 是 

2398
01:31:17,139 --> 01:31:21,699
像这样的东西这是RAM或内存 

2399
01:31:19,809 --> 01:31:23,709
你 可能一般都知道 这一点 

2400
01:31:21,699 --> 01:31:25,539
想要将文件 存储 到商店的想法

2401
01:31:23,709 --> 01:31:27,219
像你需要记忆的 音乐 和视频 

2402
01:31:25,539 --> 01:31:30,219
某种间隔的硬盘 空间是 

2403
01:31:27,219 --> 01:31:32,229
永久存储RAM或随机访问 

2404
01:31:30,219 --> 01:31:33,939
内存是临时存储所以当你的

2405
01:31:32,229 --> 01:31:35,349
打赌你的笔记本电脑是打开的还是桌面

2406
01:31:33,939 --> 01:31:37,570
计算机打开或手机上电

2407
01:31:35,349 --> 01:31:38,829
你正在为所有程序使用RAM 

2408
01:31:37,570 --> 01:31:41,349
如果你打开 一个， 那么你正在运行

2409
01:31:38,829 --> 01:31:42,879
文件存储在RAM中，但它是 

2410
01:31:41,349 --> 01:31:44,409
永久存储在硬盘上 ，以便 

2411
01:31:42,879 --> 01:31:46,599
有不同 类型的记忆但是 

2412
01:31:44,409 --> 01:31:48,939
请注意，这实际上放大了 

2413
01:31:46,599 --> 01:31:50,769
就像几英寸宽 

2414
01:31:48,939 --> 01:31:52,329
也许一英寸高， 所以它 很小 

2415
01:31:50,769 --> 01:31:54,669
但 它有多大并不重要 

2416
01:31:52,329 --> 01:31:57,099
它只是重要的 ，它是有限的 

2417
01:31:54,669 --> 01:31:59,169
大小必须 在 物理 硬件上 你 

2418
01:31:57,099 --> 01:32:01,719
圈或在你的口袋里或在家里

2419
01:31:59,169 --> 01:32:03,849
只有都这么大了， 因此只有 

2420
01:32:01,719 --> 01:32:06,280
这么多部分， 因此只有这样 

2421
01:32:03,849 --> 01:32:07,959
许多晶体管和其他部分 

2422
01:32:06,280 --> 01:32:10,030
实际上正在做 工作的 硬件 

2423
01:32:07,959 --> 01:32:13,030
存储信息，如果你 

2424
01:32:10,030 --> 01:32:15,280
只有有限 的内存如何 

2425
01:32:13,030 --> 01:32:19,269
我们将代表世界 

2426
01:32:15,280 --> 01:32:20,679
无数 的数字，因为我 

2427
01:32:19,269 --> 01:32:21,820
从小学回忆起 我被教导过 

2428
01:32:20,679 --> 01:32:23,679
有无数的数字 

2429
01:32:21,820 --> 01:32:26,349
当然是 十进制的 实数 

2430
01:32:23,679 --> 01:32:28,359
点可以永远继续下去 

2431
01:32:26,349 --> 01:32:30,280
问题， 如果你想代表所有 

2432
01:32:28,359 --> 01:32:32,919
宇宙中可能存在的数字 

2433
01:32:30,280 --> 01:32:36,909
数量有限的无限多 

2434
01:32:32,919 --> 01:32:38,949
硬件 所以在某个时刻 

2435
01:32:36,909 --> 01:32:41,109
电脑 必须开始削减一些 

2436
01:32:38,949 --> 01:32:43,959
角落 ，所以你真正看到的 

2437
01:32:41,109 --> 01:32:46,479
这里和电脑 一样近 

2438
01:32:43,959 --> 01:32:48,399
为您存储该分数

2439
01:32:46,479 --> 01:32:49,849
确切地说，我有点贪心 

2440
01:32:48,399 --> 01:32:51,499
看起来有点太远了 

2441
01:32:49,849 --> 01:32:53,749
在右边， 并授予这些 

2442
01:32:51,499 --> 01:32:56,329
无限 小，就像价值一样 

2443
01:32:53,749 --> 01:32:58,249
没有太大的关闭，但它已经关闭 

2444
01:32:56,329 --> 01:32:59,899
因为我不能指望电脑 

2445
01:32:58,249 --> 01:33:01,699
端表示的无限数量 

2446
01:32:59,899 --> 01:33:04,189
使用有限数量的 内存的值 

2447
01:33:01,699 --> 01:33:07,909
它在这里有一个圆形或者 

2448
01:33:04,189 --> 01:33:12,739
那里是不精确这么说 也是如此 

2449
01:33:07,909 --> 01:33:14,030
这是一个 问题我的意思是我，我们永远 不会 

2450
01:33:12,739 --> 01:33:15,559
如果我没有得到这个已经知道了 

2451
01:33:14,030 --> 01:33:16,939
贪心，看了 50位小数 

2452
01:33:15,559 --> 01:33:22,729
而不是 七已经 

2453
01:33:16,939 --> 01:33:29,809
非常精确这是一个问题是啊 

2454
01:33:22,729 --> 01:33:31,789
很好，为什么为什么这是一个好的 

2455
01:33:29,809 --> 01:33:33,679
逻辑上，如果我开始使用等于 等于 

2456
01:33:31,789 --> 01:33:35,269
为了比较平等， 我要去做 

2457
01:33:33,679 --> 01:33:37,429
是这会是真的很难， 我 

2458
01:33:35,269 --> 01:33:39,229
曾经比较东西 十分之二 为 

2459
01:33:37,429 --> 01:33:41,030
它的价值因为我 会字面意思 

2460
01:33:39,229 --> 01:33:42,499
必须要记住或写下或 

2461
01:33:41,030 --> 01:33:44,239
弄清楚 这个值 和比较 

2462
01:33:42,499 --> 01:33:46,010
反对，而不仅仅是 比较 更多 

2463
01:33:44,239 --> 01:33:48,199
松散地反对第二点， 那就是 

2464
01:33:46,010 --> 01:33:49,820
你真的应该永远不要比较 

2465
01:33:48,199 --> 01:33:51,829
代码中的浮点值

2466
01:33:49,820 --> 01:33:54,439
平等我 可能会逃脱 

2467
01:33:51,829 --> 01:33:55,729
小于或大于 但 即便如此 

2468
01:33:54,439 --> 01:33:59,359
它会离我有点偏离 

2469
01:33:55,729 --> 01:34:04,489
期待为什么这可能不精确

2470
01:33:59,359 --> 01:34:06,649
如果你不想要，那就太烦人了

2471
01:34:04,489 --> 01:34:08,629
你的电脑不精确是什么 

2472
01:34:06,649 --> 01:34:12,709
域名之外的世界 

2473
01:34:08,629 --> 01:34:15,530
教室是的，是的，是的 

2474
01:34:12,709 --> 01:34:18,409
火箭队就在那里有任何涉及 

2475
01:34:15,530 --> 01:34:20,719
数学和物理以及和你一样的危险 

2476
01:34:18,409 --> 01:34:22,249
不希望数字如此

2477
01:34:20,719 --> 01:34:23,899
稍稍关闭，如果你考虑 一下 

2478
01:34:22,249 --> 01:34:25,760
火箭队是一个很好的例子，因为 我 

2479
01:34:23,899 --> 01:34:27,320
对火箭队 不太了解， 但 我知道 

2480
01:34:25,760 --> 01:34:28,879
他们走得很快，而且很可能 

2481
01:34:27,320 --> 01:34:30,439
喜欢角度， 因为 你是 

2482
01:34:28,879 --> 01:34:32,300
试图让他们保持在轨道上 

2483
01:34:30,439 --> 01:34:33,800
这很好， 但如果你的轨迹 是 

2484
01:34:32,300 --> 01:34:35,840
一点点关闭和东西 

2485
01:34:33,800 --> 01:34:37,219
去 那么 快那么远你 

2486
01:34:35,840 --> 01:34:39,619
我知道我很确定 

2487
01:34:37,219 --> 01:34:41,389
最终那些小小的不精确 

2488
01:34:39,619 --> 01:34:43,639
开始加起来，确实有 

2489
01:34:41,389 --> 01:34:45,739
历史事件两个事件在哪里 

2490
01:34:43,639 --> 01:34:47,689
事实上，那种不精确

2491
01:34:45,739 --> 01:34:50,239
加上军国主义的领域 

2492
01:34:47,689 --> 01:34:51,679
运营或财务运营

2493
01:34:50,239 --> 01:34:53,419
事实上，如果你曾见过办公空间或 

2494
01:34:51,679 --> 01:34:54,829
回来的时候就像超人一样喜欢 

2495
01:34:53,419 --> 01:34:57,739
这就是有些 人 赚钱的方式 

2496
01:34:54,829 --> 01:34:59,719
因为他们只是保持了一切 

2497
01:34:57,739 --> 01:35:01,459
该便士 的馏分 计算机 

2498
01:34:59,719 --> 01:35:03,230
系统，我们只是忽略和 

2499
01:35:01,459 --> 01:35:05,180
最终他们开始加起来

2500
01:35:03,230 --> 01:35:07,400
任何时候你都有 长话短说 

2501
01:35:05,180 --> 01:35:10,040
科学的， 金融的或任何形式的 

2502
01:35:07,400 --> 01:35:12,380
涉及 大数字的大型数据集 

2503
01:35:10,040 --> 01:35:14,180
很多 时候这很多 都是 

2504
01:35:12,380 --> 01:35:15,739
一个问题 ，它几乎暗示着你 

2505
01:35:14,180 --> 01:35:18,050
难道你不应该看到她， 更不用说了 

2506
01:35:15,739 --> 01:35:20,150
计算机除非我们真正解决 

2507
01:35:18,050 --> 01:35:21,770
这现在作为人类的破坏者

2508
01:35:20,150 --> 01:35:24,860
切断了这个 问题 ，你可以 

2509
01:35:21,770 --> 01:35:26,600
使用越来越多的位 但不是 

2510
01:35:24,860 --> 01:35:28,550
在某些方面你无限多位 

2511
01:35:26,600 --> 01:35:29,960
必须 画一条线， 但这就是为什么 

2512
01:35:28,550 --> 01:35:31,670
例如证券交易所可能只 

2513
01:35:29,960 --> 01:35:33,050
代表两个小数点

2514
01:35:31,670 --> 01:35:34,700
精度 美元或也许对 

2515
01:35:33,050 --> 01:35:36,650
小数点到千 位 

2516
01:35:34,700 --> 01:35:38,480
美元和美分， 他们只是 

2517
01:35:36,650 --> 01:35:40,010
决定我们的精确度 

2518
01:35:38,480 --> 01:35:42,080
实际上可以存储，但你已经存在 

2519
01:35:40,010 --> 01:35:44,120
必须决定如何处理它 而不是 

2520
01:35:42,080 --> 01:35:46,220
只是忽略了问题，但我们 可以做到 

2521
01:35:44,120 --> 01:35:48,739
你 知道 结果会 变得 更好 

2522
01:35:46,220 --> 01:35:50,510
在大多数计算机上运行它需要 

2523
01:35:48,739 --> 01:35:53,840
是的，有限的空间，但非常 

2524
01:35:50,510 --> 01:35:57,140
特别是32位空间或4个字节 

2525
01:35:53,840 --> 01:35:59,000
字节调用是 8位，所以 4字节 是32 

2526
01:35:57,140 --> 01:36:01,040
比特， 这只是一个非常常见的单位 

2527
01:35:59,000 --> 01:36:03,710
测量， 但还有另一个 转弯 

2528
01:36:01,040 --> 01:36:05,960
如果你想要两倍的比特你出去

2529
01:36:03,710 --> 01:36:08,870
可以逐字地使用一个名为的数据类型 

2530
01:36:05,960 --> 01:36:10,489
双重，在cs50 库中有 

2531
01:36:08,870 --> 01:36:13,400
调用的函数有一个函数 

2532
01:36:10,489 --> 01:36:14,420
所谓获得双倍，如果我继续前进 ， 

2533
01:36:13,400 --> 01:36:17,420
在这里做

2534
01:36:14,420 --> 01:36:18,500
我现在可以重新编译这个代码make 

2535
01:36:17,420 --> 01:36:21,230
即使他们不是，也要漂浮

2536
01:36:18,500 --> 01:36:22,670
技术上浮动类型了，让 

2537
01:36:21,230 --> 01:36:26,390
我继续做点斜线浮标 

2538
01:36:22,670 --> 01:36:30,200
输入并让我输入两个和十个和 

2539
01:36:26,390 --> 01:36:32,330
现在它仍然不精确但通知 

2540
01:36:30,200 --> 01:36:35,660
而不是我认为我 的七个 零 

2541
01:36:32,330 --> 01:36:39,560
之前我有1 2 3 4 5 6 7 8 

2542
01:36:35,660 --> 01:36:41,450
9 10 11 12 13 14 15 零，所以我很善良 

2543
01:36:39,560 --> 01:36:43,730
把问题进一步推出 去了 

2544
01:36:41,450 --> 01:36:44,300
这样说它更精确 但 不是 

2545
01:36:43,730 --> 01:36:46,460
完善

2546
01:36:44,300 --> 01:36:48,800
如果你不能得到某些完美的价值 

2547
01:36:46,460 --> 01:36:52,810
希望能够代表 无限 

2548
01:36:48,800 --> 01:36:55,220
对此有 任何疑问 

2549
01:36:52,810 --> 01:36:58,030
我们会回过头来看一些含义 

2550
01:36:55,220 --> 01:36:58,030
是啊 

2551
01:37:00,010 --> 01:37:03,350
好的问题，如果我们总是做得更好 

2552
01:37:02,120 --> 01:37:05,690
使用双打， 因为他们更多 

2553
01:37:03,350 --> 01:37:07,159
确切的简短回答是， 但 我们会 

2554
01:37:05,690 --> 01:37:08,510
请参阅本课程的主题

2555
01:37:07,159 --> 01:37:10,550
计算机科学更普遍 有 

2556
01:37:08,510 --> 01:37:13,130
总是需要权衡， 如果你使用的 是肯定 的 

2557
01:37:10,550 --> 01:37:15,290
加倍你会避免这个问题 

2558
01:37:13,130 --> 01:37:16,090
更多， 但你 会支付 多少价格 

2559
01:37:15,290 --> 01:37:18,230
说话

2560
01:37:16,090 --> 01:37:19,670
可能是处理能力，因为它有 

2561
01:37:18,230 --> 01:37:23,060
喜欢一次处理更多比特 

2562
01:37:19,670 --> 01:37:24,800
我的意思是更多的空间 

2563
01:37:23,060 --> 01:37:26,480
相信我们可以把你的解决方案，但我 

2564
01:37:24,800 --> 01:37:28,639
会给你两倍的收费

2565
01:37:26,480 --> 01:37:30,139
几十年前，当C是 

2566
01:37:28,639 --> 01:37:32,420
首先是发明和计算机

2567
01:37:30,139 --> 01:37:34,760
真的 开始玩 两次 

2568
01:37:32,420 --> 01:37:36,590
即使 它只有 32个，也有很多比特 

2569
01:37:34,760 --> 01:37:38,480
微小的零和实际的 

2570
01:37:36,590 --> 01:37:40,400
从字面上看，这在经济上是昂贵的

2571
01:37:38,480 --> 01:37:41,989
加起来，如果你愿意，甚至今天 

2572
01:37:40,400 --> 01:37:43,850
花更多的空间，但你很好 

2573
01:37:41,989 --> 01:37:45,050
会花更多的空间， 因此 更 

2574
01:37:43,850 --> 01:37:47,000
钱，因此空间较小 

2575
01:37:45,050 --> 01:37:48,260
可用于其他 事情所以它 只是 

2576
01:37:47,000 --> 01:37:52,219
权衡，你必须决定 

2577
01:37:48,260 --> 01:37:54,139
决定作为一个聪明的人在哪里 

2578
01:37:52,219 --> 01:37:56,300
右拐点介于什么之间

2579
01:37:54,139 --> 01:37:58,969
更重要的是让我开辟一个非常

2580
01:37:56,300 --> 01:38:00,560
不同的例子现在被称为平价刚 

2581
01:37:58,969 --> 01:38:02,750
作为一个例子，让我问 这个 

2582
01:38:00,560 --> 01:38:09,110
问你怎么 知道一个数字是多少？ 

2583
01:38:02,750 --> 01:38:13,070
偶数或奇数是什么诀窍如果是的话 

2584
01:38:09,110 --> 01:38:15,110
除以2，因此0和2 ＆4＆6是偶数 

2585
01:38:13,070 --> 01:38:16,820
因为如果你除以2就得不到 

2586
01:38:15,110 --> 01:38:18,560
如果你 只是想要， 那么实际上是剩下的 

2587
01:38:16,820 --> 01:38:19,969
看一个你可能的原因的简单例子 

2588
01:38:18,560 --> 01:38:22,040
使用余数，即使它已经过了 

2589
01:38:19,969 --> 01:38:24,530
这里的上下文是奇偶校验的一个例子 

2590
01:38:22,040 --> 01:38:26,389
平价只是指甚至是一个术语 

2591
01:38:24,530 --> 01:38:28,520
在这种情况下我们可以使用或者奇怪

2592
01:38:26,389 --> 01:38:30,770
这个通知我可以从中得到它 

2593
01:38:28,520 --> 01:38:32,719
顶部 的用户最多 ，然后 我可以 检查 

2594
01:38:30,770 --> 01:38:34,520
该 整数 的奇偶性 是 它甚至或 

2595
01:38:32,719 --> 01:38:36,650
奇怪的是这样的语法现在我很善良 

2596
01:38:34,520 --> 01:38:38,750
将其中一些 运算符组合为 

2597
01:38:36,650 --> 01:38:43,159
你可能会直觉地倾向于n 

2598
01:38:38,750 --> 01:38:44,870
用户在mod 2中 键入的数字 或/ 

2599
01:38:43,159 --> 01:38:47,270
然后检查其余部分 

2600
01:38:44,870 --> 01:38:49,520
这是一个拗口 等于 等于 0您 

2601
01:38:47,270 --> 01:38:52,100
只是说这是一个偶数，所以打印 

2602
01:38:49,520 --> 01:38:53,989
甚至打印奇怪，因为它是什么 

2603
01:38:52,100 --> 01:38:56,030
如果你做 n或 其他可能的其他余数 

2604
01:38:53,989 --> 01:38:59,719
任何值除以 2 你都可能 得到一个 

2605
01:38:56,030 --> 01:39:01,730
余数为0或1 我只需要检查 

2606
01:38:59,719 --> 01:39:03,889
其中一个因为 eltz 

2607
01:39:01,730 --> 01:39:06,500
再暗示另一件事情 

2608
01:39:03,889 --> 01:39:07,880
简单的例子但老实说 我们所有人 

2609
01:39:06,500 --> 01:39:09,650
可能有一个直观的理解 

2610
01:39:07,880 --> 01:39:11,360
什么是一个奇怪的计算机需要

2611
01:39:09,650 --> 01:39:12,240
被教导， 所以有一个 

2612
01:39:11,360 --> 01:39:14,220
程序 

2613
01:39:12,240 --> 01:39:17,340
确切地说，这让我开放了 

2614
01:39:14,220 --> 01:39:18,480
更大的计划称为条件和

2615
01:39:17,340 --> 01:39:20,130
而不是输入这个，因为 

2616
01:39:18,480 --> 01:39:22,590
这几行代码让我公正 

2617
01:39:20,130 --> 01:39:24,210
打开它 ，因为它完全结束 

2618
01:39:22,590 --> 01:39:25,980
在代码中，我们看到了去 了一点点 

2619
01:39:24,210 --> 01:39:28,860
当我们将它与a进行比较时的幻灯片

2620
01:39:25,980 --> 01:39:31,170
在我的这个程序中类似的C Block 

2621
01:39:28,860 --> 01:39:34,650
主要功能让我 专注于第一个 

2622
01:39:31,170 --> 01:39:36,810
几 行那里， 我有一个名为 X 的int 

2623
01:39:34,650 --> 01:39:38,580
那我越来越再次 INS 另一 

2624
01:39:36,810 --> 01:39:40,890
int称为Y然后我通过get获得 

2625
01:39:38,580 --> 01:39:42,600
int然后我只是做一些简单的事情 

2626
01:39:40,890 --> 01:39:44,400
比较我们再看到这个

2627
01:39:42,600 --> 01:39:47,730
将它与划痕相比， 但这是 相当的 

2628
01:39:44,400 --> 01:39:49,290
在上下文中仅仅是相同的代码， 而 

2629
01:39:47,730 --> 01:39:51,690
而不只是静静地看到它 

2630
01:39:49,290 --> 01:39:54,450
幻灯片让我继续编译 

2631
01:39:51,690 --> 01:39:57,110
这使条件进入似乎 

2632
01:39:54,450 --> 01:40:01,470
编译让我 放大并做点 斜线 

2633
01:39:57,110 --> 01:40:04,650
条件输入X将再次说2 Y. 

2634
01:40:01,470 --> 01:40:06,120
如果我，将是10 X确实小于Y. 

2635
01:40:04,650 --> 01:40:08,280
再次运行它，我可以节省时间 

2636
01:40:06,120 --> 01:40:11,160
通过我的历史和公正 

2637
01:40:08,280 --> 01:40:13,440
按Enter键让我们做2 和 2 

2638
01:40:11,160 --> 01:40:15,060
实际上X等于Y，依此类推 

2639
01:40:13,440 --> 01:40:17,250
所以再次只是完全相同的那种 

2640
01:40:15,060 --> 01:40:18,990
代码和以前一样， 但 现在在上下文中 

2641
01:40:17,250 --> 01:40:20,940
一个工作程序，如果我真的 

2642
01:40:18,990 --> 01:40:23,490
想得到用户输入之类的 

2643
01:40:20,940 --> 01:40:25,740
我们过去的学生做了肯定或是

2644
01:40:23,490 --> 01:40:28,710
没有答案苹果和蛋糕 

2645
01:40:25,740 --> 01:40:30,690
问一个答案点 C它转过来 

2646
01:40:28,710 --> 01:40:31,350
你可以实际获得文本输入 

2647
01:40:30,690 --> 01:40:34,440
来自用户

2648
01:40:31,350 --> 01:40:36,960
也许是一个简单的是或否或 只是Y或 

2649
01:40:34,440 --> 01:40:38,940
n简洁的Ness，在这种情况下，如果 

2650
01:40:36,960 --> 01:40:40,020
我只是回来了一个角色 

2651
01:40:38,940 --> 01:40:41,370
有一个单独的数据类型 

2652
01:40:40,020 --> 01:40:43,620
如果你不想要一个完整的角色 

2653
01:40:41,370 --> 01:40:45,060
字符串像整个单词或段落 

2654
01:40:43,620 --> 01:40:46,590
或句子或任何你想要的东西 

2655
01:40:45,060 --> 01:40:49,230
你可以 实际使用的一个角色

2656
01:40:46,590 --> 01:40:51,140
什么叫做char或角色等等 

2657
01:40:49,230 --> 01:40:54,360
在这里，我正在使用另一个功能 

2658
01:40:51,140 --> 01:40:57,120
适当地命名为get char我是 

2659
01:40:54,360 --> 01:40:59,010
将其存储在名为C的变量中

2660
01:40:57,120 --> 01:41:02,580
因为它的漂亮和简洁的 类型 

2661
01:40:59,010 --> 01:41:04,650
char ，然后注意这可能不是 

2662
01:41:02,580 --> 01:41:06,660
之前已经看过这种语法了 

2663
01:41:04,650 --> 01:41:08,520
如果你以前从未编程过 

2664
01:41:06,660 --> 01:41:10,980
但是你可能已经看过了 

2665
01:41:08,520 --> 01:41:13,440
阻止与此类似的是什么

2666
01:41:10,980 --> 01:41:15,750
垂直双杠可能意味着 

2667
01:41:13,440 --> 01:41:17,040
在这或那就是它

2668
01:41:15,750 --> 01:41:18,540
所以在刮擦它是好的和用户

2669
01:41:17,040 --> 01:41:20,340
友好他们真的只是说 哦我们的 

2670
01:41:18,540 --> 01:41:22,530
在编程中，通常情况 就是如此 

2671
01:41:20,340 --> 01:41:24,420
你使用更多神秘的序列 

2672
01:41:22,530 --> 01:41:26,070
字符和两个垂直条 

2673
01:41:24,420 --> 01:41:28,920
就像通常 在最后一样 

2674
01:41:26,070 --> 01:41:31,800
如果 c等于等于 我们的键盘 

2675
01:41:28,920 --> 01:41:34,079
资本y或c等于小写Y. 

2676
01:41:31,800 --> 01:41:36,750
让我们假设用户想说 

2677
01:41:34,079 --> 01:41:39,090
是的，继续说是的 ， 如果 是的 话 

2678
01:41:36,750 --> 01:41:40,860
用户在大写字母或中输入N. 

2679
01:41:39,090 --> 01:41:43,380
小写让我们假设他或她的意思 

2680
01:41:40,860 --> 01:41:46,679
不，并且相应地说不，是什么 

2681
01:41:43,380 --> 01:41:48,329
我们该怎么 办，否则什么都不明显 

2682
01:41:46,679 --> 01:41:50,099
这没关系，你 不需要 

2683
01:41:48,329 --> 01:41:51,659
默认情况下，如果你想程序 

2684
01:41:50,099 --> 01:41:53,520
什么都不做可能有点混乱 

2685
01:41:51,659 --> 01:41:56,159
因为用户会输入你知道的 

2686
01:41:53,520 --> 01:41:57,929
一些随机的单词， 但 没有输出 

2687
01:41:56,159 --> 01:42:00,599
这是一个设计决定这个 逻辑 

2688
01:41:57,929 --> 01:42:04,889
就是我们如何 表达这一点 

2689
01:42:00,599 --> 01:42:07,650
有关UM 什么 实际构建 

2690
01:42:04,889 --> 01:42:11,969
我们自己阻止 任何问题 

2691
01:42:07,650 --> 01:42:14,520
在我们开始 创造没有 权利之前 

2692
01:42:11,969 --> 01:42:16,170
所以记得， 在 我们 从头开始 说了 

2693
01:42:14,520 --> 01:42:18,480
咳嗽样本让我继续前进

2694
01:42:16,170 --> 01:42:21,929
在这里快速 创建 一个文件 

2695
01:42:18,480 --> 01:42:24,179
咳嗽0点C ，只是重新创造 

2696
01:42:21,929 --> 01:42:27,750
我们所做的最后 一周，包括标准 

2697
01:42:24,179 --> 01:42:29,820
IOH int主要 虚空再次只是肌肉 

2698
01:42:27,750 --> 01:42:33,989
记忆现在然后printf引用unquote 

2699
01:42:29,820 --> 01:42:36,300
咳嗽反斜杠和分号，你知道 

2700
01:42:33,989 --> 01:42:38,550
什么让我继续前进，并呼吁不 

2701
01:42:36,300 --> 01:42:40,139
一次，而是两次三次像 

2702
01:42:38,550 --> 01:42:42,449
你开始复制和粘贴的那一刻

2703
01:42:40,139 --> 01:42:44,550
你可能没有写出好的代码 

2704
01:42:42,449 --> 01:42:46,050
对， 如果，现在 不是很可维护 

2705
01:42:44,550 --> 01:42:47,159
我想改变这个词或翻译 

2706
01:42:46,050 --> 01:42:48,690
我必须改变另一种语言 

2707
01:42:47,159 --> 01:42:51,389
它在三个地方 我们 已经决定了 

2708
01:42:48,690 --> 01:42:54,270
上周 ，这是坏的，所以这将是 

2709
01:42:51,389 --> 01:42:57,570
在C或 划伤或 一般情况下 更好 

2710
01:42:54,270 --> 01:42:58,920
比这个方法更像是一个for 

2711
01:42:57,570 --> 01:43:00,630
循环让我这样做 让我创造 

2712
01:42:58,920 --> 01:43:03,780
另一个我要称之为文件的文件

2713
01:43:00,630 --> 01:43:05,429
1个咳嗽了一声C点是我的第二个版本 让 

2714
01:43:03,780 --> 01:43:08,099
我现在继续 ，只是复制 和粘贴 

2715
01:43:05,429 --> 01:43:09,630
原始代码，让我们改进 

2716
01:43:08,099 --> 01:43:11,820
它让我们摆脱其中的两个 和 

2717
01:43:09,630 --> 01:43:16,409
让我们看看我们是否不能表达这四个 

2718
01:43:11,820 --> 01:43:19,320
所以它是四个让我 放大我得到的 

2719
01:43:16,409 --> 01:43:22,170
0我 之前 不到 一些数字 

2720
01:43:19,320 --> 01:43:25,800
现在已经50岁了，我将会有3个加号 

2721
01:43:22,170 --> 01:43:28,139
加上花括号 ，现在让我动起来吧 

2722
01:43:25,800 --> 01:43:30,179
那里的咳嗽锁和

2723
01:43:28,139 --> 01:43:32,489
缩进它只是为了漂亮而且注意到 

2724
01:43:30,179 --> 01:43:33,960
在风格上， 我一直在这样做 

2725
01:43:32,489 --> 01:43:36,540
本能的一段时间 

2726
01:43:33,960 --> 01:43:38,099
一切 都很好地缩进到了 

2727
01:43:36,540 --> 01:43:39,480
让它更具可读性 

2728
01:43:38,099 --> 01:43:40,920
刮擦盒即使再次 

2729
01:43:39,480 --> 01:43:43,290
很多那个空白并不重要 

2730
01:43:40,920 --> 01:43:45,600
到了电脑，所以如果我继续前进并 运行 

2731
01:43:43,290 --> 01:43:49,440
这 让我拉起终端窗口 

2732
01:43:45,600 --> 01:43:52,710
所以我可以看到它 让咖啡 进入 

2733
01:43:49,440 --> 01:43:55,470
看起来不错的点斜线咖啡一咳 

2734
01:43:52,710 --> 01:43:57,120
咳嗽好吧 那好，但回想起来 

2735
01:43:55,470 --> 01:43:59,550
我们实际上改进了 这个设计 

2736
01:43:57,120 --> 01:44:01,590
进一步抽象它 让我离开 

2737
01:43:59,550 --> 01:44:04,320
进取， 使 自己的功能，现在让 

2738
01:44:01,590 --> 01:44:08,520
我继续打开一个 新文件 

2739
01:44:04,320 --> 01:44:11,400
Koff  - 咖啡 - 点 C就像我一样 

2740
01:44:08,520 --> 01:44:16,290
另一个临时程序再次包括 

2741
01:44:11,400 --> 01:44:22,500
标准IO点H int主要空虚然后 

2742
01:44:16,290 --> 01:44:26,030
在这里让我继续前进 ，做得好 

2743
01:44:22,500 --> 01:44:31,470
因为我得到0我不到 3我加 

2744
01:44:26,030 --> 01:44:33,660
加上花括号然后让 我走 

2745
01:44:31,470 --> 01:44:35,100
前进，只是打电话给科夫 

2746
01:44:33,660 --> 01:44:36,540
如果咳嗽 囊肿很好但是 

2747
01:44:35,100 --> 01:44:38,190
不幸的是，咳嗽不存在

2748
01:44:36,540 --> 01:44:40,290
即便如此，它也不在cs50库中

2749
01:44:38,190 --> 01:44:42,600
这不会帮助 我，我必须做 

2750
01:44:40,290 --> 01:44:43,980
我自己的功能所以在刮擦你去了 

2751
01:44:42,600 --> 01:44:45,690
块事物，你做你的 

2752
01:44:43,980 --> 01:44:47,250
自己的阻止和大提示出现 

2753
01:44:45,690 --> 01:44:48,270
你在这里制作新的拼图 

2754
01:44:47,250 --> 01:44:51,239
我们必须要多 一点 

2755
01:44:48,270 --> 01:44:53,910
故意，事实证明你可以 做到 

2756
01:44:51,239 --> 01:44:55,620
它喜欢这 其中的一些细节 

2757
01:44:53,910 --> 01:44:57,390
起初 不明显， 但我要走了 

2758
01:44:55,620 --> 01:44:59,700
提前 和称功能咖啡和 

2759
01:44:57,390 --> 01:45:01,770
此刻咖啡不需要

2760
01:44:59,700 --> 01:45:03,450
接受任何输入，以便有关键词 

2761
01:45:01,770 --> 01:45:05,460
我们之前实际上看到过这种情况 

2762
01:45:03,450 --> 01:45:07,410
主也尚未 采取任何输入 

2763
01:45:05,460 --> 01:45:09,150
这就是为什么我们有“无效”这个词的原因 

2764
01:45:07,410 --> 01:45:10,680
在另一个时间， 咖啡不是 

2765
01:45:09,150 --> 01:45:11,970
去 要么是 返回 任何东西 

2766
01:45:10,680 --> 01:45:14,250
就像 在 屏幕上 打印 一样 

2767
01:45:11,970 --> 01:45:15,930
布莱恩做了但布莱恩回忆起来并没有动手 

2768
01:45:14,250 --> 01:45:19,020
我身体上的任何东西，所以有 

2769
01:45:15,930 --> 01:45:20,970
没有回报价值， 所以我会说 无效 

2770
01:45:19,020 --> 01:45:23,100
今天 是 咳嗽 的左边 

2771
01:45:20,970 --> 01:45:25,770
目的这只是意味着咳嗽 

2772
01:45:23,100 --> 01:45:27,120
要么输入也要返回值

2773
01:45:25,770 --> 01:45:30,090
作为输出就是它 

2774
01:45:27,120 --> 01:45:31,920
现在 void void登记为身体 

2775
01:45:30,090 --> 01:45:34,040
功能这么说，我只是要 

2776
01:45:31,920 --> 01:45:37,320
继续说简单的咳嗽 

2777
01:45:34,040 --> 01:45:38,910
反斜杠n分号就是 这样，现在我 

2778
01:45:37,320 --> 01:45:40,710
如果你愿意，那就有一块拼图

2779
01:45:38,910 --> 01:45:43,260
生活中的目的是咳嗽意味着什么 

2780
01:45:40,710 --> 01:45:46,620
现在我可以神奇地用它来称呼它

2781
01:45:43,260 --> 01:45:48,450
在这里 按照我的要求多次 命名 

2782
01:45:46,620 --> 01:45:50,070
让我们继续编译这个我 

2783
01:45:48,450 --> 01:45:52,080
一切都很好 

2784
01:45:50,070 --> 01:45:53,040
到目前为止锻炼得很好 咳嗽到 

2785
01:45:52,080 --> 01:45:57,270
输入

2786
01:45:53,040 --> 01:45:58,890
哦红色错误所以这很 有意思 

2787
01:45:57,270 --> 01:46:00,900
这种让我想起以前 

2788
01:45:58,890 --> 01:46:04,530
错误所以首先是我的行 

2789
01:46:00,900 --> 01:46:06,930
好的七和九个字符的错误

2790
01:46:04,530 --> 01:46:09,150
如果你关心，但它在第七行七 

2791
01:46:06,930 --> 01:46:11,820
功能咖啡的隐含声明

2792
01:46:09,150 --> 01:46:13,260
在c99 c99中指的 是无效的 

2793
01:46:11,820 --> 01:46:16,250
字面意思是 九九九年的 时候 

2794
01:46:13,260 --> 01:46:18,330
版本的 C的发明等 

2795
01:46:16,250 --> 01:46:21,300
隐含的功能宣告咳嗽 

2796
01:46:18,330 --> 01:46:23,340
但它就在这里呃好吧等一下 

2797
01:46:21,300 --> 01:46:27,120
分钟让我本能让我好 

2798
01:46:23,340 --> 01:46:28,410
如果让我把它放好，那就行动吧 

2799
01:46:27,120 --> 01:46:32,540
顶部让我们看看会发生什么 

2800
01:46:28,410 --> 01:46:35,940
咳嗽 - 噢，我的上帝 修好了 

2801
01:46:32,540 --> 01:46:37,830
为什么喜欢，即使你从未 编程过 

2802
01:46:35,940 --> 01:46:41,600
之前只是一种 推理 

2803
01:46:37,830 --> 01:46:41,600
直觉上为什么这会解决问题 

2804
01:46:43,970 --> 01:46:51,990
确切地说

2805
01:46:49,500 --> 01:46:54,780
因为我以前 试图使用 

2806
01:46:51,990 --> 01:46:56,310
第 7 行早早咳， 但我是 

2807
01:46:54,780 --> 01:46:58,860
只教电脑什么咳嗽

2808
01:46:56,310 --> 01:47:00,420
在文件中坦率地说 C更远了 

2809
01:46:58,860 --> 01:47:02,220
有点愚蠢，从字面上看你的 

2810
01:47:00,420 --> 01:47:03,930
代码从上到下从左到右，如果 

2811
01:47:02,220 --> 01:47:05,160
你试着在你做之前先做点什么 

2812
01:47:03,930 --> 01:47:06,660
教会计算机如何做到这一点 

2813
01:47:05,160 --> 01:47:08,700
你会得到那种未申报的 

2814
01:47:06,660 --> 01:47:11,040
标识符，因为它只是不知道 

2815
01:47:08,700 --> 01:47:12,120
这个词到底是什么呢？ 

2816
01:47:11,040 --> 01:47:14,190
你移动它并不是什么大不了的事 

2817
01:47:12,120 --> 01:47:15,750
在任何你想要的订单拼图 

2818
01:47:14,190 --> 01:47:18,840
物理上在屏幕上的块没有 

2819
01:47:15,750 --> 01:47:20,820
但事实上，但在C中它确实如此 

2820
01:47:18,840 --> 01:47:23,250
现在似乎有点烦人了 

2821
01:47:20,820 --> 01:47:25,080
这里的主要程序有点不断 

2822
01:47:23,250 --> 01:47:26,670
越走越远推下更多 

2823
01:47:25,080 --> 01:47:29,250
我希望添加到我 的 复杂性 

2824
01:47:26,670 --> 01:47:30,810
程序所以 有另一个 解决方案 让 

2825
01:47:29,250 --> 01:47:32,850
我实际上继续把它放 回去 

2826
01:47:30,810 --> 01:47:34,920
它 是因为我有点像 

2827
01:47:32,850 --> 01:47:36,600
特别是我喜欢按惯例 

2828
01:47:34,920 --> 01:47:38,910
主要是在顶部，坦率地说是 

2829
01:47:36,600 --> 01:47:40,410
如果主要是最好的那种好的风格

2830
01:47:38,910 --> 01:47:42,210
程序中的重要功能 

2831
01:47:40,410 --> 01:47:44,280
默认， 因为它是主程序 a 

2832
01:47:42,210 --> 01:47:46,860
功能，它就是被称为 每 

2833
01:47:44,280 --> 01:47:48,570
早先默认由计算机为什么 

2834
01:47:46,860 --> 01:47:50,940
我会把 它推到 一边 

2835
01:47:48,570 --> 01:47:53,880
只是为了解决这个愚蠢的细节 

2836
01:47:50,940 --> 01:47:57,180
好吧，我只需要教电脑 

2837
01:47:53,880 --> 01:47:59,240
功能是什么，我可以做到这一点 

2838
01:47:57,180 --> 01:48:02,340
多余的

2839
01:47:59,240 --> 01:48:03,800
只是说这就是我们所做的 

2840
01:48:02,340 --> 01:48:06,590
打电话给原型 

2841
01:48:03,800 --> 01:48:09,260
键入 4一个函数，如果你真的只是 

2842
01:48:06,590 --> 01:48:11,239
复制它的第一行有 

2843
01:48:09,260 --> 01:48:13,570
它的名字是它的输入，如果有的话 

2844
01:48:11,239 --> 01:48:15,770
输出，如果有任何原型 

2845
01:48:13,570 --> 01:48:17,630
分号，它的字面意思是 复制粘贴 

2846
01:48:15,770 --> 01:48:19,639
功能本身，但现在 

2847
01:48:17,630 --> 01:48:22,400
足以说明嘿电脑 

2848
01:48:19,639 --> 01:48:24,079
这个 shell存在就足够了 

2849
01:48:22,400 --> 01:48:26,510
信息供您随后调用 

2850
01:48:24,079 --> 01:48:28,250
因为电脑说话的时间太长了 

2851
01:48:26,510 --> 01:48:31,280
可以看到之前的函数名称 

2852
01:48:28,250 --> 01:48:33,530
这没关系 ，如果在零和一所以 

2853
01:48:31,280 --> 01:48:35,690
说实现它来了一点 

2854
01:48:33,530 --> 01:48:36,980
以后，所以更多 

2855
01:48:35,690 --> 01:48:41,840
传统方式来解决 这个问题 

2856
01:48:36,980 --> 01:48:44,389
所以 只是 直观地再取一想，如果 

2857
01:48:41,840 --> 01:48:49,070
这不是一个间接的飞跃 

2858
01:48:44,389 --> 01:48:53,750
什么是标准 IOH 什么是cs50 

2859
01:48:49,070 --> 01:48:56,290
dot H我们称之为的那种鸡巴 

2860
01:48:53,750 --> 01:48:59,119
他们的声明如此字面意思 

2861
01:48:56,290 --> 01:49:02,179
标准i / o点H 是一行 代码 

2862
01:48:59,119 --> 01:49:04,429
教电脑什么printf 

2863
01:49:02,179 --> 01:49:06,949
输入是什么和printf s--输出

2864
01:49:04,429 --> 01:49:08,270
如果在cs50点H中有任何字面意思是a 

2865
01:49:06,949 --> 01:49:10,760
9个码 ， 告诉 计算机 

2866
01:49:08,270 --> 01:49:12,889
什么得到字符串输入是什么和它 

2867
01:49:10,760 --> 01:49:15,800
输出是和忘记int和 

2868
01:49:12,889 --> 01:49:17,750
获得浮动 并获得char和其他人 

2869
01:49:15,800 --> 01:49:19,520
那些头文件中的所有内容 

2870
01:49:17,750 --> 01:49:21,020
一个可以说的零实际上是 

2871
01:49:19,520 --> 01:49:24,139
文件字面上称为标准i / o点

2872
01:49:21,020 --> 01:49:26,059
C和cs50点C虽然是 

2873
01:49:24,139 --> 01:49:28,070
技术上源代码为零和 

2874
01:49:26,059 --> 01:49:29,690
那些在其他地方 的编译文件 中 

2875
01:49:28,070 --> 01:49:31,550
系统，但我们所有这些 东西 

2876
01:49:29,690 --> 01:49:32,690
现在 必须成为理所当然的事 

2877
01:49:31,550 --> 01:49:34,099
希望它更有 意义 

2878
01:49:32,690 --> 01:49:36,139
因为我正在做的事实 

2879
01:49:34,099 --> 01:49:38,210
尖锐的包括在顶部 ，这只是一个 

2880
01:49:36,139 --> 01:49:39,829
解决 该文件中 的问题 是 

2881
01:49:38,210 --> 01:49:43,309
足够的信息来教电脑 

2882
01:49:39,829 --> 01:49:45,380
什么printf或什么getstring和 其他 

2883
01:49:43,309 --> 01:49:48,590
事情是这样，我不需要 

2884
01:49:45,380 --> 01:49:50,690
我懒得走动的东西 或 

2885
01:49:48,590 --> 01:49:53,239
复制和粘贴谁写了printf 

2886
01:49:50,690 --> 01:49:55,250
他或她的代码 现在 进入我的程序 

2887
01:49:53,239 --> 01:49:57,409
让我们做一个咳嗽的最后一个例子 

2888
01:49:55,250 --> 01:49:59,840
然后把咖啡叫 三 

2889
01:49:57,409 --> 01:50:01,190
点C并继续粘贴我的相同 

2890
01:49:59,840 --> 01:50:03,110
刚才的代码只是为了得到我们 

2891
01:50:01,190 --> 01:50:05,329
开始并回想起最后 一步 

2892
01:50:03,110 --> 01:50:07,429
上周我们的咖啡例子是 

2893
01:50:05,329 --> 01:50:09,559
实际上给 我的棺材输入 

2894
01:50:07,429 --> 01:50:12,020
喜欢将此代码缩减至 

2895
01:50:09,559 --> 01:50:13,820
字面意思是三个，因为这是一个 

2896
01:50:12,020 --> 01:50:15,290
非常好的抽象，就像我没有 

2897
01:50:13,820 --> 01:50:16,909
想要主要考虑如何 

2898
01:50:15,290 --> 01:50:19,070
很多次 看起来 只是 咳嗽 

2899
01:50:16,909 --> 01:50:20,959
三次，这是一个很好的有用的人

2900
01:50:19,070 --> 01:50:23,090
抽象现在让我们把它

2901
01:50:20,959 --> 01:50:25,789
这里的功能如果我想要的话

2902
01:50:23,090 --> 01:50:28,489
COFF 是 能够容忍的输入 

2903
01:50:25,789 --> 01:50:30,289
像三个提到空虚 

2904
01:50:28,489 --> 01:50:32,599
大概需要改变一个 

2905
01:50:30,289 --> 01:50:34,789
左边或右边的 那个 

2906
01:50:32,599 --> 01:50:36,800
括号 内 和原来 

2907
01:50:34,789 --> 01:50:39,619
就像 你可以声明变量一样 

2908
01:50:36,800 --> 01:50:41,570
在我们 这样做 的函数内部

2909
01:50:39,619 --> 01:50:44,659
你可以声明一个函数的参数 

2910
01:50:41,570 --> 01:50:46,579
像这样的，所以你可以把它叫做 什么 

2911
01:50:44,659 --> 01:50:48,709
你想要虽然 数据类型很重要但是 

2912
01:50:46,579 --> 01:50:51,439
现在说嘿电脑 咳嗽了 

2913
01:50:48,709 --> 01:50:53,749
并没有像亚伦那样回报价值 

2914
01:50:51,439 --> 01:50:56,329
还给一张纸嘿电脑 

2915
01:50:53,749 --> 01:50:58,729
咳嗽确实需要一个输入它是一个 

2916
01:50:56,329 --> 01:51:00,829
整数，只需将 其 称为 N即可 

2917
01:50:58,729 --> 01:51:02,929
你已经完成了这个，你可以有一条线 

2918
01:51:00,829 --> 01:51:09,709
这里的代码 就像我得到的int一样 

2919
01:51:02,929 --> 01:51:13,400
0我小于n加上加上加号 

2920
01:51:09,709 --> 01:51:15,949
然后通过这里的按键来解决问题 

2921
01:51:13,400 --> 01:51:18,409
然后我可以在里面移动这个缩进 

2922
01:51:15,949 --> 01:51:20,630
很好，现在注意到 所有 的 

2923
01:51:18,409 --> 01:51:22,760
咳嗽的复杂性已被考虑在内

2924
01:51:20,630 --> 01:51:24,590
进入一个功能我自己的拼图

2925
01:51:22,760 --> 01:51:27,559
如果你愿意，甚至会 争论 

2926
01:51:24,590 --> 01:51:29,719
所以现在你可以在字面上 移动 

2927
01:51:27,559 --> 01:51:31,579
这遥远而且 不在乎 现在你的 

2928
01:51:29,719 --> 01:51:34,039
程序变得非常有趣

2929
01:51:31,579 --> 01:51:36,499
因为它真的只是 做了它说的 

2930
01:51:34,039 --> 01:51:38,179
这是 一个很好的功能 

2931
01:51:36,499 --> 01:51:39,800
抽象，如果你愿意， 现在我 

2932
01:51:38,179 --> 01:51:43,789
有一个动词的一个新动作 新 

2933
01:51:39,800 --> 01:51:46,689
函数叫做咳嗽有 什么问题 

2934
01:51:43,789 --> 01:51:49,150
那是 啊 

2935
01:51:46,689 --> 01:51:51,440
抱歉再说一遍 

2936
01:51:49,150 --> 01:51:52,639
什么整数会炒面 回报事实证明 

2937
01:51:51,440 --> 01:51:54,409
我们会回到 这里，它会发生 

2938
01:51:52,639 --> 01:51:56,239
默认情况下几乎总是 返回零 

2939
01:51:54,409 --> 01:51:58,100
但这 几乎 让 你失望了 

2940
01:51:56,239 --> 01:51:59,389
无限数量 的非零值 

2941
01:51:58,100 --> 01:52:01,369
代表所有的很多事情 ， 

2942
01:51:59,389 --> 01:52:03,920
当我们 这样做时 ， 可能 会出错 

2943
01:52:01,369 --> 01:52:06,320
开始创造更多的错误让我们看看 

2944
01:52:03,920 --> 01:52:08,570
在另一个让我继续开放 

2945
01:52:06,320 --> 01:52:11,869
此文件 提前自己 打电话 

2946
01:52:08,570 --> 01:52:14,510
积极的C假设我不满足 

2947
01:52:11,869 --> 01:52:16,580
只是 有权获得int我想要一个 

2948
01:52:14,510 --> 01:52:18,320
函数调用get positive int 因为 

2949
01:52:16,580 --> 01:52:20,119
无论出于什么原因我的节目我的 游戏 

2950
01:52:18,320 --> 01:52:21,830
我 需要知道什么是积极的 

2951
01:52:20,119 --> 01:52:23,690
价值也许我问用户有多少 

2952
01:52:21,830 --> 01:52:25,280
球员在那里，不应该 

2953
01:52:23,690 --> 01:52:27,679
否定它应该是一个正整数 

2954
01:52:25,280 --> 01:52:29,989
结果就像一两个 或更多 

2955
01:52:27,679 --> 01:52:33,619
如果我想要 ，我可以写一个程序

2956
01:52:29,989 --> 01:52:36,619
看起来像这样在这一行上打电话了 

2957
01:52:33,619 --> 01:52:38,570
函数调用get positive int 传递它 

2958
01:52:36,619 --> 01:52:40,219
在提示中然后存储该值 

2959
01:52:38,570 --> 01:52:42,170
仍然在左手的整数

2960
01:52:40,219 --> 01:52:45,590
侧，然后就继续和打印 

2961
01:52:42,170 --> 01:52:48,500
得到积极的int 有这个原型 

2962
01:52:45,590 --> 01:52:50,060
在文件的顶部注意 这是 

2963
01:52:48,500 --> 01:52:52,429
不是cs50附带 的功能 

2964
01:52:50,060 --> 01:52:54,110
库cs50.h 函数被调用 

2965
01:52:52,429 --> 01:52:56,690
你希望它得到积极的int 

2966
01:52:54,110 --> 01:52:58,340
返回一个int，它接受一个字符串

2967
01:52:56,690 --> 01:53:01,070
它提示你想要的任何单词

2968
01:52:58,340 --> 01:53:03,440
人类看到让我们现在向下滚动

2969
01:53:01,070 --> 01:53:05,989
这个看起来更复杂一些 

2970
01:53:03,440 --> 01:53:08,420
这不是划痕的功能 

2971
01:53:05,989 --> 01:53:10,550
但是让我们来看看第一行 

2972
01:53:08,420 --> 01:53:12,230
与原型相同

2973
01:53:10,550 --> 01:53:14,780
因为我真的复制并粘贴了它 

2974
01:53:12,230 --> 01:53:17,119
这些括号之间的所有内容都是 

2975
01:53:14,780 --> 01:53:18,889
功能本身和这里回答 

2976
01:53:17,119 --> 01:53:21,380
从早期 在 做 别人的问题 

2977
01:53:18,889 --> 01:53:22,280
你必须声明一个 变量 然后 

2978
01:53:21,380 --> 01:53:24,050
马上使用它 

2979
01:53:22,280 --> 01:53:25,580
不，这实际上是有帮助的 

2980
01:53:24,050 --> 01:53:28,310
解决我们将要看到 的问题 

2981
01:53:25,580 --> 01:53:30,920
片刻注意这个新关键字 

2982
01:53:28,310 --> 01:53:34,429
在做以下之前没有看到它

2983
01:53:30,920 --> 01:53:37,369
虽然我以前不到一个 

2984
01:53:34,429 --> 01:53:39,440
看到一个while循环，我们看到了一个for循环 

2985
01:53:37,369 --> 01:53:41,540
我们没有看到do-while循环和a 

2986
01:53:39,440 --> 01:53:43,610
do-while循环所有听起来很明显 

2987
01:53:41,540 --> 01:53:45,619
类似于while循环 似乎是一个 

2988
01:53:43,610 --> 01:53:48,730
当我永远拥有那个时，我会有所 不同 

2989
01:53:45,619 --> 01:53:52,610
阻止早先翻译为true 

2990
01:53:48,730 --> 01:53:54,949
我们 的运作 顺序 是 什么？ 

2991
01:53:52,610 --> 01:53:56,719
检查条件是真的然后 

2992
01:53:54,949 --> 01:53:59,619
打印你好世界或 我们只是打印 

2993
01:53:56,719 --> 01:54:02,360
你好世界，然后检查条件 

2994
01:53:59,619 --> 01:54:02,750
是的，你可能不记得， 但是 

2995
01:54:02,360 --> 01:54:05,060
我做到了

2996
01:54:02,750 --> 01:54:07,790
实际上，我检查的是真的，我们 

2997
01:54:05,060 --> 01:54:10,550
所有人都说是的，显然 printf是真的 

2998
01:54:07,790 --> 01:54:12,800
printf是真正的printf所以它检查 

2999
01:54:10,550 --> 01:54:15,050
条件首先你可能会推断 

3000
01:54:12,800 --> 01:54:17,360
这个循环有点不同而且有 

3001
01:54:15,050 --> 01:54:20,480
换句话说这是真的 

3002
01:54:17,360 --> 01:54:22,850
首先要做 ， 然后检查 

3003
01:54:20,480 --> 01:54:24,680
条件， 只有 在 做一遍 

3004
01:54:22,850 --> 01:54:26,660
条件为真 所以它是一个很好的 方式 

3005
01:54:24,680 --> 01:54:28,540
只是翻转周围的东西 

3006
01:54:26,660 --> 01:54:31,610
要做 至少 一次的 事情 

3007
01:54:28,540 --> 01:54:33,710
而不是可能永远不会 

3008
01:54:31,610 --> 01:54:36,530
就像早先的情况那样 ，我们是什么 

3009
01:54:33,710 --> 01:54:39,350
在 这个提示中做一个int传递 

3010
01:54:36,530 --> 01:54:41,450
存储 在N中 ，如果用户输入了 

3011
01:54:39,350 --> 01:54:44,170
小于 1的值是这样的 

3012
01:54:41,450 --> 01:54:46,880
如果n小于 1， 则为真或假 

3013
01:54:44,170 --> 01:54:50,840
所以如果n就像 人类在0中那样 

3014
01:54:46,880 --> 01:54:53,300
是0 小于1是的是的是什么 

3015
01:54:50,840 --> 01:54:55,490
如果你回去做 ，你会做 

3016
01:54:53,300 --> 01:54:58,790
如果用户输入 负数1 则再次 

3017
01:54:55,490 --> 01:55:00,680
是负1小于1是或是如此 

3018
01:54:58,790 --> 01:55:02,900
你再这样做， 如果他或 她类型 

3019
01:55:00,680 --> 01:55:05,720
如果他或 她 再次负面2 

3020
01:55:02,900 --> 01:55:08,930
50井50中的类型不小于1 

3021
01:55:05,720 --> 01:55:11,510
所以这是 假的 ，所以你继续 

3022
01:55:08,930 --> 01:55:12,860
完全到下一行代码 但是 

3023
01:55:11,510 --> 01:55:16,130
关于下一行的有趣之处 

3024
01:55:12,860 --> 01:55:18,650
的 代码是 不同于 COFF示例 

3025
01:55:16,130 --> 01:55:20,240
返回类型得到的是void 

3026
01:55:18,650 --> 01:55:22,100
默认情况下应为正int 

3027
01:55:20,240 --> 01:55:24,290
像 Aaron 一样返回一个int 

3028
01:55:22,100 --> 01:55:26,750
递给我一张带绳子的纸 

3029
01:55:24,290 --> 01:55:28,790
如果我想要自己的话就在这里 

3030
01:55:26,750 --> 01:55:30,470
自定义函数称为get positive in 

3031
01:55:28,790 --> 01:55:33,200
返回一个值 还有另一个词 

3032
01:55:30,470 --> 01:55:34,970
在C中你真的写回报 然后 

3033
01:55:33,200 --> 01:55:36,850
的变量或值 的名称

3034
01:55:34,970 --> 01:55:39,440
你要交回来的 

3035
01:55:36,850 --> 01:55:43,340
任何形式的隐喻纸

3036
01:55:39,440 --> 01:55:49,400
代码正在使用这个，所以这是多么奇怪 

3037
01:55:43,340 --> 01:55:52,930
如果我要模仿，为什么我不能这样做呢？ 

3038
01:55:49,400 --> 01:55:55,100
我们之前写的代码就是这样的原因

3039
01:55:52,930 --> 01:55:57,400
这行代码不能正常工作吗？ 

3040
01:55:55,100 --> 01:56:02,020
逻辑上使用某些 种类的 

3041
01:55:57,400 --> 01:56:04,289
到目前为止我们已经拥有的心理模型

3042
01:56:02,020 --> 01:56:07,079
萨根 

3043
01:56:04,289 --> 01:56:08,219
是的，声明只是意味着创造就是 

3044
01:56:07,079 --> 01:56:09,900
说法的花哨方式和编程 

3045
01:56:08,219 --> 01:56:12,570
创造所以这说嘿计算机给 

3046
01:56:09,900 --> 01:56:13,949
我把一个整数称为 n并将其设置为相等 

3047
01:56:12,570 --> 01:56:15,900
到了get的返回值

3048
01:56:13,949 --> 01:56:18,510
无论函数或亚伦如何交给我 

3049
01:56:15,900 --> 01:56:21,960
回来把它放在这里， 但问题是 

3050
01:56:18,510 --> 01:56:24,179
在 c变量中有范围范围是 

3051
01:56:21,960 --> 01:56:27,630
一种说它们只存在于中的奇特方式

3052
01:56:24,179 --> 01:56:29,940
之间的花括号之间 

3053
01:56:27,630 --> 01:56:32,820
它们被宣布为意味着 

3054
01:56:29,940 --> 01:56:35,460
这一行这个变量只是字面上的 

3055
01:56:32,820 --> 01:56:36,960
在 这里 和这里 之间存在 ，然后 它 

3056
01:56:35,460 --> 01:56:38,940
只是有点离开电脑 

3057
01:56:36,960 --> 01:56:40,949
我不知道 它，但那是 

3058
01:56:38,940 --> 01:56:45,780
一个问题，因为在什么行号做 

3059
01:56:40,949 --> 01:56:48,179
我们实际上需要知道 n看起来像21 

3060
01:56:45,780 --> 01:56:49,769
这就是 外面的大括号这样 

3061
01:56:48,179 --> 01:56:51,840
只是基于那个基本定义 

3062
01:56:49,769 --> 01:56:53,519
范围是两个花括号之间 

3063
01:56:51,840 --> 01:56:54,929
哪个变量 被声明 它没有 

3064
01:56:53,519 --> 01:56:56,760
这些代码只存在于他们之外 

3065
01:56:54,929 --> 01:56:58,500
将无法工作，我将在以后修复它 

3066
01:56:56,760 --> 01:57:00,210
你看到正确的 错误信息为什么 

3067
01:56:58,500 --> 01:57:02,880
这是否不能很好 的工作 你声明 

3068
01:57:00,210 --> 01:57:04,500
在那些花括号里面那么怎么办 

3069
01:57:02,880 --> 01:57:06,929
事实证明，你可以避免这种情况 

3070
01:57:04,500 --> 01:57:09,000
之前存放的人只是 宣布 

3071
01:57:06,929 --> 01:57:11,639
它本身甚至没有 给它一个 

3072
01:57:09,000 --> 01:57:13,800
价值，实际上的语法 是 

3073
01:57:11,639 --> 01:57:16,289
只是 做半个思想 INT n个 

3074
01:57:13,800 --> 01:57:18,179
分号它没有 价值 ， 我们知道 

3075
01:57:16,289 --> 01:57:20,250
但它有垃圾值，但更多 

3076
01:57:18,179 --> 01:57:22,289
那是另一次， 但现在确实 存在 

3077
01:57:20,250 --> 01:57:25,199
现在注意哪些花括号呢 

3078
01:57:22,289 --> 01:57:27,119
它存在 于这一个和这一个中 

3079
01:57:25,199 --> 01:57:28,710
这意味着 它现在可以访问 

3080
01:57:27,119 --> 01:57:30,539
无处不在，如果你和你的划痕 

3081
01:57:28,710 --> 01:57:31,500
程序实际上使用了变量你 

3082
01:57:30,539 --> 01:57:32,880
可能已经注意到你必须这样做 

3083
01:57:31,500 --> 01:57:36,300
选择你必须做出决定 的 

3084
01:57:32,880 --> 01:57:37,739
这个精灵或者因为 这是 所有精灵 

3085
01:57:36,300 --> 01:57:41,280
暗示 所谓的内容 

3086
01:57:37,739 --> 01:57:42,869
编程本地或全局变量 

3087
01:57:41,280 --> 01:57:44,699
这些仍然是本地的， 我们会来的 

3088
01:57:42,869 --> 01:57:46,440
早些时候 回到 这个词， 但它必须 

3089
01:57:44,699 --> 01:57:48,989
做范围，因为如果你有 

3090
01:57:46,440 --> 01:57:51,269
为此精灵指定只有麻省理工学院会 

3091
01:57:48,989 --> 01:57:53,400
只让你使用 变量 

3092
01:57:51,269 --> 01:57:54,840
cat或or的特定精灵 

3093
01:57:53,400 --> 01:57:57,719
绵羊或者你是 什么 

3094
01:57:54,840 --> 01:58:00,150
现在 就像在 C中 编程 一样 

3095
01:57:57,719 --> 01:58:02,329
n可以在这里 使用 ，但不能 

3096
01:58:00,150 --> 01:58:07,230
像其他地方在我的节目上涨 

3097
01:58:02,329 --> 01:58:08,880
这是范围的问题，现在让我们来吧 

3098
01:58:07,230 --> 01:58:10,650
看看会出问题

3099
01:58:08,880 --> 01:58:13,199
除此之外， 让我 去 进取，不断 开拓 

3100
01:58:10,650 --> 01:58:15,119
这是因为事实证明

3101
01:58:13,199 --> 01:58:17,130
节目还有其他问题 

3102
01:58:15,119 --> 01:58:17,790
可能发生的不 只是浮点 

3103
01:58:17,130 --> 01:58:19,710
不精确

3104
01:58:17,790 --> 01:58:22,410
我将其形容为早期事实 

3105
01:58:19,710 --> 01:58:24,720
可以解决其他问题 

3106
01:58:22,410 --> 01:58:26,430
即使 是我们 友好的整数也会出错

3107
01:58:24,720 --> 01:58:28,290
中完全避免这样记得 ， 我们 

3108
01:58:26,430 --> 01:58:31,200
开始谈论1 2和3 以及为什么 

3109
01:58:28,290 --> 01:58:34,500
上周发生的事情很好 

3110
01:58:31,200 --> 01:58:37,170
十进制，如果你添加101到123什么

3111
01:58:34,500 --> 01:58:40,980
如果我们这样做，你会明白这个数字吗？ 

3112
01:58:37,170 --> 01:58:45,330
再一次100 25 26 27 28 29会发生什么 

3113
01:58:40,980 --> 01:58:47,370
如果我 在9 井中 加1 ，则以十进制表示

3114
01:58:45,330 --> 01:58:49,140
应该得到10但这不是我们的方式

3115
01:58:47,370 --> 01:58:51,540
会写下这个你放下的权利 

3116
01:58:49,140 --> 01:58:53,070
0而不是你带1右 

3117
01:58:51,540 --> 01:58:55,020
记住那种心理 

3118
01:58:53,070 --> 01:58:58,680
启发式，这就是我们在那里所做的一切 

3119
01:58:55,020 --> 01:59:02,220
然后它是2 + 1所以这就是为什么129 

3120
01:58:58,680 --> 01:59:04,260
加1是130， 因为你把0给你 

3121
01:59:02,220 --> 01:59:06,060
携带1 等等所以我们 所有人 

3122
01:59:04,260 --> 01:59:07,920
现在直观地做，但这有 

3123
01:59:06,060 --> 01:59:09,630
什么电脑做 太多 的影响 

3124
01:59:07,920 --> 01:59:12,870
因为 假设我们考虑一个 

3125
01:59:09,630 --> 01:59:16,170
更大的数字， 如999 ，那么做什么 

3126
01:59:12,870 --> 01:59:16,950
当你加1至999时，你得到了

3127
01:59:16,170 --> 01:59:18,930
携带1 

3128
01:59:16,950 --> 01:59:22,350
你携带1，你希望得到一个 

3129
01:59:18,930 --> 01:59:25,500
千， 但如果你的电脑 只是 

3130
01:59:22,350 --> 01:59:27,210
有空隙3位还是什么，如果你的 

3131
01:59:25,500 --> 01:59:28,770
电话或如果您的闹钟或 

3132
01:59:27,210 --> 01:59:31,320
无论设备 是什么， 只是字面上的 

3133
01:59:28,770 --> 01:59:35,550
有3位数的空间 

3134
01:59:31,320 --> 01:59:39,360
如果你的 硬件只有 999 加1 

3135
01:59:35,550 --> 01:59:41,310
有 3位数，显然是0所以 

3136
01:59:39,360 --> 01:59:46,140
你得到这种溢出 1 

3137
01:59:41,310 --> 01:59:48,270
不是998 999 0它可以说溢出 

3138
01:59:46,140 --> 01:59:50,610
从概念上讲，有 一种 脱落 

3139
01:59:48,270 --> 01:59:54,660
你翻到下一个 值 

3140
01:59:50,610 --> 01:59:56,580
0 0 0那么 二进制是什么呢 

3141
01:59:54,660 --> 01:59:58,020
如果你，数字是 二进制的 

3142
01:59:56,580 --> 01:59:59,880
翻译它 在你的脑袋为十进制 ， 

3143
01:59:58,020 --> 02:00:03,060
记住它是 二十二列

3144
01:59:59,880 --> 02:00:06,510
列和四列，所以这是

3145
02:00:03,060 --> 02:00:09,240
7在二进制1中所以它是4加2加1所以 

3146
02:00:06,510 --> 02:00:11,040
7二进制， 所以你怎么做算术 

3147
02:00:09,240 --> 02:00:13,230
与二进制它实际上是相同的事情 

3148
02:00:11,040 --> 02:00:14,790
只是你没有Zoar三分球 

3149
02:00:13,230 --> 02:00:16,770
或九或其间的任何东西

3150
02:00:14,790 --> 02:00:20,310
你只有零和零那么做什么

3151
02:00:16,770 --> 02:00:22,440
当你添加 1 2 1 1 1 时，你会得到它 

3152
02:00:20,310 --> 02:00:24,330
同样的想法， 你放下 了0和你 

3153
02:00:22,440 --> 02:00:26,850
携带1，因为1加1 要 

3154
02:00:24,330 --> 02:00:29,130
用小数表示2，但没有2， 所以它 

3155
02:00:26,850 --> 02:00:31,770
翻到0，但你带1 1 

3156
02:00:29,130 --> 02:00:33,600
加1是2，但 确定是 Z. 

3157
02:00:31,770 --> 02:00:34,860
携带一个 一加一每 二 

3158
02:00:33,600 --> 02:00:35,250
但是我没有两个，所以我回去了 

3159
02:00:34,860 --> 02:00:38,130
零 

3160
02:00:35,250 --> 02:00:42,510
如果你只是 携带一个 二进制文件 

3161
02:00:38,130 --> 02:00:44,520
如果你有三个字节或位 

3162
02:00:42,510 --> 02:00:47,070
只有三位你得到什么 

3163
02:00:44,520 --> 02:00:50,070
当你 以二进制形式添加一到七个时 

3164
02:00:47,070 --> 02:00:51,690
显然是 零，现在它已经到了 

3165
02:00:50,070 --> 02:00:53,430
在我的 计算机中 更加真实 

3166
02:00:51,690 --> 02:00:55,080
电话在你所有的硬件中它只是 

3167
02:00:53,430 --> 02:00:56,370
有限 的 内存 RAM 

3168
02:00:55,080 --> 02:00:57,810
我在屏幕上显示的小芯片

3169
02:00:56,370 --> 02:01:00,420
与 所有的小电路 和那 

3170
02:00:57,810 --> 02:01:02,760
有 超过三位的内存 

3171
02:01:00,420 --> 02:01:04,830
当然，但它是有限的，如果我们是 

3172
02:01:02,760 --> 02:01:06,810
仅作为 惯例的使用32 

3173
02:01:04,830 --> 02:01:08,370
用于表示事物或64位的位 

3174
02:01:06,810 --> 02:01:11,040
也许如果我们使用双打或其他东西

3175
02:01:08,370 --> 02:01:12,719
其他叫长的是64位 

3176
02:01:11,040 --> 02:01:15,680
整数， 而通常是整数 

3177
02:01:12,719 --> 02:01:18,210
在某些时候似乎是 32位

3178
02:01:15,680 --> 02:01:20,130
数字可能会溢出，我们会 

3179
02:01:18,210 --> 02:01:23,430
实际上有一些可以这么说 

3180
02:01:20,130 --> 02:01:25,110
不精确的ergo 整数溢出所以你 

3181
02:01:23,430 --> 02:01:26,580
实际上可以看到这个或防御

3182
02:01:25,110 --> 02:01:29,040
在现实世界中反对这一点 

3183
02:01:26,580 --> 02:01:30,600
是 游戏 的截图 

3184
02:01:29,040 --> 02:01:32,670
常见于几个不同的平台 和 

3185
02:01:30,600 --> 02:01:34,680
这是一款允许你玩的游戏

3186
02:01:32,670 --> 02:01:36,660
积累硬币或点真或 

3187
02:01:34,680 --> 02:01:38,130
小乐高碎片，如果你累积 

3188
02:01:36,660 --> 02:01:39,870
这些要点你会注意到这一点 

3189
02:01:38,130 --> 02:01:42,449
最终，如果你 有太多的自由 

3190
02:01:39,870 --> 02:01:45,420
时间你只能得分在 这个 如此之高 

3191
02:01:42,449 --> 02:01:46,980
游戏显然是最高分 

3192
02:01:45,420 --> 02:01:48,270
根据 谁 的截图 

3193
02:01:46,980 --> 02:01:50,390
在打了太多之后拿了这个 

3194
02:01:48,270 --> 02:01:53,580
小时不是我 

3195
02:01:50,390 --> 02:01:56,610
四百万没四十亿 四 

3196
02:01:53,580 --> 02:01:58,860
事实证明， 为什么会这么 好 

3197
02:01:56,610 --> 02:02:01,110
如果数字和计算机就像我一样 

3198
02:01:58,860 --> 02:02:02,969
建议通常使用32存储

3199
02:02:01,110 --> 02:02:04,560
那种邀请问题的比特

3200
02:02:02,969 --> 02:02:07,770
你有多高可以计算32位 

3201
02:02:04,560 --> 02:02:09,420
32位意味着 你有32个零和 

3202
02:02:07,770 --> 02:02:11,130
他们可能拥有的最大的是 

3203
02:02:09,420 --> 02:02:13,140
喜欢一一一一 三十二 

3204
02:02:11,130 --> 02:02:15,390
如果你真的 使用 数学 

3205
02:02:13,140 --> 02:02:17,670
我们的小柱子等等 

3206
02:02:15,390 --> 02:02:19,560
大约40亿 大一点 

3207
02:02:17,670 --> 02:02:21,120
超过 40亿 这样的作者 

3208
02:02:19,560 --> 02:02:22,739
乐高游戏刚刚决定 你知道什么 

3209
02:02:21,120 --> 02:02:24,870
我们只说最大数量 

3210
02:02:22,739 --> 02:02:26,940
点或硬币，你可以 在 积累 

3211
02:02:24,870 --> 02:02:29,280
这个乐高游戏甚至是四十亿 

3212
02:02:26,940 --> 02:02:32,370
它看起来 比任何东西 都更清洁 

3213
02:02:29,280 --> 02:02:34,380
实际价值是但为何有多少 

3214
02:02:32,370 --> 02:02:39,840
他们用来存储你的分数 

3215
02:02:34,380 --> 02:02:41,070
在这个游戏中大概是32位或4位 

3216
02:02:39,840 --> 02:02:42,630
字节，这只是惯例

3217
02:02:41,070 --> 02:02:44,760
他们编程的语言

3218
02:02:42,630 --> 02:02:45,300
游戏可能有一个 名为 的 数据类型 

3219
02:02:44,760 --> 02:02:48,330
一个int 

3220
02:02:45,300 --> 02:02:50,520
按惯例 ， int使用32位 

3221
02:02:48,330 --> 02:02:52,320
所以在某些时候他们决定我们 可以 

3222
02:02:50,520 --> 02:02:54,240
要么像 你提出的 那样使用更多内存

3223
02:02:52,320 --> 02:02:55,890
较早的双打让我们使用64位 

3224
02:02:54,240 --> 02:02:57,030
那么你可以有疯狂的小时数

3225
02:02:55,890 --> 02:02:58,890
玩游戏，获得更多和 

3226
02:02:57,030 --> 02:03:00,780
更多的点，或者我们可以说那是 

3227
02:02:58,890 --> 02:03:02,580
足够积分在游戏中积累 

3228
02:03:00,780 --> 02:03:04,530
现在就是你真正 期待 的时候 

3229
02:03:02,580 --> 02:03:07,200
这并不总是真的 发生 

3230
02:03:04,530 --> 02:03:09,540
如果我们继续 看看 

3231
02:03:07,200 --> 02:03:13,260
一些示例代码 让我继续前进 

3232
02:03:09,540 --> 02:03:16,980
在这个程序中打开溢出点C. 

3233
02:03:13,260 --> 02:03:18,810
在这里，你会在第 8 行看到 这个斜线 

3234
02:03:16,980 --> 02:03:19,890
斜杠语法，我有一堆 

3235
02:03:18,810 --> 02:03:21,930
这些到目前为止， 但我实际上并没有 

3236
02:03:19,890 --> 02:03:23,100
提到他们 原来在看到刚 

3237
02:03:21,930 --> 02:03:24,360
尽管你很有可能 

3238
02:03:23,100 --> 02:03:25,680
没有注意到这个小小的特征 

3239
02:03:24,360 --> 02:03:28,050
划伤你 永远不能忍受叫 

3240
02:03:25,680 --> 02:03:29,910
评论评论只是一个单词的注释 

3241
02:03:28,050 --> 02:03:31,290
为自己的TF你的朋友 

3242
02:03:29,910 --> 02:03:33,270
你的同事和你在一起

3243
02:03:31,290 --> 02:03:34,860
用代码编写代码，它只是一个注释

3244
02:03:33,270 --> 02:03:37,200
自我喜欢提醒自己什么 

3245
02:03:34,860 --> 02:03:38,880
没有 这一行我 的代码是 正确的 

3246
02:03:37,200 --> 02:03:40,290
可能希望我足够舒服 

3247
02:03:38,880 --> 02:03:41,610
编程有点弄清楚什么 

3248
02:03:40,290 --> 02:03:43,230
这些代码行 正在做 

3249
02:03:41,610 --> 02:03:44,790
坦率地说，这是浪费我写的时间 

3250
02:03:43,230 --> 02:03:46,440
代码一次，如果我看了 几周 

3251
02:03:44,790 --> 02:03:48,600
或几个月后或其他人 写的 

3252
02:03:46,440 --> 02:03:50,490
只要告诉我它做 了 什么就 这么评论 

3253
02:03:48,600 --> 02:03:53,220
在一个程序中它就像一个很好的 

3254
02:03:50,490 --> 02:03:54,630
像几行代码的总结或 

3255
02:03:53,220 --> 02:03:56,880
它是英文或其他的摘要

3256
02:03:54,630 --> 02:03:59,430
那种描述的口语

3257
02:03:56,880 --> 02:04:00,630
否则是一个神秘的代码 

3258
02:03:59,430 --> 02:04:01,980
可能实际上是这样做你没有 

3259
02:04:00,630 --> 02:04:03,930
有太辛苦去想 它 

3260
02:04:01,980 --> 02:04:05,970
如此迭代地理解程序

3261
02:04:03,930 --> 02:04:07,770
双眼迭代它只是意味着 

3262
02:04:05,970 --> 02:04:10,020
一次又一次地循环李 

3263
02:04:07,770 --> 02:04:12,720
这是时髦的， 我们之前没有看到 过 

3264
02:04:10,020 --> 02:04:16,320
但 你可能猜到它做了什么 

3265
02:04:12,720 --> 02:04:19,080
明星等于它是否会加倍 

3266
02:04:16,320 --> 02:04:20,970
喜欢加等于增加一个星等于 

3267
02:04:19,080 --> 02:04:22,980
如果右边的值是2 ，则加倍

3268
02:04:20,970 --> 02:04:26,220
所以这将 开始打印 一个 

3269
02:04:22,980 --> 02:04:28,560
然后两个然后 四个然后八个等等 

3270
02:04:26,220 --> 02:04:30,330
它注意到了这个功能

3271
02:04:28,560 --> 02:04:32,790
叫睡觉它真的会睡觉 

3272
02:04:30,330 --> 02:04:34,950
一秒钟，睡眠 功能有 

3273
02:04:32,790 --> 02:04:37,950
别人 写的一个原型

3274
02:04:34,950 --> 02:04:38,940
名为uni标准 点的文件知道 

3275
02:04:37,950 --> 02:04:40,770
通过在寻找它 

3276
02:04:38,940 --> 02:04:44,760
文档但是这是一个新的文件 只是 

3277
02:04:40,770 --> 02:04:46,320
睡觉 让溢出是善良的 

3278
02:04:44,760 --> 02:04:48,150
在这里，让我继续前进 

3279
02:04:46,320 --> 02:04:53,750
终端窗口甚至更大 

3280
02:04:48,150 --> 02:04:56,190
一个点斜线溢出好吧它会去 

3281
02:04:53,750 --> 02:04:57,750
它会 它 会 走得更快， 

3282
02:04:56,190 --> 02:04:58,650
更快，可以这么说，因为我们正在添加 

3283
02:04:57,750 --> 02:05:02,940
越来越 多 

3284
02:04:58,650 --> 02:05:04,860
每次加倍， 好两个 

3285
02:05:02,940 --> 02:05:08,070
千四万八千

3286
02:05:04,860 --> 02:05:11,159
一万六千还在继续

3287
02:05:08,070 --> 02:05:13,770
我们现在有 六十六万 六千五百 

3288
02:05:11,159 --> 02:05:16,830
进入数百万 - 四百 八十 

3289
02:05:13,770 --> 02:05:22,159
一千六百万它变得越来越大 

3290
02:05:16,830 --> 02:05:22,159
更大的所有 这些大数字 哦 

3291
02:05:22,429 --> 02:05:27,179
有趣 

3292
02:05:23,909 --> 02:05:28,350
结果发生的事情就是如此 

3293
02:05:27,179 --> 02:05:30,390
如果你的双数是足够大的你

3294
02:05:28,350 --> 02:05:32,280
最终 也 得到零 你也是 

3295
02:05:30,390 --> 02:05:34,650
实际上可能没有被教过 

3296
02:05:32,280 --> 02:05:36,690
发生 ctrl C会取消这个 

3297
02:05:34,650 --> 02:05:37,770
发生了我的意思是该计划正在尝试 

3298
02:05:36,690 --> 02:05:40,590
告诉我即使它有点 

3299
02:05:37,770 --> 02:05:41,820
神秘的有符号整数溢出符号 

3300
02:05:40,590 --> 02:05:44,870
只是意味着它从积极变为 

3301
02:05:41,820 --> 02:05:47,969
基本上是消极的，所发生 

3302
02:05:44,870 --> 02:05:49,409
是什么，是的，我跑出了我的位 

3303
02:05:47,969 --> 02:05:51,120
这个数字一次又一次地翻倍 

3304
02:05:49,409 --> 02:05:53,850
再次，在某些时候，我们进行了 

3305
02:05:51,120 --> 02:05:55,530
一个可以这么说，这是 第33个 

3306
02:05:53,850 --> 02:05:57,540
因此通过 了a的界限 

3307
02:05:55,530 --> 02:05:59,219
32位的值，它只是翻了个身 

3308
02:05:57,540 --> 02:06:00,840
显然是负面的，因为在某些方面 

3309
02:05:59,219 --> 02:06:02,820
我们没有谈到你可以 

3310
02:06:00,840 --> 02:06:04,620
在某种意义上使用最左边的位 

3311
02:06:02,820 --> 02:06:06,360
我们只是 说积极 或消极 

3312
02:06:04,620 --> 02:06:07,679
到目前为止谈到积极的，然后是 

3313
02:06:06,360 --> 02:06:09,750
那点坦率地说就是电脑 

3314
02:06:07,679 --> 02:06:11,370
放弃了不知道你是什么 

3315
02:06:09,750 --> 02:06:14,280
除此之外的意图， 如果你不这样做 

3316
02:06:11,370 --> 02:06:16,080
编写代码来 处理这种情况 

3317
02:06:14,280 --> 02:06:18,750
确保您的号码更少

3318
02:06:16,080 --> 02:06:20,699
只是 在你 翻身 之前超过40亿 

3319
02:06:18,750 --> 02:06:23,250
错误会发生，这似乎是

3320
02:06:20,699 --> 02:06:26,940
在这里做作，但事情并非如此 

3321
02:06:23,250 --> 02:06:28,110
很久以前 所以1999年才刚刚开始 

3322
02:06:26,940 --> 02:06:31,230
人们认为这个世界将会发生 

3323
02:06:28,110 --> 02:06:32,940
因为 所谓的 y2k bug而结束 

3324
02:06:31,230 --> 02:06:34,890
它真的不是那么多的错误 

3325
02:06:32,940 --> 02:06:37,650
喜欢缺乏远见或缺乏 

3326
02:06:34,890 --> 02:06:43,620
特征是什么是y2k问题 

3327
02:06:37,650 --> 02:06:46,670
简而言之，有人想提出建议 

3328
02:06:43,620 --> 02:06:46,670
一种非技术性的 感觉是的 

3329
02:06:47,929 --> 02:06:53,030
是的， 所以那么让我总结一下 

3330
02:06:50,929 --> 02:06:55,370
如果他们 只使用 两个， 那么这里

3331
02:06:53,030 --> 02:06:58,070
用于显示 值的数字

3332
02:06:55,370 --> 02:07:01,190
将2000年与实际上的混淆

3333
02:06:58,070 --> 02:07:03,170
1900年，因为长话短说什么 

3334
02:07:01,190 --> 02:07:05,659
人类有相当数十年的时间

3335
02:07:03,170 --> 02:07:08,090
以前你知道空间很贵吗？ 

3336
02:07:05,659 --> 02:07:10,400
电脑是昂贵的 记忆不是 

3337
02:07:08,090 --> 02:07:12,140
有点像现在一样丰富 

3338
02:07:10,400 --> 02:07:15,110
所有云存储等都是如此 

3339
02:07:12,140 --> 02:07:18,080
你知道如果它像1970年一样吗？ 

3340
02:07:15,110 --> 02:07:20,360
非常关心1969年1968年，更不用说了 

3341
02:07:18,080 --> 02:07:23,710
1900年不是真的让我们假设我们

3342
02:07:20,360 --> 02:07:26,330
所有在20世纪初，从未展示或存储 

3343
02:07:23,710 --> 02:07:30,920
1/9 让我们只存储两位数 

3344
02:07:26,330 --> 02:07:33,110
每年所以7 0是70 99是1999年但是 

3345
02:07:30,920 --> 02:07:35,330
问题是人类最终结束了 

3346
02:07:33,110 --> 02:07:38,300
运行他们 多年前写的 代码 

3347
02:07:35,330 --> 02:07:39,949
几十年前的方式 比人类长 

3348
02:07:38,300 --> 02:07:41,570
以为他们可能为什么这么好

3349
02:07:39,949 --> 02:07:43,610
变得 昂贵 耗费时间 

3350
02:07:41,570 --> 02:07:46,340
编码代码工作为什么试图打破 

3351
02:07:43,610 --> 02:07:48,260
它的问题是 - 随着年龄的增长而变老 

3352
02:07:46,340 --> 02:07:50,060
过世了，越来越少了 

3353
02:07:48,260 --> 02:07:51,800
那些甚至 都知道语言的人 

3354
02:07:50,060 --> 02:07:53,630
哪些程序是这样编写的 

3355
02:07:51,800 --> 02:07:55,489
现在谁还要更新 软件 

3356
02:07:53,630 --> 02:07:58,100
所以很多问题都是或者是

3357
02:07:55,489 --> 02:08:02,239
害怕，这真的只是归结 起来 

3358
02:07:58,100 --> 02:08:05,900
因为1999年可能已经溢出 - 

3359
02:08:02,239 --> 02:08:07,580
不是0本身，而是隐含的1900和 

3360
02:08:05,900 --> 02:08:09,260
确实这确实发生了

3361
02:08:07,580 --> 02:08:11,060
人们 并没有接近规模 

3362
02:08:09,260 --> 02:08:12,650
但确实发生 了更为真实的 事情 

3363
02:08:11,060 --> 02:08:16,250
就在几年前，这 是一个 例子 

3364
02:08:12,650 --> 02:08:17,870
波音787的飞机实际是有 

3365
02:08:16,250 --> 02:08:21,560
停留一段时间 

3366
02:08:17,870 --> 02:08:23,690
因为它有一个编程错误和 

3367
02:08:21,560 --> 02:08:26,840
它在网上总结了这里 

3368
02:08:23,690 --> 02:08:29,870
文章一架787飞机 

3369
02:08:26,840 --> 02:08:32,659
它持续供电248天 

3370
02:08:29,870 --> 02:08:35,210
结果是警告可能会失去一切 

3371
02:08:32,659 --> 02:08:38,420
由于它的电力

3372
02:08:35,210 --> 02:08:40,489
发电机 进入故障安全模式的 原因 

3373
02:08:38,420 --> 02:08:42,739
是这种 情况 是由a引起的 

3374
02:08:40,489 --> 02:08:47,060
内部的软件计数器

3375
02:08:42,739 --> 02:08:49,820
248后会溢出的发电机

3376
02:08:47,060 --> 02:08:51,739
连续动力的日子如此翻译 

3377
02:08:49,820 --> 02:08:54,469
这只意味着 有软件 

3378
02:08:51,739 --> 02:08:56,449
在波音的实际 787中运行

3379
02:08:54,469 --> 02:08:57,889
他们使用的是32位整数 

3380
02:08:56,449 --> 02:09:00,949
正在使用那些整数存储 

3381
02:08:57,889 --> 02:09:01,610
几百秒，在某些时候，如果 

3382
02:09:00,949 --> 02:09:05,570
你离开了

3383
02:09:01,610 --> 02:09:08,480
每天玩248天 

3384
02:09:05,570 --> 02:09:12,739
每小时 24小时60 分钟60 

3385
02:09:08,480 --> 02:09:14,929
一分钟秒和十分之一秒 

3386
02:09:12,739 --> 02:09:17,869
第二或101百秒 

3387
02:09:14,929 --> 02:09:20,330
每一秒乘以的乘积 

3388
02:09:17,869 --> 02:09:22,489
事情出得大相当快 和 

3389
02:09:20,330 --> 02:09:25,130
一天二百四 十九架飞机 

3390
02:09:22,489 --> 02:09:27,080
从理论上讲， 即使在 

3391
02:09:25,130 --> 02:09:28,280
飞行的中间非常真实 

3392
02:09:27,080 --> 02:09:30,590
原因，因为 一个非常大的数字 

3393
02:09:28,280 --> 02:09:33,500
滚到零， 这混淆 了 

3394
02:09:30,590 --> 02:09:35,690
发电机这些都是真正的智能 你 

3395
02:09:33,500 --> 02:09:37,520
知道飞机工程师制作 这些 

3396
02:09:35,690 --> 02:09:39,440
由于软件的错误

3397
02:09:37,520 --> 02:09:40,699
不要期待一行代码或 

3398
02:09:39,440 --> 02:09:42,230
一些代码 行 或者像你一样 

3399
02:09:40,699 --> 02:09:44,420
提出为什么他们不只是使用更多 

3400
02:09:42,230 --> 02:09:46,610
这些都 非常真实 

3401
02:09:44,420 --> 02:09:48,440
担心， 所以谢天谢地 

3402
02:09:46,610 --> 02:09:50,360
处理和解决，但不是之前的 

3403
02:09:48,440 --> 02:09:53,060
当然那里有 很多 恐慌 

3404
02:09:50,360 --> 02:09:55,460
所以这在旧游戏中就是这样 

3405
02:09:53,060 --> 02:09:57,110
是 文明 的游戏 结果 

3406
02:09:55,460 --> 02:09:59,060
其中一个 角色 假设你 

3407
02:09:57,110 --> 02:10:01,340
可以玩甘地实际上并不如此 

3408
02:09:59,060 --> 02:10:03,350
和平的 游戏角色 是 

3409
02:10:01,340 --> 02:10:05,449
你可能会想到并让我们为上下文 

3410
02:10:03,350 --> 02:10:09,110
如果我们，请在这里看一下

3411
02:10:05,449 --> 02:10:12,790
实际上 看看更多的二进制文件 

3412
02:10:09,110 --> 02:10:16,100
二进制数是十进制数 

3413
02:10:12,790 --> 02:10:19,699
好吧1，这 是 8位，所以它是一个完整的 

3414
02:10:16,100 --> 02:10:25,670
字节8位 是一个字节1 2 3 4 5 6 7 8所以 

3415
02:10:19,699 --> 02:10:27,080
你得到了什么 ，如果你做 1 -那么，如果 

3416
02:10:25,670 --> 02:10:30,380
你 显然 从中减去1 

3417
02:10:27,080 --> 02:10:32,540
得到什么都好0 所以1减1 只是0 

3418
02:10:30,380 --> 02:10:37,460
如果你减去2，你会得到什么呢？ 

3419
02:10:32,540 --> 02:10:39,199
从这个价值来看，这是怎么回事

3420
02:10:37,460 --> 02:10:40,699
实际上称为整数下溢 

3421
02:10:39,199 --> 02:10:42,199
这恰恰相反，但有

3422
02:10:40,699 --> 02:10:43,310
真的没有太多选择 思考 

3423
02:10:42,199 --> 02:10:44,719
关于这个，如果你只有零和 

3424
02:10:43,310 --> 02:10:49,010
那些你可以想象的是什么 

3425
02:10:44,719 --> 02:10:51,110
糟糕的情况是， 如果你是0 0 0 0 0 0 1 

3426
02:10:49,010 --> 02:10:53,989
减去1变为0 然后你 这样做 

3427
02:10:51,110 --> 02:10:56,150
再次你现在 下流 哪个 

3428
02:10:53,989 --> 02:10:59,449
带你到对面 1 1 1 

3429
02:10:56,150 --> 02:11:02,540
1 1 1 1 所以，如果你有八个1s什么的 

3430
02:10:59,449 --> 02:11:06,770
值得的是，如果你做数学的那些

3431
02:11:02,540 --> 02:11:08,540
twos fours 8 16 事实证明它是255 

3432
02:11:06,770 --> 02:11:10,760
你实际上完成了所有的数学运算

3433
02:11:08,540 --> 02:11:13,040
原来这个游戏文明 

3434
02:11:10,760 --> 02:11:15,050
使用单个字节来表示

3435
02:11:13,040 --> 02:11:15,430
每个角色的攻击性水平

3436
02:11:15,050 --> 02:11:17,920
和

3437
02:11:15,430 --> 02:11:20,200
和Gandhi的一样，正如你所期望的那样 

3438
02:11:17,920 --> 02:11:22,780
默认初始化为非常非 

3439
02:11:20,200 --> 02:11:24,220
不幸在这场比赛中咄咄逼人 

3440
02:11:22,780 --> 02:11:27,370
文明 

3441
02:11:24,220 --> 02:11:29,440
当一个球员在他或他的时候采用民主

3442
02:11:27,370 --> 02:11:32,550
她的文明侵略会 

3443
02:11:29,440 --> 02:11:36,100
自动减少两个左右 

3444
02:11:32,550 --> 02:11:37,480
如果甘地去民主党他的侵略 

3445
02:11:36,100 --> 02:11:38,890
它看起来不会消极

3446
02:11:37,480 --> 02:11:41,860
回到荒唐高处

3447
02:11:38,890 --> 02:11:45,250
255的数字让他变得好斗 

3448
02:11:41,860 --> 02:11:47,410
作为一个文明 可能是这样 

3449
02:11:45,250 --> 02:11:49,210
减少影响确定比什么 

3450
02:11:47,410 --> 02:11:51,340
像飞机的例子，但这些 

3451
02:11:49,210 --> 02:11:52,660
问题 是无所不在的 ， 如果你 

3452
02:11:51,340 --> 02:11:54,760
开始留意 在流行 

3453
02:11:52,660 --> 02:11:57,210
媒体或有错误或黑客或

3454
02:11:54,760 --> 02:12:00,400
经常利用它是因为 

3455
02:11:57,210 --> 02:12:01,930
程序员编程已经成为一个 

3456
02:12:00,400 --> 02:12:03,700
在 他或她的 代码中他们没有 错误 

3457
02:12:01,930 --> 02:12:06,340
期待一个场景或他们可能做出的 

3458
02:12:03,700 --> 02:12:08,050
多年前的合理决定但是那个 

3459
02:12:06,340 --> 02:12:09,100
最终被证明是天真 和 

3460
02:12:08,050 --> 02:12:10,510
我们仍在运行相同的 代码 

3461
02:12:09,100 --> 02:12:12,580
数字变得太大了他们的错误 

3462
02:12:10,510 --> 02:12:14,080
他们的数学是错误的，非常真实 

3463
02:12:12,580 --> 02:12:16,270
事情发生了，但最重要的是什么

3464
02:12:14,080 --> 02:12:18,610
对我们来说，只是 了解如何以及为什么 

3465
02:12:16,270 --> 02:12:20,110
那些事情发生了 ，所以我们会怎样 

3466
02:12:18,610 --> 02:12:21,580
在未来的日子做下一个 

3467
02:12:20,110 --> 02:12:23,110
家庭作业与刮擦一样 

3468
02:12:21,580 --> 02:12:25,270
是为了编程，但这一次 

3469
02:12:23,110 --> 02:12:27,400
C你将使用一个名为cs50的环境

3470
02:12:25,270 --> 02:12:28,660
实验室本质上是cs50沙箱 

3471
02:12:27,400 --> 02:12:30,580
我们今天一直在修修补补

3472
02:12:28,660 --> 02:12:32,290
但它增加了说明和 

3473
02:12:30,580 --> 02:12:33,400
问题的规范， 

3474
02:12:32,290 --> 02:12:34,960
你会想要解决它，它会坚持下去 

3475
02:12:33,400 --> 02:12:36,040
你的手最初是通过 他们的 

3476
02:12:34,960 --> 02:12:37,330
你不需要这些步骤有 

3477
02:12:36,040 --> 02:12:39,040
写下一切 并记住 

3478
02:12:37,330 --> 02:12:40,210
我今天输入的所有内容，但确实感觉到 

3479
02:12:39,040 --> 02:12:41,980
免费 的 平均时间 去 

3480
02:12:40,210 --> 02:12:43,690
课程网站和任何一个玩 

3481
02:12:41,980 --> 02:12:46,090
这些挑战中的例子

3482
02:12:43,690 --> 02:12:48,310
未来将 重新创建一些片段 

3483
02:12:46,090 --> 02:12:49,600
从昔日思考的游戏 

3484
02:12:48,310 --> 02:12:51,460
你可能会看到成长的方式 

3485
02:12:49,600 --> 02:12:53,410
up可以翻译成实际的代码和 

3486
02:12:51,460 --> 02:12:54,970
毫无疑问是最重要的事情之一 

3487
02:12:53,410 --> 02:12:56,770
你会遇到挫败感 

3488
02:12:54,970 --> 02:12:57,940
忘记愚蠢的分号或在哪里

3489
02:12:56,770 --> 02:12:59,170
括号去了，你会有 

3490
02:12:57,940 --> 02:13:01,120
回头看看 代码，但要记住 

3491
02:12:59,170 --> 02:13:02,980
这些 东西 都不 重要 

3492
02:13:01,120 --> 02:13:04,510
最初绝对令人沮丧但是 

3493
02:13:02,980 --> 02:13:06,460
最重要的是想法和想法 

3494
02:13:04,510 --> 02:13:08,440
说实话，我感到满足 

3495
02:13:06,460 --> 02:13:10,210
你喜欢所有 的 cs50工作人员 

3496
02:13:08,440 --> 02:13:12,070
最终感觉什么时候真正建设

3497
02:13:10,210 --> 02:13:13,390
并创造自己的东西

3498
02:13:12,070 --> 02:13:15,810
在那里叫它一天，我们会见到你 

3499
02:13:13,390 --> 02:13:15,810
下 一次 

