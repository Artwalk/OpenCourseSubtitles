1
00:00:00,000 --> 00:00:26,039
[音乐] 

2
00:00:30,050 --> 00:00:43,299
[音乐] 

3
00:00:46,040 --> 00:00:49,820
[掌声] 

4
00:00:47,200 --> 00:00:53,519
[音乐] 

5
00:00:49,820 --> 00:00:55,739
好吧这是 cs50，这是演讲 

6
00:00:53,519 --> 00:00:57,329
4呃 所以我们在美丽的 洛厄尔 

7
00:00:55,739 --> 00:00:58,890
演讲厅和桑德斯正在使用中 

8
00:00:57,329 --> 00:01:01,440
今天我们和一些朋友一起参加 

9
00:00:58,890 --> 00:01:03,600
很快就会清楚地 呈现出来 

10
00:01:01,440 --> 00:01:05,460
只是片刻，但在此之前回想起来 

11
00:01:03,600 --> 00:01:07,680
上次 我们看看 cs50 

12
00:01:05,460 --> 00:01:09,540
IDE 这 是一个新的基于Web的编程 

13
00:01:07,680 --> 00:01:11,820
环境与cs50类似 

14
00:01:09,540 --> 00:01:13,560
在cs50实验室的沙箱，但增加了一些 

15
00:01:11,820 --> 00:01:18,170
功能， 例如功能 

16
00:01:13,560 --> 00:01:21,690
它会增加你的能力是的

17
00:01:18,170 --> 00:01:23,250
什么是调试器如此调试50 

18
00:01:21,690 --> 00:01:24,690
打开允许的侧面板

19
00:01:23,250 --> 00:01:28,110
你逐步完成 代码 

20
00:01:24,690 --> 00:01:30,630
一步看到变量对不起说 

21
00:01:28,110 --> 00:01:32,429
再次检查50，这是一个cs50 

22
00:01:30,630 --> 00:01:33,690
允许您检查的特定工具

23
00:01:32,429 --> 00:01:34,890
代码的正确性很像 

24
00:01:33,690 --> 00:01:36,659
教学研究员什么时候开始 

25
00:01:34,890 --> 00:01:38,729
提供有关它运行的反馈

26
00:01:36,659 --> 00:01:40,289
一系列的测试，几乎是 

27
00:01:38,729 --> 00:01:41,729
同样的测试， 很多 的作业 

28
00:01:40,289 --> 00:01:43,259
会鼓励你自己跑

29
00:01:41,729 --> 00:01:46,490
手动，但 它只是自动化 

30
00:01:43,259 --> 00:01:46,490
过程和其他任何 事情 

31
00:01:50,720 --> 00:01:54,930
所以这是真的- 有一点点 

32
00:01:53,040 --> 00:01:57,149
隐藏的复活节彩蛋， 我们不使用这个 

33
00:01:54,930 --> 00:01:58,860
学期但是确实如果你寻找 

34
00:01:57,149 --> 00:02:01,259
你可以做一个小拼图 

35
00:01:58,860 --> 00:02:03,630
转换您的C代码回到 像刮 

36
00:02:01,259 --> 00:02:05,729
拼图 和来回 

37
00:02:03,630 --> 00:02:07,680
由于 奶油 和一些 来回 回来 

38
00:02:05,729 --> 00:02:08,819
团队的存在，但现在已经存在了 

39
00:02:07,680 --> 00:02:10,979
舒服起来可能更好 

40
00:02:08,819 --> 00:02:12,780
还有文字， 所以有几个 

41
00:02:10,979 --> 00:02:15,390
我们随着时间的推移使用的其他工具 

42
00:02:12,780 --> 00:02:17,730
当然除了check50和debug 50 

43
00:02:15,390 --> 00:02:20,489
我们当然要使用printf以及何时使用 

44
00:02:17,730 --> 00:02:23,220
printf很有用，就像你什么时候一样

45
00:02:20,489 --> 00:02:24,900
想要 超越需要使用它 

46
00:02:23,220 --> 00:02:28,019
打印东西，因为问题 

47
00:02:24,900 --> 00:02:29,160
告诉你- 是的，所以要找到 

48
00:02:28,019 --> 00:02:32,010
如果你只是那种你的错误 

49
00:02:29,160 --> 00:02:33,690
想要打印出变量值或 

50
00:02:32,010 --> 00:02:35,340
某种纹理， 所以你 知道是什么 

51
00:02:33,690 --> 00:02:37,230
继续，你 不一定 要 

52
00:02:35,340 --> 00:02:50,010
部署调试50你可以做到这一点 

53
00:02:37,230 --> 00:02:51,510
其他很好， 你知道的确很好 

54
00:02:50,010 --> 00:02:53,400
所以你可能想在你使用printf 

55
00:02:51,510 --> 00:02:55,440
可能有一个嵌套循环，你想要

56
00:02:53,400 --> 00:02:57,570
把一个printf在里面循环， 以 

57
00:02:55,440 --> 00:02:59,640
看它什么时候踢你当然可以 

58
00:02:57,570 --> 00:03:01,829
使用debug 50，但你可能最终 

59
00:02:59,640 --> 00:03:02,970
运行debug 50或单击下一步 

60
00:03:01,829 --> 00:03:04,200
接下来接下来就有这么多 

61
00:03:02,970 --> 00:03:05,910
有点乏味的时间 

62
00:03:04,200 --> 00:03:08,250
但请 记住， 你可以放一个 

63
00:03:05,910 --> 00:03:10,109
断点也深入到你的代码中 

64
00:03:08,250 --> 00:03:11,820
并且可能删除先前的断点 

65
00:03:10,109 --> 00:03:13,590
还有老老实实所有的 时间 

66
00:03:11,820 --> 00:03:15,720
无论是用C还是其他语言做的 

67
00:03:13,590 --> 00:03:18,630
我发现自己偶尔会使用printf 

68
00:03:15,720 --> 00:03:20,640
只是在这里输入printf就好了 

69
00:03:18,630 --> 00:03:23,130
我 可以从字面上看看我的代码是否得到了 

70
00:03:20,640 --> 00:03:24,299
在这里看某一点，看看是否 

71
00:03:23,130 --> 00:03:26,100
打印的东西，但调试器 

72
00:03:24,299 --> 00:03:27,510
你现在要找到它，从此以后就会找到

73
00:03:26,100 --> 00:03:28,769
更强大得多

74
00:03:27,510 --> 00:03:31,049
多才多艺，如果你还没有 

75
00:03:28,769 --> 00:03:32,700
养成了 使用debug 50 的习惯 

76
00:03:31,049 --> 00:03:33,870
一切都意味着开始和使用它们

77
00:03:32,700 --> 00:03:35,639
实际走过的断点 

78
00:03:33,870 --> 00:03:36,329
你的代码，你看不到的是什么 

79
00:03:35,639 --> 00:03:38,400
继续 

80
00:03:36,329 --> 00:03:39,540
所以风格50当然要检查风格 

81
00:03:38,400 --> 00:03:41,160
你的代码很像教学 

82
00:03:39,540 --> 00:03:41,639
研究员可能会以红色或红色显示你 

83
00:03:41,160 --> 00:03:43,500
绿色

84
00:03:41,639 --> 00:03:45,060
您可能想删除哪些空格

85
00:03:43,500 --> 00:03:46,200
什么样的空间，你可能希望只添加

86
00:03:45,060 --> 00:03:47,760
为了好起来，所以它更多 

87
00:03:46,200 --> 00:03:49,440
可读了你和其他人 ，然后 

88
00:03:47,760 --> 00:03:54,410
怎么样帮你 50什么时候应该 

89
00:03:49,440 --> 00:03:54,410
本能地伸出援手 50是的 

90
00:03:54,829 --> 00:03:58,469
当你不明白的时候，是的 

91
00:03:57,269 --> 00:03:59,969
一条错误消息， 因此您正在编译 

92
00:03:58,469 --> 00:04:01,200
你正在运行命令的东西 

93
00:03:59,969 --> 00:04:02,370
并没有真正完成你的工作

94
00:04:01,200 --> 00:04:03,900
看到一个神秘的错误信息 

95
00:04:02,370 --> 00:04:05,609
最终你会得到肌肉记忆 

96
00:04:03,900 --> 00:04:07,620
和那种暴露 只是知道哦 

97
00:04:05,609 --> 00:04:09,269
我记得这意味着 什么 ，但直到 

98
00:04:07,620 --> 00:04:11,459
然后在开始时运行帮助50 

99
00:04:09,269 --> 00:04:13,980
同样的命令 ，它会尝试 

100
00:04:11,459 --> 00:04:16,049
检测你的错误是什么并提供TF 

101
00:04:13,980 --> 00:04:18,479
喜欢有关如何实际工作的反馈

102
00:04:16,049 --> 00:04:21,750
在那附近， 你会看到 两个 

103
00:04:18,479 --> 00:04:23,639
课程网站是 一个 很棒的 讲义 

104
00:04:21,750 --> 00:04:25,770
由Emily Hong制作的我们自己的一个 

105
00:04:23,639 --> 00:04:27,389
讲授所有的教学研究员 

106
00:04:25,770 --> 00:04:29,370
这些工具和其他一些工具可以帮到你 

107
00:04:27,389 --> 00:04:31,080
为考虑问题 的习惯

108
00:04:29,370 --> 00:04:33,090
作为一种流程图，如果我有这个 

109
00:04:31,080 --> 00:04:34,919
如果 我有这个问题， 那么就做其他问题

110
00:04:33,090 --> 00:04:36,930
问题做其他事情所以做检查 

111
00:04:34,919 --> 00:04:39,150
那 也是， 但今天 让我们 

112
00:04:36,930 --> 00:04:41,340
真的是最后介绍的

113
00:04:39,150 --> 00:04:43,590
预见到我们的命令行工具 

114
00:04:41,340 --> 00:04:45,780
会帮助你追逐 问题 

115
00:04:43,590 --> 00:04:47,580
你的代码上周回忆起 我们的代码

116
00:04:45,780 --> 00:04:49,710
谈了很多我们谈过的记忆

117
00:04:47,580 --> 00:04:51,300
关于malloc分配内存和我们

118
00:04:49,710 --> 00:04:52,710
谈到释放记忆等 

119
00:04:51,300 --> 00:04:54,509
但事实证明你可以 做很多事情 

120
00:04:52,710 --> 00:04:56,639
当你开始 用损坏打 

121
00:04:54,509 --> 00:04:59,789
记忆其实可能 到现在差不多了 

122
00:04:56,639 --> 00:05:01,680
每个人的 细分都是 如此 

123
00:04:59,789 --> 00:05:03,630
这只是其中一个错误 

124
00:05:01,680 --> 00:05:06,150
可能会 碰到 ，坦白说你可能会 

125
00:05:03,630 --> 00:05:08,130
现在和 你的代码有错误

126
00:05:06,150 --> 00:05:09,300
从此以后 会有bug，但你却没有 

127
00:05:08,130 --> 00:05:10,949
甚至意识到它，因为你只是 

128
00:05:09,300 --> 00:05:13,289
变得幸运 ，程序就是 

129
00:05:10,949 --> 00:05:15,210
没有崩溃或它没有冻结但是 

130
00:05:13,289 --> 00:05:17,639
这仍然可以发生，所以valgrind 是 

131
00:05:15,210 --> 00:05:19,349
一个可能的命令行程序 

132
00:05:17,639 --> 00:05:20,760
看起来我们最恐怖的工具 

133
00:05:19,349 --> 00:05:22,620
使用但你 也可以在帮助下使用它 

134
00:05:20,760 --> 00:05:24,509
50，只是试图找出 是 什么 

135
00:05:22,620 --> 00:05:26,070
在您的程序中调用内存泄漏

136
00:05:24,509 --> 00:05:27,690
记得 上周我们介绍过 

137
00:05:26,070 --> 00:05:30,810
malloc 和 Malak让你分配 

138
00:05:27,690 --> 00:05:32,610
记忆， 但如果你没有释放那个记忆 

139
00:05:30,810 --> 00:05:34,110
通过逐字地调用自由函数 

140
00:05:32,610 --> 00:05:36,180
你会 经常问你的 

141
00:05:34,110 --> 00:05:38,099
操作系统Mac OS Linux Windows 

142
00:05:36,180 --> 00:05:39,419
我可以拥有更多的记忆 

143
00:05:38,099 --> 00:05:40,919
有更多的记忆我可以有更多的记忆 

144
00:05:39,419 --> 00:05:43,080
如果你从来没有真正把它交回去 

145
00:05:40,919 --> 00:05:45,659
通过免费拨打电脑可能非常 

146
00:05:43,080 --> 00:05:46,710
好慢下来或冻结或崩溃 

147
00:05:45,659 --> 00:05:49,139
坦率地说，如果你曾经有过 这样的事情 

148
00:05:46,710 --> 00:05:51,060
你的Mac 或PC 很可能就是这样 

149
00:05:49,139 --> 00:05:52,770
一些人不小心做了什么或他做了什么

150
00:05:51,060 --> 00:05:54,990
她只是分配了越来越多的记忆 

151
00:05:52,770 --> 00:05:57,000
但从来没有真正得到 周围 释放 

152
00:05:54,990 --> 00:05:58,949
那个记忆所以valgrind可以帮助你 

153
00:05:57,000 --> 00:06:01,229
在你或你之前发现那些错误

154
00:05:58,949 --> 00:06:04,050
用户这样做让我们快速举例说明 

155
00:06:01,229 --> 00:06:06,810
我进入cs50 IDE并让我继续 

156
00:06:04,050 --> 00:06:09,120
制作一个新节目 

157
00:06:06,810 --> 00:06:11,220
在这里我们称之为内存点 C因为 

158
00:06:09,120 --> 00:06:12,660
我们今天晚些时候会看到我如何追逐 

159
00:06:11,220 --> 00:06:14,040
那些内存泄漏，但现在

160
00:06:12,660 --> 00:06:16,080
让我们从 更简单的事情 开始吧 

161
00:06:14,040 --> 00:06:18,419
你们所有人现在都可以做到 

162
00:06:16,080 --> 00:06:20,160
这是偶然触摸记忆 

163
00:06:18,419 --> 00:06:21,870
你不应该改变它的阅读

164
00:06:20,160 --> 00:06:24,980
它让我们看看这可能意味着什么 

165
00:06:21,870 --> 00:06:29,280
让我 在 这里 做熟悉 的顶部 

166
00:06:24,980 --> 00:06:30,540
包括 标准的i / o，不是 

167
00:06:29,280 --> 00:06:30,960
即使做到这一点，但也会让我们只是做到 这一点 

168
00:06:30,540 --> 00:06:33,300
第一

169
00:06:30,960 --> 00:06:35,520
让我们做int main void 只是为了开始一个 

170
00:06:33,300 --> 00:06:38,250
简单的程序，在这里让 我走 

171
00:06:35,520 --> 00:06:39,780
在前面，只需调用一个名为F的函数 

172
00:06:38,250 --> 00:06:41,669
我真的不在乎它的名字是什么 

173
00:06:39,780 --> 00:06:44,669
今天我只想调用一个函数f 

174
00:06:41,669 --> 00:06:46,350
然后， 现在就是它 这个 函数f 

175
00:06:44,669 --> 00:06:48,479
让我继续并按如下方式定义它 

176
00:06:46,350 --> 00:06:51,210
void f void它不会做太多 

177
00:06:48,479 --> 00:06:52,500
什么都可以，但我们 假设只是 

178
00:06:51,210 --> 00:06:54,060
为了 讨论 的是FS 着想 

179
00:06:52,500 --> 00:06:56,190
生活中的 目的只是 分配记忆 

180
00:06:54,060 --> 00:06:58,590
无论有什么用途，但 现在 

181
00:06:56,190 --> 00:07:00,389
它只是为了演示 等等 

182
00:06:58,590 --> 00:07:04,020
有什么功能， 使用它 你可以 

183
00:07:00,389 --> 00:07:06,389
分配内存malloc所以假设我想要 

184
00:07:04,020 --> 00:07:08,070
到malloc空间 我不知道 

185
00:07:06,389 --> 00:07:09,270
像一个整数那样简单的东西 

186
00:07:08,070 --> 00:07:11,010
就像我们只是 做这 

187
00:07:09,270 --> 00:07:13,680
演示目的或实际让我们 

188
00:07:11,010 --> 00:07:16,110
我可以做更多10个整数10个整数 

189
00:07:13,680 --> 00:07:18,479
当然要好好给 我 10但是如何 

190
00:07:16,110 --> 00:07:21,570
我想要多少个字节 

191
00:07:18,479 --> 00:07:24,479
需要10个 整数是的所以我能 做到 

192
00:07:21,570 --> 00:07:29,130
字面上的int大小和最 有可能 

193
00:07:24,479 --> 00:07:31,200
int的大小将是或

194
00:07:29,130 --> 00:07:33,450
可能在 今天的 许多系统 上它只是 

195
00:07:31,200 --> 00:07:34,979
4个字节或32位，但你不想要一个 

196
00:07:33,450 --> 00:07:37,020
硬代码， 以免别人的 

197
00:07:34,979 --> 00:07:39,150
计算机不使用那些相同的值 

198
00:07:37,020 --> 00:07:41,280
int的大小是这个大小的10倍 

199
00:07:39,150 --> 00:07:47,280
一个int malloc返回什么类型的 

200
00:07:41,280 --> 00:07:48,930
数据 是什么能把我交还是的 

201
00:07:47,280 --> 00:07:51,630
返回地址或指针

202
00:07:48,930 --> 00:07:53,880
特别是地址100 900 

203
00:07:51,630 --> 00:07:55,770
它只是一 大块 记忆 

204
00:07:53,880 --> 00:07:58,020
如果我想 保留， 那么分配给你

205
00:07:55,770 --> 00:08:00,120
围绕我需要 声明一个指针 

206
00:07:58,020 --> 00:08:02,160
我 今天就把它 叫做 X. 

207
00:08:00,120 --> 00:08:03,840
地址的商店可以称之为 XYZ 

208
00:08:02,160 --> 00:08:05,760
不管它是什么， 但它不是一个int 

209
00:08:03,840 --> 00:08:06,930
返回它 是int和 的地址 

210
00:08:05,760 --> 00:08:09,870
记住这就是明星运营商 

211
00:08:06,930 --> 00:08:11,039
现在表示 某种 数据类型 的地址 

212
00:08:09,870 --> 00:08:14,550
这只是一个数字 

213
00:08:11,039 --> 00:08:16,409
好吧，如果我是 第一个的话 

214
00:08:14,550 --> 00:08:18,419
让我们把 它清理干净吧

215
00:08:16,409 --> 00:08:20,670
使用malloc 我需要使用 标准的Lib 

216
00:08:18,419 --> 00:08:22,440
我们看到了这一点

217
00:08:20,670 --> 00:08:24,510
上周虽然是短暂的，然后是 

218
00:08:22,440 --> 00:08:28,290
当然，如果我要打电话给 F 我该 怎么做 

219
00:08:24,510 --> 00:08:30,060
必须要修复此代码是的我需要 

220
00:08:28,290 --> 00:08:32,430
在这里 宣布 或我可以 

221
00:08:30,060 --> 00:08:33,570
将F的实施 提升至最高位置， 以便我 

222
00:08:32,430 --> 00:08:35,160
认为即使这样也行 

223
00:08:33,570 --> 00:08:36,930
程序目前是完全的 

224
00:08:35,160 --> 00:08:38,730
愚蠢它 没有做任何 有用的 事情 

225
00:08:36,930 --> 00:08:41,310
它将分配内存，现在做 

226
00:08:38,730 --> 00:08:44,250
如果我愿意 ，可以 使用 以下内容 

227
00:08:41,310 --> 00:08:44,850
更改此块中的第一个值

228
00:08:44,250 --> 00:08:46,920
记忆 

229
00:08:44,850 --> 00:08:50,190
我怎么可能这样做我曾经问过

230
00:08:46,920 --> 00:08:53,070
计算机为 10整数或更确切 

231
00:08:50,190 --> 00:08:54,630
10个整数的空间有趣 

232
00:08:53,070 --> 00:08:56,970
关于malloc是什么时候它返回一个 

233
00:08:54,630 --> 00:08:58,920
你的记忆大块是连续的 

234
00:08:56,970 --> 00:09:00,810
当 你 听到的 时候背靠背 

235
00:08:58,920 --> 00:09:03,680
什么样的，连续的或背靠背的 

236
00:09:00,810 --> 00:09:06,840
数据结构让人回想起来 

237
00:09:03,680 --> 00:09:09,540
在数组中，事实证明我们可以对待 

238
00:09:06,840 --> 00:09:11,460
这只是随机的大块内存 

239
00:09:09,540 --> 00:09:14,280
它是一个数组，所以如果我们想要去 

240
00:09:11,460 --> 00:09:15,990
存储器I的 该 阵列 中的第一位置

241
00:09:14,280 --> 00:09:19,470
可以这样做并 输入数字 

242
00:09:15,990 --> 00:09:22,170
说50或者如果我想去下一个 

243
00:09:19,470 --> 00:09:24,570
我可以这样做或者如果我愿意的话 

244
00:09:22,170 --> 00:09:26,010
做下一个我能做到的地方 或者如果 

245
00:09:24,570 --> 00:09:31,970
我想去最后一个位置 

246
00:09:26,010 --> 00:09:31,970
可能会这样做但是好或坏 

247
00:09:32,270 --> 00:09:37,170
为什么不好

248
00:09:35,160 --> 00:09:39,090
是的，所以这是 不平衡的 

249
00:09:37,170 --> 00:09:40,620
是有点一周 一种风格 时 出错 

250
00:09:39,090 --> 00:09:41,640
它回到了 四个 回忆 

251
00:09:40,620 --> 00:09:43,440
循环或循环你可能会去 

252
00:09:41,640 --> 00:09:45,240
小太远，这 很好 ，但 现在 

253
00:09:43,440 --> 00:09:47,100
我们实际上 会看到 我们 有一个工具 

254
00:09:45,240 --> 00:09:49,350
可以帮助 我们注意这些事情 

255
00:09:47,100 --> 00:09:51,240
希望看起来很明显 

256
00:09:49,350 --> 00:09:54,930
我在这里发生的事情就是这样 

257
00:09:51,240 --> 00:09:56,190
在第12行我有一个 变量 X 

258
00:09:54,930 --> 00:09:58,410
存储该块的地址 

259
00:09:56,190 --> 00:10:01,260
记忆 ，然后在第13行，我只是 

260
00:09:58,410 --> 00:10:03,480
试图访问的位置 10和设置 

261
00:10:01,260 --> 00:10:06,060
价值50有，但你注意 ， 

262
00:10:03,480 --> 00:10:09,000
没有位置10那里的位置0 1 2 3 

263
00:10:06,060 --> 00:10:10,770
一路走来9 当然如此 

264
00:10:09,000 --> 00:10:12,210
我们可以通过一个程序 很好地发现这一点 

265
00:10:10,770 --> 00:10:14,700
让我继续 前进， 增加我的终端 

266
00:10:12,210 --> 00:10:16,820
窗口只是在这里保存我的文件和 

267
00:10:14,700 --> 00:10:19,560
让我继续编译记忆 

268
00:10:16,820 --> 00:10:21,210
确定一切都很好，没有 任何 编译 

269
00:10:19,560 --> 00:10:25,110
错误消息现在让 我先走 

270
00:10:21,210 --> 00:10:26,730
然后运行内存 输入 就可以了 

271
00:10:25,110 --> 00:10:28,500
工作得很好让我们真的是一个 

272
00:10:26,730 --> 00:10:29,970
在这里更加明确只是为了好 

273
00:10:28,500 --> 00:10:33,690
措施让我继续打印 

274
00:10:29,970 --> 00:10:35,880
什么东西出来所以printf ％我 

275
00:10:33,690 --> 00:10:40,170
整数，现在让我们 更多 

276
00:10:35,880 --> 00:10:42,840
显式你输入％I然后逗号 

277
00:10:40,170 --> 00:10:47,940
X支架10和我需要做什么 

278
00:10:42,840 --> 00:10:49,140
包括使用printf是如此标准 

279
00:10:47,940 --> 00:10:52,230
i / o所以 它就是那么快 

280
00:10:49,140 --> 00:10:55,260
标准i / o点 H保存 好吧让我 

281
00:10:52,230 --> 00:10:57,240
重新编译这使内存 进入现在 

282
00:10:55,260 --> 00:11:00,000
让我继续前进，做点大刀阔斧 

283
00:10:57,240 --> 00:11:02,100
点斜线记忆吧 

284
00:11:00,000 --> 00:11:04,110
感觉这是一个正确的程序和 

285
00:11:02,100 --> 00:11:06,660
但是几周以来我们一直都是 

286
00:11:04,110 --> 00:11:08,880
声称 不 这样做不喜欢 

287
00:11:06,660 --> 00:11:11,010
超越 你的 数组 的边界 

288
00:11:08,880 --> 00:11:12,390
那么我们如何调和这种感觉呢

289
00:11:11,010 --> 00:11:15,710
有缺陷的代码或者至少我们告诉过你

290
00:11:12,390 --> 00:11:18,610
这是错误的代码，但它的工作 

291
00:11:15,710 --> 00:11:22,540
是啊

292
00:11:18,610 --> 00:11:22,540
这就是把它像一个好办法

293
00:11:23,200 --> 00:11:33,200
好吧，是的，我想 如果我听到了 

294
00:11:31,730 --> 00:11:36,050
你正确的 说你 看到没有 

295
00:11:33,200 --> 00:11:37,430
如果你走得太远就尖叫， 是的，好吧 

296
00:11:36,050 --> 00:11:39,770
这是一个像你 这样的好方法 

297
00:11:37,430 --> 00:11:41,020
可以在 C中获得幸运，你 可以做到 

298
00:11:39,770 --> 00:11:43,100
东西是客观 

299
00:11:41,020 --> 00:11:44,810
教学上就像技术上你一样 

300
00:11:43,100 --> 00:11:45,860
错了，但电脑不会 

301
00:11:44,810 --> 00:11:47,510
崩溃它不会冻结因为

302
00:11:45,860 --> 00:11:49,430
你很幸运，因为经常 

303
00:11:47,510 --> 00:11:51,170
分配 时的性能原因

304
00:11:49,430 --> 00:11:52,400
说你有10个整数的空间 

305
00:11:51,170 --> 00:11:54,140
实际上会得到一大块记忆 

306
00:11:52,400 --> 00:11:56,930
那比你大一点 

307
00:11:54,140 --> 00:11:58,580
需要它才能恢复它是不安全的 

308
00:11:56,930 --> 00:12:00,080
它比你需要的大，但你可能 

309
00:11:58,580 --> 00:12:01,370
只是幸运，你可能会结束 

310
00:12:00,080 --> 00:12:02,960
拥有更多的 记忆力 

311
00:12:01,370 --> 00:12:04,730
从技术上说，触摸或躲避

312
00:12:02,960 --> 00:12:06,380
访问或更改计算机的 

313
00:12:04,730 --> 00:12:07,820
不会注意到但这 不安全 

314
00:12:06,380 --> 00:12:10,070
因为在别人的Mac或PC上 

315
00:12:07,820 --> 00:12:11,150
他们的电脑可能只是在操作 

316
00:12:10,070 --> 00:12:13,040
与你的有点不同

317
00:12:11,150 --> 00:12:14,780
bam，虫子会咬他们 而不是 

318
00:12:13,040 --> 00:12:16,820
你和那些人是最难的 

319
00:12:14,780 --> 00:12:18,020
恼人的bug追下去，因为一些 

320
00:12:16,820 --> 00:12:19,520
你可能已经体验过它 

321
00:12:18,020 --> 00:12:20,750
工作您的计算机，但不能 一 

322
00:12:19,520 --> 00:12:22,700
朋友， 反之亦然 

323
00:12:20,750 --> 00:12:24,830
这些是对...的解释 

324
00:12:22,700 --> 00:12:27,200
那么valgrind可以帮助我们追踪 

325
00:12:24,830 --> 00:12:28,310
即便是这些最微妙的错误计划 

326
00:12:27,200 --> 00:12:30,140
好像在 起作用 

327
00:12:28,310 --> 00:12:31,490
检查50或类似的工具甚至可能 

328
00:12:30,140 --> 00:12:33,230
假设它正在工作， 因为它是 

329
00:12:31,490 --> 00:12:35,240
打印正确的东西，但让我们采取 

330
00:12:33,230 --> 00:12:37,280
看看这个程序是什么样的

331
00:12:35,240 --> 00:12:39,260
认为让我增加的规模 

332
00:12:37,280 --> 00:12:42,110
终端窗口在这里继续前进 

333
00:12:39,260 --> 00:12:44,930
输入valgrind dot slash memory 

334
00:12:42,110 --> 00:12:46,610
相同的程序名称点斜线内存但是

335
00:12:44,930 --> 00:12:48,890
我正在 用名字valgrind修复它 

336
00:12:46,610 --> 00:12:50,480
不幸的是，valgrind是 

337
00:12:48,890 --> 00:12:52,820
非常难看，打印出来的 

338
00:12:50,480 --> 00:12:55,130
这里有很多东西， 所以 我们来吧 

339
00:12:52,820 --> 00:12:56,390
看看最顶端，你会看到所有 

340
00:12:55,130 --> 00:12:58,490
这些数字在左边，那是 

341
00:12:56,390 --> 00:13:01,130
只是一种不幸的美学，但我们做到了 

342
00:12:58,490 --> 00:13:03,530
看一些有用的信息 无效阅读 

343
00:13:01,130 --> 00:13:05,510
大小4然后它有这些神秘 

344
00:13:03,530 --> 00:13:08,930
看字母和数字是什么

345
00:13:05,510 --> 00:13:10,490
是它刚刚解决的问题 

346
00:13:08,930 --> 00:13:12,320
十六进制它并不重要

347
00:13:10,490 --> 00:13:14,270
他们 是 什么 ，但valgrind可以告诉我们 

348
00:13:12,320 --> 00:13:16,580
记忆在哪里起作用 

349
00:13:14,270 --> 00:13:18,500
怀疑你可以看到旁边 

350
00:13:16,580 --> 00:13:21,440
那个valgrind指向的

351
00:13:18,500 --> 00:13:23,510
内存点上的函数f 看到第15行 

352
00:13:21,440 --> 00:13:25,310
所以这可能是有帮助的，然后是主要的 

353
00:13:23,510 --> 00:13:27,350
在第8行，因为这是功能 

354
00:13:25,310 --> 00:13:28,850
实际上 ，这 被称为valgrind 

355
00:13:27,350 --> 00:13:30,380
有点好，因为它向我们展示了所有 

356
00:13:28,850 --> 00:13:31,439
你调用的函数

357
00:13:30,380 --> 00:13:33,479
自下而上的多 

358
00:13:31,439 --> 00:13:36,059
从上周开始的堆栈等等 

359
00:13:33,479 --> 00:13:37,109
第15行和第15行出了问题 

360
00:13:36,059 --> 00:13:41,160
如果我们回到 那个 

361
00:13:37,109 --> 00:13:43,109
让我们看看第15行肯定是 我的 

362
00:13:41,160 --> 00:13:45,269
实际上试图访问 该内存 

363
00:13:43,109 --> 00:13:47,069
位置，坦率地说，我在第14行做到了 

364
00:13:45,269 --> 00:13:49,409
同样希望修复其中一个或两个 

365
00:13:47,069 --> 00:13:52,949
这些将解决这个问题 

366
00:13:49,409 --> 00:13:54,779
请注意这里坦率地说

367
00:13:52,949 --> 00:13:57,689
很快就压倒了然后 哦 

368
00:13:54,779 --> 00:13:59,429
一个块中的40个字节肯定是 

369
00:13:57,689 --> 00:14:00,720
丢失的记录我的意思是这是 

370
00:13:59,429 --> 00:14:03,089
瓦尔加的问题，说实话 

371
00:14:00,720 --> 00:14:04,829
几年前写的不是 特别的 

372
00:14:03,089 --> 00:14:06,689
用户友好， 但我们 有一个 

373
00:14:04,829 --> 00:14:10,079
解决 这个问题的工具让我继续前进 

374
00:14:06,689 --> 00:14:12,539
重新运行valgrind ，帮助50输入和 

375
00:14:10,079 --> 00:14:13,439
看看我们是否能够帮助解决这个问题 

376
00:14:12,539 --> 00:14:15,089
行 

377
00:14:13,439 --> 00:14:17,549
所以仍然 是相同数量 的黑色和 

378
00:14:15,089 --> 00:14:19,499
白色输入，但现在帮助50 是 

379
00:14:17,549 --> 00:14:22,319
注意到哦，我可以帮助你 

380
00:14:19,499 --> 00:14:23,759
无效写入大小4因此它仍然在 

381
00:14:22,319 --> 00:14:25,679
相同的位置，但这次或 

382
00:14:23,759 --> 00:14:28,319
相同的文件内存点C但行 

383
00:14:25,679 --> 00:14:30,329
14，我们建议看起来像你 

384
00:14:28,319 --> 00:14:32,489
试图修改 4字节的内存 

385
00:14:30,329 --> 00:14:34,169
不是你的 问号你试过吗？ 

386
00:14:32,489 --> 00:14:36,419
存储超出范围的东西 

387
00:14:34,169 --> 00:14:38,549
数组仔细看看第14行 

388
00:14:36,419 --> 00:14:40,859
记忆点C所以尽管如此 

389
00:14:38,549 --> 00:14:42,329
Valgrind的输出是疯狂的深奥像 

390
00:14:40,859 --> 00:14:45,119
至少黄色输出会 指向 

391
00:14:42,329 --> 00:14:48,089
你走向 线14，我确实是感人 

392
00:14:45,119 --> 00:14:49,889
4字节 一个整数 ，我不应该 

393
00:14:48,089 --> 00:14:52,859
所以，让我们继续前进， 如果我解决这个问题 

394
00:14:49,889 --> 00:14:54,689
进入我的程序，我不这样做 

395
00:14:52,859 --> 00:14:57,809
让我们 把它改成9号位置 

396
00:14:54,689 --> 00:15:01,759
位置9在这里保存然后让我走

397
00:14:57,809 --> 00:15:03,299
前进并在没有帮助的情况下重新运行valgrind 50 

398
00:15:01,759 --> 00:15:06,809
行 

399
00:15:03,299 --> 00:15:09,209
进步，除了哦，没有进展我 

400
00:15:06,809 --> 00:15:11,579
跳过一步是啊我没看过

401
00:15:09,209 --> 00:15:14,039
编译它有点困惑为什么我

402
00:15:11,579 --> 00:15:17,999
看到同样的事情，现在让我们重新运行 

403
00:15:14,039 --> 00:15:20,309
valgrind ，在这里似乎 更好 

404
00:15:17,999 --> 00:15:22,379
所以我没有看到相同的错误消息 

405
00:15:20,309 --> 00:15:25,350
像我们 之前 那样 在 最顶端 

406
00:15:22,379 --> 00:15:27,720
但请注意这里 有 1个块中的 40个字节 

407
00:15:25,350 --> 00:15:30,449
好吧那个程序中的语法很糟糕 

408
00:15:27,720 --> 00:15:31,859
但是在失去的记录1中肯定会丢失 

409
00:15:30,449 --> 00:15:33,959
1所以我还是 不太明白 

410
00:15:31,859 --> 00:15:36,059
没什么大不了的让我们继续前进吧 

411
00:15:33,959 --> 00:15:39,149
帮助50，看看两个中的第二个 

412
00:15:36,059 --> 00:15:41,489
错误显然就在这里，所以在这里

413
00:15:39,149 --> 00:15:43,229
突出显示那些40字节和 1行 

414
00:15:41,489 --> 00:15:44,880
块肯定会丢失和看起来

415
00:15:43,229 --> 00:15:46,350
就像你的程序泄露40 

416
00:15:44,880 --> 00:15:47,880
记忆的字节数你忘记了自由

417
00:15:46,350 --> 00:15:50,580
您使用malloc分配的内存 

418
00:15:47,880 --> 00:15:53,430
仔细看看内存的第13行 

419
00:15:50,580 --> 00:15:55,710
在这种情况下，线13确实具有 

420
00:15:53,430 --> 00:16:00,000
对malloc的调用是 什么的 修复 

421
00:15:55,710 --> 00:16:02,100
这个问题/帮助50或你自己 

422
00:16:00,000 --> 00:16:04,770
直觉我有什么要补充的 

423
00:16:02,100 --> 00:16:06,830
节目耶释放你 在哪里 呢 

424
00:16:04,770 --> 00:16:10,730
那个去

425
00:16:06,830 --> 00:16:18,150
这里的权利，所以我们可以释放记忆 

426
00:16:10,730 --> 00:16:19,470
为什么这对我们来说确实不好 

427
00:16:18,150 --> 00:16:20,760
释放这 好像是 说 内存 

428
00:16:19,470 --> 00:16:22,860
操作系统我不需要这个 

429
00:16:20,760 --> 00:16:24,990
我们以后再用两行了 

430
00:16:22,860 --> 00:16:26,940
一次又一次的那么糟糕，我们使用它

431
00:16:24,990 --> 00:16:28,260
上周没有犯这个错误，但是你 

432
00:16:26,940 --> 00:16:30,390
应该只是释放内存时 

433
00:16:28,260 --> 00:16:31,050
从字面上看， 你已经准备好了解它 

434
00:16:30,390 --> 00:16:32,490
把它还给我

435
00:16:31,050 --> 00:16:33,600
应该 在最后 

436
00:16:32,490 --> 00:16:36,140
该计划让我继续前进

437
00:16:33,600 --> 00:16:39,060
重新打开这个打开我的终端窗口 

438
00:16:36,140 --> 00:16:41,100
这次重新编译它现在让我 

439
00:16:39,060 --> 00:16:44,910
最后一次没有帮助 就跑了 valgrind 

440
00:16:41,100 --> 00:16:47,580
50 仍然有点冗长，但零 

441
00:16:44,910 --> 00:16:48,930
从零个语境听起来错误

442
00:16:47,580 --> 00:16:51,810
非常好，而且它 也 

443
00:16:48,930 --> 00:16:53,970
明确地说所有堆块都是 

444
00:16:51,810 --> 00:16:55,680
释放并回想起那堆 

445
00:16:53,970 --> 00:16:57,720
我们在视觉上画了一大堆记忆 

446
00:16:55,680 --> 00:17:00,900
这是malloc采用的地方

447
00:16:57,720 --> 00:17:03,750
从这样做的记忆，所以这 是一种 

448
00:17:00,900 --> 00:17:05,520
有这种心态 

449
00:17:03,750 --> 00:17:06,839
在接近正确性时 

450
00:17:05,520 --> 00:17:08,550
你的代码就像运行一样 

451
00:17:06,839 --> 00:17:10,230
样本输入或像我一样运行程序

452
00:17:08,550 --> 00:17:11,939
所做的一切看上去那么它的一件事 

453
00:17:10,230 --> 00:17:13,560
运行像我们人类的检查50这样的工具 

454
00:17:11,939 --> 00:17:14,970
写道， 但我们也肯定是错误的 

455
00:17:13,560 --> 00:17:16,890
我们可能不会想到任何事情 

456
00:17:14,970 --> 00:17:18,540
值得庆幸的是智能人类已经取得的工具 

457
00:17:16,890 --> 00:17:20,819
乍一看可能有点儿 

458
00:17:18,540 --> 00:17:23,430
像valgrind一样难以像debug 50一样使用 

459
00:17:20,819 --> 00:17:24,810
一个，但现在，他们最终帮助你 

460
00:17:23,430 --> 00:17:26,220
你的代码百分百 正确 

461
00:17:24,810 --> 00:17:28,140
没有你喜欢斗争 

462
00:17:26,220 --> 00:17:29,520
视觉上只是盯着屏幕

463
00:17:28,140 --> 00:17:31,470
我们 在办公时间 看到了这么多 

464
00:17:29,520 --> 00:17:33,270
老实说，很多学生都是 他们的 

465
00:17:31,470 --> 00:17:34,560
通过凝视来推理

466
00:17:33,270 --> 00:17:35,970
在屏幕上只是想了解

467
00:17:34,560 --> 00:17:38,130
出了什么问题，但 事实并非如此 

468
00:17:35,970 --> 00:17:40,020
服用比 其他 任何额外的输入 

469
00:17:38,130 --> 00:17:41,880
你有这样的屏幕上的人物

470
00:17:40,020 --> 00:17:44,580
许多工具 可以为您提供 更多和更多 

471
00:17:41,880 --> 00:17:48,240
一路上 有更多提示， 所以要获得 

472
00:17:44,580 --> 00:17:50,400
那些本能对此有任何疑问

473
00:17:48,240 --> 00:17:53,880
是啊

474
00:17:50,400 --> 00:17:55,590
带参数的主要功能 

475
00:17:53,880 --> 00:17:59,070
你会和那些人一起运行valgrind吗？ 

476
00:17:55,590 --> 00:18:01,350
论证以及是的确如此valgrind 

477
00:17:59,070 --> 00:18:03,570
像调试50一样工作就像帮助一样 

478
00:18:01,350 --> 00:18:05,790
50， 如果你有命令行参数 

479
00:18:03,570 --> 00:18:07,500
像往常一样运行它们但前缀你的 

480
00:18:05,790 --> 00:18:09,720
命令与valgrind 或甚至帮助 

481
00:18:07,500 --> 00:18:10,740
50 valgrind帮助一个与另一个 

482
00:18:09,720 --> 00:18:14,180
好问题

483
00:18:10,740 --> 00:18:14,180
其他想法是的 

484
00:18:18,450 --> 00:18:22,920
一天结束时的好问题

485
00:18:20,760 --> 00:18:24,570
想想电脑里面的 东西 

486
00:18:22,920 --> 00:18:26,040
这仅仅是像 这样如此 

487
00:18:24,570 --> 00:18:29,040
在物理上它显然仍然存在 

488
00:18:26,040 --> 00:18:31,110
它只是被操作处理 

489
00:18:29,040 --> 00:18:33,630
系统 Mac OS Windows Linux无论如何 

490
00:18:31,110 --> 00:18:35,280
就像一个 记忆 池 我们一直在画它 

491
00:18:33,630 --> 00:18:37,770
作为一个看起来有点东西的网格

492
00:18:35,280 --> 00:18:39,540
像 这样操作系统的工作 

493
00:18:37,770 --> 00:18:42,180
是只跟踪其中 的 的 

494
00:18:39,540 --> 00:18:43,740
由于malloc和，正在使用正方形

495
00:18:42,180 --> 00:18:45,180
已被释放，所以你可以 

496
00:18:43,740 --> 00:18:47,040
认为它 只有很少的 勾选标记 

497
00:18:45,180 --> 00:18:48,900
在他们旁边说这 是一个 用途 

498
00:18:47,040 --> 00:18:50,550
是这些其他未使用的用途 

499
00:18:48,900 --> 00:18:53,220
他们只是回到 所谓的免费 

500
00:18:50,550 --> 00:18:54,570
列入那个记忆池 好 

501
00:18:53,220 --> 00:18:56,130
问题，如果你采取更高的水平

502
00:18:54,570 --> 00:18:58,440
当然还是关于操作系统的课程

503
00:18:56,130 --> 00:19:00,510
在哈佛看到61或161 你会 

504
00:18:58,440 --> 00:19:02,730
实际上是建立这些东西 

505
00:19:00,510 --> 00:19:09,300
自己并实现malloc等工具

506
00:19:02,730 --> 00:19:11,040
亲爱的， 我们为什么这么好

507
00:19:09,300 --> 00:19:13,380
要 在 这种情况下， 分配内存 我们 

508
00:19:11,040 --> 00:19:15,480
这不是纯粹提到的 

509
00:19:13,380 --> 00:19:17,460
如果我们有一些示范目的 

510
00:19:15,480 --> 00:19:19,800
我们想要分配的程序 

511
00:19:17,460 --> 00:19:22,860
一些内存 然后这是如何 

512
00:19:19,800 --> 00:19:25,410
我们可以做到这一点。然而 更清洁的方式来 

513
00:19:22,860 --> 00:19:29,340
做所有的 这一切都被 说 

514
00:19:25,410 --> 00:19:30,930
嘿电脑 给我10个整数 像 

515
00:19:29,340 --> 00:19:32,400
这个而不必担心 记忆 

516
00:19:30,930 --> 00:19:35,460
管理层， 这就是我们开始的地方 

517
00:19:32,400 --> 00:19:37,650
第1周只使用堆栈上的数组 

518
00:19:35,460 --> 00:19:39,120
根本不说使用malloc 

519
00:19:37,650 --> 00:19:41,280
一旦你开始使用，只有这一点

520
00:19:39,120 --> 00:19:42,750
malloc和免费和记忆更多 

521
00:19:41,280 --> 00:19:45,950
一般来说， 你需要更多 

522
00:19:42,750 --> 00:19:47,490
责任比 我们在第1周做的那样 

523
00:19:45,950 --> 00:19:51,000
好问题

524
00:19:47,490 --> 00:19:53,250
任何其他人都可以这样出现 

525
00:19:51,000 --> 00:19:58,680
这 是一个严肃的工具

526
00:19:53,250 --> 00:20:00,390
事情dvb 50所以 调试50是一个 

527
00:19:58,680 --> 00:20:03,060
幻觉到一个非常流行的工具叫做 

528
00:20:00,390 --> 00:20:04,980
gdb 50好的新调试器它比较旧 

529
00:20:03,060 --> 00:20:07,110
您不会在命令中使用的工具

530
00:20:04,980 --> 00:20:08,820
但它是调试50工作的原因 

531
00:20:07,110 --> 00:20:10,320
事实证明有一件事，而且有一件事 

532
00:20:08,820 --> 00:20:11,520
你可能会发表实际的维基百科文章

533
00:20:10,320 --> 00:20:14,340
我昨晚在电子邮件中点击了 

534
00:20:11,520 --> 00:20:16,290
叫做 橡皮鸭调试和 

535
00:20:14,340 --> 00:20:18,300
坦率地说，你不必全力以赴 

536
00:20:16,290 --> 00:20:20,310
像我们在这里做的那样过分， 但是 

537
00:20:18,300 --> 00:20:21,660
这种橡皮鸭技术的目的

538
00:20:20,310 --> 00:20:23,610
调试就是保持字面意思 

539
00:20:21,660 --> 00:20:25,470
橡皮鸭在你的架子上或你的 

540
00:20:23,610 --> 00:20:26,790
桌子 ，当你有一个bug和你 

541
00:20:25,470 --> 00:20:29,190
没有 教学 的 奢侈 

542
00:20:26,790 --> 00:20:30,960
服用cs50 或者 cs50的研究员或室友 

543
00:20:29,190 --> 00:20:31,500
更有技术的朋友可以帮忙走路

544
00:20:30,960 --> 00:20:33,990
你通过

545
00:20:31,500 --> 00:20:36,180
代码字面上开始走过 

546
00:20:33,990 --> 00:20:39,120
你的代码口头上和 鸭子 说话 

547
00:20:36,180 --> 00:20:41,280
在网上说得好 - 我正在宣布缅因州 

548
00:20:39,120 --> 00:20:43,500
在第三行，我正在分配空间 

549
00:20:41,280 --> 00:20:45,840
对于一个数组， 然后在 第四 行， 我 

550
00:20:43,500 --> 00:20:47,310
呼唤所有我正在做的事情 

551
00:20:45,840 --> 00:20:49,080
错了，所以如果 你们曾经有过 

552
00:20:47,310 --> 00:20:50,430
那种时刻 是否是办公室 

553
00:20:49,080 --> 00:20:52,350
你要么只有几个小时

554
00:20:50,430 --> 00:20:53,910
在你的脑海里说话，或者你在说话 

555
00:20:52,350 --> 00:20:55,650
通过你的代码给别人和他 

556
00:20:53,910 --> 00:20:58,620
或者她 甚至不必回复你 

557
00:20:55,650 --> 00:21:01,410
只是听你自己说错了 

558
00:20:58,620 --> 00:21:03,450
你可以做的事情或那个时刻 

559
00:21:01,410 --> 00:21:05,370
通过保持一个来近似

560
00:21:03,450 --> 00:21:06,960
这些小家伙在你的桌子上并且有 

561
00:21:05,370 --> 00:21:09,390
这次谈话实际上 并非如此 

562
00:21:06,960 --> 00:21:11,130
疯狂探测，因为它实际上是它的 

563
00:21:09,390 --> 00:21:13,170
只是 通过 交谈这一过程

564
00:21:11,130 --> 00:21:14,700
你的代码在逻辑上 一步一步地在一个 

565
00:21:13,170 --> 00:21:16,740
你不一定能做的方式

566
00:21:14,700 --> 00:21:18,450
你自己的心灵至少我不能当你 

567
00:21:16,740 --> 00:21:20,280
听到自己说错了或 

568
00:21:18,450 --> 00:21:23,040
这并没有完全遵循逻辑上的BAM 

569
00:21:20,280 --> 00:21:24,600
你真的可以拥有那个时刻 

570
00:21:23,040 --> 00:21:25,920
在今天的出路上一定要采取 

571
00:21:24,600 --> 00:21:27,720
这些鸭子中的任何一只花了很多 

572
00:21:25,920 --> 00:21:29,970
很长一段时间 了科尔顿到今天布局 

573
00:21:27,720 --> 00:21:32,160
我们将有更多的在办公时间 

574
00:21:29,970 --> 00:21:34,260
如果你愿意的话，将来 几周 

575
00:21:32,160 --> 00:21:36,330
你们中的一些人 可能会记得 这样 

576
00:21:34,260 --> 00:21:39,000
来自Courier House的鸭子去年 - 

577
00:21:36,330 --> 00:21:40,710
这也是他的堂兄 

578
00:21:39,000 --> 00:21:43,020
对，这 就是橡皮鸭调试 

579
00:21:40,710 --> 00:21:44,460
现在上周回忆起我们开始了 

580
00:21:43,020 --> 00:21:46,230
脱掉 我们需要 使用的 训练 轮 

581
00:21:44,460 --> 00:21:47,820
几个星期的cs50库和 

582
00:21:46,230 --> 00:21:50,130
那就是过去 那种情况 

583
00:21:47,820 --> 00:21:51,390
只是一种技术我们的工具 

584
00:21:50,130 --> 00:21:53,430
可以获得更多的用户输入

585
00:21:51,390 --> 00:21:55,200
比起我们真正开始时的愉快 

586
00:21:53,430 --> 00:21:57,210
在早期和记忆决斗，我们

587
00:21:55,200 --> 00:21:59,790
上周披露了一个字符串引用 

588
00:21:57,210 --> 00:22:05,070
unquote 正是引擎盖下的东西 

589
00:21:59,790 --> 00:22:07,710
在C中 ，第二个是字符数组 

590
00:22:05,070 --> 00:22:10,950
更具体地说，它是一个 

591
00:22:07,710 --> 00:22:14,340
同义词STRing用于什么实际数据 

592
00:22:10,950 --> 00:22:16,350
键入 Shamar 星，因为我们称之为 

593
00:22:14,340 --> 00:22:18,360
char star就是电脑 

594
00:22:16,350 --> 00:22:20,640
科学家描述指针的方式 

595
00:22:18,360 --> 00:22:22,410
一个字符 或更确切地址 

596
00:22:20,640 --> 00:22:24,240
一个功能上的角色 

597
00:22:22,410 --> 00:22:26,520
相当于在一个数组中说 

598
00:22:24,240 --> 00:22:28,260
记忆或记忆序列，但它 

599
00:22:26,520 --> 00:22:30,300
一种 更精确的更多技术 

600
00:22:28,260 --> 00:22:32,700
描述它的方式， 现在我们 

601
00:22:30,300 --> 00:22:34,260
知道我们下面有炭星 

602
00:22:32,700 --> 00:22:35,850
所以那里的引擎盖都很好 

603
00:22:34,260 --> 00:22:37,980
来自它确实会 直接 映射 

604
00:22:35,850 --> 00:22:39,480
记忆中我们一直指出这一点 

605
00:22:37,980 --> 00:22:41,490
这样的事情就在 你的 内心 

606
00:22:39,480 --> 00:22:43,860
电脑 ，我们 可以想到的记忆 

607
00:22:41,490 --> 00:22:45,030
作为摆明的内存块的所有 

608
00:22:43,860 --> 00:22:47,850
其字节数是多少 

609
00:22:45,030 --> 00:22:49,680
鸟类零到 两 千兆字节或两个 

610
00:22:47,850 --> 00:22:51,270
无论价值多少，但是 

611
00:22:49,680 --> 00:22:53,340
当然， 我们上周指出了这一点 

612
00:22:51,270 --> 00:22:55,500
你 认为 这个记忆不是存在的 

613
00:22:53,340 --> 00:22:57,240
硬件本身，但它 只是 这个 

614
00:22:55,500 --> 00:22:58,770
被 分成 的内存池

615
00:22:57,240 --> 00:23:01,020
不同区域的最顶部 的 

616
00:22:58,770 --> 00:23:02,910
计算机的记忆可以这么说就是 我们 

617
00:23:01,020 --> 00:23:05,190
调用文本段以及进入的内容 

618
00:23:02,910 --> 00:23:07,340
计算机的文本段

619
00:23:05,190 --> 00:23:09,510
运行程序时的内存

620
00:23:07,340 --> 00:23:14,450
文字就像是糟糕的选择 

621
00:23:09,510 --> 00:23:17,370
坦率地说，但它是什么我 再次说 

622
00:23:14,450 --> 00:23:18,660
在这种情况下， 文件 头 是在 

623
00:23:17,370 --> 00:23:20,570
运行程序的上下文不是 

624
00:23:18,660 --> 00:23:23,430
必须保存文件是的 

625
00:23:20,570 --> 00:23:26,820
这里没有字符串文字，但它们是 

626
00:23:23,430 --> 00:23:30,150
附近实际上是记忆功能

627
00:23:26,820 --> 00:23:32,370
接近耶文 细分 

628
00:23:30,150 --> 00:23:34,380
计算机的记忆就在你身边 

629
00:23:32,370 --> 00:23:36,060
双击程序以运行它或在 

630
00:23:34,380 --> 00:23:38,220
你 点的 Linux 做点斜线 

631
00:23:36,060 --> 00:23:40,440
运行它的东西就是那个地方 

632
00:23:38,220 --> 00:23:42,150
零和 你的实际程序 

633
00:23:40,440 --> 00:23:44,460
我们谈到的机器代码

634
00:23:42,150 --> 00:23:46,170
第零周刚装入拉姆 

635
00:23:44,460 --> 00:23:47,970
所以从上周回忆你知道 

636
00:23:46,170 --> 00:23:51,330
在这个世界上任何物质的心脏 

637
00:23:47,970 --> 00:23:53,610
硬盘固态硬盘是 如此 缓慢 

638
00:23:51,330 --> 00:23:54,900
那些设备很慢，但 拉姆的东西 

639
00:23:53,610 --> 00:23:56,760
我们一直 在屏幕上 拉起来 

640
00:23:54,900 --> 00:23:58,860
如果只是因为它有相对快速 

641
00:23:56,760 --> 00:24:00,300
没有活动部件，它纯粹是 电子的 

642
00:23:58,860 --> 00:24:02,010
所以当你双击程序时 

643
00:24:00,300 --> 00:24:04,230
Mac或PC或 做点 东西 斜线 

644
00:24:02,010 --> 00:24:06,480
在Linux中从慢速加载 

645
00:24:04,230 --> 00:24:08,940
设备你的硬盘驱动器的数据所在 

646
00:24:06,480 --> 00:24:11,400
长期存储在RAM或内存中 

647
00:24:08,940 --> 00:24:14,070
它 可以 更快地 运行 

648
00:24:11,400 --> 00:24:16,410
在表现 和 表现方面令人愉快 

649
00:24:14,070 --> 00:24:18,360
这对我们来说意味着什么？ 

650
00:24:16,410 --> 00:24:20,280
好吧， 我们必须去 某个地方 

651
00:24:18,360 --> 00:24:21,780
几年前人类决定它正在发展 

652
00:24:20,280 --> 00:24:23,790
去顶部所以说到这一点 

653
00:24:21,780 --> 00:24:26,010
虽然是下面的大块内存 

654
00:24:23,790 --> 00:24:28,170
更具活力的记忆区域 

655
00:24:26,010 --> 00:24:29,970
堆栈和堆我们说这个 

656
00:24:28,170 --> 00:24:31,830
刚才在上周也是如此 

657
00:24:29,970 --> 00:24:36,390
什么在堆上或谁使用 

658
00:24:31,830 --> 00:24:36,960
随时调用堆动态内存

659
00:24:36,390 --> 00:24:38,850
的malloc 

660
00:24:36,960 --> 00:24:40,740
你问的是操作系统 

661
00:24:38,850 --> 00:24:42,390
任何时候来自所谓的堆的内存

662
00:24:40,740 --> 00:24:44,100
你打电话给你是免费的 

663
00:24:42,390 --> 00:24:45,540
从概念上讲，它就像它一样 

664
00:24:44,100 --> 00:24:47,190
实际上并没有去你自己的任何地方 

665
00:24:45,540 --> 00:24:50,040
将其标记为可供其他人使用 

666
00:24:47,190 --> 00:24:54,540
使用堆栈的函数和变量 

667
00:24:50,040 --> 00:24:56,880
同时用于当地

668
00:24:54,540 --> 00:24:58,890
变量和任何函数都是如此 

669
00:24:56,880 --> 00:25:00,240
主要通常需要一小部分

670
00:24:58,890 --> 00:25:02,340
主要呼叫时底部的内存

671
00:25:00,240 --> 00:25:04,080
另一个功能它得到了一小部分 

672
00:25:02,340 --> 00:25:05,850
上面的内存，如果该函数调用 

673
00:25:04,080 --> 00:25:06,840
一个上面有一小段记忆 

674
00:25:05,850 --> 00:25:09,030
这样他们每个人都有自己的

675
00:25:06,840 --> 00:25:11,100
不同的记忆区域 但是 

676
00:25:09,030 --> 00:25:12,840
当然这些箭头都指向 

677
00:25:11,100 --> 00:25:15,570
彼此似乎并不是那么好 

678
00:25:12,840 --> 00:25:17,160
设计，但现实是坏事可以 

679
00:25:15,570 --> 00:25:20,400
碰巧 你可以分配这么多的内存 

680
00:25:17,160 --> 00:25:22,890
BAM堆栈溢出堆栈或 

681
00:25:20,400 --> 00:25:24,990
因此，堆溢出堆栈 

682
00:25:22,890 --> 00:25:26,610
出生的网站，如Stack Overflow 和 

683
00:25:24,990 --> 00:25:28,110
等，但是这 只是如果现实 

684
00:25:26,610 --> 00:25:30,270
你有一个有限的记忆 

685
00:25:28,110 --> 00:25:31,530
有些事情会破坏或者 

686
00:25:30,270 --> 00:25:33,660
电脑 必须说 mmhmm 

687
00:25:31,530 --> 00:25:35,460
没有更多的记忆， 你将不得不退出 

688
00:25:33,660 --> 00:25:37,770
一些程序或关闭一些文件或 

689
00:25:35,460 --> 00:25:39,120
什么只是这样说 

690
00:25:37,770 --> 00:25:40,740
那就是 记忆的布局和我们 

691
00:25:39,120 --> 00:25:43,530
开始探索这个，但我们有一个 

692
00:25:40,740 --> 00:25:46,140
这里的一些程序很少 

693
00:25:43,530 --> 00:25:48,150
这里的黑暗是一个交换 

694
00:25:46,140 --> 00:25:51,780
功能以及它是如何 更暗 是 

695
00:25:48,150 --> 00:25:55,110
一个交换函数实际上做了交换 

696
00:25:51,780 --> 00:25:57,000
两个值a 和B但它没有 

697
00:25:55,110 --> 00:25:58,980
实际上按照我们的意图工作 

698
00:25:57,000 --> 00:26:03,750
这个交换功能被打破了什么

699
00:25:58,980 --> 00:26:06,390
上周，我很确定它有效 

700
00:26:03,750 --> 00:26:07,950
当 我们勇敢的志愿者出现时 

701
00:26:06,390 --> 00:26:10,910
交换了牛奶中的橙汁

702
00:26:07,950 --> 00:26:16,310
这很有效，因为逻辑是正确的 

703
00:26:10,910 --> 00:26:19,350
但节目本身没有工作 ，为什么 

704
00:26:16,310 --> 00:26:21,210
确切地说它改变了副本中的值

705
00:26:19,350 --> 00:26:23,550
这些变量让人 想起什么时候 

706
00:26:21,210 --> 00:26:25,770
main是我们调用的函数和它 

707
00:26:23,550 --> 00:26:27,690
有两个值x和y那个大块 

708
00:26:25,770 --> 00:26:29,820
记忆在这里 是一块 记忆 

709
00:26:27,690 --> 00:26:31,080
这里的头像数字1和2 

710
00:26:29,820 --> 00:26:33,450
但是当它调用交换功能时 

711
00:26:31,080 --> 00:26:35,880
退出自己的大块内存如此主要 

712
00:26:33,450 --> 00:26:37,410
在底部交换高于 它 

713
00:26:35,880 --> 00:26:39,840
有自己的内存块称为 

714
00:26:37,410 --> 00:26:42,090
和B最初获得值1 ＆ 

715
00:26:39,840 --> 00:26:45,180
确实成功地 交换了 2 1 和2 

716
00:26:42,090 --> 00:26:47,010
但这对 X＆Y没有影响 所以我们 

717
00:26:45,180 --> 00:26:48,390
修复了较新版本 的 

718
00:26:47,010 --> 00:26:50,490
这个程序 当然 看起来很多 

719
00:26:48,390 --> 00:26:52,170
乍看之下更加神秘但却在 

720
00:26:50,490 --> 00:26:54,660
英语可以有人描述一下 

721
00:26:52,170 --> 00:26:56,970
这是在这个例子中发生的事情 

722
00:26:54,660 --> 00:27:00,590
就像这个更正确 

723
00:26:56,970 --> 00:27:00,590
程序一行一行 是的 

724
00:27:02,920 --> 00:27:06,830
完全不是 传递值的 

725
00:27:05,360 --> 00:27:08,450
通过复制 它们的变量

726
00:27:06,830 --> 00:27:10,850
它传递了那些地址

727
00:27:08,450 --> 00:27:12,860
变量就像说我没有 

728
00:27:10,850 --> 00:27:14,600
技术上关心它在记忆中的位置 

729
00:27:12,860 --> 00:27:16,220
但我确实需要 知道 它是 

730
00:27:14,600 --> 00:27:18,350
在内存的某个地方，所以当而不是 

731
00:27:16,220 --> 00:27:20,660
通过一个X和第 一个让我们 

732
00:27:18,350 --> 00:27:22,490
假设X位于 我的 位置100 

733
00:27:20,660 --> 00:27:24,590
举个例子， 它实际上是数字 

734
00:27:22,490 --> 00:27:27,920
如果Y是，那将会去那里 

735
00:27:24,590 --> 00:27:29,390
在像104这样的位置它是104 

736
00:27:27,920 --> 00:27:31,640
那将去那里不 属于 

737
00:27:29,390 --> 00:27:33,830
我们想要交换的价值 但是那些是 

738
00:27:31,640 --> 00:27:35,570
有点像小 地图或面包屑 

739
00:27:33,830 --> 00:27:37,760
如果你愿意把我们 带到正确的地方 

740
00:27:35,570 --> 00:27:39,950
位置，这样 当 我们执行这个 

741
00:27:37,760 --> 00:27:42,290
代码我们所有的 西红柿都在选择 

742
00:27:39,950 --> 00:27:44,630
这三条线就是这个和 

743
00:27:42,290 --> 00:27:46,370
一路上回忆我们正在使用 

744
00:27:44,630 --> 00:27:48,530
那里的临时变量 可以 

745
00:27:46,370 --> 00:27:50,240
只是扔掉了所以这就是什么 

746
00:27:48,530 --> 00:27:51,830
指针允许我们做，那就是

747
00:27:50,240 --> 00:27:54,530
什么让我们 真正 改变 

748
00:27:51,830 --> 00:27:58,300
即使是 所谓的堆栈上的值

749
00:27:54,530 --> 00:28:00,860
虽然甚至通过调用另一个函数 

750
00:27:58,300 --> 00:28:04,240
或者 我们 离开的 地方有 任何 问题 

751
00:28:00,860 --> 00:28:09,110
最后一次与堆栈和关闭

752
00:28:04,240 --> 00:28:11,150
交换所以回忆我们介绍 

753
00:28:09,110 --> 00:28:14,000
他们 在一个 人身上失去了头脑 

754
00:28:11,150 --> 00:28:16,010
但是为什么会 发生可怕的事情 

755
00:28:14,000 --> 00:28:20,720
可怕的是从最后的场景出来 

756
00:28:16,010 --> 00:28:22,220
本周斯坦福大学的电影 是 

757
00:28:20,720 --> 00:28:24,860
做正确的事就像 

758
00:28:22,220 --> 00:28:33,740
移动值42成功 然后 

759
00:28:24,860 --> 00:28:35,900
是的，他试图取消引用一个 

760
00:28:33,740 --> 00:28:38,120
指针实际上不是的地址 

761
00:28:35,900 --> 00:28:39,620
指着一个有效的地址 回忆一下 

762
00:28:38,120 --> 00:28:42,770
这是有问题的线路编码 

763
00:28:39,620 --> 00:28:45,110
这是不吉利和坏星 Y意味着去 

764
00:28:42,770 --> 00:28:47,720
到Y的地址并做点什么 

765
00:28:45,110 --> 00:28:49,580
它设置它等于数字13但是 

766
00:28:47,720 --> 00:28:52,250
问题在于 我们看到 的 代码 

767
00:28:49,580 --> 00:28:54,350
在上周我们在开始时所做的一切都是 

768
00:28:52,250 --> 00:28:56,540
说嘿电脑给我一个指针 

769
00:28:54,350 --> 00:28:59,470
int并调用它X 做同样的并给予 

770
00:28:56,540 --> 00:29:03,320
它并称之为 Y分配空间 和 

771
00:28:59,470 --> 00:29:06,800
指向X但我们 从未做过同样的事情 

772
00:29:03,320 --> 00:29:08,660
对于y所以而 X包含在上周 

773
00:29:06,800 --> 00:29:11,450
实际大块内存的地址

774
00:29:08,660 --> 00:29:13,160
感谢malloc Y包含了什么

775
00:29:11,450 --> 00:29:15,370
故事中的那一点是黄线 

776
00:29:13,160 --> 00:29:24,230
那里

777
00:29:15,370 --> 00:29:26,720
是什么 原因包含了什么价值 

778
00:29:24,230 --> 00:29:28,190
也许但这 并不 明显，因为 

779
00:29:26,720 --> 00:29:30,140
没有提到null 

780
00:29:28,190 --> 00:29:31,970
程序，我们可能会得到幸运null只是 

781
00:29:30,140 --> 00:29:33,890
零，有时我们已经看到 零 

782
00:29:31,970 --> 00:29:35,870
是程序中的默认值 

783
00:29:33,890 --> 00:29:41,330
也许，但我说也许，我正在对冲

784
00:29:35,870 --> 00:29:42,800
为什么，它分配不好 

785
00:29:41,330 --> 00:29:44,360
分配不太合适的词

786
00:29:42,800 --> 00:29:45,920
建议你分配实际 

787
00:29:44,360 --> 00:29:47,630
内存这是一个垃圾值 还有的 

788
00:29:45,920 --> 00:29:49,160
我Mac上的东西就在那里

789
00:29:47,630 --> 00:29:50,660
运行几个小时和 你的Mac 

790
00:29:49,160 --> 00:29:52,280
而PC和手机可能正在运行 

791
00:29:50,660 --> 00:29:54,440
整天或当然盖上盖子 

792
00:29:52,280 --> 00:29:56,660
达 等 已经 习惯 你的记忆 

793
00:29:54,440 --> 00:29:58,340
并且未使用和使用很多东西 

794
00:29:56,660 --> 00:30:00,230
正在进行，所以你的电脑 不是 

795
00:29:58,340 --> 00:30:02,120
像所有 零或所有零填充

796
00:30:00,230 --> 00:30:03,920
如果你在某个随机 点 看它 

797
00:30:02,120 --> 00:30:05,390
在它充满了像束一样的那一天

798
00:30:03,920 --> 00:30:07,460
和一串零和 一些 

799
00:30:05,390 --> 00:30:09,320
您之前退出的以前的程序

800
00:30:07,460 --> 00:30:11,240
你 在后台 和 窗户 

801
00:30:09,320 --> 00:30:12,500
喜欢这样的缺点是什么时候 

802
00:30:11,240 --> 00:30:14,510
你正在运行的程序的第一 

803
00:30:12,500 --> 00:30:16,550
时间一直在对一些现在正在运行 

804
00:30:14,510 --> 00:30:18,200
那个时候它会变得那么大 

805
00:30:16,550 --> 00:30:20,030
记忆的矩形会有一些 

806
00:30:18,200 --> 00:30:22,340
在 这里的一些零 和 这里的零 

807
00:30:20,030 --> 00:30:25,970
反之亦然， 所以他们是垃圾价值 

808
00:30:22,340 --> 00:30:27,290
因为那些字节中有一些值 

809
00:30:25,970 --> 00:30:29,270
他们你 不一定知道 

810
00:30:27,290 --> 00:30:31,730
他们是什么所以重点是你应该 

811
00:30:29,270 --> 00:30:34,610
从来没有提领的指针

812
00:30:31,730 --> 00:30:36,650
你有没有为自己设定 也许它会 

813
00:30:34,610 --> 00:30:38,360
崩溃也许它不会崩溃valgrind可以 

814
00:30:36,650 --> 00:30:41,240
帮助你找到这些东西，但 有时 

815
00:30:38,360 --> 00:30:43,070
但它只是不是一个安全的操作 所有 

816
00:30:41,240 --> 00:30:44,630
对 ，最后我们做的最后一件事 

817
00:30:43,070 --> 00:30:46,100
上周介绍的将是 

818
00:30:44,630 --> 00:30:48,590
踩石头会遇到什么问题 

819
00:30:46,100 --> 00:30:51,110
解决这个星期是struct 所以struct是 

820
00:30:48,590 --> 00:30:53,930
有点酷，你可以设计 你的 

821
00:30:51,110 --> 00:30:55,580
自己的自定义数据结构 C很 漂亮 

822
00:30:53,930 --> 00:30:58,190
开箱即用，可以这么说 

823
00:30:55,580 --> 00:31:00,140
你只有chars， bools和floats 

824
00:30:58,190 --> 00:31:02,300
和intz和双打以及Long和 

825
00:31:00,140 --> 00:31:03,740
中风本身甚至没有字符串 

826
00:31:02,300 --> 00:31:05,510
所以它并没有 真正 与 许多 

827
00:31:03,740 --> 00:31:07,220
像许多语言一样的功能 

828
00:31:05,510 --> 00:31:09,950
我们将在几周后看到Python 

829
00:31:07,220 --> 00:31:11,900
c中的结构你 有能力 

830
00:31:09,950 --> 00:31:14,800
解决你 自己的一些问题

831
00:31:11,900 --> 00:31:19,160
我们可以实际使用struct的实例

832
00:31:14,800 --> 00:31:20,900
开始实施我们自己的特点 我们 

833
00:31:19,160 --> 00:31:22,610
我们自己的数据类型让我 

834
00:31:20,900 --> 00:31:25,090
何去何从，让我继续 前进 ， 

835
00:31:22,610 --> 00:31:28,880
创建一个名为say的文件 

836
00:31:25,090 --> 00:31:31,280
学生相当破坏， 所以 回忆一下 

837
00:31:28,880 --> 00:31:32,840
点H是一个头文件 迄今为止 ，我们为您 

838
00:31:31,280 --> 00:31:35,360
使用过其他人的头文件

839
00:31:32,840 --> 00:31:37,280
像cs50.h和标准IO点H一样 

840
00:31:35,360 --> 00:31:39,830
和标准的盖子，但你可以做 

841
00:31:37,280 --> 00:31:41,600
你自己的头文件或只是文件 

842
00:31:39,830 --> 00:31:43,670
通常包含您想要的代码

843
00:31:41,600 --> 00:31:45,500
分享多个计划，我们会 

844
00:31:43,670 --> 00:31:46,760
及时看到这个 ，让 我走吧 

845
00:31:45,500 --> 00:31:48,590
提前，只需保存此文件即可 

846
00:31:46,760 --> 00:31:51,800
假设我要 代表一个 

847
00:31:48,590 --> 00:31:54,040
记忆中的学生当然是学生 

848
00:31:51,800 --> 00:31:58,670
很可能将有什么样的一个 

849
00:31:54,040 --> 00:32:01,070
例如 ，一个字符串如何 

850
00:31:58,670 --> 00:32:02,780
他们的名字是他们宿舍的字符串但是

851
00:32:01,070 --> 00:32:05,540
字符串是两周前的那种让我们的 

852
00:32:02,780 --> 00:32:08,480
叫这个char星，让我们叫名字

853
00:32:05,540 --> 00:32:10,040
char star，所以你可能想要 

854
00:32:08,480 --> 00:32:12,020
像多个 数据 一样关联 

855
00:32:10,040 --> 00:32:13,460
与学生对，你不想要 

856
00:32:12,020 --> 00:32:14,600
有多个变量本身就很好 

857
00:32:13,460 --> 00:32:16,310
将这些封装在一起 

858
00:32:14,600 --> 00:32:19,040
并记得在上周末 

859
00:32:16,310 --> 00:32:22,040
我们看到了您可以定义的此功能 

860
00:32:19,040 --> 00:32:24,590
你自己的类型 死亡 类型 是一个 

861
00:32:22,040 --> 00:32:27,380
结构本身，你可以给它 一个 

862
00:32:24,590 --> 00:32:29,540
简单地通过执行来简单命名 

863
00:32:27,380 --> 00:32:31,130
这这些行代码你 刚刚 

864
00:32:29,540 --> 00:32:33,230
创建了 自己的自定义数据类型 

865
00:32:31,130 --> 00:32:35,360
现在叫学生和每个 学生 

866
00:32:33,230 --> 00:32:38,060
世界将根据此代码a 

867
00:32:35,360 --> 00:32:39,830
现在名称和与他们相关的宿舍

868
00:32:38,060 --> 00:32:41,420
为什么这对我们的计划很有用 

869
00:32:39,830 --> 00:32:43,600
看着上次末尾 

870
00:32:41,420 --> 00:32:48,500
看起来像 这样的 东西 

871
00:32:43,600 --> 00:32:51,650
指示0点C我们有 以下我 

872
00:32:48,500 --> 00:32:53,060
第一个分配的空间一定量 

873
00:32:51,650 --> 00:32:54,650
学生我问用户是什么 

874
00:32:53,060 --> 00:32:57,530
报名参加课堂或其他什么 

875
00:32:54,650 --> 00:33:01,070
给 我们一个 INT，然后我们分配了一个 

876
00:32:57,530 --> 00:33:04,010
一类学生称为学生 

877
00:33:01,070 --> 00:33:06,550
复数， 这是另一种回忆 

878
00:33:04,010 --> 00:33:10,220
做这样的 字符串名称 

879
00:33:06,550 --> 00:33:11,690
报名 和字符串宿舍 注册 

880
00:33:10,220 --> 00:33:13,010
哪个可以，你可以有两个 

881
00:33:11,690 --> 00:33:16,130
单独的数组， 你只需要 

882
00:33:13,010 --> 00:33:18,170
记住这个 名字0和宿舍0是 

883
00:33:16,130 --> 00:33:20,420
相同的人， 但为什么这样做，如果你可以 

884
00:33:18,170 --> 00:33:22,900
我们将结构保持在一起 

885
00:33:20,420 --> 00:33:25,700
能够做到这一点给我这么多 

886
00:33:22,900 --> 00:33:28,280
学生结构，并呼吁 整体 

887
00:33:25,700 --> 00:33:31,130
数组学生和唯一的新语法 

888
00:33:28,280 --> 00:33:33,760
我们介绍满足这个目标是

889
00:33:31,130 --> 00:33:33,760
什么算子 

890
00:33:34,630 --> 00:33:40,130
点耶所以在过去召回 

891
00:33:37,970 --> 00:33:41,660
湖周第二周我们介绍了阵列和 

892
00:33:40,130 --> 00:33:44,180
数组允许你 方括号 

893
00:33:41,660 --> 00:33:46,250
符号因此与a没有区别 

894
00:33:44,180 --> 00:33:48,980
几个星期后， 但如果 你的阵列 

895
00:33:46,250 --> 00:33:50,900
不存储整数或字符或 

896
00:33:48,980 --> 00:33:53,510
浮动或其实际存储的任何东西

897
00:33:50,900 --> 00:33:55,730
就像一个学生 ，你可以得到一个结构

898
00:33:53,510 --> 00:33:58,220
在那个学生的名字上 只是 字面意思 

899
00:33:55,730 --> 00:34:00,320
说点名，你可以 得到他们的 

900
00:33:58,220 --> 00:34:01,640
宿舍做宿舍然后 

901
00:34:00,320 --> 00:34:03,350
一切 是 一样的 ，这是 

902
00:34:01,640 --> 00:34:04,700
什么叫封装 ，它是 

903
00:34:03,350 --> 00:34:06,980
有点像一个基本原则 

904
00:34:04,700 --> 00:34:09,140
编程，如果你有一些真实的 

905
00:34:06,980 --> 00:34:11,660
像学生一样的世界实体，你想要的 

906
00:34:09,140 --> 00:34:13,730
代表学生代码是的你 

907
00:34:11,660 --> 00:34:16,580
可能有 一堆阵列全部 

908
00:34:13,730 --> 00:34:18,230
已经打电话给de names宿舍 电子邮件 

909
00:34:16,580 --> 00:34:20,750
数字，但你可以变得混乱 

910
00:34:18,230 --> 00:34:22,610
而不是封装所有 相关 的 

911
00:34:20,750 --> 00:34:25,010
大约一个学生 到一个 信息 

912
00:34:22,610 --> 00:34:28,370
数据结构，所以现在你有 

913
00:34:25,010 --> 00:34:30,560
零周和 像学生一样的 抽象 

914
00:34:28,370 --> 00:34:33,250
是一种抽象，如果我们打破它 

915
00:34:30,560 --> 00:34:35,900
抽象实际上是什么学生 

916
00:34:33,250 --> 00:34:38,720
不是在现实世界中，而是在我们的代码中 

917
00:34:35,900 --> 00:34:40,430
这里的世界学生是抽象的

918
00:34:38,720 --> 00:34:42,680
这是我们所有人都能说的有用的词 

919
00:34:40,430 --> 00:34:46,250
同意意味着什么，但技术上 

920
00:34:42,680 --> 00:34:47,960
这显然意味着一个学生 

921
00:34:46,250 --> 00:34:49,910
实际上是一个宿舍的名称 ，其 

922
00:34:47,960 --> 00:34:51,710
对每个人来说都是微不足道的 

923
00:34:49,910 --> 00:34:54,290
在这个房间，但我们已经蒸馏了它

924
00:34:51,710 --> 00:34:55,580
代码只是 这两个 值所以 有 

925
00:34:54,290 --> 00:34:57,620
我们有封装你是那种

926
00:34:55,580 --> 00:34:59,240
将多个值封装在一起

927
00:34:57,620 --> 00:35:00,560
而你正在抽象而已

928
00:34:59,240 --> 00:35:02,660
更有用的术语，因为没有人 会 

929
00:35:00,560 --> 00:35:05,300
我想 谈谈 代码行 

930
00:35:02,660 --> 00:35:07,220
描述 过这么同一主题是 

931
00:35:05,300 --> 00:35:09,320
过去所以现在我们有 能力 

932
00:35:07,220 --> 00:35:11,360
拿出 我们自己的自定义数据 

933
00:35:09,320 --> 00:35:13,340
结构似乎我们可以存储

934
00:35:11,360 --> 00:35:16,220
我们想要的任何内在 的东西

935
00:35:13,340 --> 00:35:18,260
我们现在看看我们有多糟糕 

936
00:35:16,220 --> 00:35:22,160
为过去的几个设计一些东西 

937
00:35:18,260 --> 00:35:23,390
周所以事实证明， 很多 的 

938
00:35:22,160 --> 00:35:25,550
代码希望我们一直在写 

939
00:35:23,390 --> 00:35:28,430
最近几周是 正确的，但我们已经 

940
00:35:25,550 --> 00:35:29,660
一直在设计解决方案 

941
00:35:28,430 --> 00:35:30,980
我们称之为最好的方式

942
00:35:29,660 --> 00:35:33,800
我们拥有这块记忆 

943
00:35:30,980 --> 00:35:35,780
通常在阵列中将其视为最多 

944
00:35:33,800 --> 00:35:37,700
所以只是一块连续的记忆和 

945
00:35:35,780 --> 00:35:40,610
感谢这个非常简单的心理模型 

946
00:35:37,700 --> 00:35:43,640
我们得到字符串吗？ 

947
00:35:40,610 --> 00:35:45,500
学生现在但阵列不是

948
00:35:43,640 --> 00:35:47,180
必然是最好的数据结构 

949
00:35:45,500 --> 00:35:47,810
世界就像是 一个缺点 

950
00:35:47,180 --> 00:35:52,790
排列

951
00:35:47,810 --> 00:35:54,800
如果你到目前为止在C中遇到过

952
00:35:52,790 --> 00:36:00,890
什么是阵列的缺点 

953
00:35:54,800 --> 00:36:03,710
是啊皮匠不了你不能被 

954
00:36:00,890 --> 00:36:06,470
是的，所以在C中你不能混合数据类型 

955
00:36:03,710 --> 00:36:08,330
在 数组 内部 ，他们必须都在 

956
00:36:06,470 --> 00:36:11,090
他们必须全部收取所有费用 

957
00:36:08,330 --> 00:36:12,230
是学生，这是一个白色的谎言

958
00:36:11,090 --> 00:36:13,700
因为技术上你可以拥有 

959
00:36:12,230 --> 00:36:16,100
你 可以 称之为虚空之星的东西 

960
00:36:13,700 --> 00:36:18,200
实际上映射，但肯定是真的 ，虽然 

961
00:36:16,100 --> 00:36:19,640
严格来说不能混合数据类型

962
00:36:18,200 --> 00:36:20,840
虽然坦率地说即使是其他的 

963
00:36:19,640 --> 00:36:22,550
语言让你做到这一点不是 

964
00:36:20,840 --> 00:36:24,500
必然是最好的设计决策 

965
00:36:22,550 --> 00:36:27,980
但肯定限制其他想法 

966
00:36:24,500 --> 00:36:29,990
是的，大小不能改变让我们专注

967
00:36:27,980 --> 00:36:32,360
在那一个，因为那更多 

968
00:36:29,990 --> 00:36:35,780
看起来 更加严格 

969
00:36:32,360 --> 00:36:37,760
如果你想要一个数组说两个值 

970
00:36:35,780 --> 00:36:42,350
你做得怎么样你可以做点什么 

971
00:36:37,760 --> 00:36:43,670
比如int X 括号2分号 和什么 

972
00:36:42,350 --> 00:36:45,470
这 实际上是否让你内心 

973
00:36:43,670 --> 00:36:47,570
你的计算机的内存给你一些 

974
00:36:45,470 --> 00:36:49,790
块，也将以此作为一个矩形 

975
00:36:47,570 --> 00:36:51,830
这是位置0这是位置1 

976
00:36:49,790 --> 00:36:54,110
假设哦，几分钟后 你 

977
00:36:51,830 --> 00:36:56,480
改变主意哦，我只是拿了一个我 

978
00:36:54,110 --> 00:36:57,980
想输入第三个值或我想要的 

979
00:36:56,480 --> 00:37:01,580
将另一个学生添加到数组中 

980
00:36:57,980 --> 00:37:03,440
你把它放在哪里，如果你没有 

981
00:37:01,580 --> 00:37:04,490
你想为一个第三个值添加

982
00:37:03,440 --> 00:37:08,660
大小为二的数组

983
00:37:04,490 --> 00:37:10,730
你做C的唯一选择是什么？ 

984
00:37:08,660 --> 00:37:13,520
新数组如此字面上和如果这个数组

985
00:37:10,730 --> 00:37:15,770
有这个数字像42 ，这有 

986
00:37:13,520 --> 00:37:17,930
13号 是添加第三 个 的 唯一方法 

987
00:37:15,770 --> 00:37:21,170
号码是 分配的三分之一 

988
00:37:17,930 --> 00:37:24,020
第二阵列中的值复制到 

989
00:37:21,170 --> 00:37:26,300
相同的位置42 13然后我们将添加

990
00:37:24,020 --> 00:37:28,460
另一个值50然后你就是这样 

991
00:37:26,300 --> 00:37:30,770
几乎没有使用两倍的 空间 

992
00:37:28,460 --> 00:37:32,900
永久现在你可以 免费 

993
00:37:30,770 --> 00:37:35,120
不知何故或停止使用那一块 

994
00:37:32,900 --> 00:37:36,950
记忆， 这样很好，这是正确的 

995
00:37:35,120 --> 00:37:41,360
我们刚刚 做了但是运行 时间 是多少 

996
00:37:36,950 --> 00:37:42,860
几个 星期 前 ， 这个过程的召唤 

997
00:37:41,360 --> 00:37:45,550
我们开始谈论效率 和 

998
00:37:42,860 --> 00:37:51,110
设计什么是运行时间 

999
00:37:45,550 --> 00:37:56,530
在阵列中调整大小再说太久了 

1000
00:37:51,110 --> 00:37:56,530
公平，但让我们更精确的大O. 

1001
00:37:57,820 --> 00:38:06,130
什么大O. 

1002
00:38:01,350 --> 00:38:09,730
这有什么好 ñ 真实的，但什么呢ñ 

1003
00:38:06,130 --> 00:38:11,050
代表耶，所以你实际上并没有 

1004
00:38:09,730 --> 00:38:12,970
不得不知道 它只是一个 

1005
00:38:11,050 --> 00:38:15,490
在这种 情况下，一般答案 很长 

1006
00:38:12,970 --> 00:38:17,830
这个数组叫它很多

1007
00:38:15,490 --> 00:38:19,810
将其大小调整为加一个的步骤 

1008
00:38:17,830 --> 00:38:21,640
从技术上讲，这是n +的大O. 

1009
00:38:19,810 --> 00:38:23,680
一个，但 在我们讨论Big 

1010
00:38:21,640 --> 00:38:25,840
O符号我们只是忽略较小的

1011
00:38:23,680 --> 00:38:28,000
加上除以二的加号

1012
00:38:25,840 --> 00:38:30,490
加号我们 只关注最多 

1013
00:38:28,000 --> 00:38:33,220
表达式中强有力的术语 

1014
00:38:30,490 --> 00:38:35,500
就在这里， 如果你有一个阵列，那就是 

1015
00:38:33,220 --> 00:38:37,990
大小为2， 你把它调整为一个 

1016
00:38:35,500 --> 00:38:40,180
大小为三的数组或真正的n加一 

1017
00:38:37,990 --> 00:38:42,400
这将 花费我大约 n步 

1018
00:38:40,180 --> 00:38:45,190
技术上n加1 步但n步 

1019
00:38:42,400 --> 00:38:48,010
因此，它是一个线性过程 

1020
00:38:45,190 --> 00:38:49,510
可能但不一定是 

1021
00:38:48,010 --> 00:38:52,090
最快的事，因为我们确实有

1022
00:38:49,510 --> 00:38:56,260
把所有那些该死的价值 都 移到这 附近 

1023
00:38:52,090 --> 00:38:57,760
什么比这更好 ，如果 

1024
00:38:56,260 --> 00:39:00,430
你可能 在之前编程 

1025
00:38:57,760 --> 00:39:08,380
正确的直觉我们如何解决

1026
00:39:00,430 --> 00:39:09,700
这个问题哦，是的，我们分配更多 

1027
00:39:08,380 --> 00:39:13,140
数组末尾的内存所以它 

1028
00:39:09,700 --> 00:39:17,230
事实证明C确实有一个叫做的函数 

1029
00:39:13,140 --> 00:39:19,750
重新 锁定完美，如果 明显楠 

1030
00:39:17,230 --> 00:39:21,880
命名为重新分配内存，如果你

1031
00:39:19,750 --> 00:39:24,160
传递一块内存 的 地址 

1032
00:39:21,880 --> 00:39:25,810
你分配和操作 

1033
00:39:24,160 --> 00:39:27,640
系统通知哦，是的，你很幸运

1034
00:39:25,810 --> 00:39:29,380
我在本月底得到了更多的内存 

1035
00:39:27,640 --> 00:39:31,810
数组然后将分配 

1036
00:39:29,380 --> 00:39:32,020
为您额外的RAM，让你 使用 

1037
00:39:31,810 --> 00:39:33,940
它

1038
00:39:32,020 --> 00:39:35,710
或者更坏的情况，如果没有 

1039
00:39:33,940 --> 00:39:36,880
在阵列的末尾可用 

1040
00:39:35,710 --> 00:39:39,010
记忆因为它被使用了 

1041
00:39:36,880 --> 00:39:39,580
你的程序中有别的东西 

1042
00:39:39,010 --> 00:39:42,220
精细

1043
00:39:39,580 --> 00:39:44,380
realloc 将采取 

1044
00:39:42,220 --> 00:39:46,570
创建另一个数组的责任

1045
00:39:44,380 --> 00:39:48,640
在内存中的某处复制所有 这些 

1046
00:39:46,570 --> 00:39:50,880
数据为 你进入它并返回 

1047
00:39:48,640 --> 00:39:54,870
那块新记忆的地址

1048
00:39:50,880 --> 00:39:57,610
不幸的是，这仍然是线性的 

1049
00:39:54,870 --> 00:39:59,950
这一切都在堆Malik中完成 

1050
00:39:57,610 --> 00:40:03,130
和realloc 和 free.all 在 

1051
00:39:59,950 --> 00:40:04,510
堆是的所以这是一个解决方案，但它 

1052
00:40:03,130 --> 00:40:11,970
并没有真正说出效率 

1053
00:40:04,510 --> 00:40:11,970
是啊是啊，什么是链表继续 

1054
00:40:13,300 --> 00:40:17,560
好吧指向其他元素 是啊 所以让 

1055
00:40:16,180 --> 00:40:19,390
我说的是什么是根本的 

1056
00:40:17,560 --> 00:40:21,280
这里问题的根本问题是 

1057
00:40:19,390 --> 00:40:24,640
就像 画自己一样 

1058
00:40:21,280 --> 00:40:26,740
进入 一个角落，可以说是陈词滥调 

1059
00:40:24,640 --> 00:40:28,900
你正在决定使用的阵列

1060
00:40:26,740 --> 00:40:31,120
推进数据结构的大小 

1061
00:40:28,900 --> 00:40:33,370
并且如果你好的话 ， 那就很好 

1062
00:40:31,120 --> 00:40:36,550
只是对面不这样做， 如果 

1063
00:40:33,370 --> 00:40:39,880
你最初想要一个房间

1064
00:40:36,550 --> 00:40:42,100
值说一个整数只询问 

1065
00:40:39,880 --> 00:40:44,140
计算机为我提供了空间 

1066
00:40:42,100 --> 00:40:47,740
整数，我会把我的 号码42 

1067
00:40:44,140 --> 00:40:49,540
在这里，当且仅当你想要一个

1068
00:40:47,740 --> 00:40:51,670
第二个整数你问电脑吗？ 

1069
00:40:49,540 --> 00:40:53,800
对于第二个整数，所以计算机 

1070
00:40:51,670 --> 00:40:55,660
正如malloc或 whatnot 会给你的 

1071
00:40:53,800 --> 00:40:57,070
另一个像数字 13 和如果 

1072
00:40:55,660 --> 00:40:58,930
你想要第三个问同样的问题

1073
00:40:57,070 --> 00:41:01,060
每个操作系统的问题

1074
00:40:58,930 --> 00:41:04,060
时间刚刚 回到一个大块 

1075
00:41:01,060 --> 00:41:07,240
记忆，但有一个基本的问题 

1076
00:41:04,060 --> 00:41:08,860
这里总是有一个权衡， 所以是的 

1077
00:41:07,240 --> 00:41:11,470
你 可以调用malloc 

1078
00:41:08,860 --> 00:41:13,630
每次要求 一个大块 三次 

1079
00:41:11,470 --> 00:41:16,120
大小为1而不是大小为3的内存

1080
00:41:13,630 --> 00:41:17,800
例如但什么是 你 的价格 

1081
00:41:16,120 --> 00:41:21,340
支付或者我们还需要 什么问题

1082
00:41:17,800 --> 00:41:23,500
解决是的，是的，他们没有被存储 

1083
00:41:21,340 --> 00:41:25,450
彼此相邻所以即使我可以 

1084
00:41:23,500 --> 00:41:28,510
认为这 是 第一要素 

1085
00:41:25,450 --> 00:41:31,930
你没有的第二个和第三个

1086
00:41:28,510 --> 00:41:33,190
在这个故事中随机访问元素 

1087
00:41:31,930 --> 00:41:35,890
随机访问

1088
00:41:33,190 --> 00:41:37,330
ergo 随机存取内存或Ram 

1089
00:41:35,890 --> 00:41:39,220
意思是算术li 

1090
00:41:37,330 --> 00:41:42,790
在数学上你可以跳到位置 

1091
00:41:39,220 --> 00:41:45,460
0位置1位置两个随机或在 

1092
00:41:42,790 --> 00:41:47,110
恒定的时间，因为如果 

1093
00:41:45,460 --> 00:41:49,270
他们都是背靠背背你 

1094
00:41:47,110 --> 00:41:50,890
要做的就是添加一个或添加四个 

1095
00:41:49,270 --> 00:41:53,080
或者你 的地址 等等 

1096
00:41:50,890 --> 00:41:55,900
但问题是，如果你是 

1097
00:41:53,080 --> 00:41:58,000
一次又一次地调用malloc 

1098
00:41:55,900 --> 00:42:00,070
这些东西 无法 保证 

1099
00:41:58,000 --> 00:42:02,110
甚至 会 接近一个 

1100
00:42:00,070 --> 00:42:05,350
另外这些第二块记忆

1101
00:42:02,110 --> 00:42:07,000
如果这是最重要的一部分可能会结束 

1102
00:42:05,350 --> 00:42:08,650
记忆我们一直在谈论的地方 

1103
00:42:07,000 --> 00:42:11,770
但这里 的堆 和堆栈 

1104
00:42:08,650 --> 00:42:13,420
在这里42可能会在 这里结束

1105
00:42:11,770 --> 00:42:15,490
下一块内存50可能会结束 

1106
00:42:13,420 --> 00:42:17,560
在这里，第三块可能会结束 

1107
00:42:15,490 --> 00:42:19,870
在这里所以 你不能只是 跳 

1108
00:42:17,560 --> 00:42:23,560
因为你， 从 0到1到2 

1109
00:42:19,870 --> 00:42:24,339
不得不以某种方式 记住位置 

1110
00:42:23,560 --> 00:42:26,640
0 

1111
00:42:24,339 --> 00:42:28,779
一，二是如何解决这个问题 

1112
00:42:26,640 --> 00:42:36,400
即使你 之前 没有编程 过 

1113
00:42:28,779 --> 00:42:40,569
就像这里的解决方案一样好吧 

1114
00:42:36,400 --> 00:42:41,979
以某种方式存储所有的地址

1115
00:42:40,569 --> 00:42:43,479
对，所以让我们假设 是 为了这个 

1116
00:42:41,979 --> 00:42:46,119
这一段记忆的讨论

1117
00:42:43,479 --> 00:42:50,009
最终在100号位置结束了 

1118
00:42:46,119 --> 00:42:53,829
在150 这样的情况下，这个结果就像是 

1119
00:42:50,009 --> 00:42:55,390
475无论那些价值是多少

1120
00:42:53,829 --> 00:43:00,219
看起来我需要以某种方式或其他方式

1121
00:42:55,390 --> 00:43:02,319
记住三个值100 150和475所以 

1122
00:43:00,219 --> 00:43:04,539
事实证明，我在哪里可以存储好 

1123
00:43:02,319 --> 00:43:06,249
我可能是一个 小聪明但有点 

1124
00:43:04,539 --> 00:43:07,989
贪婪我可以对malloc说你知道的 

1125
00:43:06,249 --> 00:43:10,450
我每次 打电话给你的 不仅仅是 

1126
00:43:07,989 --> 00:43:13,989
给我一个整数的空间 给我 

1127
00:43:10,450 --> 00:43:16,450
整数的空格加上地址 

1128
00:43:13,989 --> 00:43:18,609
另一个整数 ，如果你有点好的话 

1129
00:43:16,450 --> 00:43:22,269
看起来像爆米花串在一起 

1130
00:43:18,609 --> 00:43:24,430
字符串或任何类型的链式围栏 

1131
00:43:22,269 --> 00:43:27,849
其中一个链接链接到另一个链接我们 

1132
00:43:24,430 --> 00:43:30,369
可以创造相当于呐喊 

1133
00:43:27,849 --> 00:43:34,569
不是我们可以创造等价物 

1134
00:43:30,369 --> 00:43:36,640
这种图片 中的每一个 

1135
00:43:34,569 --> 00:43:38,559
这些方块或节点将开始 

1136
00:43:36,640 --> 00:43:40,809
用图形方式称它们为一种 链接 

1137
00:43:38,559 --> 00:43:42,640
我们已经看到了这些链接 

1138
00:43:40,809 --> 00:43:44,559
或者这些指针字面意思是箭头 

1139
00:43:42,640 --> 00:43:46,869
指向在代码中实现

1140
00:43:44,559 --> 00:43:48,549
箭头或指针只是一个地址所以 

1141
00:43:46,869 --> 00:43:52,059
你知道我们应该问马利克 

1142
00:43:48,549 --> 00:43:55,390
没有 足够的空间 只有数字 

1143
00:43:52,059 --> 00:43:57,640
42我们应该要求一点点

1144
00:43:55,390 --> 00:43:59,920
每个方格中的内存更多

1145
00:43:57,640 --> 00:44:03,089
现在将它们制成图形矩形 

1146
00:43:59,920 --> 00:44:05,259
所以现在是的， 我们 确实有 这些箭头 

1147
00:44:03,089 --> 00:44:05,859
概念上指向一个位置 

1148
00:44:05,259 --> 00:44:08,079
到另一个

1149
00:44:05,859 --> 00:44:12,640
但我真正想要的 是 什么价值观 

1150
00:44:08,079 --> 00:44:14,259
放入这些新的附加盒子 

1151
00:44:12,640 --> 00:44:16,450
如果他们喜欢 ， 那么下一个的地址

1152
00:44:14,259 --> 00:44:18,519
这个盒子里有小面包屑

1153
00:44:16,450 --> 00:44:22,529
与第一个值相关联的应该 

1154
00:44:18,519 --> 00:44:25,779
是 我的第二个值475 的地址 

1155
00:44:22,529 --> 00:44:27,279
与我的第二个值相关联

1156
00:44:25,779 --> 00:44:30,369
箭头让我画出箭头

1157
00:44:27,279 --> 00:44:32,829
箭头应该是正确的地方 

1158
00:44:30,369 --> 00:44:35,829
地址150因为那是最后一次 

1159
00:44:32,829 --> 00:44:37,120
然后从这个额外的盒子 应该是什么 

1160
00:44:35,829 --> 00:44:40,420
我放在那儿

1161
00:44:37,120 --> 00:44:41,710
是的，所以 可能是等同的 

1162
00:44:40,420 --> 00:44:44,890
削减 世界上的零 

1163
00:44:41,710 --> 00:44:46,570
指针回忆起来就是这样 

1164
00:44:44,890 --> 00:44:48,340
特殊值 ， 意味着这就是它这个 

1165
00:44:46,570 --> 00:44:50,350
是 仍然离开的线 的 终点 

1166
00:44:48,340 --> 00:44:52,480
我们有空间添加第四个值和 

1167
00:44:50,350 --> 00:44:54,000
指向它，但它现在表示 

1168
00:44:52,480 --> 00:44:58,150
对我们来说很清楚没什么

1169
00:44:54,000 --> 00:45:00,550
实际上 那里我们 刚刚做了什么 

1170
00:44:58,150 --> 00:45:03,790
创建了值列表50 或抱歉 

1171
00:45:00,550 --> 00:45:05,500
四十到五十三， 但我们联系在一起 

1172
00:45:03,790 --> 00:45:07,030
他们首先合影 

1173
00:45:05,500 --> 00:45:09,040
只是箭头像任何人类可能有一个 

1174
00:45:07,030 --> 00:45:11,370
UH粉笔，但 在 技术上 

1175
00:45:09,040 --> 00:45:14,410
我们可以通过 存储 来完成这个代码

1176
00:45:11,370 --> 00:45:15,940
这些地方的每个地址都是如此 

1177
00:45:14,410 --> 00:45:19,840
只是为了清楚那么这可能是什么 

1178
00:45:15,940 --> 00:45:23,680
实际上转换为代码很好

1179
00:45:19,840 --> 00:45:28,900
如果我 在代码中 提出 这个 我们 可能会这样做 

1180
00:45:23,680 --> 00:45:30,790
如果 我们想要 存储， 这样的事情

1181
00:45:28,900 --> 00:45:32,620
我们 当然需要的整数

1182
00:45:30,790 --> 00:45:35,890
像 int这样存储会调用它 

1183
00:45:32,620 --> 00:45:37,960
将代表42或50或13 但是 

1184
00:45:35,890 --> 00:45:39,040
如果我们想创建一个数据结构 我们 

1185
00:45:37,960 --> 00:45:40,750
可能想要开始提供这些数据 

1186
00:45:39,040 --> 00:45:42,700
结构我们的名字我称之为片刻 

1187
00:45:40,750 --> 00:45:45,220
以前节点是一个 类似于a 的 CS术语 

1188
00:45:42,700 --> 00:45:47,350
链接列表中的节点可以这么说 

1189
00:45:45,220 --> 00:45:49,810
它看起来像 这样类型def意味着 

1190
00:45:47,350 --> 00:45:51,790
给我自己的类型struct意味着成功 

1191
00:45:49,810 --> 00:45:53,230
像学生一样的结构然后 

1192
00:45:51,790 --> 00:45:54,610
节点将是这个名字

1193
00:45:53,230 --> 00:45:57,850
事情， 我会在一瞬间解释为什么我 

1194
00:45:54,610 --> 00:46:00,520
这次有两个单词节点， 但我 

1195
00:45:57,850 --> 00:46:04,570
在董事会上留下了一个房间

1196
00:46:00,520 --> 00:46:06,670
除了一个名为int的行

1197
00:46:04,570 --> 00:46:09,220
ñ或者 我需要以某种方式 

1198
00:46:06,670 --> 00:46:10,900
在代码中 表示附加内存 

1199
00:46:09,220 --> 00:46:13,060
我希望malloc给我这个 

1200
00:46:10,900 --> 00:46:15,160
因此，首先要 解决 这些问题 

1201
00:46:13,060 --> 00:46:17,560
每种数据类型的地址

1202
00:46:15,160 --> 00:46:20,500
那三个盒子他们是 

1203
00:46:17,560 --> 00:46:23,680
该点 中 整数的地址

1204
00:46:20,500 --> 00:46:27,370
故事但 技术上是什么 

1205
00:46:23,680 --> 00:46:31,540
盒子真的指向它指向 

1206
00:46:27,370 --> 00:46:33,100
特别是它指向的int 

1207
00:46:31,540 --> 00:46:34,930
如果你 愿意 ，那一大堆记忆 

1208
00:46:33,100 --> 00:46:36,730
所以，如果你开始考虑每一个 

1209
00:46:34,930 --> 00:46:38,680
这些矩形作为节点和

1210
00:46:36,730 --> 00:46:41,080
每个箭头都指向 

1211
00:46:38,680 --> 00:46:44,020
另一个节点 我们需要以某种方式表达 

1212
00:46:41,080 --> 00:46:46,720
我需要以某种方式存储指向a的指针 

1213
00:46:44,020 --> 00:46:48,820
换句话说，这些箭头中的每一个 

1214
00:46:46,720 --> 00:46:52,510
需要指向另一个节点和 

1215
00:46:48,820 --> 00:46:54,280
代码我们可以说这就像让我们一样 

1216
00:46:52,510 --> 00:46:55,990
给它起一个名字，而不是 n 

1217
00:46:54,280 --> 00:46:57,580
号码让我们接下来叫它

1218
00:46:55,990 --> 00:46:59,260
所以next应该是这个 字段的名称

1219
00:46:57,580 --> 00:47:01,900
指向 内存中的下一个节点 

1220
00:46:59,260 --> 00:47:07,840
和节点明星的意思是什么

1221
00:47:01,900 --> 00:47:09,340
英语， 如果你再说一遍 

1222
00:47:07,840 --> 00:47:11,350
到一个地址， 它看起来不同 

1223
00:47:09,340 --> 00:47:13,930
注意是今天的新词， 这很好 

1224
00:47:11,350 --> 00:47:16,480
但节点明星只是意味着一个指向

1225
00:47:13,930 --> 00:47:18,820
node节点的地址然后转 

1226
00:47:16,480 --> 00:47:20,620
这是 一个自定义结构 

1227
00:47:18,820 --> 00:47:22,270
我们实际上不得不说这个但是它 

1228
00:47:20,620 --> 00:47:24,700
即使事情也是如此 

1229
00:47:22,270 --> 00:47:27,520
我们在这里迅速升级

1230
00:47:24,700 --> 00:47:30,010
只需要两个值 一个 int然后一个 

1231
00:47:27,520 --> 00:47:31,240
指向另一件事 ，其他 

1232
00:47:30,010 --> 00:47:32,800
事情将成为另一个节点 

1233
00:47:31,240 --> 00:47:35,620
我们只是 坦率地使用节点 

1234
00:47:32,800 --> 00:47:37,990
将两个值封装为int和a 

1235
00:47:35,620 --> 00:47:40,000
指针和你在C中表达的方式

1236
00:47:37,990 --> 00:47:41,620
虽然有点隐秘指针或 

1237
00:47:40,000 --> 00:47:44,950
其中一个箭头是你说给我 一个 

1238
00:47:41,620 --> 00:47:48,280
被称为next的变量让它指向a 

1239
00:47:44,950 --> 00:47:50,710
结构称为节点或宁可拥有它

1240
00:47:48,280 --> 00:47:54,060
是类型结构的地址 

1241
00:47:50,710 --> 00:47:54,060
节点是的

1242
00:47:59,700 --> 00:48:05,170
好问题所以这感觉就像一个 

1243
00:48:02,920 --> 00:48:07,750
圆形的定义，因为我 

1244
00:48:05,170 --> 00:48:10,600
定义节点但在节点内部 

1245
00:48:07,750 --> 00:48:14,680
是一个可以正常的节点因为 

1246
00:48:10,600 --> 00:48:17,170
明星是必要的，而且还要记得 

1247
00:48:14,680 --> 00:48:19,930
是 c 始终是那种红顶 

1248
00:48:17,170 --> 00:48:22,120
因此，这是第一个 

1249
00:48:19,930 --> 00:48:24,370
这里 的代码行 键入def struct node 

1250
00:48:22,120 --> 00:48:26,680
在铿锵的故事中 

1251
00:48:24,370 --> 00:48:31,320
已经读了线它知道 

1252
00:48:26,680 --> 00:48:33,370
短语struct node完全存在

1253
00:48:31,320 --> 00:48:34,600
我们确实不需要这样做 

1254
00:48:33,370 --> 00:48:36,910
学生，因为没有指针

1255
00:48:34,600 --> 00:48:39,040
参与其他学生，但是在 

1256
00:48:36,910 --> 00:48:41,230
这个案子简而言之就告诉了铿锵 

1257
00:48:39,040 --> 00:48:43,840
嘿铿锵给我一个叫做的结构 

1258
00:48:41,230 --> 00:48:45,670
节点然后在这里我们说嘿铛 

1259
00:48:43,840 --> 00:48:48,700
每个节点都应有两个

1260
00:48:45,670 --> 00:48:51,040
整数中的 东西 叫做 n和一个指针 

1261
00:48:48,700 --> 00:48:53,160
另一个 数据结构 

1262
00:48:51,040 --> 00:48:57,130
类型节点并调用整个事物 

1263
00:48:53,160 --> 00:48:58,840
节点它有点拗口 但是 全部 

1264
00:48:57,130 --> 00:49:01,900
这是下面就让我先走 

1265
00:48:58,840 --> 00:49:05,950
并删除 所有这些数据类型 

1266
00:49:01,900 --> 00:49:08,650
如果我们摆脱我们 画 的画面 

1267
00:49:05,950 --> 00:49:11,040
在飞行中有这个说嘿铿锵

1268
00:49:08,650 --> 00:49:13,450
给我的数据结构

1269
00:49:11,040 --> 00:49:15,220
图像看起来像这样它是分开的 

1270
00:49:13,450 --> 00:49:18,460
分为两部分，第一部分称为 

1271
00:49:15,220 --> 00:49:20,830
n 接下来调用 第二种类型 

1272
00:49:18,460 --> 00:49:24,280
数据类型是int类型，这是 一个 

1273
00:49:20,830 --> 00:49:26,260
指向另一个这样的节点的指针

1274
00:49:24,280 --> 00:49:30,330
即使代码看起来很复杂 

1275
00:49:26,260 --> 00:49:30,330
这个想法正是如此 

1276
00:49:34,600 --> 00:49:42,070
好的问题，原因是什么 

1277
00:49:38,440 --> 00:49:43,960
刚刚走到刚才 铛和 

1278
00:49:42,070 --> 00:49:45,700
他们看到 一般 或有点 愚蠢 

1279
00:49:43,960 --> 00:49:47,800
他们 刚读码 从上到下 

1280
00:49:45,700 --> 00:49:50,260
问题是你 必须 申报 

1281
00:49:47,800 --> 00:49:52,990
这个结构的名称是一个结构 

1282
00:49:50,260 --> 00:49:54,400
实际使用它 之前的节点

1283
00:49:52,990 --> 00:49:56,020
在 精神上类似于我们的讨论 

1284
00:49:54,400 --> 00:49:58,270
原型为什么功能需 

1285
00:49:56,020 --> 00:50:00,400
提到的 方式，这只是说德 

1286
00:49:58,270 --> 00:50:01,990
clang 给我一个 叫做struct node 的类型 

1287
00:50:00,400 --> 00:50:04,480
你不知道它是怎么回事 看看 

1288
00:50:01,990 --> 00:50:06,369
还没有，但 我 会完成我的想法 

1289
00:50:04,480 --> 00:50:08,890
稍后再来这里我们就是 

1290
00:50:06,369 --> 00:50:11,020
告诉该节点里面的clang应该 

1291
00:50:08,890 --> 00:50:13,030
是一个整数以及指向 

1292
00:50:11,020 --> 00:50:15,070
我正处于中间的那种事情 

1293
00:50:13,030 --> 00:50:16,840
定义， 但如果我离开了 

1294
00:50:15,070 --> 00:50:18,610
字节点在那里， 只是说结构 

1295
00:50:16,840 --> 00:50:22,000
你做不到，因为 它没有 

1296
00:50:18,610 --> 00:50:23,850
看到这个词和OD e就是这样 

1297
00:50:22,000 --> 00:50:27,369
其他问题 

1298
00:50:23,850 --> 00:50:30,700
没事 ，所以如果我现在有一个数据 

1299
00:50:27,369 --> 00:50:32,200
结构称为节点，我可以用它 来 

1300
00:50:30,700 --> 00:50:33,820
这些联系 在一起的那种缝合 

1301
00:50:32,200 --> 00:50:35,320
列表，也许只是 改变一些事情 

1302
00:50:33,820 --> 00:50:38,550
一点点， 并开始赠送一些 

1303
00:50:35,320 --> 00:50:40,600
鸭子会让人觉得舒服 

1304
00:50:38,550 --> 00:50:47,020
志愿在这里解决问题

1305
00:50:40,600 --> 00:50:48,940
是的，好吧 ， 你肯定还是 一 两个 

1306
00:50:47,020 --> 00:50:51,280
你可以带鸭子跑两个好 

1307
00:50:48,940 --> 00:50:53,050
大约有三个来到这里三个所以 

1308
00:50:51,280 --> 00:50:54,970
如果你想成为我们的第一个指针 

1309
00:50:53,050 --> 00:50:58,060
即将到来，你可以成为第五名 

1310
00:50:54,970 --> 00:51:00,130
在这里想要成为第九和第一 

1311
00:50:58,060 --> 00:51:06,280
更多的志愿者来了 

1312
00:51:00,130 --> 00:51:10,600
好的，所以我会见到你 

1313
00:51:06,280 --> 00:51:13,090
好在十七点 好吧 

1314
00:51:10,600 --> 00:51:14,320
因此，如果你想只所以我们 选择 这个 

1315
00:51:13,090 --> 00:51:15,609
如果你在家里跟随那些人

1316
00:51:14,320 --> 00:51:24,670
我 想跟你打招呼 

1317
00:51:15,609 --> 00:51:26,350
观众精彩好，如果你不愿意 

1318
00:51:24,670 --> 00:51:27,550
介意我向后退了一大步 

1319
00:51:26,350 --> 00:51:29,680
鸭子只是 让我们有点儿 

1320
00:51:27,550 --> 00:51:31,119
再往后让我们继续 这样做吧 

1321
00:51:29,680 --> 00:51:33,310
如果你能成为我们的第一个指针

1322
00:51:31,119 --> 00:51:34,840
比如来这里来吧

1323
00:51:33,310 --> 00:51:36,430
站在 鸭外，如果你们 

1324
00:51:34,840 --> 00:51:38,950
前面可能会有点过来 

1325
00:51:36,430 --> 00:51:40,720
仍然没问题，所以我们在这里 

1326
00:51:38,950 --> 00:51:44,050
链接列表的材料 和你的 

1327
00:51:40,720 --> 00:51:45,290
汤米是我们的第一个指针if 

1328
00:51:44,050 --> 00:51:47,360
你会

1329
00:51:45,290 --> 00:51:49,100
commies变量是我们要 保持的 

1330
00:51:47,360 --> 00:51:50,710
轨道链接的第一个元素 的 

1331
00:51:49,100 --> 00:51:53,480
列出所以，如果你可以用你的左手 

1332
00:51:50,710 --> 00:51:54,080
代表第一个 只是指向 你 

1333
00:51:53,480 --> 00:51:56,240
再次 

1334
00:51:54,080 --> 00:51:57,770
安德烈所以安德烈是数字 9，如果 你 

1335
00:51:56,240 --> 00:52:00,440
可以用你的左手指向 

1336
00:51:57,770 --> 00:52:02,900
5号，如果你可以使用你的左边 

1337
00:52:00,440 --> 00:52:04,490
手是的，指向17号和你的 

1338
00:52:02,900 --> 00:52:06,110
左手 只是指向空这 

1339
00:52:04,490 --> 00:52:07,610
我们只是打电话给 你，所以你不要 

1340
00:52:06,110 --> 00:52:08,960
我想随便指出它，因为 

1341
00:52:07,610 --> 00:52:11,060
这就像是假冒伪劣 

1342
00:52:08,960 --> 00:52:13,670
指针所以这里指空没事如此 

1343
00:52:11,060 --> 00:52:16,340
这是 您需要 的链接列表 

1344
00:52:13,670 --> 00:52:18,980
存储3个值的链表是三个 

1345
00:52:16,340 --> 00:52:20,900
其中的节点是三个整数 

1346
00:52:18,980 --> 00:52:23,270
他们的左手代表着这一点

1347
00:52:20,900 --> 00:52:24,920
下一个指针可以说是一个

1348
00:52:23,270 --> 00:52:26,570
她并非如此 

1349
00:52:24,920 --> 00:52:29,690
持有她没有持有的价值 

1350
00:52:26,570 --> 00:52:32,120
整数而只持有 皮毛正好 

1351
00:52:29,690 --> 00:52:33,080
首先是变量的名称， 所以你就是 

1352
00:52:32,120 --> 00:52:34,910
只有一个 在这里 不同 

1353
00:52:33,080 --> 00:52:37,090
从根本上说，假设我想

1354
00:52:34,910 --> 00:52:39,110
插入数字20 就是某人 

1355
00:52:37,090 --> 00:52:41,000
自愿 成为第20号好吧来吧 

1356
00:52:39,110 --> 00:52:44,510
没事 

1357
00:52:41,000 --> 00:52:47,330
埃里克埃里克 你 叫什么名字 ？ 

1358
00:52:44,510 --> 00:52:51,860
数字20 和埃里克实际上 让我们 

1359
00:52:47,330 --> 00:52:54,920
看到我们来看看，让我们 其实可以做什么 

1360
00:52:51,860 --> 00:52:58,220
这让我让我做一个 

1361
00:52:54,920 --> 00:52:58,670
从来没有这么多不同 

1362
00:52:58,220 --> 00:53:02,840
发生

1363
00:52:58,670 --> 00:53:05,240
好的埃里克给我那个 我想要的 

1364
00:53:02,840 --> 00:53:07,250
插入埃里克是 5号 所以埃里克我是 

1365
00:53:05,240 --> 00:53:09,920
保持这个列表排序所以我们是 

1366
00:53:07,250 --> 00:53:11,330
显然你会 好起来 但是 

1367
00:53:09,920 --> 00:53:13,160
在你这样做之前，让我们考虑一下 

1368
00:53:11,330 --> 00:53:16,550
在代码中的代码看起来像什么 

1369
00:53:13,160 --> 00:53:19,100
大概我们有 Malick的Eric 

1370
00:53:16,550 --> 00:53:21,950
观众我给了他一个值n 

1371
00:53:19,100 --> 00:53:23,450
5号和他的左手 就像是 它 

1372
00:53:21,950 --> 00:53:25,430
垃圾价值现在因为它不是 

1373
00:53:23,450 --> 00:53:27,470
指着任何特定的东西， 所以他是 

1374
00:53:25,430 --> 00:53:30,260
得 值的整数和左手 

1375
00:53:27,470 --> 00:53:34,640
表示下一个指针

1376
00:53:30,260 --> 00:53:36,920
目标是将 Eric按排序顺序排列 

1377
00:53:34,640 --> 00:53:38,540
我们的步骤应该像谁的手 

1378
00:53:36,920 --> 00:53:42,500
应该指出哪里和以什么顺序 

1379
00:53:38,540 --> 00:53:44,270
是的，给我们一步 好，所以你应该 

1380
00:53:42,500 --> 00:53:46,970
指向第九位，相当于 

1381
00:53:44,270 --> 00:53:48,380
无论先说什么，都要说点 

1382
00:53:46,970 --> 00:53:48,710
科米指着这样做，继续做下去 

1383
00:53:48,380 --> 00:53:50,510
那

1384
00:53:48,710 --> 00:53:55,130
所有的旁边有什么下一步 

1385
00:53:50,510 --> 00:53:56,900
其他人几乎就在那里 

1386
00:53:55,130 --> 00:53:59,120
是啊

1387
00:53:56,900 --> 00:54:01,100
好的，所以首先你的昏迷可以指出 

1388
00:53:59,120 --> 00:54:02,540
五这很好 ，你甚至不 

1389
00:54:01,100 --> 00:54:04,460
必须向右移动这是美丽的 

1390
00:54:02,540 --> 00:54:06,650
一个链接 列表，无论你在哪里都没关系 

1391
00:54:04,460 --> 00:54:07,970
在记忆中它是整个美丽的 

1392
00:54:06,650 --> 00:54:10,010
这些指针你可以字面意思 

1393
00:54:07,970 --> 00:54:11,360
指向那个其他位置它不是 

1394
00:54:10,010 --> 00:54:12,650
阵列， 他们需要 站在 

1395
00:54:11,360 --> 00:54:14,060
回背靠背 他们可以 

1396
00:54:12,650 --> 00:54:16,370
指向任何地方没事 ，让我们去 

1397
00:54:14,060 --> 00:54:20,170
提前并插入一个多 谁愿意 

1398
00:54:16,370 --> 00:54:23,300
可以说55大价值是的，来吧 

1399
00:54:20,170 --> 00:54:25,280
好吧，你的名字 kion好吧 

1400
00:54:23,300 --> 00:54:26,870
来吧， 我们只是 malloc 到kion 

1401
00:54:25,280 --> 00:54:29,900
我从观众那里得到了他的结局 

1402
00:54:26,870 --> 00:54:32,330
他左手的价值只有一些 

1403
00:54:29,900 --> 00:54:33,620
垃圾价值现在 我们如何插入 

1404
00:54:32,330 --> 00:54:37,100
基永的顺序正确

1405
00:54:33,620 --> 00:54:38,570
其中他显然应该 去 

1406
00:54:37,100 --> 00:54:41,150
排序顺序他 显然属于 

1407
00:54:38,570 --> 00:54:43,670
结束，但这是一个链接的捕获 

1408
00:54:41,150 --> 00:54:45,200
列表就像我们 讨论时一样 

1409
00:54:43,670 --> 00:54:47,300
在过去搜索和排序

1410
00:54:45,200 --> 00:54:49,550
计算机对 所有人都是 盲目的 

1411
00:54:47,300 --> 00:54:51,110
一个 正值 和 链表 

1412
00:54:49,550 --> 00:54:53,180
那一刻我不知道 这些 

1413
00:54:51,110 --> 00:54:55,250
我知道这四个中的三个存在 

1414
00:54:53,180 --> 00:54:57,980
他们真的叫 我存在，因为 

1415
00:54:55,250 --> 00:55:00,200
通过这个第一个指针是唯一的 

1416
00:54:57,980 --> 00:55:02,060
访问其余 元素 和 

1417
00:55:00,200 --> 00:55:04,520
那么链接列表有什么好看但是 

1418
00:55:02,060 --> 00:55:06,530
或许不明显的是你只有 

1419
00:55:04,520 --> 00:55:08,330
最重要的价值是第一个

1420
00:55:06,530 --> 00:55:10,340
因为从第一个 值 可以得到 

1421
00:55:08,330 --> 00:55:12,920
其他人对我说没用 

1422
00:55:10,340 --> 00:55:15,380
让我独自记住Andrea Andrea 

1423
00:55:12,920 --> 00:55:17,180
因为如果我这样做，我就会失去踪迹 

1424
00:55:15,380 --> 00:55:20,030
打电话给我，更重要的是因为 

1425
00:55:17,180 --> 00:55:21,650
他的号码埃里克所以我必须 这么做 

1426
00:55:20,030 --> 00:55:24,410
真的是记得 科米所以如果目标 

1427
00:55:21,650 --> 00:55:26,290
现在是插入55号的步骤 

1428
00:55:24,410 --> 00:55:32,960
应该先来 

1429
00:55:26,290 --> 00:55:34,130
没有双关语打算再说好找 

1430
00:55:32,960 --> 00:55:35,960
第一个空间，所以我要开始 

1431
00:55:34,130 --> 00:55:39,560
科米和我要 跟着这个指针 

1432
00:55:35,960 --> 00:55:41,600
5号确实55属于这里，所以我是

1433
00:55:39,560 --> 00:55:44,090
要按照这个指针进行操作

1434
00:55:41,600 --> 00:55:46,670
安德烈 做55属于这里没有 会 

1435
00:55:44,090 --> 00:55:49,520
跟着她的指针，22 它属于它 

1436
00:55:46,670 --> 00:55:51,110
这里没有我跟着这个指针26没有但是

1437
00:55:49,520 --> 00:55:55,070
事实证明，你有一个空闲的手

1438
00:55:51,110 --> 00:55:58,730
接下来应该采取什么步骤

1439
00:55:55,070 --> 00:56:00,590
你有没有指向 55，现在已经这样做了 

1440
00:55:58,730 --> 00:56:03,550
相对简单，但是什么

1441
00:56:00,590 --> 00:56:03,550
运行时间

1442
00:56:03,770 --> 00:56:08,119
是的它是 N 的大O 它是线性的因为 

1443
00:56:06,320 --> 00:56:09,560
我甚至不得不从头开始 

1444
00:56:08,119 --> 00:56:10,970
虽然我们人类拥有 公正 的奢侈品 

1445
00:56:09,560 --> 00:56:12,920
眼睛看它说 哦， 显然他 

1446
00:56:10,970 --> 00:56:14,270
属于最后的方式mmm不编码 

1447
00:56:12,920 --> 00:56:16,010
就像我们必须从头开始 

1448
00:56:14,270 --> 00:56:18,020
在我们之前反转整个完整的清单

1449
00:56:16,010 --> 00:56:18,619
直线到最后，现在

1450
00:56:18,020 --> 00:56:22,070
我们完成了 

1451
00:56:18,619 --> 00:56:23,770
让我们尝试一个最后一个怎么样 啊 20 

1452
00:56:22,070 --> 00:56:26,900
右下来吧 你叫什么名字 

1453
00:56:23,770 --> 00:56:28,850
詹姆斯 好吧詹姆斯好吧 我们就这样 

1454
00:56:26,900 --> 00:56:30,020
malloc James给了他20号 

1455
00:56:28,850 --> 00:56:32,680
显然大致属于中间 

1456
00:56:30,020 --> 00:56:36,619
什么是第一步 

1457
00:56:32,680 --> 00:56:38,420
抱歉， 好吧 ，所以我们先从 科米 

1458
00:56:36,619 --> 00:56:40,940
再好吧首先好吗 五 ，你呢 

1459
00:56:38,420 --> 00:56:43,190
属于这里没有 让我按照链接 

1460
00:56:40,940 --> 00:56:47,920
好的九你属于这里没有你 

1461
00:56:43,190 --> 00:56:50,660
属于22但是我做错了什么我 

1462
00:56:47,920 --> 00:56:52,520
至少在这个故事中走得太远了

1463
00:56:50,660 --> 00:56:54,460
我确实安德里亚 在我身后好了 

1464
00:56:52,520 --> 00:56:56,990
所以我可以向后追指针 

1465
00:56:54,460 --> 00:56:58,400
你不能喜欢我们的每张照片 

1466
00:56:56,990 --> 00:56:59,570
在我们完成的每一个例子中都画了 

1467
00:56:58,400 --> 00:57:01,340
地址我们只有地址 

1468
00:56:59,570 --> 00:57:03,110
下一个指针，我们没有什么 

1469
00:57:01,340 --> 00:57:04,640
所谓双向链表至少 在 

1470
00:57:03,110 --> 00:57:06,140
这个故事，我可以转身 

1471
00:57:04,640 --> 00:57:07,970
所以这是一个错误，所以我需要开始 

1472
00:57:06,140 --> 00:57:10,190
而不是第一个好的五 

1473
00:57:07,970 --> 00:57:12,500
好的 十九我在代码中真正需要的东西 

1474
00:57:10,190 --> 00:57:14,390
最终是为了向前看而已 

1475
00:57:12,500 --> 00:57:16,640
没有实际移动不会太远只是 

1476
00:57:14,390 --> 00:57:19,400
二十岁 ，在 22 岁时 向前看， 并意识到 

1477
00:57:16,640 --> 00:57:21,619
哦， 这太过分了 

1478
00:57:19,400 --> 00:57:23,690
还不够，所以让我们继续吧 

1479
00:57:21,619 --> 00:57:25,160
实际上 你可以把詹姆斯带过来哦 

1480
00:57:23,690 --> 00:57:27,410
身体在那里，但步骤 

1481
00:57:25,160 --> 00:57:30,950
恰好先发生，我现在知道了 

1482
00:57:27,410 --> 00:57:34,880
属于这里你要指向他 

1483
00:57:30,950 --> 00:57:36,619
还好尖他也让我们这样做， 只是 

1484
00:57:34,880 --> 00:57:38,510
因为这是不正确的， 没关系 

1485
00:57:36,619 --> 00:57:42,460
安德里亚建议我们 指出这里 

1486
00:57:38,510 --> 00:57:44,810
你 刚刚打破了整个链接列表的 原因 

1487
00:57:42,460 --> 00:57:46,880
没有人记得谁是你的 

1488
00:57:44,810 --> 00:57:48,170
名字再也没有人记得Keyon在哪里

1489
00:57:46,880 --> 00:57:49,609
是如此不能这样做 ，你的左手 有 

1490
00:57:48,170 --> 00:57:53,200
留在那里应该发生什么步骤 

1491
00:57:49,609 --> 00:57:56,030
首先，詹姆斯应该指出 

1492
00:57:53,200 --> 00:57:57,800
无论Andrea指的是什么 

1493
00:57:56,030 --> 00:57:59,450
所以 此刻 有点 冗余 

1494
00:57:57,800 --> 00:57:59,750
就像以前一样， 现在发生了什么 

1495
00:57:59,450 --> 00:58:03,380
下一个

1496
00:57:59,750 --> 00:58:06,020
这是第一步，现在你可以 指着他 

1497
00:58:03,380 --> 00:58:08,810
好吧， 可以做到这一点 ，所以现在 

1498
00:58:06,020 --> 00:58:11,000
这看起来像一个完整的混乱， 但如果 

1499
00:58:08,810 --> 00:58:14,060
我们知道， 我们可以先打电话给我

1500
00:58:11,000 --> 00:58:17,070
按照这些面包屑去Eric 和 

1501
00:58:14,060 --> 00:58:20,010
然后到安德里亚然后到詹姆斯和

1502
00:58:17,070 --> 00:58:22,320
那么， 我们的 清单一步 一步 的其余部分

1503
00:58:20,010 --> 00:58:24,120
一步 所以这是一个 巨大的量 一样 

1504
00:58:22,320 --> 00:58:25,620
逻辑，但现在的问题是什么，我们有

1505
00:58:24,120 --> 00:58:27,630
解决了，我想我们确定了它

1506
00:58:25,620 --> 00:58:31,260
这里早些时候 首先是什么问题 

1507
00:58:27,630 --> 00:58:34,680
最重要的是你需要的阵列 

1508
00:58:31,260 --> 00:58:36,000
提前 和一次决定他们的大小 

1509
00:58:34,680 --> 00:58:37,620
你这样做， 如果你想添加一个 

1510
00:58:36,000 --> 00:58:39,390
您必须调整其他元素 

1511
00:58:37,620 --> 00:58:40,770
整个很贵的东西

1512
00:58:39,390 --> 00:58:42,900
因为 你必须让每个人都感动 

1513
00:58:40,770 --> 00:58:44,610
坦率地说，我有点 贪心 

1514
00:58:42,900 --> 00:58:45,990
在这里，每次我们插入这些 

1515
00:58:44,610 --> 00:58:47,940
我一直把 它们留在了新元素中 

1516
00:58:45,990 --> 00:58:50,130
排序顺序所以看起来如果 

1517
00:58:47,940 --> 00:58:51,570
你按排序顺序插入东西Big O. 

1518
00:58:50,130 --> 00:58:53,190
因为在最坏的情况下每次都是 

1519
00:58:51,570 --> 00:58:55,020
如果新元素可能最终结束

1520
00:58:53,190 --> 00:58:56,490
在 最后 的方式 ，但如果我们 放松 了什么 

1521
00:58:55,020 --> 00:58:58,170
如果我不是这样的那么约束 

1522
00:58:56,490 --> 00:59:00,540
紧张，需要一切都很好 

1523
00:58:58,170 --> 00:59:02,040
像有条不紊地排序 ，如果我只是 

1524
00:59:00,540 --> 00:59:03,870
想继续增加任何名单 

1525
00:59:02,040 --> 00:59:06,390
随机顺序我分配号码 

1526
00:59:03,870 --> 00:59:09,690
34 在哪里，我将打34号 

1527
00:59:06,390 --> 00:59:15,360
Mal'akh 34 哪里是最快的地方 

1528
00:59:09,690 --> 00:59:16,620
我去 好了，我会指向 五 

1529
00:59:15,360 --> 00:59:19,530
然后来，如果你能指出我完成 

1530
00:59:16,620 --> 00:59:22,260
一口井两步 好吧， 现在我 想 

1531
00:59:19,530 --> 00:59:23,520
malloc 十七与其他人一起 

1532
00:59:22,260 --> 00:59:27,120
假装 就在这里 

1533
00:59:23,520 --> 00:59:30,270
十七走 正确的最好的地方 

1534
00:59:27,120 --> 00:59:32,100
在科米之后- 所以现在 平静，我们 可以指出 

1535
00:59:30,270 --> 00:59:34,050
十七，十七可以指着我 

1536
00:59:32,100 --> 00:59:36,450
可以指向 Erik 等等 

1537
00:59:34,050 --> 00:59:37,740
如果是的话，这又是两个步骤

1538
00:59:36,450 --> 00:59:39,750
每次 我们 都有相同数量的步骤

1539
00:59:37,740 --> 00:59:42,450
称之为恒定时间，我们写它 

1540
00:59:39,750 --> 00:59:44,420
作为一个人的大O在这里 - 它 只是 

1541
00:59:42,450 --> 00:59:46,620
如果你想要真的很快就能获得折衷

1542
00:59:44,420 --> 00:59:47,910
插入不担心排序 

1543
00:59:46,620 --> 00:59:50,070
只是把它们放在开头并处理 

1544
00:59:47,910 --> 00:59:52,290
如果你 想要 动态 ，以后再用它 

1545
00:59:50,070 --> 00:59:53,910
调整bility大小不要使用数组使用a 

1546
00:59:52,290 --> 00:59:55,500
链表 ，只是不停地分配 

1547
00:59:53,910 --> 00:59:57,300
越走越远，不要浪费 

1548
00:59:55,500 --> 00:59:58,740
通知的巨大空间

1549
00:59:57,300 --> 01:00:00,810
这是阵列的另一个大问题

1550
00:59:58,740 --> 01:00:02,970
如果你超过分配空间而只使用 

1551
01:00:00,810 --> 01:00:04,860
部分原因是你只是在浪费空间 

1552
01:00:02,970 --> 01:00:06,240
这里没有一个解决方案，但我们做到了 

1553
01:00:04,860 --> 01:00:09,000
现在有能力认为 他们是 

1554
01:00:06,240 --> 01:00:10,650
打击Sandpoint指针 

1555
01:00:09,000 --> 01:00:18,450
如果你将这些新问题放在一起

1556
01:00:10,650 --> 01:00:22,680
是的 ，我在这个 故事中 是 谁 

1557
01:00:18,450 --> 01:00:24,450
哦， 好吧绝对是另一个非常 

1558
01:00:22,680 --> 01:00:26,160
合理的想法就是为什么 不这样做 

1559
01:00:24,450 --> 01:00:29,430
我把新的那些放在最后 

1560
01:00:26,160 --> 01:00:29,580
如果我跟踪 谁 在 ，那就没关系 

1561
01:00:29,430 --> 01:00:31,470
该

1562
01:00:29,580 --> 01:00:33,180
问题出在此刻 

1563
01:00:31,470 --> 01:00:35,100
故事， 我们最终会 看到这一点 

1564
01:00:33,180 --> 01:00:37,530
代码我只 记得来 - 来自 

1565
01:00:35,100 --> 01:00:39,990
叫我，我到处都是我 

1566
01:00:37,530 --> 01:00:41,160
可能有另一个指针秒

1567
01:00:39,990 --> 01:00:42,960
指针，字面意思称它为最后一个 

1568
01:00:41,160 --> 01:00:44,160
这相当于你或那个 

1569
01:00:42,960 --> 01:00:45,870
总是指着你

1570
01:00:44,160 --> 01:00:47,310
我只需要两个指针一个 

1571
01:00:45,870 --> 01:00:48,390
字面意思是第一个字面意思 

1572
01:00:47,310 --> 01:00:50,070
最后称为没关系

1573
01:00:48,390 --> 01:00:52,050
如果我愿意，这是一个很好的优化 

1574
01:00:50,070 --> 01:00:54,780
扔掉所有的元素 在年底 

1575
01:00:52,050 --> 01:00:56,610
坦白说， 我 真的很喜欢和 

1576
01:00:54,780 --> 01:00:59,610
解决安德里亚引用的问题 

1577
01:00:56,610 --> 01:01:01,590
如果我不只是存储一个 int和一个 

1578
01:00:59,610 --> 01:01:03,690
指针， 而是一个int和两个 

1579
01:01:01,590 --> 01:01:05,280
指针我甚至可以 拥有这些指针

1580
01:01:03,690 --> 01:01:08,100
球员与他们的左侧和右侧指向

1581
01:01:05,280 --> 01:01:10,230
手在一个双向链表 ，以 

1582
01:01:08,100 --> 01:01:12,030
解决安德里亚确定的问题

1583
01:01:10,230 --> 01:01:14,250
如果我走得太远就没什么大不了的 

1584
01:01:12,030 --> 01:01:16,230
退一步 我没有想到 

1585
01:01:14,250 --> 01:01:17,820
这个逻辑很难，所以他们是两个 

1586
01:01:16,230 --> 01:01:18,930
我们将继续进行权衡取舍 

1587
01:01:17,820 --> 01:01:20,340
五分钟休息我会打开 一些 

1588
01:01:18,930 --> 01:01:21,810
音乐抢鸭子现在，如果你想 和 

1589
01:01:20,340 --> 01:01:24,570
我们将返回 一些更精彩的数据 

1590
01:01:21,810 --> 01:01:24,810
结构仍然感谢所有 对，我们 

1591
01:01:24,570 --> 01:01:26,700
背部

1592
01:01:24,810 --> 01:01:28,980
现在让我们翻译一些的这些 

1593
01:01:26,700 --> 01:01:30,300
代码的想法，所以我们可以实际解决 

1594
01:01:28,980 --> 01:01:32,280
这个问题更具体一点 

1595
01:01:30,300 --> 01:01:33,870
而不只是让人类指着 每个人 

1596
01:01:32,280 --> 01:01:35,310
其他所以例如让我们尝试 

1597
01:01:33,870 --> 01:01:37,950
提炼出我们一直在 谈论的 一切 

1598
01:01:35,310 --> 01:01:40,080
关于存储 的目标 编码 

1599
01:01:37,950 --> 01:01:42,150
我建议的数字列表

1600
01:01:40,080 --> 01:01:43,950
我们可以在此通过三次通过 

1601
01:01:42,150 --> 01:01:45,570
问题 首先是让我们 公正的 

1602
01:01:43,950 --> 01:01:47,160
决定提前多少个 数字，我们 

1603
01:01:45,570 --> 01:01:48,510
想要存储，所以我们没有必要处理 

1604
01:01:47,160 --> 01:01:50,160
所有这些复杂性与 

1605
01:01:48,510 --> 01:01:52,260
指向和指针以及所有这一切 

1606
01:01:50,160 --> 01:01:54,600
并且只是以某种方式硬编码这个价值 

1607
01:01:52,260 --> 01:01:57,360
并在用户输入时停止

1608
01:01:54,600 --> 01:01:59,190
许多数字而不是更多- 我们可以 

1609
01:01:57,360 --> 01:02:02,400
提高在这一点， 至少 让 

1610
01:01:59,190 --> 01:02:03,930
用户动态调整他们的阵列，以便 

1611
01:02:02,400 --> 01:02:05,460
如果他们决定 输入更多 

1612
01:02:03,930 --> 01:02:07,620
数字超过我们 打算它会增长 

1613
01:02:05,460 --> 01:02:09,030
并处理当然数组 

1614
01:02:07,620 --> 01:02:10,950
不一定理想， 因为我们必须 

1615
01:02:09,030 --> 01:02:13,620
做所有那些该死的复制从旧到新 

1616
01:02:10,950 --> 01:02:15,510
这是线性时间，似乎最聪明 

1617
01:02:13,620 --> 01:02:16,860
得到一些实际的版本三 

1618
01:02:15,510 --> 01:02:19,890
要使用 链表，所以我们只是 

1619
01:02:16,860 --> 01:02:21,390
更适度地分配空间 

1620
01:02:19,890 --> 01:02:23,670
另一个号码 ，其他 号码 和 

1621
01:02:21,390 --> 01:02:26,040
另一个数字或 真正的节点之一 

1622
01:02:23,670 --> 01:02:27,900
一次一个号， 所以让我继续 吧 

1623
01:02:26,040 --> 01:02:32,310
从以下开始我将继续 前进 

1624
01:02:27,900 --> 01:02:34,890
在列表 零中包含一些熟悉的行

1625
01:02:32,310 --> 01:02:36,450
cs50 库的 dot C 只是 为了 制作 

1626
01:02:34,890 --> 01:02:39,030
很容易 获得一些用户输入 

1627
01:02:36,450 --> 01:02:40,620
和标准的i / o点 H 用于printf和 

1628
01:02:39,030 --> 01:02:43,140
让我继续，宣布我的主要 

1629
01:02:40,620 --> 01:02:43,290
像往常一样运作，然后在这里让我们 

1630
01:02:43,140 --> 01:02:45,630
做

1631
01:02:43,290 --> 01:02:48,870
首先让我们问一下用户 

1632
01:02:45,630 --> 01:02:50,340
对于我们 所在 阵列 的容量 

1633
01:02:48,870 --> 01:02:50,730
要 使用或者说让我们做到这一点 

1634
01:02:50,340 --> 01:02:52,950
第一

1635
01:02:50,730 --> 01:02:56,910
让我先回来说你知道 

1636
01:02:52,950 --> 01:02:58,110
什么诠释 号 50 以及 这会 是 

1637
01:02:56,910 --> 01:02:59,550
我们打算输入50个号码很烦人 

1638
01:02:58,110 --> 01:03:01,950
也会 给用户 两个号码 

1639
01:02:59,550 --> 01:03:04,230
首先， 他或 她可以 输入下一个 

1640
01:03:01,950 --> 01:03:08,270
让我们继续并提示用户 

1641
01:03:04,230 --> 01:03:10,440
这些数字 让我继续说 

1642
01:03:08,270 --> 01:03:12,270
让我们这样做让我们至少清理它 

1643
01:03:10,440 --> 01:03:14,550
一点点 ， 使 我们可以重新使用 

1644
01:03:12,270 --> 01:03:15,600
这个价值所以我们会有一个魔力 

1645
01:03:14,550 --> 01:03:20,700
数字刚出现在 讨论中 

1646
01:03:15,600 --> 01:03:22,590
实际上， 所以 我不 打算 这样做 

1647
01:03:20,700 --> 01:03:25,320
让我解决这个问题，这将是 我的 

1648
01:03:22,590 --> 01:03:26,970
容量大小为2， 这将 是 

1649
01:03:25,320 --> 01:03:28,800
给我 那么大，然后我会 

1650
01:03:26,970 --> 01:03:30,810
跟踪 有 多少 整数已经 

1651
01:03:28,800 --> 01:03:32,400
到目前为止提示用户

1652
01:03:30,810 --> 01:03:34,200
最初这个结构的大小是 

1653
01:03:32,400 --> 01:03:36,090
将是零，但其容量 如此 

1654
01:03:34,200 --> 01:03:37,740
说话是两个这么大的意思是多少 

1655
01:03:36,090 --> 01:03:40,680
事物在 其 容量意味着多少 

1656
01:03:37,740 --> 01:03:42,180
事物可以 在它 和大小 

1657
01:03:40,680 --> 01:03:43,980
结构小于它 

1658
01:03:42,180 --> 01:03:45,960
容量让我们继续前进 并获得一些 

1659
01:03:43,980 --> 01:03:48,150
来自用户的输入，让我们继续前进 ， 

1660
01:03:45,960 --> 01:03:50,580
用他们的旧请问他们一个号码 

1661
01:03:48,150 --> 01:03:52,740
朋友得到int只是说给我一个 

1662
01:03:50,580 --> 01:03:56,250
号码，然后让我去前进 ， 

1663
01:03:52,740 --> 01:03:59,970
插入他们输入的号码 

1664
01:03:56,250 --> 01:04:03,720
这个数组的位置大小是这样的 

1665
01:03:59,970 --> 01:04:05,550
然后做大小加上我想你 

1666
01:04:03,720 --> 01:04:07,980
知道我写的很快，但让我们 

1667
01:04:05,550 --> 01:04:09,630
考虑什么，我只是做了 我初始化 

1668
01:04:07,980 --> 01:04:12,030
大小为零 ，因为 没有 东西 在 

1669
01:04:09,630 --> 01:04:13,650
它最初然后我说，虽然大小是

1670
01:04:12,030 --> 01:04:15,900
小于整体 的容量 

1671
01:04:13,650 --> 01:04:17,460
东西和容量默认是两个 去 

1672
01:04:15,900 --> 01:04:18,840
提前做以下事情给我一个 

1673
01:04:17,460 --> 01:04:22,530
来自用户的int 

1674
01:04:18,840 --> 01:04:25,350
好吧所以int number得到int然后放在 

1675
01:04:22,530 --> 01:04:27,780
我的数字数组中的位置大小

1676
01:04:25,350 --> 01:04:30,260
无论人类输入的数量和数量

1677
01:04:27,780 --> 01:04:32,460
然后用加号增加大小 

1678
01:04:30,260 --> 01:04:34,410
好吧，所以在第一次迭代 大小 

1679
01:04:32,460 --> 01:04:36,330
为零， 因此数字括号为零 

1680
01:04:34,410 --> 01:04:38,490
第一个数字括号一个得到

1681
01:04:36,330 --> 01:04:40,560
第二个数字然后大小等于

1682
01:04:38,490 --> 01:04:43,940
容量因此它在 逻辑上 停止 任何 

1683
01:04:40,560 --> 01:04:46,050
关于这段代码逻辑的问题

1684
01:04:43,940 --> 01:04:48,780
好吧，一旦我们有这些数字 

1685
01:04:46,050 --> 01:04:51,840
让我们做一些简单的事情 

1686
01:04:48,780 --> 01:04:54,630
int我得到0 我比 实际 少 

1687
01:04:51,840 --> 01:04:56,869
大小 我加上让我们 继续前进吧 

1688
01:04:54,630 --> 01:05:02,289
打印 

1689
01:04:56,869 --> 01:05:06,470
您输入的数字％I 

1690
01:05:02,289 --> 01:05:09,529
反斜杠n并输出数字括号 

1691
01:05:06,470 --> 01:05:12,650
我 没事，所以如果我没有输入错别字 

1692
01:05:09,529 --> 01:05:14,779
列出零点C然后我会 继续 

1693
01:05:12,650 --> 01:05:16,220
并做点 斜线 零点C我要去 

1694
01:05:14,779 --> 01:05:19,309
被提示输入几个 号码 

1695
01:05:16,220 --> 01:05:21,440
继续做你输入的一个 

1696
01:05:19,309 --> 01:05:27,410
Q和把它 好起来 所以不坏，但 

1697
01:05:21,440 --> 01:05:29,960
这 是糟糕的设计，可以说是为什么 

1698
01:05:27,410 --> 01:05:35,390
发现一个错误是正确但不好的 

1699
01:05:29,960 --> 01:05:37,130
设计重复， 因为我正在使用 

1700
01:05:35,390 --> 01:05:38,779
情侣循环岸和它的 

1701
01:05:37,130 --> 01:05:40,999
从根本上说它非常有限

1702
01:05:38,779 --> 01:05:45,049
功能为何如此有用 

1703
01:05:40,999 --> 01:05:46,339
这个程序也 很难编码 

1704
01:05:45,049 --> 01:05:48,079
让我们至少改进 这一点 

1705
01:05:46,339 --> 01:05:50,359
一点点，摆脱这困难 

1706
01:05:48,079 --> 01:05:52,609
编码为什么我至少不问用户 

1707
01:05:50,359 --> 01:05:55,099
对于像这样的东西而不是 

1708
01:05:52,609 --> 01:05:57,589
只是声明 容量让我走了 

1709
01:05:55,099 --> 01:06:00,019
提前说你知道什么是正义的 

1710
01:05:57,589 --> 01:06:02,480
替换为获取int，然后说 

1711
01:06:00,019 --> 01:06:05,720
例如， 好的，如果 

1712
01:06:02,480 --> 01:06:10,130
我这样做我会被提示这样做 

1713
01:06:05,720 --> 01:06:13,819
列表0 点 斜杠列表零一个 

1714
01:06:10,130 --> 01:06:15,799
容量将是两个两个，这很好 

1715
01:06:13,819 --> 01:06:19,789
但如果我再次运行并给它一个 

1716
01:06:15,799 --> 01:06:21,980
容量为三一二三 

1717
01:06:19,789 --> 01:06:23,749
我获得了更多的容量，所以这很好 

1718
01:06:21,980 --> 01:06:27,710
肯定有一个错误的改进 

1719
01:06:23,749 --> 01:06:32,950
在我进一步测试之前，任何人都可以 

1720
01:06:27,710 --> 01:06:37,489
识别一个错误或以某种方式崩溃这个哦 

1721
01:06:32,950 --> 01:06:41,230
哦，如果我甚至不放一个，那就继续吧

1722
01:06:37,489 --> 01:06:41,230
整数或同样的评论在这里 

1723
01:06:43,369 --> 01:06:50,569
哦不， 因为我在每个都重新运行它 

1724
01:06:49,579 --> 01:06:52,670
时间我不需要担心 

1725
01:06:50,569 --> 01:07:01,999
之前的一轮比赛

1726
01:06:52,670 --> 01:07:04,940
程序是的，我正在迭代 

1727
01:07:01,999 --> 01:07:06,859
因为现在 可能是容量的大小

1728
01:07:04,940 --> 01:07:08,450
他们最终是等同的，因为 

1729
01:07:06,859 --> 01:07:10,160
我正在填补整个事情， 但让我们 

1730
01:07:08,450 --> 01:07:13,009
如果您没有输入 值， 请尝试此操作 

1731
01:07:10,160 --> 01:07:16,579
让我继续，重新运行我的 

1732
01:07:13,009 --> 01:07:18,619
容量应鸭子没事 所以 

1733
01:07:16,579 --> 01:07:20,390
确实处理了因为get int 

1734
01:07:18,619 --> 01:07:23,059
对我来说， 但我敢打赌，我 仍然可以打破 

1735
01:07:20,390 --> 01:07:25,099
这个哦是的让我们总是尝试一下 

1736
01:07:23,059 --> 01:07:27,140
负哦 好吧 

1737
01:07:25,099 --> 01:07:28,339
好像看起来很神秘，但是

1738
01:07:27,140 --> 01:07:29,900
它显然 有负面 办 

1739
01:07:28,339 --> 01:07:31,970
价值所以我应该 是 一 点点 

1740
01:07:29,900 --> 01:07:34,279
更加聪明， 并从中回忆起来 

1741
01:07:31,970 --> 01:07:35,720
一星期内 做了 与马里奥你这样 做 

1742
01:07:34,279 --> 01:07:40,369
可能已经这样做了所以我能做到 

1743
01:07:35,720 --> 01:07:43,009
类似的事情 - 虽然容量较少 

1744
01:07:40,369 --> 01:07:46,880
不止一个， 我可以继续说 

1745
01:07:43,009 --> 01:07:48,710
容量得到int容量所以只是一个 

1746
01:07:46,880 --> 01:07:50,690
关闭 错误 检查的一 点点 

1747
01:07:48,710 --> 01:07:52,519
你识别出的错误就是这样 

1748
01:07:50,690 --> 01:07:54,220
让我们继续并重新编译这个make 

1749
01:07:52,519 --> 01:07:56,690
列出零呐喊 

1750
01:07:54,220 --> 01:07:59,089
让我们开始听到这个 

1751
01:07:56,690 --> 01:08:01,309
很多今天 我们的 多制作清单 零点 

1752
01:07:59,089 --> 01:08:02,359
斜线列表零容量将为三 

1753
01:08:01,309 --> 01:08:04,489
一二三 

1754
01:08:02,359 --> 01:08:05,749
现在容量将为负数

1755
01:08:04,489 --> 01:08:07,849
不允许

1756
01:08:05,749 --> 01:08:10,849
容量零 不允许它的容量 

1757
01:08:07,849 --> 01:08:12,470
一个是， 所以非常详尽地我已经测试过了 

1758
01:08:10,849 --> 01:08:14,900
感觉好像它的形状更好 

1759
01:08:12,470 --> 01:08:17,239
但这个程序虽然正确 而且同时 

1760
01:08:14,900 --> 01:08:19,069
更多功能仍然有这个 

1761
01:08:17,239 --> 01:08:20,719
基本限制不会很好 

1762
01:08:19,069 --> 01:08:23,739
允许用户继续输入 

1763
01:08:20,719 --> 01:08:26,089
数字尽可能多 ，然后 

1764
01:08:23,739 --> 01:08:27,679
一旦他们完成 推杆就退出

1765
01:08:26,089 --> 01:08:29,509
如果你正在 制作一个节目，那 就是正确的 

1766
01:08:27,679 --> 01:08:30,319
计算某人的GPA不同 

1767
01:08:29,509 --> 01:08:32,210
学生可能会有所不同 

1768
01:08:30,319 --> 01:08:34,130
你不想要的课程

1769
01:08:32,210 --> 01:08:35,239
输入所有32门课程，如果他们是

1770
01:08:34,130 --> 01:08:36,650
更年轻， 并 采取了所有这些 

1771
01:08:35,239 --> 01:08:38,389
像这里的课程有很多 场景 

1772
01:08:36,650 --> 01:08:40,400
你 不知道提前多少 

1773
01:08:38,389 --> 01:08:42,319
用户想要提供的数字但是 

1774
01:08:40,400 --> 01:08:44,449
你想支持少数几个号码 

1775
01:08:42,319 --> 01:08:48,190
很多数字或更多数字 让我们这样做 

1776
01:08:44,449 --> 01:08:50,779
这在 列表1点C的第二个版本中 

1777
01:08:48,190 --> 01:08:53,420
让我继续和改进 该 

1778
01:08:50,779 --> 01:08:56,270
例如，首先让我给我 

1779
01:08:53,420 --> 01:08:57,349
熟悉的朋友在这里cs50点H为 

1780
01:08:56,270 --> 01:09:00,440
IO 

1781
01:08:57,349 --> 01:09:04,219
标准的i / o 点H然后在这里int 

1782
01:09:00,440 --> 01:09:09,040
主要的空虚然后让我们开始写作 

1783
01:09:04,219 --> 01:09:11,239
所以现在我事先并不知道 

1784
01:09:09,040 --> 01:09:12,710
用户 必须有多少个号码 

1785
01:09:11,239 --> 01:09:14,119
像我 想要的 那样打算输入 

1786
01:09:12,710 --> 01:09:16,069
他们能够输入一个数字 

1787
01:09:14,119 --> 01:09:17,810
另一个数字 ，然后 

1788
01:09:16,069 --> 01:09:18,650
戒掉 相当于 Q 的东西 

1789
01:09:17,810 --> 01:09:20,150
当他们完成了

1790
01:09:18,650 --> 01:09:21,290
把数字放在我不想要的地方 

1791
01:09:20,150 --> 01:09:24,170
他们必须提前考虑 

1792
01:09:21,290 --> 01:09:26,779
他们输入了多少个数字 

1793
01:09:24,170 --> 01:09:28,909
但我怎么能这样做， 就像我不能做到的那样 

1794
01:09:26,779 --> 01:09:31,400
拿出 一个数组被叫号码和 

1795
01:09:28,909 --> 01:09:33,319
说50，因为如果用户 想要输入 

1796
01:09:31,400 --> 01:09:39,469
在51个数字中，我将不得不调整大小 

1797
01:09:33,319 --> 01:09:44,119
但是如何调整数组的大小呢？ 

1798
01:09:39,469 --> 01:09:46,159
你调整数组的大小是什么？ 

1799
01:09:44,119 --> 01:09:48,109
不能对，我们从未见过一个实例 

1800
01:09:46,159 --> 01:09:49,579
你调整了我们谈过的数组的大小 

1801
01:09:48,109 --> 01:09:52,040
关于它 在黑板上这里很好 

1802
01:09:49,579 --> 01:09:53,150
就像分配更大的一个并复制一样 

1803
01:09:52,040 --> 01:09:55,699
一切都在，我们确实认同 

1804
01:09:53,150 --> 01:09:58,730
realloc但你实际上不能使用 

1805
01:09:55,699 --> 01:10:01,190
实际上 realloc 在数组realloc上 

1806
01:09:58,730 --> 01:10:04,250
接受一块内存的地址

1807
01:10:01,190 --> 01:10:06,260
你想要成长或缩小它 

1808
01:10:04,250 --> 01:10:08,270
事实证明，如果我们现在开始利用 

1809
01:10:06,260 --> 01:10:10,550
这种基本定义 

1810
01:10:08,270 --> 01:10:13,250
什么数组是我们的一大块内存

1811
01:10:10,550 --> 01:10:15,500
实际上可以 自己构建阵列 

1812
01:10:13,250 --> 01:10:17,570
数组只是一块 内存 或 

1813
01:10:15,500 --> 01:10:20,239
更具体地说， 它就像地址 

1814
01:10:17,570 --> 01:10:23,210
一块 内存的第一个字节 

1815
01:10:20,239 --> 01:10:25,849
似乎 我可以宣布我的 

1816
01:10:23,210 --> 01:10:27,829
我们没有使用方括号的数组

1817
01:10:25,849 --> 01:10:30,050
我已经做 了几个星期，但我可以说你 

1818
01:10:27,829 --> 01:10:31,820
知道什么数字真的是 真的 

1819
01:10:30,050 --> 01:10:34,159
只是一个指针，我最初 会 

1820
01:10:31,820 --> 01:10:36,619
将它初始化为null，因为有 

1821
01:10:34,159 --> 01:10:38,840
没有数组， 但现在我有 能力 

1822
01:10:36,619 --> 01:10:41,570
将指针指向任何一块

1823
01:10:38,840 --> 01:10:43,369
记忆小或大现在为什么这样 

1824
01:10:41,570 --> 01:10:45,020
有用的最初让我声称 

1825
01:10:43,369 --> 01:10:46,820
我的能力是零，因为什么都没有 

1826
01:10:45,020 --> 01:10:50,599
继续， 我还没有打电话给malloc或 

1827
01:10:46,820 --> 01:10:51,920
什么，最初我的大小是零 

1828
01:10:50,599 --> 01:10:53,989
因为没有什么 数组中和 

1829
01:10:51,920 --> 01:10:56,179
它甚至 没有尺寸，但让我 

1830
01:10:53,989 --> 01:10:57,949
就像这样永远这样做 

1831
01:10:56,179 --> 01:10:59,960
从头开始，我们可以永远阻止你 

1832
01:10:57,949 --> 01:11:01,969
使用虽然真实，并看到 只是说保持 

1833
01:10:59,960 --> 01:11:03,739
这样做直到用户突然出现 

1834
01:11:01,969 --> 01:11:07,099
这让我继续 问问 

1835
01:11:03,739 --> 01:11:09,590
用户给我一个数字 得到int和just 

1836
01:11:07,099 --> 01:11:11,110
问他们一个号码 ，然后 我们就是 

1837
01:11:09,590 --> 01:11:14,830
需要一个地方 把 它 

1838
01:11:11,110 --> 01:11:16,570
那我该把这个号码放在哪里呢？ 

1839
01:11:14,830 --> 01:11:19,840
此刻 任何地方 都有 

1840
01:11:16,570 --> 01:11:22,300
没有，从技术上说 如何 

1841
01:11:19,840 --> 01:11:25,240
你表达，像在 我 的伪代码 

1842
01:11:22,300 --> 01:11:27,850
想说没有数字的地方但是

1843
01:11:25,240 --> 01:11:31,030
从技术上讲， 如果 我能 做得好的话 

1844
01:11:27,850 --> 01:11:33,700
此刻 阵列的大小等于 

1845
01:11:31,030 --> 01:11:35,740
它的容量 感觉 就像一个 

1846
01:11:33,700 --> 01:11:38,140
较低层次的表达方式 

1847
01:11:35,740 --> 01:11:40,330
如果是的话，无论能力如何 

1848
01:11:38,140 --> 01:11:44,260
大小是一样的 ， 没有 更多的空间 

1849
01:11:40,330 --> 01:11:46,630
而这个简单的陈述 也涵盖了 

1850
01:11:44,260 --> 01:11:49,210
其中 容量为零的情况下 

1851
01:11:46,630 --> 01:11:51,310
因此，大小是零，所以它是 

1852
01:11:49,210 --> 01:11:53,020
同样的问题要么我们 没有空间 

1853
01:11:51,310 --> 01:11:56,590
所有或我们有一些空间，但我们已经使用过 

1854
01:11:53,020 --> 01:11:58,720
在所有大小等于容量， 所以如果 

1855
01:11:56,590 --> 01:12:00,250
大小等于容量或放什么 

1856
01:11:58,720 --> 01:12:04,530
如果我没有足够的话，更随意

1857
01:12:00,250 --> 01:12:06,850
空间 我想直观地做什么 

1858
01:12:04,530 --> 01:12:08,910
分配更多的内存，事实证明 

1859
01:12:06,850 --> 01:12:10,930
你提议或先前提出过的人 

1860
01:12:08,910 --> 01:12:13,060
重新分配内存我们 可以使用它 

1861
01:12:10,930 --> 01:12:15,370
对于第一次的功能让我 

1862
01:12:13,060 --> 01:12:16,840
继续 说这个我抓住了 

1863
01:12:15,370 --> 01:12:18,280
realloc你必须要聪明一点

1864
01:12:16,840 --> 01:12:20,500
因为它返回一个指针但是让它 

1865
01:12:18,280 --> 01:12:22,240
我首先提出这个代码的第一个 GUID 

1866
01:12:20,500 --> 01:12:24,910
只是给我一个临时变量调用 

1867
01:12:22,240 --> 01:12:27,430
它 会存储以下内容 

1868
01:12:24,910 --> 01:12:29,440
或者实际上没有让我让我开始 

1869
01:12:27,430 --> 01:12:34,170
这更简单地让我继续说 

1870
01:12:29,440 --> 01:12:39,190
数字应该重新分配 

1871
01:12:34,170 --> 01:12:42,700
realloc通过传递自己和这个

1872
01:12:39,190 --> 01:12:47,230
时间给我一个int次的大小 

1873
01:12:42,700 --> 01:12:49,060
这次我想要多少蚂蚁 

1874
01:12:47,230 --> 01:12:53,800
很多你 可以输入 多少个数字 

1875
01:12:49,060 --> 01:12:55,450
大概只是输入了人类

1876
01:12:53,800 --> 01:12:57,370
一个是正​​确的， 因为字面上我们只有 

1877
01:12:55,450 --> 01:13:01,000
所谓在这个故事中得到它曾经如此 

1878
01:12:57,370 --> 01:13:04,060
不管这个数组的大小 是现在 

1879
01:13:01,000 --> 01:13:07,770
我们需要将它增加一个 

1880
01:13:04,060 --> 01:13:10,360
所以这行代码 就是嘿 

1881
01:13:07,770 --> 01:13:14,170
付费电脑继续前进，我会 

1882
01:13:10,360 --> 01:13:17,050
从任何它重新分配这个数组

1883
01:13:14,170 --> 01:13:20,740
当前大小是这样的大小 

1884
01:13:17,050 --> 01:13:23,380
而不是它的大小加上

1885
01:13:20,740 --> 01:13:24,520
int的大小的一倍 

1886
01:13:23,380 --> 01:13:25,720
这就是我们想要存储的东西 

1887
01:13:24,520 --> 01:13:27,880
int所以 我们必须做乘法 

1888
01:13:25,720 --> 01:13:29,770
和前面提到的realloc 是 

1889
01:13:27,880 --> 01:13:31,180
非常想要它会接受一个 

1890
01:13:29,770 --> 01:13:33,940
指针你所记忆的任何一块记忆 

1891
01:13:31,180 --> 01:13:35,680
已经分配了，然后呢 

1892
01:13:33,940 --> 01:13:37,840
重新分配更大的内存 

1893
01:13:35,680 --> 01:13:40,270
希望这会发生什么呢？ 

1894
01:13:37,840 --> 01:13:42,610
你的大块记忆最初看起来 

1895
01:13:40,270 --> 01:13:44,800
像这样它会有希望注意到 

1896
01:13:42,610 --> 01:13:46,270
所有这些 记忆都是免费的 让我给予 

1897
01:13:44,800 --> 01:13:48,430
你回到 同一个地址，如果这样的话 

1898
01:13:46,270 --> 01:13:50,410
地址是100，你会得到幸运 

1899
01:13:48,430 --> 01:13:51,970
这个地址 也可用 

1900
01:13:50,410 --> 01:13:53,710
realloc函数将要记住 

1901
01:13:51,970 --> 01:13:55,270
对于 操作系统而言，它正在发展 

1902
01:13:53,710 --> 01:13:56,650
再次返回数字100 

1903
01:13:55,270 --> 01:14:00,120
你很高兴去，你可以安全地触摸 

1904
01:13:56,650 --> 01:14:03,070
记忆在这里或如果这已经 在使用 

1905
01:14:00,120 --> 01:14:04,990
这块 记忆因此是的 

1906
01:14:03,070 --> 01:14:07,360
我们不能在那里放入另一个字节因为

1907
01:14:04,990 --> 01:14:10,090
您编写的其他一些代码正在使用它 

1908
01:14:07,360 --> 01:14:12,610
内存， 但有两倍 的内存 

1909
01:14:10,090 --> 01:14:14,770
这里有 什么realloc会做什么 

1910
01:14:12,610 --> 01:14:16,840
如果你已存储数字50它 

1911
01:14:14,770 --> 01:14:18,700
将处理复制 50到 的过程 

1912
01:14:16,840 --> 01:14:20,260
这 将留下 新的价值 

1913
01:14:18,700 --> 01:14:22,930
作为你要处理的垃圾值 

1914
01:14:20,260 --> 01:14:25,480
它会 回复你的地址 

1915
01:14:22,930 --> 01:14:28,090
新的大块记忆已经 完成了 

1916
01:14:25,480 --> 01:14:30,610
为你复制， 即使它是 

1917
01:14:28,090 --> 01:14:32,650
技术上重新分配它的数组 

1918
01:14:30,610 --> 01:14:35,410
不一定只会增长 它 

1919
01:14:32,650 --> 01:14:37,120
可能会将它重新定位在更大的内存中 

1920
01:14:35,410 --> 01:14:51,400
chunk 然后给你新的地址 

1921
01:14:37,120 --> 01:14:52,930
那个记忆问题真的是真的 

1922
01:14:51,400 --> 01:14:54,850
老实说我们可以避免这个问题 

1923
01:14:52,930 --> 01:14:58,060
只是做你这个问题

1924
01:14:54,850 --> 01:15:00,160
知道什么让我至少去 

1925
01:14:58,060 --> 01:15:02,740
提前，给我至少 的大小 

1926
01:15:00,160 --> 01:15:03,880
蚂蚁x我不知道大多数人是谁 

1927
01:15:02,740 --> 01:15:06,040
不打算超过50 

1928
01:15:03,880 --> 01:15:08,200
数字让我们选择50就 可以了 

1929
01:15:06,040 --> 01:15:09,850
这样做，这 确实可以拯救你 

1930
01:15:08,200 --> 01:15:11,680
时间， 因为我目前的方法 

1931
01:15:09,850 --> 01:15:14,140
服用是非常低效的， 因为 

1932
01:15:11,680 --> 01:15:15,910
每个该死的时间 就像用户打电话一样 

1933
01:15:14,140 --> 01:15:18,730
int并给出一个INT，我们正在调整大小 

1934
01:15:15,910 --> 01:15:21,010
调整大小非常昂贵

1935
01:15:18,730 --> 01:15:23,440
什么是最好的价值，但50应该 

1936
01:15:21,010 --> 01:15:25,420
如果它是一千，我也是 

1937
01:15:23,440 --> 01:15:28,600
下赌注去或以上 的赌注 ，它 

1938
01:15:25,420 --> 01:15:31,969
只是取决于你决定哪个 

1939
01:15:28,600 --> 01:15:34,610
那些是 最糟糕 的 决定 

1940
01:15:31,969 --> 01:15:36,170
程序访问非常昂贵 

1941
01:15:34,610 --> 01:15:38,570
有男人是你没有使用或 

1942
01:15:36,170 --> 01:15:40,250
一般来说它通常 更好 

1943
01:15:38,570 --> 01:15:41,510
你正在写的课程中的问题是

1944
01:15:40,250 --> 01:15:43,010
有更多的 记忆比 

1945
01:15:41,510 --> 01:15:45,290
你正在使用或者你应该真的 

1946
01:15:43,010 --> 01:15:47,540
保守的这些天记忆很便宜 

1947
01:15:45,290 --> 01:15:50,570
我们都有几千兆字节的内存 等等 

1948
01:15:47,540 --> 01:15:52,880
浪费50个字节或200个字节 乘以4 个 

1949
01:15:50,570 --> 01:15:55,250
记忆不是什么大不了 就像得到的那样 

1950
01:15:52,880 --> 01:15:56,810
尽快完成工作 ， 但在 

1951
01:15:55,250 --> 01:15:58,760
资源受限的设备可能 

1952
01:15:56,810 --> 01:16:00,679
像手机或小互联网的东西 

1953
01:15:58,760 --> 01:16:02,929
东西 风格的设备有很多 

1954
01:16:00,679 --> 01:16:05,329
你真的不 想要的资源更少

1955
01:16:02,929 --> 01:16:06,710
去浪费字节 但老实说 CPU是 

1956
01:16:05,329 --> 01:16:08,239
大脑和我们的电脑都是如此 

1957
01:16:06,710 --> 01:16:10,400
这几天即使你打电话也快

1958
01:16:08,239 --> 01:16:11,929
malloc的 十倍千倍 它的 

1959
01:16:10,400 --> 01:16:14,239
发生得如此快，以至于人类

1960
01:16:11,929 --> 01:16:15,530
他们 甚至没有注意到 - 这些 

1961
01:16:14,239 --> 01:16:16,639
被称为设计决策和 

1962
01:16:15,530 --> 01:16:18,290
这些就是 那种 东西 

1963
01:16:16,639 --> 01:16:19,730
你可能会真正辩论的现实世界

1964
01:16:18,290 --> 01:16:21,409
有人在 白板上说不 

1965
01:16:19,730 --> 01:16:22,880
由于 这个原因，这是愚蠢 的 

1966
01:16:21,409 --> 01:16:25,040
他或她可能会推回其他人 

1967
01:16:22,880 --> 01:16:26,360
原因， 没有人必然是对的 

1968
01:16:25,040 --> 01:16:27,889
整个目标是只是 有 

1969
01:16:26,360 --> 01:16:37,070
思考过程首先让你至少 

1970
01:16:27,889 --> 01:16:40,250
自信，你选择什么 时候 呀 

1971
01:16:37,070 --> 01:16:42,469
你曾经打电话给F Reed 

1972
01:16:40,250 --> 01:16:46,099
法医问题集中的定义

1973
01:16:42,469 --> 01:16:47,570
从磁盘读取字节到内存时 

1974
01:16:46,099 --> 01:16:50,230
你打电话给F写道你是 

1975
01:16:47,570 --> 01:16:53,420
将字节从内存复制回 磁盘 

1976
01:16:50,230 --> 01:16:59,420
如果这回答了问题还可以 

1977
01:16:53,420 --> 01:17:02,840
问题是的，为什么我说大小 加 

1978
01:16:59,420 --> 01:17:05,449
第16行中的一个， 因为整个目标是 

1979
01:17:02,840 --> 01:17:06,920
为 这个阵列腾出空间 

1980
01:17:05,449 --> 01:17:09,139
输入的人数正好

1981
01:17:06,920 --> 01:17:11,239
键入in等等当前 

1982
01:17:09,139 --> 01:17:13,750
阵列的大小我显然需要一个 

1983
01:17:11,239 --> 01:17:13,750
更多空间 

1984
01:17:15,850 --> 01:17:20,540
它因为它没有 重复 上和 

1985
01:17:18,680 --> 01:17:23,810
因为此刻 我是 这 里面 

1986
01:17:20,540 --> 01:17:25,670
while循环所以我们确实需要问一个 

1987
01:17:23,810 --> 01:17:27,410
问题人类什么时候完成 

1988
01:17:25,670 --> 01:17:28,820
输入 ，事实证明， 这是 

1989
01:17:27,410 --> 01:17:30,950
不明显，它不是最好的用户 

1990
01:17:28,820 --> 01:17:34,130
在键盘上 为人类 体验 

1991
01:17:30,950 --> 01:17:38,060
但 我们实际上可以 检测 到以下内容 

1992
01:17:34,130 --> 01:17:41,840
如果用户在推杆中完成情绪

1993
01:17:38,060 --> 01:17:43,700
数字然后让我们继续 前进并打破 

1994
01:17:41,840 --> 01:17:46,460
但问题是你是怎么做的 

1995
01:17:43,700 --> 01:17:49,340
表达伪 很好 ，你可以 

1996
01:17:46,460 --> 01:17:50,330
在一些程序中可能是q型退出 

1997
01:17:49,340 --> 01:17:54,830
但这是否 会起作用 

1998
01:17:50,330 --> 01:18:03,200
当使用get int时，我们可以检测到 q为什么 

1999
01:17:54,830 --> 01:18:04,700
不完全是因为 立即 进入 

2000
01:18:03,200 --> 01:18:05,990
提示你换 另一英寸因为 

2001
01:18:04,700 --> 01:18:07,910
我们设计cs50 库的方式 

2002
01:18:05,990 --> 01:18:11,270
你无法检测Q或你不能拥有 

2003
01:18:07,910 --> 01:18:16,460
人类退出除非你 不使用get 

2004
01:18:11,270 --> 01:18:18,470
int 你改为使用我们可以使用get 

2005
01:18:16,460 --> 01:18:20,600
字符串，然后每次人类

2006
01:18:18,470 --> 01:18:23,480
我们可以使用的数字类型， 如 - 

2007
01:18:20,600 --> 01:18:26,600
我将它转换为int但是如果 

2008
01:18:23,480 --> 01:18:28,430
Q或 Q中的人类类型也是一个字符串 

2009
01:18:26,600 --> 01:18:30,710
我们可以只有一个if条件 

2010
01:18:28,430 --> 01:18:32,960
搅拌比较和退出 但老实说 

2011
01:18:30,710 --> 01:18:35,510
那么你就像进入一样重新发明

2012
01:18:32,960 --> 01:18:37,550
无论如何，这是一种常见的 工作方式 

2013
01:18:35,510 --> 01:18:39,050
在这周围你会知道 ctrl 

2014
01:18:37,550 --> 01:18:40,550
C退出程序 

2015
01:18:39,050 --> 01:18:42,260
也许取消你的计划

2016
01:18:40,550 --> 01:18:44,930
还有另一种流行的按键 

2017
01:18:42,260 --> 01:18:47,960
控制D发送所谓的结束 

2018
01:18:44,930 --> 01:18:50,090
它模拟文件的结尾 

2019
01:18:47,960 --> 01:18:51,530
它模拟 了人类输入 的 结束 

2020
01:18:50,090 --> 01:18:53,150
所以它有点像时期 

2021
01:18:51,530 --> 01:18:54,980
结束英语句子 ，如果你 

2022
01:18:53,150 --> 01:18:56,720
我想忽略 一台计算机 

2023
01:18:54,980 --> 01:18:57,830
等待 输入来自你，你 

2024
01:18:56,720 --> 01:18:59,900
不想退出那个程序 

2025
01:18:57,830 --> 01:19:02,390
将是 ctrl C，但你 只想成为 

2026
01:18:59,900 --> 01:19:04,460
完成输入到 您 的 计算机的 输入 

2027
01:19:02,390 --> 01:19:06,170
命中控制D，也称为Oh F 

2028
01:19:04,460 --> 01:19:07,760
以及表达这一点和你的方式 

2029
01:19:06,170 --> 01:19:09,650
只会从文档中知道这一点 

2030
01:19:07,760 --> 01:19:12,470
如果是这样的 话 就是这样说的 

2031
01:19:09,650 --> 01:19:14,990
人类输入的数字等于结尾 

2032
01:19:12,470 --> 01:19:16,880
的文件，但没有这样的东西

2033
01:19:14,990 --> 01:19:19,640
这种情况下 ，你真正做到这一点 

2034
01:19:16,880 --> 01:19:22,400
因为cs50 库的工作原理 

2035
01:19:19,640 --> 01:19:24,080
事实证明 ，如果 唯一的价值观 

2036
01:19:22,400 --> 01:19:27,890
函数可以返回我们的整数 

2037
01:19:24,080 --> 01:19:28,310
意味着你可以返回0 1负1 2 

2038
01:19:27,890 --> 01:19:29,330
十亿

2039
01:19:28,310 --> 01:19:31,910
负20亿

2040
01:19:29,330 --> 01:19:33,830
永远接受人类多年来的所作所为 

2041
01:19:31,910 --> 01:19:36,170
旧的编程语言就是它们 

2042
01:19:33,830 --> 01:19:37,970
偷例如一个或几个数字 

2043
01:19:36,170 --> 01:19:40,640
你偷了 二十亿 

2044
01:19:37,970 --> 01:19:42,500
并将其称为int max最大 整数 

2045
01:19:40,640 --> 01:19:44,450
而你只是说你实际上永远不会 

2046
01:19:42,500 --> 01:19:46,850
输入二十亿，因为我们正在使用 

2047
01:19:44,450 --> 01:19:48,770
这 是一个特殊的价值来 表示 这一点 

2048
01:19:46,850 --> 01:19:50,570
人类命中ctrl D或你可以做到 

2049
01:19:48,770 --> 01:19:52,610
负20亿或你可以做零 

2050
01:19:50,570 --> 01:19:54,830
或50，但在某些 时候你必须 

2051
01:19:52,610 --> 01:19:57,080
窃取 40亿可用中的一个 

2052
01:19:54,830 --> 01:19:58,910
用作哨兵价值的数字a 

2053
01:19:57,080 --> 01:20:02,270
您 可以检查的特殊值 

2054
01:19:58,910 --> 01:20:03,710
因为无论如何这是一个常数 

2055
01:20:02,270 --> 01:20:05,420
表示 用户在打字 时 完成的操作 

2056
01:20:03,710 --> 01:20:07,940
输入继续进行并突破 这一点 

2057
01:20:05,420 --> 01:20:10,190
虽然循环 并作为一个旁边让我解决 

2058
01:20:07,940 --> 01:20:13,370
有一件事事情可以证明 

2059
01:20:10,190 --> 01:20:16,310
realloc错误，如果realloc失败 

2060
01:20:13,370 --> 01:20:18,530
分配内存它可以 返回null a 

2061
01:20:16,310 --> 01:20:20,510
特殊价值只是意味着什么 

2062
01:20:18,530 --> 01:20:22,940
出了问题，这是一个无效的指针 

2063
01:20:20,510 --> 01:20:24,440
事实证明，地址为0 

2064
01:20:22,940 --> 01:20:26,900
这里有一个微妙的错误

2065
01:20:24,440 --> 01:20:29,930
从技术上讲，我应该这样做 

2066
01:20:26,900 --> 01:20:32,420
商店Ari Alex的回报值 

2067
01:20:29,930 --> 01:20:35,870
临时变量， 因为如果temp 

2068
01:20:32,420 --> 01:20:38,660
等于null出错了我 

2069
01:20:35,870 --> 01:20:40,730
实际上应该继续并退出 

2070
01:20:38,660 --> 01:20:42,290
这个节目， 但 让我挥手 

2071
01:20:40,730 --> 01:20:43,880
现在因为它更像是一个 

2072
01:20:42,290 --> 01:20:45,320
角落案例， 但你会在网上看到 

2073
01:20:43,880 --> 01:20:47,060
我们 有 这个 程序的 版本 

2074
01:20:45,320 --> 01:20:49,100
额外的错误检查只是 

2075
01:20:47,060 --> 01:20:52,250
在罕见的情况下检查realloc 

2076
01:20:49,100 --> 01:20:54,020
无法清理并正确返回 

2077
01:20:52,250 --> 01:20:56,660
但我会向 在线 代码 挥手致意 

2078
01:20:54,020 --> 01:21:01,990
对此有 任何疑问 

2079
01:20:56,660 --> 01:21:01,990
我们继续前行的例子 

2080
01:21:05,180 --> 01:21:13,680
当你打电话给realloc时，这是个好问题 

2081
01:21:11,820 --> 01:21:17,190
它最终会分配更多的空间

2082
01:21:13,680 --> 01:21:19,340
它是否清除了原始记忆no和 

2083
01:21:17,190 --> 01:21:21,990
这正是 垃圾值来自 

2084
01:21:19,340 --> 01:21:23,460
例如， 因为如果他们 只是 

2085
01:21:21,990 --> 01:21:27,150
从以前的使用中留在内存中

2086
01:21:23,460 --> 01:21:32,880
用户实际 输入的其他问题

2087
01:21:27,150 --> 01:21:35,310
打破哦控制D控制D和它的 

2088
01:21:32,880 --> 01:21:37,860
不是Brahe它只是发送 文件 结束 

2089
01:21:35,310 --> 01:21:43,190
输入控制C的杀死或爆发 

2090
01:21:37,860 --> 01:21:48,480
程序本身与int max相同 

2091
01:21:43,190 --> 01:21:58,350
在cs50库int max中 是正确 的 

2092
01:21:48,480 --> 01:21:59,760
是的是符号是的，我们可以添加 

2093
01:21:58,350 --> 01:22:01,440
更多逻辑，你可以使用getstring 

2094
01:21:59,760 --> 01:22:02,880
我们可以告诉她，嘿，你呢 

2095
01:22:01,440 --> 01:22:04,440
想要只输入另一个号码 

2096
01:22:02,880 --> 01:22:06,150
的下跌 空间 将是 现在我要 

2097
01:22:04,440 --> 01:22:08,130
输入不仅是 我的号码，而且是的 

2098
01:22:06,150 --> 01:22:11,220
或者不经常这样只是权衡 

2099
01:22:08,130 --> 01:22:14,700
用户 界面明智，所以让 我 

2100
01:22:11,220 --> 01:22:16,740
继续，让我继续前进并返回 

2101
01:22:14,700 --> 01:22:19,140
0就像我的简单解决方案一样 

2102
01:22:16,740 --> 01:22:21,780
这个问题 出了问题 

2103
01:22:19,140 --> 01:22:23,550
我刚刚编译了这个程序让 我 

2104
01:22:21,780 --> 01:22:27,030
继续运行 它我 打算输入 

2105
01:22:23,550 --> 01:22:28,830
一个 数字两个数字 三个数字和 

2106
01:22:27,030 --> 01:22:31,220
现在我很无聊，我不想继续这样做 

2107
01:22:28,830 --> 01:22:35,310
这怎么告诉电脑我已经完成了 

2108
01:22:31,220 --> 01:22:36,780
控制D哦， 好吧 

2109
01:22:35,310 --> 01:22:42,020
这是正确的行为，因为我忘记了 

2110
01:22:36,780 --> 01:22:43,850
一个关键的一步那是什么 

2111
01:22:42,020 --> 01:22:45,410
是的我实际上并没有做任何事情 

2112
01:22:43,850 --> 01:22:49,640
我应该喜欢的价值观 

2113
01:22:45,410 --> 01:22:52,310
对于int int我得到0我不到 叹息我 

2114
01:22:49,640 --> 01:22:55,450
+我们以前的代码，我应该 

2115
01:22:52,310 --> 01:23:00,920
可能打印出你输入的％I 

2116
01:22:55,450 --> 01:23:03,680
逗号这个保存使列表1全部 

2117
01:23:00,920 --> 01:23:06,070
如果是的话，我现在就是打印代码 

2118
01:23:03,680 --> 01:23:13,340
我重新跑了1 2 3 

2119
01:23:06,070 --> 01:23:16,280
控制D 该死的 哦现在我打破了我的 

2120
01:23:13,340 --> 01:23:17,690
这里的代码让 我这样做我们会得到的 

2121
01:23:16,280 --> 01:23:20,240
摆脱这个错误检查， 因为我 

2122
01:23:17,690 --> 01:23:23,000
实际上并没有调整数字的大小 

2123
01:23:20,240 --> 01:23:26,270
realloc 哦，也许 有人在说话 

2124
01:23:23,000 --> 01:23:31,160
用这个数字括号进行调整 

2125
01:23:26,270 --> 01:23:32,810
size获取用户输入大小 + + 

2126
01:23:31,160 --> 01:23:34,520
这是有人想要我的关键细节 

2127
01:23:32,810 --> 01:23:36,080
好的 

2128
01:23:34,520 --> 01:23:38,450
所以我实际上没有完成这个程序

2129
01:23:36,080 --> 01:23:41,780
提前通知我们如下 

2130
01:23:38,450 --> 01:23:44,390
嘿计算机给我一个大小为 0 的数组 

2131
01:23:41,780 --> 01:23:46,610
最初那是空的，没有记忆 

2132
01:23:44,390 --> 01:23:49,730
它 因此该数组的大小 

2133
01:23:46,610 --> 01:23:52,490
是0 做以下永远得到一个 

2134
01:23:49,730 --> 01:23:54,350
如果人数来自人数 

2135
01:23:52,490 --> 01:23:57,650
等于这个特殊值int max just 

2136
01:23:54,350 --> 01:24:01,160
突破， 因为程序已经完成并且 

2137
01:23:57,650 --> 01:24:06,680
真的很抱歉这就是我写这些的原因 

2138
01:24:01,160 --> 01:24:08,780
提前- 好吧继续 并提示 

2139
01:24:06,680 --> 01:24:11,360
用户是否有号码 

2140
01:24:08,780 --> 01:24:13,610
输入的 CTRL d刚刚 打出来 的 

2141
01:24:11,360 --> 01:24:16,040
这个循环但是如果的大小 

2142
01:24:13,610 --> 01:24:18,110
数组等于其当前容量 

2143
01:24:16,040 --> 01:24:21,140
提前并为此重新分配空间

2144
01:24:18,110 --> 01:24:23,900
事情比它大一个数 

2145
01:24:21,140 --> 01:24:25,940
以前现在假设 说 

2146
01:24:23,900 --> 01:24:27,800
成功了，我们有记忆 继续前进 

2147
01:24:25,940 --> 01:24:30,500
就像我们的列表 零示例一样 

2148
01:24:27,800 --> 01:24:32,690
存储在数字阵列中

2149
01:24:30,500 --> 01:24:34,400
当前位置为零 

2150
01:24:32,690 --> 01:24:36,740
编号人类输入然后 

2151
01:24:34,400 --> 01:24:37,970
将大小增加一个 以便 记住 

2152
01:24:36,740 --> 01:24:39,910
我们所做的

2153
01:24:37,970 --> 01:24:42,710
我也需要做 

2154
01:24:39,910 --> 01:24:44,150
容量加上加上 这里要记住 ， 

2155
01:24:42,710 --> 01:24:46,370
我们增加了容量 

2156
01:24:44,150 --> 01:24:48,590
阵列又是两个 新的措施能力 

2157
01:24:46,370 --> 01:24:50,630
总大小是多少空间 

2158
01:24:48,590 --> 01:24:53,300
是我们使用它们的次数 

2159
01:24:50,630 --> 01:24:55,620
现在是相同的，因为我们是 

2160
01:24:53,300 --> 01:24:57,660
一步一步地发展这件事 

2161
01:24:55,620 --> 01:24:59,430
好吧，让我继续前进并击中 

2162
01:24:57,660 --> 01:25:03,270
保存让我继续编译 

2163
01:24:59,430 --> 01:25:07,530
最后一次点斜杠列表 1 和输入 

2164
01:25:03,270 --> 01:25:08,370
1 2 3 ctrl D，好吧现在它只是一个 

2165
01:25:07,530 --> 01:25:11,820
美学错误 

2166
01:25:08,370 --> 01:25:14,370
我忘记了我的反斜杠，所以只是为了证明

2167
01:25:11,820 --> 01:25:21,030
我实际上可以编写 点斜杠 

2168
01:25:14,370 --> 01:25:22,470
清单1 1 2 3 控制D好吧 所以你 

2169
01:25:21,030 --> 01:25:24,210
输入1和 它没有移动 的 原因 

2170
01:25:22,470 --> 01:25:26,130
另一行是因为 ctrl D得到了 

2171
01:25:24,210 --> 01:25:29,910
立即发送而不 按Enter键 

2172
01:25:26,130 --> 01:25:32,850
好了， 现在全部使用数组

2173
01:25:29,910 --> 01:25:35,430
我们已经把那种蛋糕烤好 了 

2174
01:25:32,850 --> 01:25:38,510
并将它从烤箱中拉出第三个 

2175
01:25:35,430 --> 01:25:40,710
这里的最后一个例子是清单2和 

2176
01:25:38,510 --> 01:25:42,930
实际上在我们到达那里之前让我注意一下 

2177
01:25:40,710 --> 01:25:45,690
有一件事是的，让我们做最后一件事 

2178
01:25:42,930 --> 01:25:49,730
下面就让我继续前进 ， 每早 跑 

2179
01:25:45,690 --> 01:25:54,180
我们在名单 1 上的新朋友valgrind 进入 

2180
01:25:49,730 --> 01:25:55,700
它等待 我在1个2 3设键入 

2181
01:25:54,180 --> 01:25:58,800
我继续前进并击中 对照D. 

2182
01:25:55,700 --> 01:26:00,510
有趣的是我似乎 有一辆马车 

2183
01:25:58,800 --> 01:26:02,640
节目虽然 我声称了一下 

2184
01:26:00,510 --> 01:26:05,370
以前， 我知道我在做什么12 

2185
01:26:02,640 --> 01:26:06,930
1个块中的字节肯定会丢失 

2186
01:26:05,370 --> 01:26:08,310
失去了1的记录，我 没有 

2187
01:26:06,930 --> 01:26:11,340
了解大部分这些词，但 12 

2188
01:26:08,310 --> 01:26:16,970
肯定丢失的字节可能是 我的错 

2189
01:26:11,340 --> 01:26:16,970
为什么它是12 ，那12个字节是什么 

2190
01:26:18,770 --> 01:26:22,340
是的1 2 和3 

2191
01:26:23,170 --> 01:26:27,050
我输入三个数字1 2 和3 

2192
01:26:25,640 --> 01:26:30,110
每个都是4个字节 

2193
01:26:27,050 --> 01:26:31,820
计算机是12 3次4 ，所以我 

2194
01:26:30,110 --> 01:26:34,190
永远不会释放它们似乎 是源头 

2195
01:26:31,820 --> 01:26:36,440
这个 问题 所以 最后 我们就是这样 

2196
01:26:34,190 --> 01:26:39,040
证明 的valgrind可以检测 

2197
01:26:36,440 --> 01:26:41,720
正确性以及我的数字

2198
01:26:39,040 --> 01:26:44,480
分号让我继续并 重新运行make 

2199
01:26:41,720 --> 01:26:47,950
列表1现在让我增加 大小 

2200
01:26:44,480 --> 01:26:50,300
这一点，并在列表1上再次做valgrind 

2201
01:26:47,950 --> 01:26:53,480
输入相同的值1 2和3 

2202
01:26:50,300 --> 01:26:55,760
控制 d所有堆块都被释放了 

2203
01:26:53,480 --> 01:26:57,110
泄漏是可能的，所以valgrind再次

2204
01:26:55,760 --> 01:26:58,310
你的朋友，他们发现你的问题

2205
01:26:57,110 --> 01:26:59,240
甚至没有必要注意到 你 

2206
01:26:58,310 --> 01:27:01,220
没有读过你的 

2207
01:26:59,240 --> 01:27:02,990
代码行一次 又一次地 

2208
01:27:01,220 --> 01:27:04,640
找出问题的根源 

2209
01:27:02,990 --> 01:27:06,950
当然， 任何问题都可以 

2210
01:27:04,640 --> 01:27:09,440
在这些动态的数组上

2211
01:27:06,950 --> 01:27:13,960
分配和我们在其中找到的错误

2212
01:27:09,440 --> 01:27:16,550
和valgrind一样，所以最后 

2213
01:27:13,960 --> 01:27:19,580
代码的演示将是 

2214
01:27:16,550 --> 01:27:21,830
我为这场决赛偷了这个 

2215
01:27:19,580 --> 01:27:24,410
例如一些构建 块 

2216
01:27:21,830 --> 01:27:27,260
我们在我的代码 已经在 屏幕 上 较早 

2217
01:27:24,410 --> 01:27:30,020
对于列表 2 点CI需要一个结构 

2218
01:27:27,260 --> 01:27:31,670
我们声称的称为节点和节点 

2219
01:27:30,020 --> 01:27:33,350
早前我们志愿者是 

2220
01:27:31,670 --> 01:27:34,850
将包含一个被称为数字的数字 

2221
01:27:33,350 --> 01:27:36,860
我们会打电话给这个时候 ， 而不是 n和 

2222
01:27:34,850 --> 01:27:40,310
它将包含一个名为的指针 

2223
01:27:36,860 --> 01:27:42,290
旁边的另一个这样的节点，所以 

2224
01:27:40,310 --> 01:27:43,820
早先复制并粘贴， 尽管是 

2225
01:27:42,290 --> 01:27:46,550
整数重命名 为数字 

2226
01:27:43,820 --> 01:27:49,850
清晰现在注意到我的主要内容 

2227
01:27:46,550 --> 01:27:53,720
先做，然后分配一个 

2228
01:27:49,850 --> 01:27:56,060
最初没有空间的 数组 所以这是 

2229
01:27:53,720 --> 01:27:58,100
就像当 我在第一时间举起来的那样 

2230
01:27:56,060 --> 01:28:00,110
代表我们数据的开头

2231
01:27:58,100 --> 01:28:02,300
结构，这 是 使用模拟 

2232
01:28:00,110 --> 01:28:03,830
将那张纸片排成一列 

2233
01:28:02,300 --> 01:28:05,840
在这里举行将是数字和 

2234
01:28:03,830 --> 01:28:07,700
它只是指着什么都没有

2235
01:28:05,840 --> 01:28:10,190
左手放在地板上， 因为 

2236
01:28:07,700 --> 01:28:13,430
然后没有分配内存

2237
01:28:10,190 --> 01:28:15,320
继续前进，真正继续前行 

2238
01:28:13,430 --> 01:28:18,290
来自具有此代码的用户的整数

2239
01:28:15,320 --> 01:28:22,760
这里检查用户是否按下ctrl D as 

2240
01:28:18,290 --> 01:28:25,490
用这种神秘的技术，然后我们的 

2241
01:28:22,760 --> 01:28:27,980
代码在精神上是相似的，但我们必须这样做 

2242
01:28:25,490 --> 01:28:30,260
把这些东西缝在一起分配 

2243
01:28:27,980 --> 01:28:31,700
在数字空间，所以当我是一个loc'd 

2244
01:28:30,260 --> 01:28:33,590
另外一名志愿者

2245
01:28:31,700 --> 01:28:36,560
观众和他或她来了 

2246
01:28:33,590 --> 01:28:39,680
相当于代码是这台嘿电脑 

2247
01:28:36,560 --> 01:28:42,830
与马利克足够的空间， 以适应大小 

2248
01:28:39,680 --> 01:28:45,830
然后，节点将结果存储在a中

2249
01:28:42,830 --> 01:28:48,590
指针叫n，所以节点星n正好 

2250
01:28:45,830 --> 01:28:50,660
意味着给 我一个指向节点调用的指针 

2251
01:28:48,590 --> 01:28:52,490
它并存储 刚才 的地址 

2252
01:28:50,660 --> 01:28:54,470
像以前一样从观众那里分配

2253
01:28:52,490 --> 01:28:55,970
为什么我 在这里 有这些代码行 

2254
01:28:54,470 --> 01:29:05,540
我已经 用蓝色 高亮显示 

2255
01:28:55,970 --> 01:29:07,460
什么是表达是爆炸N或如果 

2256
01:29:05,540 --> 01:29:16,850
不是你会发音的方式 

2257
01:29:07,460 --> 01:29:18,260
究竟发生了什么 事实 并非如此 

2258
01:29:16,850 --> 01:29:19,880
会经常发生，但如果

2259
01:29:18,260 --> 01:29:22,130
计算机内存 不足 ， 因此 

2260
01:29:19,880 --> 01:29:24,020
malloc失败你不想要程序 

2261
01:29:22,130 --> 01:29:25,670
只是为了担心崩溃或像所有人一样冻结 

2262
01:29:24,020 --> 01:29:29,140
我们讨厌在Mac OS或者Mac OS上发生这种情况 

2263
01:29:25,670 --> 01:29:31,820
如果不是N或者 Windows ，请检查它 

2264
01:29:29,140 --> 01:29:34,520
等价， 如果 n等于null 

2265
01:29:31,820 --> 01:29:36,170
只返回 1优雅地退出 

2266
01:29:34,520 --> 01:29:38,000
虽然烦人但不只是崩溃 

2267
01:29:36,170 --> 01:29:41,900
或做一些意想不到的事情 ，你可以 

2268
01:29:38,000 --> 01:29:45,050
简化检查，如果不是n if 

2269
01:29:41,900 --> 01:29:47,840
n现在不是有效的指针返回1 

2270
01:29:45,050 --> 01:29:49,460
这是我们的代码

2271
01:29:47,840 --> 01:29:51,290
用我们的方式实施示范 

2272
01:29:49,460 --> 01:29:52,850
人类，这是最可怕的 期待 

2273
01:29:51,290 --> 01:29:56,420
或者至少看起来很神秘的代码

2274
01:29:52,850 --> 01:29:58,790
我们今天要在C中说是我们的决赛 

2275
01:29:56,420 --> 01:30:00,740
天在看到排序我们的 过 

2276
01:29:58,790 --> 01:30:02,270
最近跑了一座非常陡峭的山坡 

2277
01:30:00,740 --> 01:30:04,790
了解内存和现在的数据 

2278
01:30:02,270 --> 01:30:08,360
结构和语法是我们的最后一个 

2279
01:30:04,790 --> 01:30:11,180
C语法中的符号是什么？ 

2280
01:30:08,360 --> 01:30:14,210
要知道 这行代码 是 在这里 

2281
01:30:11,180 --> 01:30:16,850
我是如何交给我们的一名志愿者的

2282
01:30:14,210 --> 01:30:19,670
右边的那张纸是 

2283
01:30:16,850 --> 01:30:21,860
输入的数字是55或5或 

2284
01:30:19,670 --> 01:30:23,690
20或左边的任何值 

2285
01:30:21,860 --> 01:30:27,980
手边是你想要的地方 

2286
01:30:23,690 --> 01:30:32,090
然后字面意思 是 箭头数字 

2287
01:30:27,980 --> 01:30:35,060
这对于malloc来说是一个 先前 的 衬垫 

2288
01:30:32,090 --> 01:30:37,730
在记忆中给我的 只是其中一个 

2289
01:30:35,060 --> 01:30:40,640
矩形，再次在这个顶部 

2290
01:30:37,730 --> 01:30:42,590
这个例子叫做数字和 

2291
01:30:40,640 --> 01:30:44,420
底部被称为下一个， 所以 这是我们的 

2292
01:30:42,590 --> 01:30:46,820
已经从 后面 站起来的人

2293
01:30:44,420 --> 01:30:49,940
当我把那个人交给一个号码的时候

2294
01:30:46,820 --> 01:30:51,469
像55一样在视觉上去那里 

2295
01:30:49,940 --> 01:30:54,800
你实现这一目标的代码行 

2296
01:30:51,469 --> 01:30:58,370
今年 是因为 第31行的通知 

2297
01:30:54,800 --> 01:31:01,730
这里 当 我是 我存储的那个节点的地方 

2298
01:30:58,370 --> 01:31:04,340
它在一个名为 n和的变量中的地址

2299
01:31:01,730 --> 01:31:06,770
这是一个用箭头绘制的指针

2300
01:31:04,340 --> 01:31:08,570
到那个大 节点或者我们真的想要 

2301
01:31:06,770 --> 01:31:10,370
如果这是地址100，那就太挑剔了

2302
01:31:08,570 --> 01:31:12,500
是的然后指针实际上有 

2303
01:31:10,370 --> 01:31:14,270
价值100，但很少 

2304
01:31:12,500 --> 01:31:18,020
有用的信息所以我们可以抽象 

2305
01:31:14,270 --> 01:31:20,650
因为只有箭头所以31号线就是 

2306
01:31:18,020 --> 01:31:25,250
什么在屏幕上创建这些框

2307
01:31:20,650 --> 01:31:27,730
第38行是将 数字作为数字 

2308
01:31:25,250 --> 01:31:29,930
实例55 进入框中 

2309
01:31:27,730 --> 01:31:33,199
正是很像我递给一张 

2310
01:31:29,930 --> 01:31:35,870
纸翻 所以这是什么，这 是 

2311
01:31:33,199 --> 01:31:37,370
尽管今天只是真正的新记谱 

2312
01:31:35,870 --> 01:31:41,360
我们在其他地方使用了很多明星 

2313
01:31:37,370 --> 01:31:43,219
箭头这是第一次奇妙 

2314
01:31:41,360 --> 01:31:45,860
在看到它实际上映射到我们的照片 

2315
01:31:43,219 --> 01:31:48,110
如果n是变量，你做n箭头 

2316
01:31:45,860 --> 01:31:49,460
这意味着遵循箭头

2317
01:31:48,110 --> 01:31:51,410
如果你有点像滑槽和梯子

2318
01:31:49,460 --> 01:31:53,870
从小就玩，然后把它 

2319
01:31:51,410 --> 01:31:58,360
箭头引导你进入的数字 

2320
01:31:53,870 --> 01:32:00,500
这个字段叫做数字而不是一边 

2321
01:31:58,360 --> 01:32:03,350
我们可以 用不同的方式 思考 这个问题 

2322
01:32:00,500 --> 01:32:10,040
是什么数据类型是什么东西 

2323
01:32:03,350 --> 01:32:12,080
在蓝色n它是一个指针，它是一个 

2324
01:32:10,040 --> 01:32:13,430
指向我们这些事情之一 

2325
01:32:12,080 --> 01:32:15,170
早些时候创建， 所以我们没有做 

2326
01:32:13,430 --> 01:32:17,000
我们的结构已经是学生了

2327
01:32:15,170 --> 01:32:19,430
我们正在实现具有的节点 

2328
01:32:17,000 --> 01:32:22,699
数字和下一个指针，所以它转 

2329
01:32:19,430 --> 01:32:25,160
如果n是节点或n是a 

2330
01:32:22,699 --> 01:32:28,190
指向节点的指针调用该点 

2331
01:32:25,160 --> 01:32:30,050
从此之前的符号不是你的方式 

2332
01:32:28,190 --> 01:32:32,330
在这种 情况下 访问号码， 因为 n是 

2333
01:32:30,050 --> 01:32:34,910
不是节点本身它是指针但是如果 

2334
01:32:32,330 --> 01:32:37,219
n是一个指针，你怎么去一个 

2335
01:32:34,910 --> 01:32:41,270
指针你怎么去一个地址 

2336
01:32:37,219 --> 01:32:44,390
什么符号明星如此回忆起来 

2337
01:32:41,270 --> 01:32:46,160
一周，如果我们想去你 的地址 

2338
01:32:44,390 --> 01:32:47,870
可以做这样的语法 忽略 

2339
01:32:46,160 --> 01:32:49,910
括号一会儿就是明星 

2340
01:32:47,870 --> 01:32:52,730
表示n是否是一个 块的 地址 

2341
01:32:49,910 --> 01:32:54,620
记忆明星n意味着 一旦你 去了那里 

2342
01:32:52,730 --> 01:32:56,810
你在概念上是正确的

2343
01:32:54,620 --> 01:32:58,790
这里左上角你好吗？ 

2344
01:32:56,810 --> 01:33:01,850
访问个别字段，如数字或

2345
01:32:58,790 --> 01:33:03,800
接下来你使用点符号，如果你 

2346
01:33:01,850 --> 01:33:06,380
从字面上做明星ñ 

2347
01:33:03,800 --> 01:33:10,040
点 号表示转到该地址 

2348
01:33:06,380 --> 01:33:12,440
并访问数字字段很好 

2349
01:33:10,040 --> 01:33:14,690
C中的语法糖只是一种 

2350
01:33:12,440 --> 01:33:16,940
用 速记符号表达的 奇特方式 

2351
01:33:14,690 --> 01:33:18,590
这是箭头， 但就是这样 

2352
01:33:16,940 --> 01:33:21,860
这个箭头表示法没有做任何事情

2353
01:33:18,590 --> 01:33:24,530
新的它只是结合去那里 

2354
01:33:21,860 --> 01:33:26,810
访问结构中的一个字段 

2355
01:33:24,530 --> 01:33:28,790
如果你愿意，这就是呼吸

2356
01:33:26,810 --> 01:33:30,950
当我告诉时，这看起来有点漂亮

2357
01:33:28,790 --> 01:33:32,750
我们的志愿者早先指出了你的手 

2358
01:33:30,950 --> 01:33:35,330
所有这一切都在地板上 

2359
01:33:32,750 --> 01:33:38,000
代码正在做它说的 结束 

2360
01:33:35,330 --> 01:33:40,580
这里的地址访问下一个 

2361
01:33:38,000 --> 01:33:43,400
字段并 在该字段中写入 null 

2362
01:33:40,580 --> 01:33:45,110
只是默认的地址 0 

2363
01:33:43,400 --> 01:33:48,230
特别 地址就像指着 

2364
01:33:45,110 --> 01:33:50,600
这行代码40只是一个 

2365
01:33:48,230 --> 01:33:52,250
快速错误检查数字是什么

2366
01:33:50,600 --> 01:33:54,500
相当于那个实际上只是 

2367
01:33:52,250 --> 01:33:57,230
说如果数字不等于null，那么如果 

2368
01:33:54,500 --> 01:33:59,630
如果malloc 有效，则数字是合法的

2369
01:33:57,230 --> 01:34:04,190
正确然后让我们继续 前进 

2370
01:33:59,630 --> 01:34:06,950
接下来这 是一个满口 是什么 

2371
01:34:04,190 --> 01:34:09,500
继续这里，所以这是一个for 循环 

2372
01:34:06,950 --> 01:34:11,390
这不是很好地使用数字或是它 

2373
01:34:09,500 --> 01:34:13,310
我们写的几乎每一个循环 

2374
01:34:11,390 --> 01:34:16,820
你可能写的只是使用IJ 

2375
01:34:13,310 --> 01:34:18,890
也许是K，但可能只是整数 

2376
01:34:16,820 --> 01:34:20,600
不一定是这样的 情况 

2377
01:34:18,890 --> 01:34:26,000
一个指针它是一个地址是什么 

2378
01:34:20,600 --> 01:34:27,710
在内存或 数字中寻址一个地方 

2379
01:34:26,000 --> 01:34:29,570
真的，你当然可以使用 

2380
01:34:27,710 --> 01:34:32,330
循环只涉及地址，但如何

2381
01:34:29,570 --> 01:34:34,820
所以我们会考虑这行代码 

2382
01:34:32,330 --> 01:34:36,560
今天看起来不一样但是它 

2383
01:34:34,820 --> 01:34:38,060
在第一个分号之前的一切

2384
01:34:36,560 --> 01:34:41,390
这就是你初始化一个值的地方 

2385
01:34:38,060 --> 01:34:44,660
所以这就像说嘿电脑 去吧 

2386
01:34:41,390 --> 01:34:49,180
提前给 我一个 叫做PTR 的变量 

2387
01:34:44,660 --> 01:34:54,050
并初始化 它是 开始我 

2388
01:34:49,180 --> 01:34:55,790
列表然后我说嘿电脑做 

2389
01:34:54,050 --> 01:34:58,610
这只要指针不相等

2390
01:34:55,790 --> 01:35:01,700
null然后我在做什么

2391
01:34:58,610 --> 01:35:07,730
如果我们 现在 忽略它 是一个 

2392
01:35:01,700 --> 01:35:10,450
错误检查继续，抱歉让 我 

2393
01:35:07,730 --> 01:35:10,450
想一秒钟 

2394
01:35:12,310 --> 01:35:20,230
如果可以的话， 让我们这样做是什么 

2395
01:35:17,950 --> 01:35:21,760
执行 此操作的 这些 代码 行 是 

2396
01:35:20,230 --> 01:35:23,800
实际建议的代码

2397
01:35:21,760 --> 01:35:26,410
我们人类的例子就像是什么 

2398
01:35:23,800 --> 01:35:28,810
如果我们想插入 所有元素 

2399
01:35:26,410 --> 01:35:29,740
在链表的末尾你是怎么做的 

2400
01:35:28,810 --> 01:35:32,020
表达这一点 

2401
01:35:29,740 --> 01:35:34,660
所以在这个突出显示的代码行中 

2402
01:35:32,020 --> 01:35:37,660
我们问的是当前的问题 

2403
01:35:34,660 --> 01:35:40,150
指针下一个字段为null我们找到了 

2404
01:35:37,660 --> 01:35:43,180
结束继续 并更新下一个字段 

2405
01:35:40,150 --> 01:35:45,220
等于 n然后打破 所以让我 

2406
01:35:43,180 --> 01:35:47,620
将其转换为实际图片 

2407
01:35:45,220 --> 01:35:50,620
使用较小的盒子清楚 

2408
01:35:47,620 --> 01:35:52,270
事情发生的地方，所以假设 

2409
01:35:50,620 --> 01:35:54,100
这个程序一直在运行 

2410
01:35:52,270 --> 01:35:58,060
我们有一个链表 

2411
01:35:54,100 --> 01:36:00,370
这个 看起来像这个 

2412
01:35:58,060 --> 01:36:03,670
指着这里，也许是这个 

2413
01:36:00,370 --> 01:36:06,130
指着这里，这里说空了

2414
01:36:03,670 --> 01:36:11,680
这点和数字是这样的 

2415
01:36:06,130 --> 01:36:16,260
因为我们今天一直在使用4250 13所以 

2416
01:36:11,680 --> 01:36:18,520
此列表的开头称为数字

2417
01:36:16,260 --> 01:36:21,310
这指向列表的开头 

2418
01:36:18,520 --> 01:36:23,440
我到底在这做了循环 我 

2419
01:36:21,310 --> 01:36:25,480
只是实现以下逻辑

2420
01:36:23,440 --> 01:36:28,030
用这个循环给我一个 名为 的变量 

2421
01:36:25,480 --> 01:36:30,640
指针在 故事中 所代表 的 

2422
01:36:28,030 --> 01:36:33,970
就像我的左手指在这里并初始化 

2423
01:36:30,640 --> 01:36:37,720
那就是那个列表的开头 

2424
01:36:33,970 --> 01:36:43,030
节点下一指针不等于 

2425
01:36:37,720 --> 01:36:45,910
null在这里添加一个新节点， 但事实并非如此 

2426
01:36:43,030 --> 01:36:47,950
null 我想按照面包屑去做 

2427
01:36:45,910 --> 01:36:48,370
在这里 ，然后 哦我们在的结束 

2428
01:36:47,950 --> 01:36:50,710
名单

2429
01:36:48,370 --> 01:36:54,970
我想在这里插入这个新东西

2430
01:36:50,710 --> 01:37:00,820
我如何在 C中实际表达此代码

2431
01:36:54,970 --> 01:37:02,890
所以，如果 我 回头看 在 这里，这是 

2432
01:37:00,820 --> 01:37:04,870
分配我左边的代码行

2433
01:37:02,890 --> 01:37:07,330
这里的手指叫指针和 

2434
01:37:04,870 --> 01:37:08,470
将它初始化为相等的数字 

2435
01:37:07,330 --> 01:37:10,360
就像指着第一个一样 

2436
01:37:08,470 --> 01:37:12,190
元素有点像Co me 

2437
01:37:10,360 --> 01:37:15,220
代表第一次提前但现在我们的

2438
01:37:12,190 --> 01:37:18,280
数组被称为数字接下来 我是什么 

2439
01:37:15,220 --> 01:37:20,080
做的指针等于null 我们都知道 

2440
01:37:18,280 --> 01:37:21,880
如果我的左手指向这里 

2441
01:37:20,080 --> 01:37:23,980
显然不等于null所以我们不这样做

2442
01:37:21,880 --> 01:37:24,789
不得不担心 然后我想要什么 

2443
01:37:23,980 --> 01:37:27,669
做

2444
01:37:24,789 --> 01:37:29,709
如果指针下一个等于null就好了 

2445
01:37:27,669 --> 01:37:32,949
这是否 意味着井指针在这里 

2446
01:37:29,709 --> 01:37:36,249
指针箭头接下来意味着 这样做 

2447
01:37:32,949 --> 01:37:37,929
在这个故事中等于null 我的意思是 

2448
01:37:36,249 --> 01:37:39,369
从字面上看并不是因为它是空的 

2449
01:37:37,929 --> 01:37:42,699
没有写在那里null就在那里 

2450
01:37:39,369 --> 01:37:43,719
所以情况不会 如此 

2451
01:37:42,699 --> 01:37:46,929
我接下来要做什么

2452
01:37:43,719 --> 01:37:51,069
如果指针等于null 则不行 

2453
01:37:46,929 --> 01:37:52,510
应用这里是一个奇怪的更新指针得到 

2454
01:37:51,069 --> 01:37:54,999
指针下

2455
01:37:52,510 --> 01:37:57,519
所以它看起来很神秘， 但是如果 

2456
01:37:54,999 --> 01:38:00,549
指针指向这里指针是什么 

2457
01:37:57,519 --> 01:38:02,649
接下来就是这就是n 

2458
01:38:00,549 --> 01:38:06,459
这是下一个或这是数字 

2459
01:38:02,649 --> 01:38:08,079
接下来所以指针接下来是这样 的 

2460
01:38:06,459 --> 01:38:10,569
这个值 很好，这是一个指针 

2461
01:38:08,079 --> 01:38:13,959
指向此处以突出显示块 

2462
01:38:10,569 --> 01:38:18,489
代码指针等于指针下一个有

2463
01:38:13,959 --> 01:38:20,589
这样做的目的是为什么如果 

2464
01:38:18,489 --> 01:38:22,209
箭头有点太神奇了 

2465
01:38:20,589 --> 01:38:24,339
如果，请 考虑 这些问题 

2466
01:38:22,209 --> 01:38:27,549
这是说下一个地址是 

2467
01:38:24,339 --> 01:38:30,339
位置100指针等于指针下一个

2468
01:38:27,549 --> 01:38:32,709
就像说得好， 这也等于100 

2469
01:38:30,339 --> 01:38:34,839
例如 100 在这里 

2470
01:38:32,709 --> 01:38:36,879
这两个箭头现在应该指向什么

2471
01:38:34,839 --> 01:38:38,109
如果你现在重复这个过程和 

2472
01:38:36,879 --> 01:38:40,030
重复这个过程

2473
01:38:38,109 --> 01:38:42,579
最后我们问了这个问题 

2474
01:38:40,030 --> 01:38:45,309
如果指针，则 更早 应用 

2475
01:38:42,579 --> 01:38:49,719
next等于null 我想做什么 

2476
01:38:45,309 --> 01:38:52,889
好吧，如果指针next等于null那么

2477
01:38:49,719 --> 01:38:55,989
在指针旁边的两条线等于n 

2478
01:38:52,889 --> 01:38:59,049
所以指针next不再为null 

2479
01:38:55,989 --> 01:39:02,409
应该改为指向n 

2480
01:38:59,049 --> 01:39:04,239
新笔记，那就是因为 

2481
01:39:02,409 --> 01:39:06,609
这已经 初始化为null 和 

2482
01:39:04,239 --> 01:39:08,829
我们建议这是55岁，我们已经完成了 

2483
01:39:06,609 --> 01:39:10,179
显然更容易做到这一点 

2484
01:39:08,829 --> 01:39:11,709
只有人类 四处走动的人 

2485
01:39:10,179 --> 01:39:13,839
并与他们的箭头指向同 

2486
01:39:11,709 --> 01:39:15,249
他们的左手， 但 你只是 代码 

2487
01:39:13,839 --> 01:39:17,379
不得不考虑 基本建筑 

2488
01:39:15,249 --> 01:39:20,469
阻止 这些 值中的 每一个 

2489
01:39:17,379 --> 01:39:22,149
每个指向哪里和哪个 

2490
01:39:20,469 --> 01:39:24,129
您需要 更新 这些字段吗？ 

2491
01:39:22,149 --> 01:39:25,659
这是唯一的新代码 

2492
01:39:24,129 --> 01:39:27,819
我们所有种类的 结合于一体 

2493
01:39:25,659 --> 01:39:30,639
大量的例子是我们实际上 

2494
01:39:27,819 --> 01:39:33,519
使用 箭头符号 说去那 

2495
01:39:30,639 --> 01:39:35,889
在那里 寻址并 获取一些价值 

2496
01:39:33,519 --> 01:39:37,599
这个条件在这里，我会 

2497
01:39:35,889 --> 01:39:38,740
挥手示意现在只是处理 

2498
01:39:37,599 --> 01:39:43,150
Liss 的情况 

2499
01:39:38,740 --> 01:39:46,420
最初是空 的任何 疑问 

2500
01:39:43,150 --> 01:39:50,860
到目前为止还可以 

2501
01:39:46,420 --> 01:39:52,810
所以让我们以图形方式来看看

2502
01:39:50,860 --> 01:39:55,120
我们可以解决一些问题，最终和 

2503
01:39:52,810 --> 01:39:56,740
你将在未来的日子里看到什么 

2504
01:39:55,120 --> 01:39:58,870
当谈到这些 以下 

2505
01:39:56,740 --> 01:40:01,000
链接列表和我们现在有更多 

2506
01:39:58,870 --> 01:40:02,410
实际分配内容的能力 

2507
01:40:01,000 --> 01:40:04,030
动态记忆我们不一定

2508
01:40:02,410 --> 01:40:05,560
事先知道我们有多少号码 

2509
01:40:04,030 --> 01:40:07,330
或者在下一个问题的情况下说 

2510
01:40:05,560 --> 01:40:08,920
我们有多少单词 

2511
01:40:07,330 --> 01:40:11,380
虽然能够使用malloc 而且可能 

2512
01:40:08,920 --> 01:40:12,910
甚至realloc来增长和发展我们的数据 

2513
01:40:11,380 --> 01:40:14,980
记忆中的结构，我们有 

2514
01:40:12,910 --> 01:40:17,470
代码 实际遍历的能力

2515
01:40:14,980 --> 01:40:19,420
这些价值观我们可以这样做 

2516
01:40:17,470 --> 01:40:21,790
存取存储器这一切都在 板 

2517
01:40:19,420 --> 01:40:23,590
现在并不一定要背靠背 

2518
01:40:21,790 --> 01:40:26,050
回来但如果 我们想要 发生什么 

2519
01:40:23,590 --> 01:40:28,390
将这些想法结合到一起 

2520
01:40:26,050 --> 01:40:32,650
解决方案仍然很好看看

2521
01:40:28,390 --> 01:40:35,560
特别是如果我继续说的话 

2522
01:40:32,650 --> 01:40:38,080
在 这里，以下是让我们的 

2523
01:40:35,560 --> 01:40:40,030
考虑一下我们现在可以解决的问题 

2524
01:40:38,080 --> 01:40:44,140
我在此想商店每个人的名字

2525
01:40:40,030 --> 01:40:46,630
数据结构中的房间我可以做什么 

2526
01:40:44,140 --> 01:40:48,220
好吧， 我们可以使用阵列， 所以我可以 

2527
01:40:46,630 --> 01:40:49,630
实际上它决定了多少人 

2528
01:40:48,220 --> 01:40:51,910
在房间里让我们打电话给和 

2529
01:40:49,630 --> 01:40:53,350
实际上在板上 画 端盒 

2530
01:40:51,910 --> 01:40:55,630
然后迭代地问每个人 他们的 

2531
01:40:53,350 --> 01:40:57,700
名字， 如果我 ，实际上写下来

2532
01:40:55,630 --> 01:40:59,470
当时就想好好听讲 和 

2533
01:40:57,700 --> 01:41:01,480
他们在 追求并说爱丽丝在这里哦 

2534
01:40:59,470 --> 01:41:03,310
或鲍勃在这里或是卡里姆在这里或 

2535
01:41:01,480 --> 01:41:05,620
布莱恩我可以看看通过 

2536
01:41:03,310 --> 01:41:07,060
数组并 说是或否是人类 

2537
01:41:05,620 --> 01:41:09,400
在这里，但什么 的 的运行时间 

2538
01:41:07,060 --> 01:41:11,770
算法需要 多长时间 才能 看出来 

2539
01:41:09,400 --> 01:41:13,360
我所在 的数据结构 中的名称

2540
01:41:11,770 --> 01:41:17,350
刚刚绘制它作为一个数组的大名单 上 

2541
01:41:13,360 --> 01:41:18,550
董事会是什么，这是一个大的权利 

2542
01:41:17,350 --> 01:41:20,110
因为如果它只是一个 名称 列表 

2543
01:41:18,550 --> 01:41:22,810
这将是N的大O 和坦率地说 

2544
01:41:20,110 --> 01:41:24,190
这看起来有点慢 我怎么办 

2545
01:41:22,810 --> 01:41:25,990
优化

2546
01:41:24,190 --> 01:41:27,790
那么如果我们将其中一些结合起来呢？ 

2547
01:41:25,990 --> 01:41:30,400
想法数组很好，因为他们给 

2548
01:41:27,790 --> 01:41:32,260
我随机排序即时访问 

2549
01:41:30,400 --> 01:41:33,640
内存位置，但链接列表 

2550
01:41:32,260 --> 01:41:36,100
很好， 因为他们允许我 

2551
01:41:33,640 --> 01:41:38,800
动态添加或减少元素 

2552
01:41:36,100 --> 01:41:40,660
即使我想从 列表中 得到你知道的 

2553
01:41:38,800 --> 01:41:44,680
什么而不是写下每个人的 

2554
01:41:40,660 --> 01:41:48,850
爱丽丝，鲍勃和查理等名字

2555
01:41:44,680 --> 01:41:51,010
像这样只有一大部分 

2556
01:41:48,850 --> 01:41:53,680
固定大小 

2557
01:41:51,010 --> 01:41:55,570
现在我只需要进入一个角落

2558
01:41:53,680 --> 01:41:57,610
如果我，还有 一个 名字的 空间 

2559
01:41:55,570 --> 01:41:59,050
而是更 聪明地 做事情 

2560
01:41:57,610 --> 01:42:01,330
所以当我实际记下来的时候 

2561
01:41:59,050 --> 01:42:04,690
我 在房间里的每个人的名字怎么样？ 

2562
01:42:01,330 --> 01:42:07,990
反而没有好是 爱丽丝这里 好吗 

2563
01:42:04,690 --> 01:42:09,670
爱丽丝在这儿，然后 布莱恩在这里， 我 

2564
01:42:07,990 --> 01:42:13,170
将布莱恩放在这里，然后也许 

2565
01:42:09,670 --> 01:42:16,720
查理在这里很好，所以 查理和 

2566
01:42:13,170 --> 01:42:18,850
那么也许阿诺德在这里应该在哪里 

2567
01:42:16,720 --> 01:42:21,450
把阿诺德这样也从你开始

2568
01:42:18,850 --> 01:42:24,880
知道是什么让我们把阿诺德放在这里 

2569
01:42:21,450 --> 01:42:26,260
阿诺德，我们走吧，修道院就 在这里 

2570
01:42:24,880 --> 01:42:29,920
你知道让我们放弃Abby的原因 

2571
01:42:26,260 --> 01:42:31,030
鲍勃也是如此，鲍勃也是如此 

2572
01:42:29,920 --> 01:42:32,950
我 显然 是什么样的模式

2573
01:42:31,030 --> 01:42:38,740
以下是我听到名字叫 

2574
01:42:32,950 --> 01:42:40,930
按字母顺序排序的类似a 

2575
01:42:38,740 --> 01:42:42,850
B有点 在怪异的地方结束了 

2576
01:42:40,930 --> 01:42:45,040
这里很好，因为我没有 

2577
01:42:42,850 --> 01:42:47,830
先听到她的名字， 但我确实做到了 

2578
01:42:45,040 --> 01:42:49,870
桶眼睛的人在两个不同的行 

2579
01:42:47,830 --> 01:42:51,700
换句话说，所有 的a 

2580
01:42:49,870 --> 01:42:53,320
我似乎只是写下来的名字

2581
01:42:51,700 --> 01:42:54,820
顶部便利，然后全部 

2582
01:42:53,320 --> 01:42:56,080
B一起命名和C名称和 

2583
01:42:54,820 --> 01:42:57,340
可能如果我继续前进 我可以 做到这一点 

2584
01:42:56,080 --> 01:42:59,470
通过 在英语字母z 一路 

2585
01:42:57,340 --> 01:43:01,900
这是 多么 好的字母表

2586
01:42:59,470 --> 01:43:03,970
是的，我正在制作 名单但是 

2587
01:43:01,900 --> 01:43:06,370
多久是 每个名单如果 

2588
01:43:03,970 --> 01:43:08,590
我 房间里 每个人都有人

2589
01:43:06,370 --> 01:43:10,630
列表不会长，哪个

2590
01:43:08,590 --> 01:43:15,490
很慢，它将成为什么和 

2591
01:43:10,630 --> 01:43:16,480
如果我们 假设，除以26给予或接受 

2592
01:43:15,490 --> 01:43:18,220
有相同数量的人 

2593
01:43:16,480 --> 01:43:20,830
以Z的名称和名字这 将 

2594
01:43:18,220 --> 01:43:22,690
大致n除以26，这样我 

2595
01:43:20,830 --> 01:43:24,640
有这些像人类的名字链 

2596
01:43:22,690 --> 01:43:25,990
但他们比他们要短得多 

2597
01:43:24,640 --> 01:43:27,910
如果我只是把每个人都分组了 

2598
01:43:25,990 --> 01:43:30,310
这是一个根本 

2599
01:43:27,910 --> 01:43:32,590
编程技术叫做

2600
01:43:30,310 --> 01:43:34,630
哈希它发现有东西在里面 

2601
01:43:32,590 --> 01:43:37,720
这个世界称哈希函数为这些 

2602
01:43:34,630 --> 01:43:39,700
只是数学或口头或代码 

2603
01:43:37,720 --> 01:43:42,120
实现了作为输入的函数

2604
01:43:39,700 --> 01:43:45,460
东西， 并作为输出产生一个数字 

2605
01:43:42,120 --> 01:43:47,590
通常是从0到25或25的数字 

2606
01:43:45,460 --> 01:43:50,170
从1到26，但他们也可以 输出 

2607
01:43:47,590 --> 01:43:52,510
在其他情况下 ， 以及 使我的琴弦

2608
01:43:50,170 --> 01:43:54,250
哈希函数在我脑海里就是你

2609
01:43:52,510 --> 01:43:56,200
递给我一个名字，我会看看 

2610
01:43:54,250 --> 01:43:58,390
你姓名的 第一个 字母， 如果是的话 

2611
01:43:56,200 --> 01:44:00,430
如果它是B，我会把你放在0号位置

2612
01:43:58,390 --> 01:44:02,680
如果是的话，我会把你放在1号位置

2613
01:44:00,430 --> 01:44:04,360
我想把你送到25号位置

2614
01:44:02,680 --> 01:44:06,040
结束所以这些都是 

2615
01:44:04,360 --> 01:44:08,230
基特，我可以用电脑说话 

2616
01:44:06,040 --> 01:44:10,300
像26 桶或房间的科学

2617
01:44:08,230 --> 01:44:12,940
代表开始的董事会

2618
01:44:10,300 --> 01:44:14,710
人们的名字 那么 好吧 

2619
01:44:12,940 --> 01:44:16,750
看起来如果我不 知道 

2620
01:44:14,710 --> 01:44:18,730
提前我有多少名字 

2621
01:44:16,750 --> 01:44:20,560
有点像把它画 成一个链接 

2622
01:44:18,730 --> 01:44:23,740
列出你将 可能只得到 

2623
01:44:20,560 --> 01:44:26,170
越来越长但我知道 我 

2624
01:44:23,740 --> 01:44:29,140
只有有限数量 的第一网 

2625
01:44:26,170 --> 01:44:31,600
字母，以便有可能画一个 

2626
01:44:29,140 --> 01:44:34,450
小杂乱有点像画画 

2627
01:44:31,600 --> 01:44:38,890
它有点像什么数据结构

2628
01:44:34,450 --> 01:44:41,680
绘制一个只有26个点的数组 

2629
01:44:38,890 --> 01:44:43,810
一个阵列的好处是我 

2630
01:44:41,680 --> 01:44:45,850
随机访问我可以跳到 右边 

2631
01:44:43,810 --> 01:44:48,250
任何字母表 中的 任何字母 

2632
01:44:45,850 --> 01:44:50,100
时间一步，一旦我到达那里， 我就是 

2633
01:44:48,250 --> 01:44:52,270
还会看到名单

2634
01:44:50,100 --> 01:44:54,790
值得庆幸的是由于链表 是 

2635
01:44:52,270 --> 01:44:57,160
列表可以是短期或长期但平均而言 

2636
01:44:54,790 --> 01:44:59,620
让我们说这将是 二十六分之一 

2637
01:44:57,160 --> 01:45:02,260
如果我这么长 

2638
01:44:59,620 --> 01:45:05,680
只使用了一个数组或一个链表 

2639
01:45:02,260 --> 01:45:07,660
所以这种 使用哈希的 技术 

2640
01:45:05,680 --> 01:45:08,350
我 再 定义为你的功能 

2641
01:45:07,660 --> 01:45:10,300
给我一个名字 

2642
01:45:08,350 --> 01:45:11,650
我把它作为输入我看第一个 

2643
01:45:10,300 --> 01:45:15,610
字母 和我返回 输出一个数字 

2644
01:45:11,650 --> 01:45:17,530
从 0到25，哈希函数 可以让你 

2645
01:45:15,610 --> 01:45:19,270
创建一个哈希表，然后就可以了 

2646
01:45:17,530 --> 01:45:20,890
实现哈希表的不同方法 

2647
01:45:19,270 --> 01:45:23,320
但也许最常见的一个是 

2648
01:45:20,890 --> 01:45:26,830
确实是这样你事先决定 

2649
01:45:23,320 --> 01:45:28,810
关于数组的大小，但该数组 

2650
01:45:26,830 --> 01:45:31,090
不包含字符串或 

2651
01:45:28,810 --> 01:45:34,660
人类 实际上将该数组 命名 

2652
01:45:31,090 --> 01:45:37,300
包含链接列表， 它是 

2653
01:45:34,660 --> 01:45:39,100
包含名称的链接列表

2654
01:45:37,300 --> 01:45:40,990
我们从第二周开始借用我们的想法 

2655
01:45:39,100 --> 01:45:43,030
从星期开始将它们与想法合并

2656
01:45:40,990 --> 01:45:45,220
将加注添加到链表中的四个

2657
01:45:43,030 --> 01:45:47,020
我们分别得到 了最好的 

2658
01:45:45,220 --> 01:45:48,940
两个世界 因为 我可以立即 

2659
01:45:47,020 --> 01:45:51,100
跳到字母表中的任何字母超级 

2660
01:45:48,940 --> 01:45:52,780
快 ，一旦我在那里，是的，有一个 

2661
01:45:51,100 --> 01:45:54,100
列表，但它不会那么长 

2662
01:45:52,780 --> 01:45:57,100
如果我没有使用它，本来可以 

2663
01:45:54,100 --> 01:45:59,770
这就是 所有人 的运行 时间 

2664
01:45:57,100 --> 01:46:01,960
这很好，事实证明，哈希 

2665
01:45:59,770 --> 01:46:03,640
在最坏的情况下表可能仍然需要 

2666
01:46:01,960 --> 01:46:05,080
你 找 了多少 步骤 

2667
01:46:03,640 --> 01:46:07,600
名称一旦被添加到 列表中 

2668
01:46:05,080 --> 01:46:11,910
最糟糕 的 情况下，有多少步骤，如果 

2669
01:46:07,600 --> 01:46:14,440
房间里有n 个人也许是为什么 

2670
01:46:11,910 --> 01:46:16,440
这是一种不正常的情况但是 

2671
01:46:14,440 --> 01:46:17,630
你能设想一个场景吗？ 

2672
01:46:16,440 --> 01:46:18,980
即使

2673
01:46:17,630 --> 01:46:20,990
我们仍然在做这种幻想 

2674
01:46:18,980 --> 01:46:23,930
我采取了步骤来确认或否认这一点 

2675
01:46:20,990 --> 01:46:25,430
有人在这里是的，每个人的名字

2676
01:46:23,930 --> 01:46:27,500
一些人用相同的字母开头 

2677
01:46:25,430 --> 01:46:28,910
奇怪的原因现在有点 傻了 

2678
01:46:27,500 --> 01:46:30,470
人类世界， 但如果 

2679
01:46:28,910 --> 01:46:32,450
你只是在说数据或 其他什么 

2680
01:46:30,470 --> 01:46:35,660
在计算机世界中， 这可以 

2681
01:46:32,450 --> 01:46:38,030
只用一个就可以放入数组中 

2682
01:46:35,660 --> 01:46:40,460
真的很长的链表 但在实践中 

2683
01:46:38,030 --> 01:46:41,720
如果这不太可能发生 

2684
01:46:40,460 --> 01:46:42,980
我们实际花费的时间在这里 和 

2685
01:46:41,720 --> 01:46:44,960
问大家 我们 的名字 

2686
01:46:42,980 --> 01:46:47,300
可能会得到一个相当统一的

2687
01:46:44,960 --> 01:46:49,070
信件的分发至少如同 

2688
01:46:47,300 --> 01:46:50,660
在统计上可能只有人类 

2689
01:46:49,070 --> 01:46:52,250
名称， 以便 传播 

2690
01:46:50,660 --> 01:46:54,170
事情出来，所以就是这样 

2691
01:46:52,250 --> 01:46:56,510
排序 之间 的 根本区别 

2692
01:46:54,170 --> 01:46:58,010
现实世界的运行 时间或挂钟 

2693
01:46:56,510 --> 01:47:00,170
实际上是多少秒 

2694
01:46:58,010 --> 01:47:01,340
在 时钟 上旋转与渐近 

2695
01:47:00,170 --> 01:47:02,810
我们谈过一对夫妇的运行时间

2696
01:47:01,340 --> 01:47:05,810
周现在大约运行时间 为 

2697
01:47:02,810 --> 01:47:08,210
N个 大O 和 可能仍然是 

2698
01:47:05,810 --> 01:47:10,130
最糟糕的情况是哈希表是的 

2699
01:47:08,210 --> 01:47:11,360
它仍然是n数据的大O. 

2700
01:47:10,130 --> 01:47:13,820
结构，因为在最坏的情况下它是 

2701
01:47:11,360 --> 01:47:17,510
要在现实世界中采取n步骤 

2702
01:47:13,820 --> 01:47:19,730
n的大O真的很大 

2703
01:47:17,510 --> 01:47:22,040
虽然我们总是忽略那些，但到了26岁 

2704
01:47:19,730 --> 01:47:24,260
低阶条款， 但是当它是你的时候 

2705
01:47:22,040 --> 01:47:28,310
人类运行代码并分析 

2706
01:47:24,260 --> 01:47:30,620
实际上运行速度快26倍的数据

2707
01:47:28,310 --> 01:47:32,300
实时节省即使 一个 

2708
01:47:30,620 --> 01:47:34,340
数学家可能会说 是的这就是 

2709
01:47:32,300 --> 01:47:36,350
同样从根本上确实 是一个

2710
01:47:34,340 --> 01:47:38,750
下一个问题 集 的未来问题 

2711
01:47:36,350 --> 01:47:40,340
将要完全是什么 

2712
01:47:38,750 --> 01:47:43,160
影响在你自己的代码中 

2713
01:47:40,340 --> 01:47:45,260
对于实际的挂钟运行时间和 

2714
01:47:43,160 --> 01:47:47,150
为这样的决策制定更聪明的设计

2715
01:47:45,260 --> 01:47:49,220
这样的事实上真的 可以 

2716
01:47:47,150 --> 01:47:51,200
将你的代码加速为26倍 

2717
01:47:49,220 --> 01:47:53,410
虽然是理论家，但速度很快

2718
01:47:51,200 --> 01:47:55,580
会说AB，但那仍然是 

2719
01:47:53,410 --> 01:47:58,100
渐近或数学上

2720
01:47:55,580 --> 01:47:59,450
相当于线性的东西

2721
01:47:58,100 --> 01:48:01,670
正是这种微调才能让你的 

2722
01:47:59,450 --> 01:48:03,680
坦率地说，代码甚至更好，更好 

2723
01:48:01,670 --> 01:48:05,630
对名字进行哈希可能不是 

2724
01:48:03,680 --> 01:48:07,250
像这样最聪明的事情 

2725
01:48:05,630 --> 01:48:10,280
没有人会这很难 

2726
01:48:07,250 --> 01:48:13,850
特别是它的名字开始了 

2727
01:48:10,280 --> 01:48:15,650
Z在这里 紫罗兰不在这里，但谢谢 

2728
01:48:13,850 --> 01:48:17,810
你是那个 完美的反例但是 

2729
01:48:15,650 --> 01:48:20,240
她不在这里所以看看那里没有Z 

2730
01:48:17,810 --> 01:48:21,530
现在我们已经达到 25个可能的值了 

2731
01:48:20,240 --> 01:48:22,910
我可能会选择一些不常见的东西 

2732
01:48:21,530 --> 01:48:24,530
字母也是如此 

2733
01:48:22,910 --> 01:48:26,420
可能 比现有的更多 

2734
01:48:24,530 --> 01:48:28,520
Z或者还有几只蜜蜂 

2735
01:48:26,420 --> 01:48:30,470
根据人名 的性质排队 

2736
01:48:28,520 --> 01:48:31,220
所以也许只选择第一个字母 

2737
01:48:30,470 --> 01:48:33,950
不好 

2738
01:48:31,220 --> 01:48:35,630
坦率地说，有二十六个 名字 

2739
01:48:33,950 --> 01:48:37,460
假设我们为哈佛 所有人做过这件事

2740
01:48:35,630 --> 01:48:39,110
并有名字的数千 我 的每一个 

2741
01:48:37,460 --> 01:48:41,120
链可能仍然有数百或 

2742
01:48:39,110 --> 01:48:42,680
成千上万的名字是 另一种设计 

2743
01:48:41,120 --> 01:48:44,480
问题将 是 好多少 

2744
01:48:42,680 --> 01:48:46,130
你应该有多大的桶 

2745
01:48:44,480 --> 01:48:47,630
也许你不应该看看阵列 

2746
01:48:46,130 --> 01:48:49,520
第一个字母 ，如果你看看 

2747
01:48:47,630 --> 01:48:52,580
第一个和第二个字母在一起 

2748
01:48:49,520 --> 01:48:56,120
aa和B和C 然后点点 

2749
01:48:52,580 --> 01:48:58,040
B ABC BBC 所以你可以拿出 更多 

2750
01:48:56,120 --> 01:49:01,070
还有更多的桶，但还有什么 其他的 

2751
01:48:58,040 --> 01:49:02,810
我们可以统一分配

2752
01:49:01,070 --> 01:49:06,370
人们， 你们所有人都拥有我们 

2753
01:49:02,810 --> 01:49:06,370
可以用作哈希函数的输入

2754
01:49:06,460 --> 01:49:09,980
好吧，你可以做什么姓氏哪个 

2755
01:49:08,570 --> 01:49:13,970
可能会给我们一个不同的或类似的 

2756
01:49:09,980 --> 01:49:15,560
分配是 的，你能做什么 

2757
01:49:13,970 --> 01:49:17,390
用你的身份证号码， 实际上看 

2758
01:49:15,560 --> 01:49:20,420
你的身份证 和赔率 的第一位数字 是 

2759
01:49:17,390 --> 01:49:22,130
在 0到9 所以我们可能在 

2760
01:49:20,420 --> 01:49:24,110
至少得到10桶这样的，那就是 

2761
01:49:22,130 --> 01:49:26,900
可能是均匀分布我不是 

2762
01:49:24,110 --> 01:49:28,550
我们确定可以使用出生日期

2763
01:49:26,900 --> 01:49:30,200
某种方式，我们可以把所有的 

2764
01:49:28,550 --> 01:49:31,790
所有前辈都在一桶新生

2765
01:49:30,200 --> 01:49:32,990
在另一个桶和其他人和 

2766
01:49:31,790 --> 01:49:34,940
在他们自己的水桶中如此

2767
01:49:32,990 --> 01:49:37,010
也会给我们一些输入 

2768
01:49:34,940 --> 01:49:39,800
哈希函数完全取决于你 

2769
01:49:37,010 --> 01:49:41,600
程序和设计的目标虽然是 

2770
01:49:39,800 --> 01:49:43,730
你想要的 东西很顺利

2771
01:49:41,600 --> 01:49:45,920
大致相同 数量的东西 

2772
01:49:43,730 --> 01:49:48,380
每个链表只是为了你有 

2773
01:49:45,920 --> 01:49:51,410
发现大约在同样的性能 

2774
01:49:48,380 --> 01:49:52,670
所有这些不同的输入让我们这样做 

2775
01:49:51,410 --> 01:49:54,710
看看 其他 几个数据 

2776
01:49:52,670 --> 01:49:56,330
以这种抽象的方式再次构建

2777
01:49:54,710 --> 01:49:58,580
现在我们知道 即使它是 

2778
01:49:56,330 --> 01:50:00,410
在 第一次尝试时并不明显 我们知道如何 

2779
01:49:58,580 --> 01:50:02,630
构建 我们现在知道的 数组 

2780
01:50:00,410 --> 01:50:04,010
如何 构建 它所代表的 链表 

2781
01:50:02,630 --> 01:50:06,410
为什么我们可以实施它们 

2782
01:50:04,010 --> 01:50:09,140
在代码中我们还能做些什么 

2783
01:50:06,410 --> 01:50:11,120
现在有了这些构建块 

2784
01:50:09,140 --> 01:50:14,510
例如，这里的结构是非常的 

2785
01:50:11,120 --> 01:50:16,280
常见的一种叫做树的树 

2786
01:50:14,510 --> 01:50:17,660
有一位族长的家谱 

2787
01:50:16,280 --> 01:50:19,310
或者在顶部的女族长然后他们的

2788
01:50:17,660 --> 01:50:21,050
孩子，然后他们的孙子 

2789
01:50:19,310 --> 01:50:23,300
和曾孙等等 

2790
01:50:21,050 --> 01:50:25,310
树结构的好处是 

2791
01:50:23,300 --> 01:50:27,170
如果您正在存储数据，那么

2792
01:50:25,310 --> 01:50:29,930
实际上以巧妙的方式存储数据 

2793
01:50:27,170 --> 01:50:34,820
左边的 孩子到了正确的孩子和 

2794
01:50:29,930 --> 01:50:36,740
等等， 如 在此公告 如下 有 

2795
01:50:34,820 --> 01:50:39,530
对所有数字感到好奇 

2796
01:50:36,740 --> 01:50:43,060
在这个数据结构中 是什么 

2797
01:50:39,530 --> 01:50:43,060
值得注意的是他们 

2798
01:50:43,840 --> 01:50:50,090
值得注意的是，那是什么 

2799
01:50:47,510 --> 01:50:51,970
它们只是 11的倍数

2800
01:50:50,090 --> 01:50:56,480
让它们看起来很漂亮 

2801
01:50:51,970 --> 01:50:58,400
作者在这里是的，是的，有一个

2802
01:50:56,480 --> 01:51:00,620
喜欢没有的数学意义

2803
01:50:58,400 --> 01:51:03,830
无论你看到什么节点或圈子 

2804
01:51:00,620 --> 01:51:07,250
它的值比左边大 

2805
01:51:03,830 --> 01:51:09,500
孩子，它比右边小 

2806
01:51:07,250 --> 01:51:11,000
孩子所以它 介于任何 一个 之间 

2807
01:51:09,500 --> 01:51:12,170
圆你看号到 

2808
01:51:11,000 --> 01:51:13,580
左边是小，如果数到 

2809
01:51:12,170 --> 01:51:16,670
权利更大，我认为适用 

2810
01:51:13,580 --> 01:51:18,140
普遍到处都是这样的 

2811
01:51:16,670 --> 01:51:20,390
这是什么意思我们会记得 

2812
01:51:18,140 --> 01:51:23,330
就像第0周， 当我们有 一大堆 

2813
01:51:20,390 --> 01:51:25,610
像我们是电话簿的号码

2814
01:51:23,330 --> 01:51:27,710
我们正在搜索的页面1 2 3 4 5 6 

2815
01:51:25,610 --> 01:51:29,510
让我们自己 回忆起第7次 

2816
01:51:27,710 --> 01:51:31,670
当我们分裂和征服或 

2817
01:51:29,510 --> 01:51:33,650
二进制搜索我们在一个数组上做了它 

2818
01:51:31,670 --> 01:51:34,940
二进制搜索的好处是我们 

2819
01:51:33,650 --> 01:51:36,560
从中间开始，然后我们 也许 

2820
01:51:34,940 --> 01:51:37,940
走了，或者我们可能走对了，我们 

2821
01:51:36,560 --> 01:51:39,680
那种分裂，分裂和分裂 

2822
01:51:37,940 --> 01:51:42,110
并更多地克服了这个问题

2823
01:51:39,680 --> 01:51:43,850
在对数时间内有效

2824
01:51:42,110 --> 01:51:46,400
如果我们 线性地 做了就会这样 

2825
01:51:43,850 --> 01:51:49,040
但我们现在知道几周后 

2826
01:51:46,400 --> 01:51:50,930
如果我坚持的话，提出一种限制权利 

2827
01:51:49,040 --> 01:51:56,690
将所有 值存储在数组中 

2828
01:51:50,930 --> 01:51:58,760
我不能用阵列做什么呢

2829
01:51:56,690 --> 01:52:00,800
更大的权利我不能添加元素 

2830
01:51:58,760 --> 01:52:03,110
它不复制每一次缝补元素 

2831
01:52:00,800 --> 01:52:05,120
我们今天到目前为止已经讨论了但是什么 

2832
01:52:03,110 --> 01:52:06,890
如果我是一个聪明一点关于它的 什么 

2833
01:52:05,120 --> 01:52:09,200
如果我存储我的价值观不仅仅是在 

2834
01:52:06,890 --> 01:52:11,720
数组，但我开始存储它们 

2835
01:52:09,200 --> 01:52:14,120
这些圈子 让我们称它们为节点 

2836
01:52:11,720 --> 01:52:18,530
每个节点 实际上只是一个 

2837
01:52:14,120 --> 01:52:20,180
整数加两个附加值如何 

2838
01:52:18,530 --> 01:52:22,310
我们会实现 这个数据 结构吗？ 

2839
01:52:20,180 --> 01:52:24,530
在内存中这里是一个int n会 

2840
01:52:22,310 --> 01:52:26,180
代表有问题的数字和我们 

2841
01:52:24,530 --> 01:52:28,340
可以把它放在数据 结构中 

2842
01:52:26,180 --> 01:52:30,200
称为具有相同的节点 

2843
01:52:28,340 --> 01:52:32,120
语法就像今天早些时候但我离开了

2844
01:52:30,200 --> 01:52:34,760
还有两个领域的空间 是什么呢 

2845
01:52:32,120 --> 01:52:36,320
我 想在代码来表示如果我想 

2846
01:52:34,760 --> 01:52:43,510
开始存储我的数字不是在这个 旧的 

2847
01:52:36,320 --> 01:52:47,330
学校周 零 阵但在树上 两个 

2848
01:52:43,510 --> 01:52:49,580
两个指针右边是一棵树，如图所示

2849
01:52:47,330 --> 01:52:51,020
字面上用箭头就像

2850
01:52:49,580 --> 01:52:53,270
说这些节点中的每一个或 

2851
01:52:51,020 --> 01:52:55,670
圆圈有一个左边的孩子和一个右边的 

2852
01:52:53,270 --> 01:52:56,739
孩子你如何很好地实施孩子

2853
01:52:55,670 --> 01:52:59,230
你真的可以 

2854
01:52:56,739 --> 01:53:00,579
指针符号， 以及在这里 左 

2855
01:52:59,230 --> 01:53:02,739
孩子只是 指向另一个人的指针 

2856
01:53:00,579 --> 01:53:04,449
左边的结构和右边的孩子是 

2857
01:53:02,739 --> 01:53:06,570
只是指向孩子的另一个指针 

2858
01:53:04,449 --> 01:53:09,099
对，这有什么好处 

2859
01:53:06,570 --> 01:53:12,070
最终是我们现在可以遍历 

2860
01:53:09,099 --> 01:53:15,519
这棵树就像我们一样有效 

2861
01:53:12,070 --> 01:53:18,369
遍历这个数组因为 注意我是否 

2862
01:53:15,519 --> 01:53:23,199
要搜索的 号码66怎么样 

2863
01:53:18,369 --> 01:53:24,940
如果我开始，我会采取许多步骤

2864
01:53:23,199 --> 01:53:26,590
顶部就像 科米代表的那样 

2865
01:53:24,940 --> 01:53:28,269
在世界上开始我们的链表 

2866
01:53:26,590 --> 01:53:30,130
一棵树的 路线有特殊之处 

2867
01:53:28,269 --> 01:53:32,349
意义，这就是我们永远的地方 

2868
01:53:30,130 --> 01:53:35,829
开始吧我需要多少步骤 

2869
01:53:32,349 --> 01:53:38,409
找到66给出顶部看起来像 

2870
01:53:35,829 --> 01:53:40,719
是的，就像1 2或3对 我开始 

2871
01:53:38,409 --> 01:53:41,019
顶部我看 它说55我的方式 

2872
01:53:40,719 --> 01:53:43,719
走

2873
01:53:41,019 --> 01:53:44,289
我去右边然后我 说77好吧哪个 

2874
01:53:43,719 --> 01:53:46,360
我该怎么办

2875
01:53:44,289 --> 01:53:48,670
我向左走， 所以它是相同的 逻辑 

2876
01:53:46,360 --> 01:53:50,349
作为分裂和征服的第0周

2877
01:53:48,670 --> 01:53:52,929
电话簿或阵列几周 

2878
01:53:50,349 --> 01:53:55,090
稍后我们会得到我们关心的数字 

2879
01:53:52,929 --> 01:53:56,980
关于很快，它不是线性的 

2880
01:53:55,090 --> 01:53:58,780
事实上，如果我们 真的做到了 

2881
01:53:56,980 --> 01:54:00,219
数学二进制文件真的很酷 

2882
01:53:58,780 --> 01:54:02,739
搜索树就是如果你有n 

2883
01:54:00,219 --> 01:54:05,860
元件 和圆形的 ， 所述高度 

2884
01:54:02,739 --> 01:54:08,499
树根据定义以数学方式记录

2885
01:54:05,860 --> 01:54:11,139
那么树的高度就是如此 

2886
01:54:08,499 --> 01:54:13,480
恰好对应于 究竟 如何 

2887
01:54:11,139 --> 01:54:15,579
很多时候你可以 把它除掉 

2888
01:54:13,480 --> 01:54:16,780
除以二， 你分分它 

2889
01:54:15,579 --> 01:54:18,460
如果你想的话，实际上 可以 看到这个 

2890
01:54:16,780 --> 01:54:21,940
它 是底部 的反方向 

2891
01:54:18,460 --> 01:54:24,610
排有多少元素 好吧 

2892
01:54:21,940 --> 01:54:26,440
在中间一排有 两个并且在上面 

2893
01:54:24,610 --> 01:54:27,340
最上面的那一行是你可以的 

2894
01:54:26,440 --> 01:54:29,590
实际上是 在反方向 看到它 

2895
01:54:27,340 --> 01:54:31,869
这就像分而治之， 但 在一个 

2896
01:54:29,590 --> 01:54:34,659
不同的概念方式，就像它的存在一样 

2897
01:54:31,869 --> 01:54:36,969
把每一个嗡嗡声划分为每一行 

2898
01:54:34,659 --> 01:54:38,980
树的元素是一半

2899
01:54:36,969 --> 01:54:40,780
一个低于它，所以的含义 

2900
01:54:38,980 --> 01:54:42,249
就像从第 零 周 开始的那样 

2901
01:54:40,780 --> 01:54:44,559
我们分手时的电话簿

2902
01:54:42,249 --> 01:54:46,690
划分为一半 

2903
01:54:44,559 --> 01:54:48,699
一半，所以这只是说现在 

2904
01:54:46,690 --> 01:54:50,679
我们有结构和指针 

2905
01:54:48,699 --> 01:54:53,590
建立这样的东西， 但试试吧 

2906
01:54:50,679 --> 01:54:56,199
另一个例子 - 这是一个 

2907
01:54:53,590 --> 01:54:59,559
看起来很疯狂的例子，但它有点像

2908
01:54:56,199 --> 01:55:01,869
惊人的假设 ，如果我们想 

2909
01:54:59,559 --> 01:55:03,610
存储单词词典所以不是 

2910
01:55:01,869 --> 01:55:05,769
人类这次命名但是 喜欢英语 

2911
01:55:03,610 --> 01:55:07,239
所以merriam-webster 牛津英语 

2912
01:55:05,769 --> 01:55:08,679
字典就像成千上万 

2913
01:55:07,239 --> 01:55:09,840
数十万字的 这些 

2914
01:55:08,679 --> 01:55:11,820
英语天数

2915
01:55:09,840 --> 01:55:13,139
实例你如何实际存储这些 

2916
01:55:11,820 --> 01:55:13,739
还有，如果你只是查词 一 

2917
01:55:13,139 --> 01:55:15,869
字典

2918
01:55:13,739 --> 01:55:17,340
回到过去，就像那是线性的

2919
01:55:15,869 --> 01:55:19,230
就像你必须从头开始 

2920
01:55:17,340 --> 01:55:20,369
并 逐页查看 

2921
01:55:19,230 --> 01:55:21,840
对于单词或你可能是一 点点 

2922
01:55:20,369 --> 01:55:23,460
因为 任何一个词都比较聪明

2923
01:55:21,840 --> 01:55:25,830
字典有希望按字母顺序排列

2924
01:55:23,460 --> 01:55:27,360
你可以做 迈克史密斯的风格划分 

2925
01:55:25,830 --> 01:55:28,889
并打算到中间 ，然后 征服 

2926
01:55:27,360 --> 01:55:31,440
中间的中间等等 

2927
01:55:28,889 --> 01:55:33,949
如果我 告诉你你 怎么办 ？ 

2928
01:55:31,440 --> 01:55:36,810
可以在不断的时间内查找单词

2929
01:55:33,949 --> 01:55:39,030
步骤没有这 一些 固定数量 

2930
01:55:36,810 --> 01:55:41,550
划分和征服复杂性没有日志和 

2931
01:55:39,030 --> 01:55:44,699
只是你想要一个单词 去的 恒定时间 

2932
01:55:41,550 --> 01:55:46,949
立即得到它就是最后的地方 

2933
01:55:44,699 --> 01:55:49,830
结构进来，称为尝试 

2934
01:55:46,949 --> 01:55:52,110
TR 即使是检索的缩写 

2935
01:55:49,830 --> 01:55:56,909
它的发音恰恰相反， 所以试一试 

2936
01:55:52,110 --> 01:55:59,190
每个节点 都是一个数组的trie 

2937
01:55:56,909 --> 01:56:00,929
所以就像这个奇怪的弗兰肯斯坦一样

2938
01:55:59,190 --> 01:56:02,730
怪物种类的数据结构我们是

2939
01:56:00,929 --> 01:56:05,460
真的结合了很多不同的东西 

2940
01:56:02,730 --> 01:56:09,270
以下的想法和尝试的方式 

2941
01:56:05,460 --> 01:56:11,429
正如 这个部分图 所 暗示的那样 

2942
01:56:09,270 --> 01:56:14,130
董事会是，如果你想 存储 

2943
01:56:11,429 --> 01:56:16,500
在你的名字中，例如Br​​ian这个名字

2944
01:56:14,130 --> 01:56:18,960
字典作为 你做 的第一个字 

2945
01:56:16,500 --> 01:56:20,670
你是从创建一棵树开始的吗？ 

2946
01:56:18,960 --> 01:56:23,280
只有一个节点，但该节点是 

2947
01:56:20,670 --> 01:56:26,580
实际上是一个数组的 数组 

2948
01:56:23,280 --> 01:56:30,570
尺寸让我们说简单26所以A 

2949
01:56:26,580 --> 01:56:32,849
因此，通过Z这个位置

2950
01:56:30,570 --> 01:56:35,550
如果我愿意的话，我代表布莱恩的B. 

2951
01:56:32,849 --> 01:56:37,980
将Brian 插入此树 我创建一个 

2952
01:56:35,550 --> 01:56:40,230
顶部的节点， 然后是第二个节点

2953
01:56:37,980 --> 01:56:44,400
在他的名字 RI的信创造另一个 

2954
01:56:40,230 --> 01:56:47,699
节点也是一个数组a到Z等 

2955
01:56:44,400 --> 01:56:50,880
这里我在这里放了一个指向这个节点的指针 

2956
01:56:47,699 --> 01:56:57,900
BR 我，所以我应该画更多 

2957
01:56:50,880 --> 01:57:03,380
ABCD EFG HI的盒子，所以我要去 

2958
01:56:57,900 --> 01:57:05,580
绘制另一个指针为 n的 权重 

2959
01:57:03,380 --> 01:57:10,949
好吧那是错的 

2960
01:57:05,580 --> 01:57:14,820
我想念比利将是比利的名字 

2961
01:57:10,949 --> 01:57:18,780
B 重量 但 不是没有 该死的 

2962
01:57:14,820 --> 01:57:19,860
蜂蜂IFP是这 本 作品 

2963
01:57:18,780 --> 01:57:21,659
工作 好 遗憾 

2964
01:57:19,860 --> 01:57:23,550
所以我们在这里，我们将比利插入 

2965
01:57:21,659 --> 01:57:25,170
这种奇特的数据结构

2966
01:57:23,550 --> 01:57:26,820
所以第一个节点代表第一个节点

2967
01:57:25,170 --> 01:57:28,440
字母第二个节点代表 

2968
01:57:26,820 --> 01:57:30,540
第三个节点代表的第二个字母 

2969
01:57:28,440 --> 01:57:32,850
第三个字母等等 但是什么的 

2970
01:57:30,540 --> 01:57:35,160
很酷的是这样 的可重用性 

2971
01:57:32,850 --> 01:57:37,560
请注意这是第二个字母和 

2972
01:57:35,160 --> 01:57:39,570
我正确地计算了这个， 我是这样的 

2973
01:57:37,560 --> 01:57:42,870
将导致 更深入 的第三个 节点 

2974
01:57:39,570 --> 01:57:45,260
我们关心的那棵树

2975
01:57:42,870 --> 01:57:47,820
下一个，然后另一个在这里 

2976
01:57:45,260 --> 01:57:50,250
这代表 另一个L和我 

2977
01:57:47,820 --> 01:57:53,760
开始绘制字母L这是B 

2978
01:57:50,250 --> 01:57:56,420
这是我 ，我们称之为L和 

2979
01:57:53,760 --> 01:58:00,180
然后最后另一个在这里 

2980
01:57:56,420 --> 01:58:02,610
这是一个，这指向下来 

2981
01:58:00,180 --> 01:58:05,570
这里指向这里等等 

2982
01:58:02,610 --> 01:58:08,460
第四因此，在 短期，我们有一个节点 

2983
01:58:05,570 --> 01:58:10,290
基本上对于 单词中的 每个 字母 

2984
01:58:08,460 --> 01:58:12,570
我们正在插入 数据 

2985
01:58:10,290 --> 01:58:14,700
结构现在这看起来很愚蠢 

2986
01:58:12,570 --> 01:58:19,320
低效的时刻，因为到 

2987
01:58:14,700 --> 01:58:26,190
存储bi LLY 我只记得 了多少 内存 

2988
01:58:19,320 --> 01:58:29,220
使用26 加26加26加26加26 

2989
01:58:26,190 --> 01:58:31,710
只是存储我使用的五个字符26 

2990
01:58:29,220 --> 01:58:33,840
五倍， 但这是一种主题 

2991
01:58:31,710 --> 01:58:35,880
在计算机科学上多花 一点 钱 

2992
01:58:33,840 --> 01:58:37,530
我敢打赌，我可以减少空间 

2993
01:58:35,880 --> 01:58:40,530
的时间才能 找到合适的人 

2994
01:58:37,530 --> 01:58:42,480
因为现在不管其他多少 

2995
01:58:40,530 --> 01:58:44,700
学生都在这个数据结构中 

2996
01:58:42,480 --> 01:58:50,010
例如， 如果我们，让我们做另一个

2997
01:58:44,700 --> 01:58:51,720
还有一个像鲍勃这样的B就是 

2998
01:58:50,010 --> 01:58:54,210
同样的第一封信引导我们走向 

2999
01:58:51,720 --> 01:58:58,230
第二个节点o 在此处的其他位置 

3000
01:58:54,210 --> 01:59:00,720
阵列在这里说，所以这代表O. 

3001
01:58:58,230 --> 01:59:02,520
鲍勃还有另一个， 所以有 

3002
01:59:00,720 --> 01:59:04,890
将成为另一个阵列和这个

3003
01:59:02,520 --> 01:59:07,950
这就是为什么上面的图片是 这样的 

3004
01:59:04,890 --> 01:59:08,520
这么简洁，这就是我们可以存储的方式 

3005
01:59:07,950 --> 01:59:30,810
短发

3006
01:59:08,520 --> 01:59:32,370
所以bill212 dn't 犯罪 类或 

3007
01:59:30,810 --> 01:59:34,170
我们房间里有一千名学生

3008
01:59:32,370 --> 01:59:37,050
那里会有 很多 节点 

3009
01:59:34,170 --> 01:59:37,380
但是 需要多少步骤才能完成 

3010
01:59:37,050 --> 01:59:41,940
精细 

3011
01:59:37,380 --> 01:59:45,000
比利 或鲍勃或任何有此数据的名称 

3012
01:59:41,940 --> 01:59:49,140
结构并总结是或否 

3013
01:59:45,000 --> 01:59:52,440
学生在课堂上就像五个人一样 

3014
01:59:49,140 --> 01:59:55,830
四个比利 三个四个鲍勃和通知 

3015
01:59:52,440 --> 01:59:58,080
没有那个数学 有任何关系 

3016
01:59:55,830 --> 01:59:59,910
有多少 学生在 房间里 ，如果 

3017
01:59:58,080 --> 02:00:02,160
我们只好写了一个很长的名单 

3018
01:59:59,910 --> 02:00:03,570
在最坏的情况下，千名

3019
02:00:02,160 --> 02:00:05,490
可能需要我一千步才能找到 

3020
02:00:03,570 --> 02:00:06,900
比利或鲍勃也许我可能会有点 

3021
02:00:05,490 --> 02:00:09,390
如果我对它进行排序，那就更聪明了 

3022
02:00:06,900 --> 02:00:11,940
案例N 的大O 是 线性的 或者如果我使用的话 

3023
02:00:09,390 --> 02:00:13,920
之前的哈希表，也许还有 

3024
02:00:11,940 --> 02:00:15,330
房间里有一千名学生， 但没关系 

3025
02:00:13,920 --> 02:00:17,130
英语中有26个字母 

3026
02:00:15,330 --> 02:00:18,780
字母表至少是26个桶 

3027
02:00:17,130 --> 02:00:21,030
所以也许这是一个由千分26 

3028
02:00:18,780 --> 02:00:23,130
最坏的情况，如果我使用这些链

3029
02:00:21,030 --> 02:00:25,140
我的数组中的那些链接列表

3030
02:00:23,130 --> 02:00:27,420
但如果我正在使用它，请等一下 

3031
02:00:25,140 --> 02:00:30,240
结构一个尝试在哪里的每个节点 

3032
02:00:27,420 --> 02:00:33,300
树只是一个 引导我 的阵列 

3033
02:00:30,240 --> 02:00:37,110
到下一个 节点 Allah breadcrumbs BI 

3034
02:00:33,300 --> 02:00:40,500
LL Y是 五个始终五 伯 B是 

3035
02:00:37,110 --> 02:00:43,830
总是三个Bri a n本来就是 

3036
02:00:40,500 --> 02:00:47,070
五个以及这些总数中没有一个

3037
02:00:43,830 --> 02:00:48,780
任何影响或从任何影响 

3038
02:00:47,070 --> 02:00:51,630
数据中的总名称数

3039
02:00:48,780 --> 02:00:54,300
结构， 所以在 某种意义上 尝试 是这样的 

3040
02:00:51,630 --> 02:00:55,710
令人惊叹的像这个 惊人的圣杯 

3041
02:00:54,300 --> 02:00:57,780
通过组合这些各种数据 

3042
02:00:55,710 --> 02:00:59,820
结构现在你得到恒定的时间但是

3043
02:00:57,780 --> 02:01:03,500
你确实付出了代价而且要清楚 

3044
02:00:59,820 --> 02:01:05,670
什么是 我们似乎对价格进行支付 

3045
02:01:03,500 --> 02:01:07,650
记忆，事实上这就是为什么我不是 

3046
02:01:05,670 --> 02:01:09,180
因为它真的吸引了它 

3047
02:01:07,650 --> 02:01:10,980
只是 在屏幕上 变得 一团糟 

3048
02:01:09,180 --> 02:01:12,540
因为很难得出如此广泛的数据 

3049
02:01:10,980 --> 02:01:14,430
结构它需要大量的 

3050
02:01:12,540 --> 02:01:18,380
记忆，但理论上它是存在的 

3051
02:01:14,430 --> 02:01:18,380
来得更快是的问题 

3052
02:01:19,940 --> 02:01:25,730
好 问题所以它有点 像 

3053
02:01:24,380 --> 02:01:27,949
如果您同时存储两个，则简化 

3054
02:01:25,730 --> 02:01:30,020
鲍勃 和 鲍比，你真的会 保持 

3055
02:01:27,949 --> 02:01:30,980
去所以这些 元件的每不 

3056
02:01:30,020 --> 02:01:33,739
只有一个字母

3057
02:01:30,980 --> 02:01:36,020
你基本上还有一个节点

3058
02:01:33,739 --> 02:01:38,630
或其他一些数据结构，上面写着 

3059
02:01:36,020 --> 02:01:39,860
要么停在这里，要么继续，你会 

3060
02:01:38,630 --> 02:01:41,030
看到实际上在将问题

3061
02:01:39,860 --> 02:01:43,190
向你提出如何代表

3062
02:01:41,030 --> 02:01:44,989
如果你选择 走这条路 ，那个想法 

3063
02:01:43,190 --> 02:01:46,969
确实最终面临的挑战是

3064
02:01:44,989 --> 02:01:48,710
你会 喜欢 这样的东西

3065
02:01:46,969 --> 02:01:50,540
实现你自己的拼写检查 

3066
02:01:48,710 --> 02:01:51,860
我们会给你代码 ，让你 

3067
02:01:50,540 --> 02:01:53,270
从这个 过程开始，当然 

3068
02:01:51,860 --> 02:01:54,320
这些天在谷歌的拼写检查

3069
02:01:53,270 --> 02:01:56,000
文档和Microsoft Word 

3070
02:01:54,320 --> 02:01:57,739
就像红色拼写错误的下划线一样

3071
02:01:56,000 --> 02:01:59,780
但是发生了什么以及它是如何发生的 

3072
02:01:57,739 --> 02:02:01,940
该单词或Google文档可以拼写检查 

3073
02:01:59,780 --> 02:02:03,710
你的英语或其他任何语言

3074
02:02:01,940 --> 02:02:05,570
很快， 它有一本字典 

3075
02:02:03,710 --> 02:02:07,130
记忆可能有成千上万 

3076
02:02:05,570 --> 02:02:09,620
或成千上万 的单词 和 

3077
02:02:07,130 --> 02:02:11,150
他们所做的就是每一个人 

3078
02:02:09,620 --> 02:02:13,489
你输入 一个 单词并点击的时间 

3079
02:02:11,150 --> 02:02:15,440
空格键或句号或快速输入 

3080
02:02:13,489 --> 02:02:16,910
抬头看那个新单词或那些单词

3081
02:02:15,440 --> 02:02:19,670
在它的字典里说是 或 否 

3082
02:02:16,910 --> 02:02:21,380
我 应该 在下面 摆 一条红线 

3083
02:02:19,670 --> 02:02:23,360
这个词，所以我们要做的是 

3084
02:02:21,380 --> 02:02:25,580
给你一个大文本文件ASCII文本 

3085
02:02:23,360 --> 02:02:27,320
含有一百多万

3086
02:02:25,580 --> 02:02:29,480
你要决定如何做的话 

3087
02:02:27,320 --> 02:02:31,580
将它们加载到内存中不仅仅是 

3088
02:02:29,480 --> 02:02:33,650
正确但但方式很好 

3089
02:02:31,580 --> 02:02:35,630
设计，甚至会给 你一个工具 

3090
02:02:33,650 --> 02:02:37,130
如果你选择使用它的 时间如何 

3091
02:02:35,630 --> 02:02:38,930
你的代码需要很长时间，甚至 算得上 

3092
02:02:37,130 --> 02:02:40,880
你实际使用 了多少 RAM 

3093
02:02:38,930 --> 02:02:43,160
但本周和 我们的关键目标

3094
02:02:40,880 --> 02:02:45,820
C的最后一周 是采取其中的 一些 

3095
02:02:43,160 --> 02:02:49,310
数组和数据库等基本构建块 

3096
02:02:45,820 --> 02:02:51,080
指针和结构并决定 

3097
02:02:49,310 --> 02:02:53,330
你自己是多么舒服 

3098
02:02:51,080 --> 02:02:55,010
将它们拼接到一起的程度 

3099
02:02:53,330 --> 02:02:56,719
你想 真正 微调你的 代码 

3100
02:02:55,010 --> 02:02:57,920
除了让它正确 和它之外 

3101
02:02:56,719 --> 02:03:00,920
给你一个更好的感觉 

3102
02:02:57,920 --> 02:03:02,600
人们必须使用的基础代码 

3103
02:03:00,920 --> 02:03:05,239
写了多年，图书馆， 使 

3104
02:03:02,600 --> 02:03:06,350
编程是可行 的， 因为 

3105
02:03:05,239 --> 02:03:08,570
在 短短的几周内我们将要去 

3106
02:03:06,350 --> 02:03:10,010
过渡到Python和几十个 

3107
02:03:08,570 --> 02:03:12,199
你现在写的代码行

3108
02:03:10,010 --> 02:03:13,969
将被削减到一个 

3109
02:03:12,199 --> 02:03:15,260
因为我们要得到一条线

3110
02:03:13,969 --> 02:03:16,699
这些更新的功能更多

3111
02:03:15,260 --> 02:03:18,650
更高级的语言，但你希望 

3112
02:03:16,699 --> 02:03:20,780
什么是 真正的具有升值 

3113
02:03:18,650 --> 02:03:22,070
在那个引擎盖下进行，所以我会 

3114
02:03:20,780 --> 02:03:23,360
为我想要问题的任何人留下来 

3115
02:03:22,070 --> 02:03:24,739
让我们收工采取鸭您 

3116
02:03:23,360 --> 02:03:27,250
我们也会看到室友的出路

3117
02:03:24,739 --> 02:03:27,250
你 下 一次 

