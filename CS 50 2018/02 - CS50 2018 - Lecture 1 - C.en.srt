1
00:00:51,330 --> 00:00:54,630
SPEAKER 1: This is CS50,
and this is week 1.

2
00:00:54,630 --> 00:00:57,750
And by the end of the
day, you will know how

3
00:00:57,750 --> 00:01:00,610
to create programs that look like this.

4
00:01:00,610 --> 00:01:01,860
So this, of course, is binary.

5
00:01:01,860 --> 00:01:04,650
This is the only language that
machines ultimately understand.

6
00:01:04,650 --> 00:01:07,210
But thankfully, per last week,
there's so many abstractions

7
00:01:07,210 --> 00:01:10,380
and there are so many humans that have
come before us that we don't actually

8
00:01:10,380 --> 00:01:11,920
have to write anything at this level.

9
00:01:11,920 --> 00:01:14,910
We can abstract way above it
like we did with Scratch already

10
00:01:14,910 --> 00:01:17,340
and like we will starting today with C.

11
00:01:17,340 --> 00:01:19,500
But does anyone nonetheless
want to take a guess

12
00:01:19,500 --> 00:01:26,370
at what that program, when fed
to your Mac or PC, actually does?

13
00:01:26,370 --> 00:01:29,760
Anyone recognize?

14
00:01:29,760 --> 00:01:31,310
Anyone want to hazard a guess?

15
00:01:31,310 --> 00:01:34,140
It's perhaps the simplest
program you could write.

16
00:01:34,140 --> 00:01:38,380
Indeed, it does, when fed to
the brain of your computer,

17
00:01:38,380 --> 00:01:41,370
the so-called CPU simply prints that.

18
00:01:41,370 --> 00:01:43,280
So how do we actually get to that point?

19
00:01:43,280 --> 00:01:45,660
Well, recall where we started
this conversation last time

20
00:01:45,660 --> 00:01:47,530
talking about computer
science more generally

21
00:01:47,530 --> 00:01:50,460
and problem solving-- we proposed
could be distilled really is this.

22
00:01:50,460 --> 00:01:51,540
You've got some inputs.

23
00:01:51,540 --> 00:01:52,680
You want some outputs.

24
00:01:52,680 --> 00:01:55,800
And somewhere in the middle, you need
to do something with those inputs.

25
00:01:55,800 --> 00:01:59,940
And to get to that point, though, we had
to represent those inputs and outputs.

26
00:01:59,940 --> 00:02:03,630
We just had to decide as humans, how are
we going to represent all of the inputs

27
00:02:03,630 --> 00:02:07,020
to our problem when it comes time to
have a computer actually process them.

28
00:02:07,020 --> 00:02:10,230
And at the end of the day, all of the
phones and the computers that we're all

29
00:02:10,230 --> 00:02:12,960
using only at the end of
the day plug into the wall

30
00:02:12,960 --> 00:02:15,180
to get their physical
resource, electricity,

31
00:02:15,180 --> 00:02:17,460
and they might store that
temporarily in a battery.

32
00:02:17,460 --> 00:02:18,960
But that really is our only input.

33
00:02:18,960 --> 00:02:21,270
It's either plugged in or it's not.

34
00:02:21,270 --> 00:02:24,170
It's either a 1 or a 0, true or false.

35
00:02:24,170 --> 00:02:27,210
So the world really reduces to
those two states, so to speak.

36
00:02:27,210 --> 00:02:30,300
And so you can think of those states
then as just being like a light bulb,

37
00:02:30,300 --> 00:02:31,210
on or off.

38
00:02:31,210 --> 00:02:34,260
I pulled up my cell phone last time
to turn the flashlight on or off,

39
00:02:34,260 --> 00:02:36,540
1 or 0, true or false.

40
00:02:36,540 --> 00:02:38,950
Now of course, if you
only have one light bulb,

41
00:02:38,950 --> 00:02:41,150
you can only count from 0 to 1.

42
00:02:41,150 --> 00:02:44,070
But if you start to have a bunch of
them back to back to back to back,

43
00:02:44,070 --> 00:02:46,500
you can permute them
like I did my finger--

44
00:02:46,500 --> 00:02:50,350
0, 1, 2, 3, and so forth.

45
00:02:50,350 --> 00:02:53,470
And so we started talking
about binary more generally.

46
00:02:53,470 --> 00:02:57,060
And so here for instance
were three sequences

47
00:02:57,060 --> 00:03:00,690
of 0's and 1's and each of
those represented something,

48
00:03:00,690 --> 00:03:03,110
but we don't need to think
about the world at that level.

49
00:03:03,110 --> 00:03:04,410
We can abstract on top of that.

50
00:03:04,410 --> 00:03:07,020
All of us are so much more
familiar with decimal of course,

51
00:03:07,020 --> 00:03:12,150
and indeed recall that this was just
72, 73, and 33, which if anyone recalls,

52
00:03:12,150 --> 00:03:13,260
when you use ASCII--

53
00:03:13,260 --> 00:03:15,450
which is this global
standard for mapping numbers

54
00:03:15,450 --> 00:03:17,460
to letters-- we got what message?

55
00:03:17,460 --> 00:03:21,240
Yeah, it was just high, capital
H capital I exclamation point.

56
00:03:21,240 --> 00:03:25,620
And so that's an abstraction on top
of those otherwise binary numbers.

57
00:03:25,620 --> 00:03:28,800
But we don't have to model
just text using numbers.

58
00:03:28,800 --> 00:03:31,650
At the end of the day, our only
resource is still that electricity,

59
00:03:31,650 --> 00:03:34,530
and the only way we think about it
digitally is still zeros and ones.

60
00:03:34,530 --> 00:03:35,900
But if we take the same value--

61
00:03:35,900 --> 00:03:41,010
72, 73, 33-- and treat them
in the context of Photoshop

62
00:03:41,010 --> 00:03:42,950
or a photo program or
a graphics program,

63
00:03:42,950 --> 00:03:45,000
we can instead interpret
them as like some amount

64
00:03:45,000 --> 00:03:47,370
of red, some amount of
green, some amount of blue,

65
00:03:47,370 --> 00:03:50,040
which gave us last time,
recall, this yellowish color.

66
00:03:50,040 --> 00:03:53,640
So now we had another abstraction
on top of binary colors,

67
00:03:53,640 --> 00:03:54,940
and this is just one pixel.

68
00:03:54,940 --> 00:03:57,030
What can you do once you
have more than one pixel?

69
00:03:57,030 --> 00:03:59,910
What can you represent next?

70
00:03:59,910 --> 00:04:01,290
Yeah, right, images.

71
00:04:01,290 --> 00:04:03,540
So we're continuing the
conversation up and up and up,

72
00:04:03,540 --> 00:04:06,360
and we could represents something like
a graphical emoji on the screen, which

73
00:04:06,360 --> 00:04:07,860
has more than just one yellow dot.

74
00:04:07,860 --> 00:04:10,740
It's got a whole bunch of yellow
dots and other colors as well.

75
00:04:10,740 --> 00:04:13,200
And recall that, if we
want to animate things,

76
00:04:13,200 --> 00:04:16,590
whether it's through silly things like
animojis on a phone or just more proper

77
00:04:16,590 --> 00:04:20,160
videos and movies, well,
those are just sequences

78
00:04:20,160 --> 00:04:23,370
of images flying past your
human eyes really quite quickly.

79
00:04:23,370 --> 00:04:26,490
So that's where we kind of left off
last time starting at the base level

80
00:04:26,490 --> 00:04:29,820
and abstracting away so that we
could stipulate thereafter we

81
00:04:29,820 --> 00:04:33,030
can represent inputs,
and we can represent

82
00:04:33,030 --> 00:04:34,620
outputs, whatever those happen to be.

83
00:04:34,620 --> 00:04:36,870
And here on out, we don't
need to think at that level.

84
00:04:36,870 --> 00:04:38,910
We can just assume we
all know how to do this.

85
00:04:38,910 --> 00:04:41,950
And even if it eventually
becomes kind of a distant memory,

86
00:04:41,950 --> 00:04:43,830
we know that someone can indeed do this.

87
00:04:43,830 --> 00:04:45,990
And that's the value of abstraction.

88
00:04:45,990 --> 00:04:48,850
But inside of this black box
are so-called algorithms,

89
00:04:48,850 --> 00:04:50,370
the secret sauce--

90
00:04:50,370 --> 00:04:52,500
this is where the problems
are actually solved.

91
00:04:52,500 --> 00:04:57,130
And we not only talked about what
these algorithms are, but for instance,

92
00:04:57,130 --> 00:04:58,470
how efficient they were.

93
00:04:58,470 --> 00:05:02,550
So recall that this red line represented
a very simple algorithm just turning

94
00:05:02,550 --> 00:05:04,820
the phone book page
by page one at a time.

95
00:05:04,820 --> 00:05:07,820
And the reason that it's a straight
line is because there's a one to one

96
00:05:07,820 --> 00:05:10,320
correspondence between how many
pages there are in the book

97
00:05:10,320 --> 00:05:13,230
and how many page turns there are--
one page, one more page, one more

98
00:05:13,230 --> 00:05:14,530
turn, and so forth.

99
00:05:14,530 --> 00:05:16,560
If I fly through it at twice the speed--

100
00:05:16,560 --> 00:05:18,420
2, 4, 6, 8--

101
00:05:18,420 --> 00:05:19,540
I can do better.

102
00:05:19,540 --> 00:05:23,340
And so that yellow line now,
recall, was lower on the graph.

103
00:05:23,340 --> 00:05:25,810
If you just look at any
two points, yellow and red,

104
00:05:25,810 --> 00:05:28,260
yellow is below red,
saying it takes less time.

105
00:05:28,260 --> 00:05:30,150
But it was not quite correct.

106
00:05:30,150 --> 00:05:34,380
There was one bug when I was looking
for Mike two pages at a time.

107
00:05:34,380 --> 00:05:36,520
What was that issue?

108
00:05:36,520 --> 00:05:37,480
Yeah, I might miss him.

109
00:05:37,480 --> 00:05:40,710
He might accidentally get sandwiched
in between two pages-- not a huge deal

110
00:05:40,710 --> 00:05:42,670
because I could fix it,
but I have to fix it.

111
00:05:42,670 --> 00:05:44,880
I have to apply that additional
logic and double back

112
00:05:44,880 --> 00:05:46,590
at least a page if I go too fast.

113
00:05:46,590 --> 00:05:50,790
But of course the final algorithm-- and
frankly all of our initial intuition

114
00:05:50,790 --> 00:05:54,150
probably-- was the dividing and
conquer, open it roughly to the middle,

115
00:05:54,150 --> 00:05:56,200
look down, and then
go left, and go right,

116
00:05:56,200 --> 00:05:58,200
and just repeat that
process as the problem gets

117
00:05:58,200 --> 00:06:01,530
this big to this big to this big
to this big to just one page left.

118
00:06:01,530 --> 00:06:04,390
So that was all about efficiency.

119
00:06:04,390 --> 00:06:07,740
But to get to that point we needed
to express ourselves more precisely.

120
00:06:07,740 --> 00:06:09,120
And so we introduced pseudo code.

121
00:06:09,120 --> 00:06:10,660
There's no formal definition.

122
00:06:10,660 --> 00:06:12,000
It can be English, English like.

123
00:06:12,000 --> 00:06:14,460
It's just meant to be succinct
and get the point across.

124
00:06:14,460 --> 00:06:17,790
And recall that, along the way, we
introduced a whole bunch of concepts,

125
00:06:17,790 --> 00:06:21,090
many of which you probably
experimented with Scratch, like loops

126
00:06:21,090 --> 00:06:25,780
and conditions, Boolean expressions,
variables, and so forth.

127
00:06:25,780 --> 00:06:30,300
And those were building blocks that came
out of this kind of demonstration here.

128
00:06:30,300 --> 00:06:33,510
But honestly, even in this
demonstration, in this pseudo code,

129
00:06:33,510 --> 00:06:35,450
there were a whole bunch of assumptions.

130
00:06:35,450 --> 00:06:37,290
If you read these
instructions one at a time

131
00:06:37,290 --> 00:06:39,080
and you're holding the
phone book yourself,

132
00:06:39,080 --> 00:06:42,340
odds are you can execute this
pseudocode, this algorithm.

133
00:06:42,340 --> 00:06:47,910
But what does it really mean to, say,
open to the middle of the phone book?

134
00:06:47,910 --> 00:06:50,730
All of us have an intuitive
understanding of what that means.

135
00:06:50,730 --> 00:06:52,440
But honestly, if you
were explaining that

136
00:06:52,440 --> 00:06:55,060
to a kid or someone who's learning
English or whatever language

137
00:06:55,060 --> 00:06:57,510
for the first time, open to
the middle of the phone book,

138
00:06:57,510 --> 00:06:59,650
you should probably sets
forth some assumptions.

139
00:06:59,650 --> 00:07:03,310
OK, this thing in front of you
has 1,000 pages, pieces of paper.

140
00:07:03,310 --> 00:07:06,990
Turn to the 500th page, and
let's call that the middle.

141
00:07:06,990 --> 00:07:09,660
This would very quickly get
tedious if all of us humans

142
00:07:09,660 --> 00:07:11,440
are talking at that level of detail.

143
00:07:11,440 --> 00:07:13,450
And so we abstract
away with more sweeping

144
00:07:13,450 --> 00:07:15,660
statements like open to the
middle of the phone book,

145
00:07:15,660 --> 00:07:17,340
but that's an abstraction.

146
00:07:17,340 --> 00:07:19,950
And it's not quite as
precise as is probably ideal,

147
00:07:19,950 --> 00:07:24,100
especially feeding this algorithm to
a newbie or to a robot or a computer.

148
00:07:24,100 --> 00:07:27,870
But it's useful because we can then make
a 12 step program instead of a 20 step

149
00:07:27,870 --> 00:07:29,950
program by elaborating too much.

150
00:07:29,950 --> 00:07:32,880
And for instance, throughout here
too we had our loops and conditions

151
00:07:32,880 --> 00:07:34,980
and so forth, but even call Mike.

152
00:07:34,980 --> 00:07:36,010
What does that mean?

153
00:07:36,010 --> 00:07:38,640
Well, if you imagine that the
human knows how to use the phone,

154
00:07:38,640 --> 00:07:39,840
then it goes without saying.

155
00:07:39,840 --> 00:07:42,690
But if he or she also needs to
be programmed to use the phone,

156
00:07:42,690 --> 00:07:45,210
you've got to explain-- pick
it up, hit this button, type

157
00:07:45,210 --> 00:07:47,080
this sequence of buttons, and so forth.

158
00:07:47,080 --> 00:07:50,110
So call Mike is also an abstraction.

159
00:07:50,110 --> 00:07:54,750
So these abstractions are useful, but
they can sometimes get in the way,

160
00:07:54,750 --> 00:08:00,930
especially if you're not precise enough
to program the computer correctly.

161
00:08:00,930 --> 00:08:06,330
And to paint this picture, I thought
we could begin a little heartedly here.

162
00:08:06,330 --> 00:08:09,840
I brought some breakfast, if you didn't
quite make it next door or beyond.

163
00:08:09,840 --> 00:08:11,590
Just need a couple of
volunteers if you're

164
00:08:11,590 --> 00:08:14,340
comfortable appearing on stage
and on the internet here.

165
00:08:14,340 --> 00:08:16,260
Let me kind of-- there's
a lot of lights here.

166
00:08:16,260 --> 00:08:20,010
How about over there on the
left and over here in the front?

167
00:08:20,010 --> 00:08:20,760
Yeah, right there.

168
00:08:20,760 --> 00:08:21,800
I think your hand was up.

169
00:08:21,800 --> 00:08:23,680
Come on down.

170
00:08:23,680 --> 00:08:26,610
And Brian, do you mind
lending us a hand here, too?

171
00:08:26,610 --> 00:08:28,920
Come on down.

172
00:08:28,920 --> 00:08:31,320
If you want to take control
here, let you go ahead

173
00:08:31,320 --> 00:08:35,650
and switch over to
another program for you.

174
00:08:35,650 --> 00:08:36,360
What's your name?

175
00:08:36,360 --> 00:08:36,790
JEAN: Jean.

176
00:08:36,790 --> 00:08:37,360
DAVID: Jean, David.

177
00:08:37,360 --> 00:08:37,710
Nice to meet you.

178
00:08:37,710 --> 00:08:38,970
Have a seat on the far left.

179
00:08:38,970 --> 00:08:39,550
And your name?

180
00:08:39,550 --> 00:08:40,340
ABBY: Hi, I'm Abby.

181
00:08:40,340 --> 00:08:41,380
Nice to meet you as well.

182
00:08:41,380 --> 00:08:42,720
On the far right if you could.

183
00:08:42,720 --> 00:08:46,170
So Jean and Abby, do you want to say
a little something about yourselves

184
00:08:46,170 --> 00:08:47,860
quickly?

185
00:08:47,860 --> 00:08:48,690
JEAN: I'm Jean.

186
00:08:48,690 --> 00:08:52,490
I'm a Massachusetts native, and
I'm taking CS for the first.

187
00:08:52,490 --> 00:08:54,400
It's my first coding or anything.

188
00:08:54,400 --> 00:08:56,180
Or I'm doing and I'm enjoying it.

189
00:08:56,180 --> 00:08:57,760
DAVID: Nice, glad to have you with us.

190
00:08:57,760 --> 00:08:59,290
And Abby?

191
00:08:59,290 --> 00:09:00,090
ABBY: Hi, I'm Abby.

192
00:09:00,090 --> 00:09:02,730
I'm taking this as a
sophomore, and I know nothing

193
00:09:02,730 --> 00:09:04,260
about computers or computer science.

194
00:09:04,260 --> 00:09:06,240
So I'm probably taking it stat on stat.

195
00:09:06,240 --> 00:09:08,220
DAVID: OK, well, nice
to have you as well.

196
00:09:08,220 --> 00:09:10,550
So in front of us is a
whole bunch of ingredients,

197
00:09:10,550 --> 00:09:12,720
and hopefully we can start
this semester off gently.

198
00:09:12,720 --> 00:09:15,510
And if we're successful, we'll
actually have a quick bite here.

199
00:09:15,510 --> 00:09:17,220
But we thought we'd defer
to the audience here,

200
00:09:17,220 --> 00:09:18,780
and Brian's going to scribe as we go.

201
00:09:18,780 --> 00:09:20,730
And all we want to do
this morning is just

202
00:09:20,730 --> 00:09:24,650
make a peanut butter and jelly
sandwich, one instruction at a time.

203
00:09:24,650 --> 00:09:26,790
And each of us will just
execute what we hear.

204
00:09:26,790 --> 00:09:27,870
How does that sound?

205
00:09:27,870 --> 00:09:30,950
All right, if someone could volunteer
with the first instruction and Brian

206
00:09:30,950 --> 00:09:33,170
will type it down.

207
00:09:33,170 --> 00:09:36,030
AUDIENCE: Open bread.

208
00:09:36,030 --> 00:09:37,160
DAVID: Open bread we heard.

209
00:09:37,160 --> 00:09:38,520
Open bread is the first instruction.

210
00:09:38,520 --> 00:09:40,510
So each of you would like
to execute open bread.

211
00:09:46,480 --> 00:09:47,360
No, don't look at me.

212
00:09:50,510 --> 00:09:52,640
All right, so we're kind of on our way.

213
00:09:56,650 --> 00:10:00,790
I think Abby did it better certainly,
but we did it correctly arguably.

214
00:10:00,790 --> 00:10:04,870
So let's move on to step 2
and see if we can't improve.

215
00:10:04,870 --> 00:10:05,910
Take out bread.

216
00:10:11,600 --> 00:10:14,480
Welcome to the team now.

217
00:10:14,480 --> 00:10:16,740
Nice, all right, step three.

218
00:10:16,740 --> 00:10:17,240
Yeah.

219
00:10:17,240 --> 00:10:19,880
AUDIENCE: Place two pieces
of bread on the table.

220
00:10:19,880 --> 00:10:21,900
DAVID: Place two pieces
of bread on the table.

221
00:10:26,210 --> 00:10:27,930
Never mind the plates.

222
00:10:27,930 --> 00:10:30,740
OK, step four.

223
00:10:30,740 --> 00:10:34,080
AUDIENCE: Twist cover
of jelly till it opens.

224
00:10:34,080 --> 00:10:36,370
DAVID: Twist cover of
jelly till it opens.

225
00:10:36,370 --> 00:10:36,870
Thank you.

226
00:10:41,790 --> 00:10:42,500
Step five?

227
00:10:45,280 --> 00:10:45,910
Step five?

228
00:10:45,910 --> 00:10:46,940
Yeah?

229
00:10:46,940 --> 00:10:48,440
AUDIENCE: Place the lid to the side.

230
00:10:48,440 --> 00:10:49,140
DAVID: Thank you.

231
00:10:49,140 --> 00:10:51,050
Place the lid to the side.

232
00:10:51,050 --> 00:10:52,400
I took some liberties myself.

233
00:10:52,400 --> 00:10:53,450
AUDIENCE: Take the knife.

234
00:10:53,450 --> 00:10:54,360
DAVID: Take the knife.

235
00:11:00,990 --> 00:11:02,730
Peel off the cover of the jelly.

236
00:11:06,000 --> 00:11:06,880
No covers on ours.

237
00:11:11,370 --> 00:11:16,680
Stick knife into the bottle?

238
00:11:16,680 --> 00:11:18,330
From the top.

239
00:11:18,330 --> 00:11:24,820
Stick-- step nine.

240
00:11:24,820 --> 00:11:27,610
AUDIENCE: Rotate hands
so jelly ends up on.

241
00:11:27,610 --> 00:11:30,070
DAVID: Rotate hands
so jelly ends up on--

242
00:11:35,530 --> 00:11:37,910
OK, step-- quickly--

243
00:11:37,910 --> 00:11:38,410
10.

244
00:11:41,910 --> 00:11:43,970
Yes, step 10?

245
00:11:43,970 --> 00:11:45,460
AUDIENCE: Pull out knife.

246
00:11:45,460 --> 00:11:46,910
DAVID: Pull out knife.

247
00:11:46,910 --> 00:11:49,720
OK, step 11.

248
00:11:52,350 --> 00:11:55,360
Jelly side down on bread.

249
00:12:01,640 --> 00:12:04,180
All right, step 12.

250
00:12:08,900 --> 00:12:10,280
Step 12, anyone?

251
00:12:10,280 --> 00:12:11,960
Yes.

252
00:12:11,960 --> 00:12:14,350
Thank you.

253
00:12:14,350 --> 00:12:18,130
Step 13.

254
00:12:18,130 --> 00:12:19,720
Pour jelly on bread.

255
00:12:24,280 --> 00:12:25,030
JEAN: Pour jelly--

256
00:12:25,030 --> 00:12:27,520
DAVID: Pour jelly, jelly.

257
00:12:27,520 --> 00:12:28,090
All of it?

258
00:12:28,090 --> 00:12:29,590
OK, now you're just messing with us.

259
00:12:35,910 --> 00:12:38,180
Step 14.

260
00:12:38,180 --> 00:12:39,920
AUDIENCE: Put jelly down.

261
00:12:39,920 --> 00:12:40,840
DAVID: Put jelly down.

262
00:12:40,840 --> 00:12:42,100
Thank you.

263
00:12:42,100 --> 00:12:44,590
15?

264
00:12:44,590 --> 00:12:46,240
Pick up peanut butter.

265
00:12:46,240 --> 00:12:47,600
AUDIENCE: Take the lid off.

266
00:12:47,600 --> 00:12:48,440
DAVID: Take lid off.

267
00:12:48,440 --> 00:12:48,940
Thank you.

268
00:12:52,350 --> 00:12:54,050
Peel off lid.

269
00:12:54,050 --> 00:12:54,550
Thank you.

270
00:12:57,070 --> 00:12:59,630
Step 18?

271
00:12:59,630 --> 00:13:07,550
Pick up knife by blunt end, scoop.

272
00:13:13,230 --> 00:13:14,780
Scoop.

273
00:13:14,780 --> 00:13:18,270
Step 20?

274
00:13:18,270 --> 00:13:19,630
Put peanut butter on bread?

275
00:13:25,070 --> 00:13:26,060
21?

276
00:13:26,060 --> 00:13:27,690
AUDIENCE: Move the knife left to right.

277
00:13:27,690 --> 00:13:31,650
DAVID: Move-- move the
knife left to right, please.

278
00:13:31,650 --> 00:13:32,250
Left to right.

279
00:13:37,910 --> 00:13:38,700
Step 22?

280
00:13:41,470 --> 00:13:42,910
AUDIENCE: Put down knife.

281
00:13:42,910 --> 00:13:43,880
DAVID: Thank you.

282
00:13:43,880 --> 00:13:44,960
23?

283
00:13:44,960 --> 00:13:46,580
AUDIENCE: Put down jar.

284
00:13:46,580 --> 00:13:48,580
DAVID: 24.

285
00:13:48,580 --> 00:13:49,540
What was that?

286
00:13:53,400 --> 00:13:54,780
Eat sandwich.

287
00:13:54,780 --> 00:13:56,870
OK, I think we're--

288
00:13:56,870 --> 00:13:58,360
well, why don't each take a bite?

289
00:13:58,360 --> 00:14:00,740
And a round of applause, if
we could, for our volunteers.

290
00:14:06,700 --> 00:14:09,450
Thank you.

291
00:14:09,450 --> 00:14:11,150
ABBY: Mind if I take some for the row?

292
00:14:11,150 --> 00:14:14,190
DAVID: You can take some
for the row if you'd like.

293
00:14:14,190 --> 00:14:14,690
Thank you.

294
00:14:14,690 --> 00:14:17,320
So-- thank you, Brian.

295
00:14:17,320 --> 00:14:18,320
OK, now I need a minute.

296
00:14:21,080 --> 00:14:22,250
Thank you.

297
00:14:22,250 --> 00:14:28,190
So suffice it to say, this
obviously demonstrated even more so

298
00:14:28,190 --> 00:14:31,550
than the phone book example
where our certain assumptions are

299
00:14:31,550 --> 00:14:33,180
and our abstractions are.

300
00:14:33,180 --> 00:14:35,310
And honestly, almost all
the time those are useful.

301
00:14:35,310 --> 00:14:36,790
And of course, we kind
of hammed things up.

302
00:14:36,790 --> 00:14:39,490
And I think the instructions were
kind of helping with that here.

303
00:14:39,490 --> 00:14:42,950
But when it comes time to program
with Scratch and certainly with C

304
00:14:42,950 --> 00:14:45,980
starting this week, you can't really
make as many of those assumptions

305
00:14:45,980 --> 00:14:48,950
anymore because, if you don't
handle these corner cases

306
00:14:48,950 --> 00:14:51,430
and if you don't think about
what that instruction means,

307
00:14:51,430 --> 00:14:54,350
you're going to get the proverbial
spinning beachball or the hourglass

308
00:14:54,350 --> 00:14:55,820
that you're familiar
with on your Mac or PC.

309
00:14:55,820 --> 00:14:57,570
The program is going
to crash, something's

310
00:14:57,570 --> 00:15:02,740
going to go wrong just because you
miss some specificity or precision.

311
00:15:02,740 --> 00:15:04,940
Now we're full of peanut butter.

312
00:15:04,940 --> 00:15:08,750
So over time, we're going to
find that, much like in Scratch,

313
00:15:08,750 --> 00:15:10,730
we were able to make
our own building blocks.

314
00:15:10,730 --> 00:15:14,000
You might recall the short examples
we did with the cough example

315
00:15:14,000 --> 00:15:16,580
where I had cough 0 and
then cough 1 and cough 2

316
00:15:16,580 --> 00:15:19,530
where I was making my own
puzzle piece within Scratch.

317
00:15:19,530 --> 00:15:21,950
That was useful because, after
that example theoretically,

318
00:15:21,950 --> 00:15:26,210
I never again need to think about or
worry about how to implement cough.

319
00:15:26,210 --> 00:15:27,710
I can just use that abstraction.

320
00:15:27,710 --> 00:15:29,920
But someone has to implement
them, and sometimes it's

321
00:15:29,920 --> 00:15:31,970
going to be other people
who have come before us.

322
00:15:31,970 --> 00:15:33,400
And sometimes it's going to be us.

323
00:15:33,400 --> 00:15:36,260
So this isn't to say that
programming ends up being so tedious

324
00:15:36,260 --> 00:15:38,430
that you have to point
out every little thing,

325
00:15:38,430 --> 00:15:42,710
but you or someone does have to do
that level of precision at least once.

326
00:15:42,710 --> 00:15:46,700
And nicely enough in Scratch, MIT
did most of that legwork for you.

327
00:15:46,700 --> 00:15:48,410
We all had the building
blocks with which

328
00:15:48,410 --> 00:15:51,020
to make our own animation or
game or artwork or the like.

329
00:15:51,020 --> 00:15:54,140
But even then, you probably had to
connect several dozen puzzle pieces

330
00:15:54,140 --> 00:15:56,930
or even more to get
those fundamentals to do

331
00:15:56,930 --> 00:15:59,390
what it is that you wanted it to do.

332
00:15:59,390 --> 00:16:01,770
So today we're going to start
to transition from Scratch,

333
00:16:01,770 --> 00:16:04,560
this graphical programming language,
that while targeted at younger

334
00:16:04,560 --> 00:16:07,070
students, is typically
representative of a lot

335
00:16:07,070 --> 00:16:10,380
of the same concepts that are now going
to be laced throughout the semester.

336
00:16:10,380 --> 00:16:13,790
But we're going to introduce today an
older, more traditional language that's

337
00:16:13,790 --> 00:16:15,050
just text based.

338
00:16:15,050 --> 00:16:16,640
And as such it's a lot more powerful.

339
00:16:16,640 --> 00:16:19,640
But at first glance, it's actually
going to look a lot more cryptic.

340
00:16:19,640 --> 00:16:23,030
In fact, instead of writing
zeros and ones starting today,

341
00:16:23,030 --> 00:16:25,400
we're instead going to
write something like this.

342
00:16:25,400 --> 00:16:28,380
Now if you've never programmed
before, odds are, at first glance,

343
00:16:28,380 --> 00:16:30,500
this does look pretty
cryptic, and there's

344
00:16:30,500 --> 00:16:33,560
a lot of symbols within it,
punctuation from the keyboard.

345
00:16:33,560 --> 00:16:36,230
There's probably some
familiar English like words.

346
00:16:36,230 --> 00:16:39,890
And frankly, even after doing Scratch
anyone, even with no prior background,

347
00:16:39,890 --> 00:16:43,070
can probably hazard a guess as
to what this program written

348
00:16:43,070 --> 00:16:46,810
in this other language called
C does when you run it.

349
00:16:46,810 --> 00:16:48,440
It just prints hello world.

350
00:16:48,440 --> 00:16:51,700
Now granted there's a decent
amount of overhead syntactically.

351
00:16:51,700 --> 00:16:53,750
There's a bunch of stuff
you have to type to make

352
00:16:53,750 --> 00:16:55,740
this program do what you want it to do.

353
00:16:55,740 --> 00:16:58,250
But at the end of the day,
that's all it's going to do.

354
00:16:58,250 --> 00:17:00,320
And this is among the
simplest of programs

355
00:17:00,320 --> 00:17:02,600
we're going to add to
our puzzle pieces, so

356
00:17:02,600 --> 00:17:05,270
to speak, today and see
some of those same concepts

357
00:17:05,270 --> 00:17:07,260
that we saw last time as well.

358
00:17:07,260 --> 00:17:09,020
So let's do this first though.

359
00:17:09,020 --> 00:17:12,710
Let me take a moment
to compare Scratch to C

360
00:17:12,710 --> 00:17:14,580
because the most important
takeaway for today

361
00:17:14,580 --> 00:17:17,570
is going to be that, even if the
syntax doesn't look so obvious--

362
00:17:17,570 --> 00:17:19,910
and frankly, even if your
first minutes or hours

363
00:17:19,910 --> 00:17:22,910
with writing your own code in
C is frustrating because, oh,

364
00:17:22,910 --> 00:17:25,060
dammit, you left off
a semi-colon or, oh,

365
00:17:25,060 --> 00:17:26,690
I had a parenthesis in the wrong place.

366
00:17:26,690 --> 00:17:28,780
There's a lot of these
stupid syntactic hangups

367
00:17:28,780 --> 00:17:31,490
that make you feel quite often
that you really aren't getting it.

368
00:17:31,490 --> 00:17:32,940
But that's not the important stuff.

369
00:17:32,940 --> 00:17:35,480
A lot of the syntax is
the least important.

370
00:17:35,480 --> 00:17:37,940
That's not at all fundamentally
intellectually interesting.

371
00:17:37,940 --> 00:17:40,850
So try to see past that, and
try to take comfort in the fact

372
00:17:40,850 --> 00:17:43,610
that it's the principles that
are going to be important.

373
00:17:43,610 --> 00:17:47,060
And honestly, just muscle memory
and practice, all of the other stuff

374
00:17:47,060 --> 00:17:49,790
that at first is going to be
an occasional frustration,

375
00:17:49,790 --> 00:17:51,950
it just starts to go
away as you start to see

376
00:17:51,950 --> 00:17:54,610
this for what it is
and not for the syntax

377
00:17:54,610 --> 00:17:56,930
alone that you see on first glance.

378
00:17:56,930 --> 00:18:01,330
So this is to say this
program on the right in C

379
00:18:01,330 --> 00:18:04,910
is equivalent to what we did just a week
ago with two puzzle pieces in Scratch.

380
00:18:04,910 --> 00:18:07,760
Now there isn't going to be a
green flag on my Mac or my PC

381
00:18:07,760 --> 00:18:09,560
as we move forward that
you can just click.

382
00:18:09,560 --> 00:18:11,630
We're going to run these programs
in a little different way,

383
00:18:11,630 --> 00:18:13,650
but that's all the code
on the right is doing.

384
00:18:13,650 --> 00:18:15,180
It's equivalent to the code on the left.

385
00:18:15,180 --> 00:18:17,300
So let's do this again and again
for just a few of those concepts

386
00:18:17,300 --> 00:18:20,580
from last time, and then we'll start
writing some of our own programs.

387
00:18:20,580 --> 00:18:26,300
So this was an example, this purple
block, of what concept in programming?

388
00:18:26,300 --> 00:18:27,110
Yeah, a function.

389
00:18:27,110 --> 00:18:27,980
So it was a verb.

390
00:18:27,980 --> 00:18:30,110
It was an action, and we're going
to call those generally functions.

391
00:18:30,110 --> 00:18:32,010
They just have functionality
built into them.

392
00:18:32,010 --> 00:18:33,500
So how do we do this in C?

393
00:18:33,500 --> 00:18:35,490
Well, you might remember
from just a moment ago,

394
00:18:35,490 --> 00:18:38,060
because one of the lines of
code was representative of this,

395
00:18:38,060 --> 00:18:39,930
it had some of this syntax.

396
00:18:39,930 --> 00:18:42,020
So in fact, if I were
to translate the block

397
00:18:42,020 --> 00:18:45,110
on the left in Scratch to the
equivalent code in this other text based

398
00:18:45,110 --> 00:18:47,750
language called C, I'm going
to start by writing print

399
00:18:47,750 --> 00:18:50,330
and then open parenthesis
and then close parenthesis.

400
00:18:50,330 --> 00:18:54,110
And those parentheses represent the
oval, the white oval on the left,

401
00:18:54,110 --> 00:18:56,420
that we typed hello world into before.

402
00:18:56,420 --> 00:18:58,760
Now in C, it's not quite
as literal as that.

403
00:18:58,760 --> 00:19:01,700
The function, or the verb,
is actually not called print.

404
00:19:01,700 --> 00:19:04,370
It's called printf, and
the F stands for formatted.

405
00:19:04,370 --> 00:19:06,530
And it just means that
in C you can actually

406
00:19:06,530 --> 00:19:08,340
format your text in different ways.

407
00:19:08,340 --> 00:19:10,770
So we'll see that before
long, and it turns out

408
00:19:10,770 --> 00:19:13,400
that you don't just write hello
world between those parentheses

409
00:19:13,400 --> 00:19:14,600
like we did in Scratch.

410
00:19:14,600 --> 00:19:18,230
You also actually have to surround
them with double quotes in C.

411
00:19:18,230 --> 00:19:20,900
Not such a big deal, but something
you didn't have to do before.

412
00:19:20,900 --> 00:19:23,960
But in C, you're also
going to generally want

413
00:19:23,960 --> 00:19:26,000
to be super specific to the computer.

414
00:19:26,000 --> 00:19:28,640
And when you want the cursor
the text on the screen

415
00:19:28,640 --> 00:19:31,790
to move down to the next line,
you need to tell the computer that

416
00:19:31,790 --> 00:19:33,830
by literally typing backslash n.

417
00:19:33,830 --> 00:19:36,170
The human is not going to
see a backslash and an n.

418
00:19:36,170 --> 00:19:38,330
He or she is actually going
to see the cursor move

419
00:19:38,330 --> 00:19:41,150
to the next line of the
screen like in Google Docs

420
00:19:41,150 --> 00:19:42,710
or in Microsoft Word or the like.

421
00:19:42,710 --> 00:19:45,110
But this just speaks to
the precision that you

422
00:19:45,110 --> 00:19:47,720
need to have when talking
to a computer at this level

423
00:19:47,720 --> 00:19:49,230
and not just with the puzzle pieces.

424
00:19:49,230 --> 00:19:51,440
And then one last thing--
and I alluded to it earlier

425
00:19:51,440 --> 00:19:54,050
because it's the bane of a
lot of programmers early on.

426
00:19:54,050 --> 00:19:58,220
Most lines of code in C
have to end in a semi-colon.

427
00:19:58,220 --> 00:20:01,070
That's the sort of code equivalent
of a period in an English

428
00:20:01,070 --> 00:20:02,940
or some other languages sentence.

429
00:20:02,940 --> 00:20:03,700
So that's it.

430
00:20:03,700 --> 00:20:05,530
It took us a little
while to build that up.

431
00:20:05,530 --> 00:20:06,410
But that's all it is.

432
00:20:06,410 --> 00:20:09,050
The idea on the left of saying
something is the same in C

433
00:20:09,050 --> 00:20:12,850
as printing something with
this function called printf.

434
00:20:12,850 --> 00:20:15,230
And before I forge ahead
with some other comparisons,

435
00:20:15,230 --> 00:20:18,120
any questions on just this translation?

436
00:20:18,120 --> 00:20:20,070
AUDIENCE: How do you write backslash n?

437
00:20:20,070 --> 00:20:21,570
DAVID: How do you write backslash n?

438
00:20:21,570 --> 00:20:25,500
Good, so thinking ahead, this would
seem to make it hard to literally show

439
00:20:25,500 --> 00:20:27,510
the user backslash n.

440
00:20:27,510 --> 00:20:30,360
Well, it turns out that this
backslash, because it's not

441
00:20:30,360 --> 00:20:33,030
a terribly common character,
the programming world

442
00:20:33,030 --> 00:20:35,100
uses it as what's called
an escape character.

443
00:20:35,100 --> 00:20:38,760
It's one that you use when you want
to escape information and show it

444
00:20:38,760 --> 00:20:40,120
in a slightly different way.

445
00:20:40,120 --> 00:20:42,710
So the way you would show
literally to the human

446
00:20:42,710 --> 00:20:46,290
a actual backslash n is
to actually in your code

447
00:20:46,290 --> 00:20:50,970
do backslash backslash n
because the second backslash is

448
00:20:50,970 --> 00:20:53,130
like saying treat the
next character special

449
00:20:53,130 --> 00:20:54,930
and actually show it to the human.

450
00:20:54,930 --> 00:20:56,830
And there's other such examples of that.

451
00:20:56,830 --> 00:20:57,900
So how about this one?

452
00:20:57,900 --> 00:21:02,340
This orange block was an example
of one concept in Scratch?

453
00:21:02,340 --> 00:21:05,350
Yeah, so this was a variable,
like an x and y in algebra.

454
00:21:05,350 --> 00:21:08,330
This was just a placeholder for
data, and you could store numbers.

455
00:21:08,330 --> 00:21:09,720
It turns out you can store words.

456
00:21:09,720 --> 00:21:12,160
You can store other things
too in other languages.

457
00:21:12,160 --> 00:21:14,050
So in C, we're going to do this.

458
00:21:14,050 --> 00:21:16,500
We're going to say, literally, the name
of the variable we want-- for instance,

459
00:21:16,500 --> 00:21:17,050
counter.

460
00:21:17,050 --> 00:21:18,840
But we could call anything we want--

461
00:21:18,840 --> 00:21:22,260
equals zero if we're setting
it initially equal to zero.

462
00:21:22,260 --> 00:21:24,270
But C is a little more pedantic.

463
00:21:24,270 --> 00:21:27,670
You've also got to tell the
computer, the type of variable I want

464
00:21:27,670 --> 00:21:31,320
is specifically for an integer,
otherwise abbreviated int.

465
00:21:31,320 --> 00:21:33,870
So you have to tell the computer
in advance what type of data

466
00:21:33,870 --> 00:21:35,030
you're going to store on it.

467
00:21:35,030 --> 00:21:35,970
And take a guess.

468
00:21:35,970 --> 00:21:40,120
You've got to finish the thought ion
C. What more do we need to add to the--

469
00:21:40,120 --> 00:21:41,400
yeah, just a semi-colon.

470
00:21:41,400 --> 00:21:41,990
And that's it.

471
00:21:41,990 --> 00:21:46,080
It looks a little more cryptic, but
the idea is fundamentally the same.

472
00:21:46,080 --> 00:21:48,090
So what if we wanted
to do this in Scratch?

473
00:21:48,090 --> 00:21:52,740
Change counter by 1-- this was
equivalent to incrementing or adding 1

474
00:21:52,740 --> 00:21:53,670
to counter.

475
00:21:53,670 --> 00:21:56,290
Well, let me go ahead and propose
that you could literally just

476
00:21:56,290 --> 00:22:03,000
do this in C. Set counter equal to
whatever counter currently is plus 1.

477
00:22:03,000 --> 00:22:04,830
That seems to be the right intuition.

478
00:22:04,830 --> 00:22:07,020
And now notice, what's
key to note here is

479
00:22:07,020 --> 00:22:12,180
that this equal sign isn't saying
that counter equals counter plus 1

480
00:22:12,180 --> 00:22:14,730
because that just doesn't seem possible.

481
00:22:14,730 --> 00:22:17,430
If you pick any value for
counter, like the number 1,

482
00:22:17,430 --> 00:22:21,930
well, one definitely does not
equal 1 plus 1, which is 2.

483
00:22:21,930 --> 00:22:23,940
And 1 does not equal
2, and you can come up

484
00:22:23,940 --> 00:22:27,580
with an infinite number of
worrisome incorrect comparisons.

485
00:22:27,580 --> 00:22:30,660
So the equal sign in C, like a lot
of languages we'll see in the class,

486
00:22:30,660 --> 00:22:31,830
actually means assignment.

487
00:22:31,830 --> 00:22:35,250
Copy the value on the right
into the value on the left.

488
00:22:35,250 --> 00:22:38,380
So set counter equal to
whatever it is plus 1.

489
00:22:38,380 --> 00:22:38,880
What?

490
00:22:38,880 --> 00:22:40,590
We've got to finish the thought.

491
00:22:40,590 --> 00:22:42,060
So we need a semi-colon.

492
00:22:42,060 --> 00:22:47,720
I don't though need to remention
int, and why might that be?

493
00:22:47,720 --> 00:22:49,850
Yeah, I already told the
computer it's an integer.

494
00:22:49,850 --> 00:22:52,260
You don't need to repeat
yourself by mentioning int again,

495
00:22:52,260 --> 00:22:55,460
assuming in this context, even though
we're looking at it just on the slide,

496
00:22:55,460 --> 00:22:58,400
has actually been created
before just like you did

497
00:22:58,400 --> 00:23:00,380
with Scratch by saying make a variable.

498
00:23:00,380 --> 00:23:04,040
So it turns out you can be a little more
succinct in C and a lot of languages.

499
00:23:04,040 --> 00:23:07,410
If you find this a little tedious
to type-- and it's a little verbose.

500
00:23:07,410 --> 00:23:08,540
It's a bunch of keystrokes.

501
00:23:08,540 --> 00:23:10,450
You can actually abbreviate
it with just this.

502
00:23:10,450 --> 00:23:15,200
So plus equals is just syntactic
sugar, as a programmer would say.

503
00:23:15,200 --> 00:23:18,860
It's just a nice fancy feature that
lets you write fewer words or characters

504
00:23:18,860 --> 00:23:19,770
but do the same thing.

505
00:23:19,770 --> 00:23:21,400
And frankly, we can do a little better.

506
00:23:21,400 --> 00:23:24,360
And if you've taken a PCS, you might
have seen this in Java as well.

507
00:23:24,360 --> 00:23:29,330
You can also simplify this even more
to just counter plus plus semi-colon.

508
00:23:29,330 --> 00:23:30,660
So that's it-- all equivalent.

509
00:23:30,660 --> 00:23:32,210
This is just a little more efficient.

510
00:23:32,210 --> 00:23:34,040
And as you get more
comfortable programming,

511
00:23:34,040 --> 00:23:35,960
saving keystrokes just saves you time.

512
00:23:35,960 --> 00:23:40,130
Now this of course was an example
of what in Scratch by contrast?

513
00:23:40,130 --> 00:23:41,640
Yeah, we called this a condition.

514
00:23:41,640 --> 00:23:45,110
And it had a Boolean expression
that we were asking a question of.

515
00:23:45,110 --> 00:23:49,160
In this case, we're apparently asking
in Scratch is x less than y and, if so,

516
00:23:49,160 --> 00:23:50,540
say it on the screen.

517
00:23:50,540 --> 00:23:52,430
So how might we translate this to see?

518
00:23:52,430 --> 00:23:56,030
Well, it turns out we can quite simply
translate this one pretty literally.

519
00:23:56,030 --> 00:23:58,610
We've seen almost all of the
building blocks thus far,

520
00:23:58,610 --> 00:24:01,130
but we do have to introduce
a little something new here.

521
00:24:01,130 --> 00:24:04,340
Notice that the printf line
is almost identical to what

522
00:24:04,340 --> 00:24:05,840
I used earlier for just hello world.

523
00:24:05,840 --> 00:24:09,470
I've obviously just changed the words
in it, but I still have the backslash n.

524
00:24:09,470 --> 00:24:11,660
I still have the quotes,
still have the semi-colon.

525
00:24:11,660 --> 00:24:13,910
So the rest of that is the same.

526
00:24:13,910 --> 00:24:16,940
Now if is new, but this is
a one to one translation.

527
00:24:16,940 --> 00:24:17,870
Scratch calls it if.

528
00:24:17,870 --> 00:24:18,620
C calls it if.

529
00:24:18,620 --> 00:24:20,410
And the only additional
thing you need in C

530
00:24:20,410 --> 00:24:22,320
is parentheses around
the Boolean expression.

531
00:24:22,320 --> 00:24:25,400
So that's what takes the place
of the little green block there.

532
00:24:25,400 --> 00:24:28,100
And then assuming x and
y are indeed variables

533
00:24:28,100 --> 00:24:31,160
that we created earlier, you
can just compare them like this

534
00:24:31,160 --> 00:24:34,190
and you can use greater than and
other symbols for comparison as well.

535
00:24:34,190 --> 00:24:36,640
But there is something a little
interesting, and most of us

536
00:24:36,640 --> 00:24:39,560
don't often have occasion to even
use these keys on our keyboard.

537
00:24:39,560 --> 00:24:42,080
Curly braces, on a US
keyboard they tend to be

538
00:24:42,080 --> 00:24:44,690
over on the top right
above your Enter key.

539
00:24:44,690 --> 00:24:49,020
These are just C's
equivalent of this shape.

540
00:24:49,020 --> 00:24:51,860
Notice that most of the
yellow blocks in Scratch

541
00:24:51,860 --> 00:24:55,490
had this embracing or this
embracing shape to them.

542
00:24:55,490 --> 00:24:59,030
You can simulate that in C by having
what's called an open curly brace

543
00:24:59,030 --> 00:25:00,300
and then a closed curly brace.

544
00:25:00,300 --> 00:25:01,640
So that's the same exact idea.

545
00:25:01,640 --> 00:25:05,600
Now as an aside, you don't technically
always need these curly braces.

546
00:25:05,600 --> 00:25:07,700
If you just got a one
liner like this, you

547
00:25:07,700 --> 00:25:10,230
can omit them as you might
see online or in textbooks.

548
00:25:10,230 --> 00:25:13,280
But we'll just always draw them for
consistency so that the C code always

549
00:25:13,280 --> 00:25:16,740
looks like this.

550
00:25:16,740 --> 00:25:19,550
What if you wanted to
express this, though?

551
00:25:19,550 --> 00:25:24,890
If x is less than y, then say x is less
than y, else say x is not less than y.

552
00:25:24,890 --> 00:25:27,200
Well, it turns out this
is almost identical.

553
00:25:27,200 --> 00:25:30,830
The first four lines,
perfectly the same as before.

554
00:25:30,830 --> 00:25:33,050
But it turns out in C,
you can literally say else

555
00:25:33,050 --> 00:25:35,100
after that closing curly brace.

556
00:25:35,100 --> 00:25:38,390
And then just print out alternatively
whatever it is you want to say.

557
00:25:38,390 --> 00:25:40,070
So this is like the fork in the road.

558
00:25:40,070 --> 00:25:41,360
If you go one way, say this.

559
00:25:41,360 --> 00:25:44,570
If you go the other way,
say this other thing.

560
00:25:44,570 --> 00:25:46,850
Any questions on these
comparisons thus far?

561
00:25:46,850 --> 00:25:47,530
Yeah.

562
00:25:47,530 --> 00:25:52,000
AUDIENCE: Should we put the first
bracket on the same line as the if?

563
00:25:52,000 --> 00:25:53,560
DAVID: Really good question.

564
00:25:53,560 --> 00:25:56,260
Can you or do you put the curly
brace on the same line is the if?

565
00:25:56,260 --> 00:25:59,140
You can, and we're going to talk
about this the next couple of weeks,

566
00:25:59,140 --> 00:26:00,430
this matter of style.

567
00:26:00,430 --> 00:26:03,850
There are different ways I could
express this exact same code.

568
00:26:03,850 --> 00:26:08,690
Frankly, I could write out all of
this code with no spaces whatsoever.

569
00:26:08,690 --> 00:26:13,060
In fact, just to make that point, if I
go ahead and just open up a simple text

570
00:26:13,060 --> 00:26:13,930
editor here--

571
00:26:13,930 --> 00:26:16,870
not to actually program,
but to just type something--

572
00:26:16,870 --> 00:26:21,970
I could actually do something
like this if x less than y.

573
00:26:21,970 --> 00:26:28,090
Then go ahead and print out x is less
than y backslash n semi-colon curly

574
00:26:28,090 --> 00:26:30,610
brace else print and so forth--

575
00:26:30,610 --> 00:26:33,340
completely unreadable at the end
of the day or unmaintainable,

576
00:26:33,340 --> 00:26:35,110
especially when the
code gets complicated.

577
00:26:35,110 --> 00:26:37,930
But whitespace does not tend
to matter to the computer,

578
00:26:37,930 --> 00:26:39,280
but it does matter to the human.

579
00:26:39,280 --> 00:26:41,500
And as you're alluding
to in some languages,

580
00:26:41,500 --> 00:26:44,560
it's actually conventional to
do this, where you actually

581
00:26:44,560 --> 00:26:46,600
keep the curly brace on the same line.

582
00:26:46,600 --> 00:26:49,790
And indeed, you might see
textbooks do this as well.

583
00:26:49,790 --> 00:26:51,490
Some people will even do this.

584
00:26:51,490 --> 00:26:53,530
These are all long story
short matters of style.

585
00:26:53,530 --> 00:26:56,110
In CS50, in the earliest
weeks of the class,

586
00:26:56,110 --> 00:26:58,750
we're going to insist that
everyone follow the same style so

587
00:26:58,750 --> 00:27:00,650
that we have some basis for comparison.

588
00:27:00,650 --> 00:27:02,410
But eventually, this
is the kind of thing

589
00:27:02,410 --> 00:27:05,030
that, like in your own English
writing or whatever language you

590
00:27:05,030 --> 00:27:09,190
tend to write in, you have your own
stylistic or linguistic flair to it.

591
00:27:09,190 --> 00:27:10,830
Code has that as well.

592
00:27:10,830 --> 00:27:12,710
Other questions?

593
00:27:12,710 --> 00:27:13,910
Yeah.

594
00:27:13,910 --> 00:27:16,390
AUDIENCE: When you establish
the counter-variable,

595
00:27:16,390 --> 00:27:19,120
do you always have to
say what it is equal to,

596
00:27:19,120 --> 00:27:21,380
or can you just say int counter section?

597
00:27:21,380 --> 00:27:22,550
DAVID: Really good question.

598
00:27:22,550 --> 00:27:25,040
When you declare a
variable, create a variable,

599
00:27:25,040 --> 00:27:27,710
do you have to set it equal
to something right away?

600
00:27:27,710 --> 00:27:28,630
Short answer, no.

601
00:27:28,630 --> 00:27:31,380
And we'll see examples of that
before long, where you can actually

602
00:27:31,380 --> 00:27:34,640
say give me a variable called
counter, but don't actually

603
00:27:34,640 --> 00:27:36,290
set it equal to some value.

604
00:27:36,290 --> 00:27:38,540
Come back to that in a bit.

605
00:27:38,540 --> 00:27:40,610
So what if we want to add this logic?

606
00:27:40,610 --> 00:27:43,910
Frankly, in Scratch it's starting
to look a little overwhelming.

607
00:27:43,910 --> 00:27:45,830
But this is just a three
way fork in the road.

608
00:27:45,830 --> 00:27:50,630
If x is less than y, say so,
else if x is greater than y,

609
00:27:50,630 --> 00:27:56,450
say so, else if x equals y, then
go ahead and say they're equal.

610
00:27:56,450 --> 00:28:00,090
And in C, we can do this
translation pretty directly as well.

611
00:28:00,090 --> 00:28:02,480
In fact, now the first
eight lines of code

612
00:28:02,480 --> 00:28:05,390
are identical to before
except this middle one

613
00:28:05,390 --> 00:28:07,880
here where I'm adding a
second Boolean expression.

614
00:28:07,880 --> 00:28:09,890
Is x greater than y?

615
00:28:09,890 --> 00:28:13,220
And then I have this third
condition, else if x equals y.

616
00:28:13,220 --> 00:28:18,580
But there seems to be a typo
perhaps or something anomalous here.

617
00:28:18,580 --> 00:28:19,460
So anything jump out?

618
00:28:19,460 --> 00:28:21,900
Yeah.

619
00:28:21,900 --> 00:28:25,730
I have a double equal sign, which
maybe is just a typographical error

620
00:28:25,730 --> 00:28:27,440
on my part, but turns out it's not.

621
00:28:27,440 --> 00:28:29,210
This is deliberate.

622
00:28:29,210 --> 00:28:29,980
But why?

623
00:28:29,980 --> 00:28:32,690
This seems like our first example
of where Scratch doesn't really

624
00:28:32,690 --> 00:28:34,300
map perfectly to C?

625
00:28:34,300 --> 00:28:36,840
AUDIENCE: Well, because the
equal sign is like an assignment.

626
00:28:36,840 --> 00:28:40,000
And so counting the equal
sign actively sets it equal--

627
00:28:40,000 --> 00:28:40,630
DAVID: Exactly.

628
00:28:40,630 --> 00:28:45,250
We already a moment ago decided as
humans-- or really, years ago-- equals

629
00:28:45,250 --> 00:28:47,950
is actually in the context of
C going to be assignment-- copy

630
00:28:47,950 --> 00:28:50,320
the value from the right
to the value on the left.

631
00:28:50,320 --> 00:28:52,450
And so we kind of painted
ourselves into a corner.

632
00:28:52,450 --> 00:28:54,460
We still as humans, as
programmers, want to be

633
00:28:54,460 --> 00:28:57,610
able to express the notion
of equality and comparing.

634
00:28:57,610 --> 00:29:00,010
But if we've already used the
equal sign for assignment,

635
00:29:00,010 --> 00:29:03,300
we need another pattern of
symbols to represent equality.

636
00:29:03,300 --> 00:29:06,850
And as it turns out, humans just
chose two equal signs instead--

637
00:29:06,850 --> 00:29:08,590
so slightly different from Scratch.

638
00:29:08,590 --> 00:29:10,690
The reason Scratch does it this
way is because you don't really

639
00:29:10,690 --> 00:29:12,640
want to have to get into
those weeds certainly

640
00:29:12,640 --> 00:29:14,530
when the target audience
is 8-year-olds just

641
00:29:14,530 --> 00:29:15,880
learning to program in the first place.

642
00:29:15,880 --> 00:29:18,280
It's not important nor is
it really important for us.

643
00:29:18,280 --> 00:29:22,000
But for us there's going
to be a logical difference

644
00:29:22,000 --> 00:29:24,840
because, if we use the wrong one,
the behavior is going to be wrong.

645
00:29:24,840 --> 00:29:29,470
If we had just one equal sign, we would
literally be changing x to equal y

646
00:29:29,470 --> 00:29:31,460
rather than just comparing it.

647
00:29:31,460 --> 00:29:33,520
Was there a hand in here?

648
00:29:33,520 --> 00:29:34,020
Yeah.

649
00:29:34,020 --> 00:29:34,960
AUDIENCE: Just a quick question.

650
00:29:34,960 --> 00:29:37,310
So if you wanted to express
greater than or equal to,

651
00:29:37,310 --> 00:29:39,330
would you write equal and greater than?

652
00:29:39,330 --> 00:29:40,210
DAVID: Good question.

653
00:29:40,210 --> 00:29:43,450
If you wanted to express greater than
or equal to, how might you do that?

654
00:29:43,450 --> 00:29:45,490
It turns out there are ways to do that.

655
00:29:45,490 --> 00:29:49,320
And if I go ahead and just give myself
someplace to draw here for a moment,

656
00:29:49,320 --> 00:29:55,240
you can actually indeed do less than
or equal or greater than or equal.

657
00:29:55,240 --> 00:29:57,970
There's no way on a typical
keyboard to put them atop each other

658
00:29:57,970 --> 00:29:59,270
like you might recall for math.

659
00:29:59,270 --> 00:30:00,810
You just put them next to each other.

660
00:30:04,460 --> 00:30:05,300
Well, it depends.

661
00:30:05,300 --> 00:30:08,150
I want the double equal
sign here because I

662
00:30:08,150 --> 00:30:14,270
want to explicitly check this
third case and say x is equal to y.

663
00:30:14,270 --> 00:30:15,320
So that was my goal.

664
00:30:15,320 --> 00:30:17,120
But logically, this is not necessary.

665
00:30:17,120 --> 00:30:19,640
Let's make the program a
little better designed.

666
00:30:19,640 --> 00:30:24,020
How many possible cases are there
when comparing two integers, x

667
00:30:24,020 --> 00:30:27,890
and y, for greater than,
less than, or equality?

668
00:30:27,890 --> 00:30:31,750
Well, I kinda of just answered
the question, didn't I?

669
00:30:31,750 --> 00:30:32,330
Three.

670
00:30:32,330 --> 00:30:32,930
Excellent!

671
00:30:32,930 --> 00:30:36,680
There's three scenarios there-- x
is either less than or greater than

672
00:30:36,680 --> 00:30:37,460
or equal to.

673
00:30:37,460 --> 00:30:40,550
And I'm hard pressed
to think of a fourth.

674
00:30:40,550 --> 00:30:45,650
So do I need this amount of specificity?

675
00:30:45,650 --> 00:30:48,440
What could I do to give
myself a slight optimization,

676
00:30:48,440 --> 00:30:50,690
improve the code just a
little bit just to save myself

677
00:30:50,690 --> 00:30:53,140
a little bit of time writing
it and maybe even the computer

678
00:30:53,140 --> 00:30:54,270
a little time running it?

679
00:30:54,270 --> 00:30:54,950
Yeah.

680
00:30:54,950 --> 00:30:55,890
AUDIENCE: You don't
need the last condition.

681
00:30:55,890 --> 00:30:58,090
DAVID: Yeah, I don't need
the last condition because,

682
00:30:58,090 --> 00:31:02,150
if we all agree logically that either
x is less than y or greater than y

683
00:31:02,150 --> 00:31:05,390
or maybe equal to y, well, if there's
only a third and final case that

684
00:31:05,390 --> 00:31:06,770
can just be my so-called else.

685
00:31:06,770 --> 00:31:08,870
Just make that be the
so-called default case.

686
00:31:08,870 --> 00:31:11,750
And in fact, even though this
is what most people would

687
00:31:11,750 --> 00:31:15,140
call an over optimization, you
are saving the computer some time.

688
00:31:15,140 --> 00:31:17,690
Because suppose that
x does in fact equal y

689
00:31:17,690 --> 00:31:19,520
and they're both the value number 1.

690
00:31:19,520 --> 00:31:24,650
So is 1 less than 1 when this
line of code is executed?

691
00:31:24,650 --> 00:31:25,700
Yes or no?

692
00:31:25,700 --> 00:31:26,700
No, obviously not.

693
00:31:26,700 --> 00:31:27,830
1 is not less than 1.

694
00:31:27,830 --> 00:31:29,330
So this code does not execute.

695
00:31:29,330 --> 00:31:31,670
But the Boolean expression
is evaluated, so to speak.

696
00:31:31,670 --> 00:31:33,050
The question is asked.

697
00:31:33,050 --> 00:31:35,000
Is 1 greater than 1?

698
00:31:35,000 --> 00:31:38,690
No, and so this code is not executed,
but this Boolean expression is.

699
00:31:38,690 --> 00:31:42,770
So we just spent another step or
second or however fast the computer is.

700
00:31:42,770 --> 00:31:45,020
Is 1 equal to 1?

701
00:31:45,020 --> 00:31:45,600
Yeah, it is.

702
00:31:45,600 --> 00:31:46,970
So this actually prints.

703
00:31:46,970 --> 00:31:49,270
But to your point, you don't
need to ask that question.

704
00:31:49,270 --> 00:31:52,230
And in fact, you just
increased by a factor of 50%

705
00:31:52,230 --> 00:31:54,200
how many questions you're asking.

706
00:31:54,200 --> 00:31:56,060
So you just wasted a little bit of time.

707
00:31:56,060 --> 00:31:57,950
Now as an aside, our
Macs and PCs and phones

708
00:31:57,950 --> 00:32:00,620
these days, I mean, again, they're
operating at like a gigahertz

709
00:32:00,620 --> 00:32:02,880
speed, one billion things per second.

710
00:32:02,880 --> 00:32:06,260
So in practice, who cares if
you're asking that third question?

711
00:32:06,260 --> 00:32:10,520
And frankly, if it makes your code more
readable or to your teaching fellow

712
00:32:10,520 --> 00:32:13,400
or to a colleague or friend who's
working on the program for you,

713
00:32:13,400 --> 00:32:14,150
then that's great.

714
00:32:14,150 --> 00:32:17,460
If it's more clear from the code
what's going on, leave it that way.

715
00:32:17,460 --> 00:32:20,300
But these are the kinds of design
decisions that we'll now make.

716
00:32:20,300 --> 00:32:24,560
And arguably this version of the scratch
program and this version of the C code

717
00:32:24,560 --> 00:32:26,780
is just a little better
designed because why

718
00:32:26,780 --> 00:32:32,030
write more code than you need
to express the exact same idea.

719
00:32:32,030 --> 00:32:33,080
So what about this?

720
00:32:33,080 --> 00:32:34,640
This was a loop in Scratch.

721
00:32:34,640 --> 00:32:38,060
This was an infinite loop because it
was just forever saying hello world.

722
00:32:38,060 --> 00:32:40,770
Now in C, this gets a little
less directly translated.

723
00:32:40,770 --> 00:32:43,370
It turns out c uses the key word while.

724
00:32:43,370 --> 00:32:47,150
So there is no forever keyword in
C, but there is the word while.

725
00:32:47,150 --> 00:32:50,210
And of course, I'm going
to use my curly braces--

726
00:32:50,210 --> 00:32:54,200
curly braces, curly brackets to
encompass the following lines of code.

727
00:32:54,200 --> 00:32:56,570
The line of code I want in
there is just another printf.

728
00:32:56,570 --> 00:33:00,950
So that's the exact same as before, but
it's not sufficient to just say while.

729
00:33:00,950 --> 00:33:05,630
It turns out that while wants you
to ask it a question every time

730
00:33:05,630 --> 00:33:06,780
the loop executes.

731
00:33:06,780 --> 00:33:08,370
And it's going to check that question.

732
00:33:08,370 --> 00:33:10,680
And if the answer is yes,
it's going to run the loop.

733
00:33:10,680 --> 00:33:14,780
But if the answer being asked
in C is ever no or false,

734
00:33:14,780 --> 00:33:16,780
it's going to not execute
the code and it's just

735
00:33:16,780 --> 00:33:20,090
going to move on to any further
lines of code lower down in the file.

736
00:33:20,090 --> 00:33:23,870
So in C, you actually need a pair
parentheses after the keyword while.

737
00:33:23,870 --> 00:33:26,120
And then you need to ask a question.

738
00:33:26,120 --> 00:33:29,210
You need to ask a question
like, is x less than y

739
00:33:29,210 --> 00:33:32,870
or a question like is x greater
than y or is x equal to y.

740
00:33:32,870 --> 00:33:35,870
But none of those scenarios
apply because the whole purpose

741
00:33:35,870 --> 00:33:39,410
of this Scratch block is
literally to do something forever.

742
00:33:39,410 --> 00:33:44,010
So what's a question we could ask
to which the answer is surely true?

743
00:33:46,680 --> 00:33:47,730
Does 1 equal 1?

744
00:33:47,730 --> 00:33:51,540
We could contrive an arbitrary but very
met mathematically correct scenario.

745
00:33:51,540 --> 00:33:53,850
We can just say just 1 equal equal 1.

746
00:33:53,850 --> 00:33:57,240
But it turns out you can be even
more succinct because in C there's

747
00:33:57,240 --> 00:34:01,230
a couple of keywords, one of which
is true, one of which is false.

748
00:34:01,230 --> 00:34:04,080
And the word true is by
definition always true,

749
00:34:04,080 --> 00:34:06,210
and the word false is by
definition always false.

750
00:34:06,210 --> 00:34:09,420
So you don't need to contrive
some arbitrary but correct idea

751
00:34:09,420 --> 00:34:12,770
of does 1 equal equal 1
or does 50 equal equal 50.

752
00:34:12,770 --> 00:34:15,270
You don't need to just come up
with some arbitrary solution.

753
00:34:15,270 --> 00:34:20,460
You can literally just say true because
that key word true never changes value.

754
00:34:20,460 --> 00:34:22,380
So even though this is
a little weird looking,

755
00:34:22,380 --> 00:34:26,010
it's how you induce
something to happen forever.

756
00:34:26,010 --> 00:34:29,250
You asked the same question again
and assume that the question always

757
00:34:29,250 --> 00:34:30,800
has the same answer of true.

758
00:34:30,800 --> 00:34:34,060
Any questions on that one?

759
00:34:34,060 --> 00:34:36,500
Yeah, in the back.

760
00:34:36,500 --> 00:34:37,630
AUDIENCE: Do spaces matter?

761
00:34:37,630 --> 00:34:39,850
Can you take out the
space between y and 0?

762
00:34:39,850 --> 00:34:40,730
DAVID: Good question.

763
00:34:40,730 --> 00:34:42,290
Do spaces matter?

764
00:34:42,290 --> 00:34:44,480
Short answer, no, not in this case.

765
00:34:44,480 --> 00:34:47,480
You can in fact delete
all of the space here

766
00:34:47,480 --> 00:34:49,190
except for the one in
the English phrase,

767
00:34:49,190 --> 00:34:51,440
and it would still be
functionally correct.

768
00:34:51,440 --> 00:34:53,450
You can even add spaces
anywhere you want.

769
00:34:53,450 --> 00:34:55,910
You can make this taller by
hitting Enter a bunch of times,

770
00:34:55,910 --> 00:34:58,070
tabs, spaces around the word true.

771
00:34:58,070 --> 00:35:01,820
All of the examples I"ll show here today
and you'll see in the coming weeks are

772
00:35:01,820 --> 00:35:04,420
the better way to do things
because they're more readable.

773
00:35:04,420 --> 00:35:06,110
But again, as you get
more comfortable with code

774
00:35:06,110 --> 00:35:07,690
or if you're coming in
with some prior experience,

775
00:35:07,690 --> 00:35:09,260
you might already have
your own opinions.

776
00:35:09,260 --> 00:35:11,180
And frankly, this is
just a religious debate

777
00:35:11,180 --> 00:35:13,730
among programmers, which is the
right way to write your code.

778
00:35:13,730 --> 00:35:14,310
And that's fine.

779
00:35:14,310 --> 00:35:17,510
Once you get comfy, so long as you're
consistent is the most important thing.

780
00:35:17,510 --> 00:35:20,150
You don't need to adhere to
one person's or the other.

781
00:35:20,150 --> 00:35:21,880
So how does this code work logically?

782
00:35:21,880 --> 00:35:24,620
Well, the first thing the computer,
your Mac or PC or your phone

783
00:35:24,620 --> 00:35:27,440
or whatever is going to do,
it's going to ask the question.

784
00:35:27,440 --> 00:35:28,010
Well, true.

785
00:35:28,010 --> 00:35:29,310
Well, true is always true.

786
00:35:29,310 --> 00:35:31,520
So it's going to proceed to
execute the line of code.

787
00:35:31,520 --> 00:35:34,550
But after it does, because that's
the entirety of the code that's

788
00:35:34,550 --> 00:35:36,800
in between the curly braces,
we could have more lines.

789
00:35:36,800 --> 00:35:38,780
These are just short programs.

790
00:35:38,780 --> 00:35:41,690
The computer is going to
check, OK, is true still true.

791
00:35:41,690 --> 00:35:42,400
Yes.

792
00:35:42,400 --> 00:35:43,900
So it's going to execute it again.

793
00:35:43,900 --> 00:35:45,110
Then it's going to ask
the question again.

794
00:35:45,110 --> 00:35:46,250
Is true still true?

795
00:35:46,250 --> 00:35:48,380
Yes, so it's going to
execute the code again,

796
00:35:48,380 --> 00:35:52,300
and this is going to
repeat literally forever.

797
00:35:52,300 --> 00:35:54,600
But what if you don't want
to repeat something forever?

798
00:35:54,600 --> 00:35:56,430
What if you only want
to repeat it 50 times?

799
00:35:56,430 --> 00:35:58,660
Scratch doesn't make you
think very hard about this.

800
00:35:58,660 --> 00:36:02,660
People just figure out how to keep
track of 1, 2, 3, 4, 5, and all the way

801
00:36:02,660 --> 00:36:04,160
up to 50 and then stop.

802
00:36:04,160 --> 00:36:04,670
That's nice.

803
00:36:04,670 --> 00:36:06,410
It makes it easy to use the block.

804
00:36:06,410 --> 00:36:10,850
C and a lot of languages aren't
quite that user friendly.

805
00:36:10,850 --> 00:36:13,550
You will see later in the
semester that newer languages are

806
00:36:13,550 --> 00:36:15,590
a little closer to what Scratch offers.

807
00:36:15,590 --> 00:36:17,930
But in C, we need to be
more explicit, but this

808
00:36:17,930 --> 00:36:20,590
is a chance to use some of these
more primitive building blocks.

809
00:36:20,590 --> 00:36:26,660
In C, the equivalent of repeat is going
to be the proposition for just because,

810
00:36:26,660 --> 00:36:27,590
for now.

811
00:36:27,590 --> 00:36:30,410
And then, just as before,
if we want to do something

812
00:36:30,410 --> 00:36:32,390
again and again within
this loop, we're going

813
00:36:32,390 --> 00:36:35,780
to use the curly braces, similar
to the little orange block there.

814
00:36:35,780 --> 00:36:37,080
And then what am I going to do?

815
00:36:37,080 --> 00:36:41,660
I'm going to do this every time, 50
times hopefully, print out hello world.

816
00:36:41,660 --> 00:36:44,570
So now I just need to figure
out and see how to express

817
00:36:44,570 --> 00:36:47,390
the number of times specifically 50.

818
00:36:47,390 --> 00:36:50,240
So it turns out in C--
use parentheses again--

819
00:36:50,240 --> 00:36:53,390
this is going to be a pretty common
characteristic of a lot of the code

820
00:36:53,390 --> 00:36:54,270
we write.

821
00:36:54,270 --> 00:36:56,210
And then you need to do three things.

822
00:36:56,210 --> 00:36:59,210
The burden is now going
to be on us the programmer

823
00:36:59,210 --> 00:37:04,460
to keep track of how many times we want
to execute this code to how many times

824
00:37:04,460 --> 00:37:07,850
we've already executed this code
and then constantly make sure

825
00:37:07,850 --> 00:37:09,410
that one does not exceed the other.

826
00:37:09,410 --> 00:37:11,540
So we stop once we hit 50.

827
00:37:11,540 --> 00:37:15,440
So what's the fundamental construct
that we use to keep track of anything

828
00:37:15,440 --> 00:37:17,550
in a program?

829
00:37:17,550 --> 00:37:19,760
A counter, which was an
example of a variable.

830
00:37:19,760 --> 00:37:21,530
So we just need to use a variable.

831
00:37:21,530 --> 00:37:24,320
Now it's actually going to be
inside of the parentheses this time.

832
00:37:24,320 --> 00:37:28,120
So it's not on its own as it was just
a bit ago, but the syntax is the same.

833
00:37:28,120 --> 00:37:31,600
I could call it counter, but the reality
is that the convention in programming

834
00:37:31,600 --> 00:37:34,700
is just to use shorter variables when
you're just doing something mundane.

835
00:37:34,700 --> 00:37:36,190
And if all you're doing is looping--

836
00:37:36,190 --> 00:37:40,090
i stands for integer, is sort of
many programmers' go-to variable name

837
00:37:40,090 --> 00:37:43,240
rather than the more verbose
but correct counter or whatever.

838
00:37:43,240 --> 00:37:47,080
So this says, hey, computer,
give me a variable called i.

839
00:37:47,080 --> 00:37:52,030
Let me store integers or ints in
it and set the initial value to 0.

840
00:37:52,030 --> 00:37:52,750
Why?

841
00:37:52,750 --> 00:37:56,290
Well, almost everyone in this room
probably starts counting from 1.

842
00:37:56,290 --> 00:37:59,080
Computers just tend to
start counting from 0.

843
00:37:59,080 --> 00:37:59,580
But why?

844
00:37:59,580 --> 00:38:01,620
What's the rationale for
starting to count from 0

845
00:38:01,620 --> 00:38:02,750
perhaps based on last week?

846
00:38:06,570 --> 00:38:07,990
Why does that kind of makes sense?

847
00:38:07,990 --> 00:38:09,210
Yeah, what do you think?

848
00:38:09,210 --> 00:38:11,760
AUDIENCE: Well, because it's
ones and zeros, and it's binary.

849
00:38:11,760 --> 00:38:14,580
DAVID: Yeah, it's just
ones and zeros, and what's

850
00:38:14,580 --> 00:38:16,380
the smallest number,
negative values aside,

851
00:38:16,380 --> 00:38:17,790
that you can represent in binary?

852
00:38:17,790 --> 00:38:20,550
Well, it's just 0, 0,
0, a bunch of zeros.

853
00:38:20,550 --> 00:38:23,130
So why would you waste
that representation,

854
00:38:23,130 --> 00:38:24,180
that permutation of bits?

855
00:38:24,180 --> 00:38:26,880
Let's just start counting
at 0 and then add to that.

856
00:38:26,880 --> 00:38:31,170
So you can start counting from 1 in C,
but the convention in most languages

857
00:38:31,170 --> 00:38:31,830
is count from 0.

858
00:38:31,830 --> 00:38:33,420
So we'll get off on that foot as well.

859
00:38:33,420 --> 00:38:37,900
And you might recall even that in our
PBJ, for the peanut butter and jelly--

860
00:38:37,900 --> 00:38:40,350
not for the PDJ code--

861
00:38:40,350 --> 00:38:43,380
for the phone pseudo code, I
actually deliberately started

862
00:38:43,380 --> 00:38:47,280
numbering the lines from 0 to
1 to 2 for that same intuition.

863
00:38:47,280 --> 00:38:50,820
So here's how you then say to
the computer check, if you would,

864
00:38:50,820 --> 00:38:51,980
whether i is less than 50.

865
00:38:51,980 --> 00:38:54,230
Now, initially it's obviously
going to be less than 50

866
00:38:54,230 --> 00:38:56,550
because zero is less than 50
but that same condition is

867
00:38:56,550 --> 00:39:00,480
going to be checked again and again
and again as this loop executes.

868
00:39:00,480 --> 00:39:05,870
And then recall from before, we can just
plus plus a variable to add 1 to it.

869
00:39:05,870 --> 00:39:07,830
We can do this more verbosely.

870
00:39:07,830 --> 00:39:10,650
We could say i equals
i plus 1, but it's just

871
00:39:10,650 --> 00:39:13,260
more conventional to
write i plus plus just

872
00:39:13,260 --> 00:39:15,090
to say the same thing more tersely.

873
00:39:15,090 --> 00:39:16,520
So what happens next logically?

874
00:39:16,520 --> 00:39:17,730
That's the code I've written.

875
00:39:17,730 --> 00:39:19,240
What does the computer do with it?

876
00:39:19,240 --> 00:39:23,440
Well, it initialises i to 0 and
prepare to store integers in it.

877
00:39:23,440 --> 00:39:27,120
It checks the condition just in case
you initialized it too big of a value.

878
00:39:27,120 --> 00:39:29,070
You might not want the
loop to execute at all.

879
00:39:29,070 --> 00:39:31,390
But obviously 0 is less than 50.

880
00:39:31,390 --> 00:39:33,750
So this line of code executes.

881
00:39:33,750 --> 00:39:37,270
Take a guess as to what happens next.

882
00:39:37,270 --> 00:39:39,140
Yeah, you probably
want to do i plus plus

883
00:39:39,140 --> 00:39:41,470
because you're done executing
all the lines of code

884
00:39:41,470 --> 00:39:43,910
in between the curly braces,
even though there's just one.

885
00:39:43,910 --> 00:39:45,410
So let's go ahead and increment i.

886
00:39:45,410 --> 00:39:47,190
So i is now 1.

887
00:39:47,190 --> 00:39:49,160
Let's now make sure-- is 1 less than 50?

888
00:39:49,160 --> 00:39:50,120
Obviously.

889
00:39:50,120 --> 00:39:51,390
Execute the code.

890
00:39:51,390 --> 00:39:54,170
I plus plus-- is 2 less than 50.

891
00:39:54,170 --> 00:39:59,390
Obviously execute the code. i plus
plus-- is 3 less than 50, obviously.

892
00:39:59,390 --> 00:40:03,290
Now go ahead and execute the code,
and again and again and again.

893
00:40:03,290 --> 00:40:09,620
And at some point, we're going to get up
to i equals 49, and is 49 less than 50?

894
00:40:09,620 --> 00:40:10,190
Obviously.

895
00:40:10,190 --> 00:40:12,500
So we print out hello world.

896
00:40:12,500 --> 00:40:17,570
And then i plus plus kicks in,
and then it's, is 50 less than 50.

897
00:40:17,570 --> 00:40:18,170
No.

898
00:40:18,170 --> 00:40:20,480
So wait that feels like
a logical error, no?

899
00:40:20,480 --> 00:40:24,440
Should I be checking if i
is less than or equal to 50?

900
00:40:24,440 --> 00:40:26,630
Yeah, because if I
started from 0, I already

901
00:40:26,630 --> 00:40:28,190
spent that one additional cycle.

902
00:40:28,190 --> 00:40:34,100
So I can count from 0 through 49 which
seems to work or from 1 through 50,

903
00:40:34,100 --> 00:40:36,320
but the convention in
programming honestly

904
00:40:36,320 --> 00:40:38,330
is typically to start
counting at some value

905
00:40:38,330 --> 00:40:43,370
and then count up to but not
through some value just because.

906
00:40:43,370 --> 00:40:46,460
But logically, you can implement this
in half a dozen different ways most

907
00:40:46,460 --> 00:40:47,560
likely.

908
00:40:47,560 --> 00:40:49,520
Let's look at one final
example that allowed us

909
00:40:49,520 --> 00:40:52,040
to actually get user input in Scratch.

910
00:40:52,040 --> 00:40:54,590
Recall that we used this
block to actually get

911
00:40:54,590 --> 00:40:57,140
the name of someone in
lecture, and we also

912
00:40:57,140 --> 00:41:00,950
in the animation with the gingerbread
house used it to get yes or no--

913
00:41:00,950 --> 00:41:03,120
do you want the cupcake
or the apple or the like.

914
00:41:03,120 --> 00:41:05,390
So this is an example
of a function in Scratch

915
00:41:05,390 --> 00:41:09,170
that actually takes input like
the sentence what's your name,

916
00:41:09,170 --> 00:41:12,140
but it also returns a
value, which in this case

917
00:41:12,140 --> 00:41:15,200
was just hard coded in Scratch
by MIT to be called answer.

918
00:41:15,200 --> 00:41:17,240
So it's like a special
variable called answer,

919
00:41:17,240 --> 00:41:20,610
but effectively it's being
handed back to the user.

920
00:41:20,610 --> 00:41:22,580
So how might we think about this?

921
00:41:22,580 --> 00:41:26,840
In C it turns out that you can express
this line of code a little more

922
00:41:26,840 --> 00:41:30,440
verbosely than before but using a
new function called get string--

923
00:41:30,440 --> 00:41:32,840
so get underscore string is
the name of the function.

924
00:41:32,840 --> 00:41:35,840
The underscore is convention in C.
If you ever want to have a space,

925
00:41:35,840 --> 00:41:37,840
you can't have spaces in
the names of functions.

926
00:41:37,840 --> 00:41:41,960
So people just started using underscores
like you might in your own social media

927
00:41:41,960 --> 00:41:44,780
user names and the like-- is
a convention there as well.

928
00:41:44,780 --> 00:41:48,200
Here's the sentence I
want to display, and I'm

929
00:41:48,200 --> 00:41:50,510
going to start calling this
more formally a string.

930
00:41:50,510 --> 00:41:53,870
A string in a programming language
is just a sequence of characters.

931
00:41:53,870 --> 00:41:56,610
It's a word, it's a phrase, it's
a character, it's a paragraph.

932
00:41:56,610 --> 00:41:57,320
This is a string.

933
00:41:57,320 --> 00:41:59,540
Anything between double
quotes is a string in C,

934
00:41:59,540 --> 00:42:03,020
and the backslash n it's
just end of line as before.

935
00:42:03,020 --> 00:42:05,120
We still already have
the semi-colon, but this

936
00:42:05,120 --> 00:42:08,750
isn't quite a literal translation
of what's going on just yet

937
00:42:08,750 --> 00:42:13,020
because I also now need to
do something with the answer.

938
00:42:13,020 --> 00:42:16,820
So if get string is a function that
actually gets input from the user,

939
00:42:16,820 --> 00:42:20,990
as via his or her keyboard, just
like the blue block in Scratch, in C

940
00:42:20,990 --> 00:42:23,030
we need to be a little
more explicit as to where

941
00:42:23,030 --> 00:42:28,520
we're putting the return value from that
function, what it is it's handing back.

942
00:42:28,520 --> 00:42:30,950
And so I can store in a
variable called answer.

943
00:42:30,950 --> 00:42:32,720
I could call it anything I want.

944
00:42:32,720 --> 00:42:35,980
But for consistency with
Scratch, let's call it answer.

945
00:42:35,980 --> 00:42:40,710
But recall what we have to do in
C anytime we create a variable.

946
00:42:40,710 --> 00:42:41,840
We have to be more precise.

947
00:42:41,840 --> 00:42:42,440
Yeah.

948
00:42:42,440 --> 00:42:44,070
AUDIENCE: Define its class as a string.

949
00:42:44,070 --> 00:42:46,350
DAVID: We have to define its--
let me call it a type or class,

950
00:42:46,350 --> 00:42:47,870
if you've taken a previous class.

951
00:42:47,870 --> 00:42:51,180
It's type and it's not going to be an
int because probably the words being

952
00:42:51,180 --> 00:42:52,410
typed in are not numbers.

953
00:42:52,410 --> 00:42:54,910
It's going to be this time
what I just called it a string.

954
00:42:54,910 --> 00:42:58,020
And so, indeed, we would
declare the variable on the left

955
00:42:58,020 --> 00:43:00,900
by saying give me a
string, call it answer,

956
00:43:00,900 --> 00:43:03,530
and assign to it
whatever's on the right.

957
00:43:03,530 --> 00:43:04,620
Well, what's on the right?

958
00:43:04,620 --> 00:43:06,540
What is on the right is
whatever this function

959
00:43:06,540 --> 00:43:12,160
get string comes back with and
gets stored from right to left.

960
00:43:12,160 --> 00:43:15,660
So how do I now say this person's name?

961
00:43:15,660 --> 00:43:18,930
Well, in Scratch I just say and then
I drag and drop the answer variable,

962
00:43:18,930 --> 00:43:19,980
and it's done.

963
00:43:19,980 --> 00:43:22,680
What's the function in C with
which we can say something, though,

964
00:43:22,680 --> 00:43:23,770
on the screen?

965
00:43:23,770 --> 00:43:26,730
So printf, print a formatted string,
even though we haven't really seen

966
00:43:26,730 --> 00:43:28,500
any formatting yet until now.

967
00:43:28,500 --> 00:43:32,700
It turns out in C, You
have to actually tell

968
00:43:32,700 --> 00:43:38,760
d if you're not passing in a
hard coded string or sentence,

969
00:43:38,760 --> 00:43:43,800
you have to pass to printf what's called
a format code or a format string--

970
00:43:43,800 --> 00:43:46,050
this first input to printf.

971
00:43:46,050 --> 00:43:48,610
Now printf apparently
seems to take two things.

972
00:43:48,610 --> 00:43:50,580
The first is this one before the comma.

973
00:43:50,580 --> 00:43:52,380
The second is the thing after the comma.

974
00:43:52,380 --> 00:43:55,740
And we've not seen this
before yet in C. So printf

975
00:43:55,740 --> 00:43:59,840
is being told, go ahead and print
out a string that looks like this.

976
00:43:59,840 --> 00:44:03,990
Percent S is a placeholder,
and S stands for string.

977
00:44:03,990 --> 00:44:05,790
And that literally is
a placeholder saying,

978
00:44:05,790 --> 00:44:11,400
printf, I'm going to give you a
string to plug in to this first input.

979
00:44:11,400 --> 00:44:12,420
What is that string?

980
00:44:12,420 --> 00:44:14,220
Literally, the answer variable.

981
00:44:14,220 --> 00:44:16,350
Now it feels like we're
jumping through hoops here.

982
00:44:16,350 --> 00:44:19,220
It would have been nice to just say
printf, open parenthesis, answer,

983
00:44:19,220 --> 00:44:21,670
close parenthesis, semi-colon,
and be done with it.

984
00:44:21,670 --> 00:44:23,420
That's just not the way printf works.

985
00:44:23,420 --> 00:44:25,380
In older versions, you
could maybe do something

986
00:44:25,380 --> 00:44:26,580
a little more simple like that.

987
00:44:26,580 --> 00:44:28,990
But honestly, we're not typically
going to be printing out

988
00:44:28,990 --> 00:44:30,200
just what the human typed in.

989
00:44:30,200 --> 00:44:32,620
After all, this is kind of a
stupid example at the moment.

990
00:44:32,620 --> 00:44:33,570
I'm typing in a word.

991
00:44:33,570 --> 00:44:34,890
You're just saying it on the screen.

992
00:44:34,890 --> 00:44:36,970
We already decided in
Scratch that's kind of lame.

993
00:44:36,970 --> 00:44:39,810
It'd would be nice to at least
have the program, not just

994
00:44:39,810 --> 00:44:44,640
say David or whatever the name
is-- but what did we do last time?

995
00:44:44,640 --> 00:44:46,660
Like hello comma David.

996
00:44:46,660 --> 00:44:50,280
But this would seem to
give us that capability.

997
00:44:50,280 --> 00:44:54,210
Right now I'm literally just
printing out the human's name in C,

998
00:44:54,210 --> 00:44:57,690
but let me change this ever so
slightly just as we did in Scratch.

999
00:44:57,690 --> 00:45:03,030
Recall that in C we did this green
block of join where I literally

1000
00:45:03,030 --> 00:45:04,810
get past join two arguments.

1001
00:45:04,810 --> 00:45:07,420
The first one was hello comma space.

1002
00:45:07,420 --> 00:45:09,840
The second one was answer,
and this concatenated.

1003
00:45:09,840 --> 00:45:12,410
This combined back to
back those two strings.

1004
00:45:12,410 --> 00:45:16,000
Well, in C, thanks to printf,
we can do that same thing.

1005
00:45:16,000 --> 00:45:17,790
It's just a different syntax.

1006
00:45:17,790 --> 00:45:23,190
Printf still gets one argument first,
that is, the string you want to format,

1007
00:45:23,190 --> 00:45:24,990
ergo the F in printf.

1008
00:45:24,990 --> 00:45:30,930
But this time I'm going to literally
say H-E-L-L-O comma space percent S

1009
00:45:30,930 --> 00:45:34,780
for string and then give
printf a second argument,

1010
00:45:34,780 --> 00:45:38,520
which is its instruction to go ahead
and plug in whatever this variable is

1011
00:45:38,520 --> 00:45:42,440
to whatever this placeholder is.

1012
00:45:42,440 --> 00:45:45,650
And so here we've now joined the
two strings effectively and thus

1013
00:45:45,650 --> 00:45:50,670
was born our first formatted string.

1014
00:45:50,670 --> 00:45:53,750
Well, any questions then on that?

1015
00:45:53,750 --> 00:45:54,670
Yeah.

1016
00:45:54,670 --> 00:45:58,120
AUDIENCE: What if you wanted to
say something extra after it?

1017
00:45:58,120 --> 00:46:00,570
DAVID: What if you want to
say something extra after?

1018
00:46:00,570 --> 00:46:02,260
You could certainly continue the logic.

1019
00:46:02,260 --> 00:46:05,070
You don't have to end
this quoted expression

1020
00:46:05,070 --> 00:46:08,520
with percent S. You could
say, hello, comma percent S

1021
00:46:08,520 --> 00:46:10,440
comma, nice to meet you.

1022
00:46:10,440 --> 00:46:12,690
And then what printf
will do is it's only

1023
00:46:12,690 --> 00:46:16,980
going to substitute that variable
called answer where the percent S is.

1024
00:46:16,980 --> 00:46:20,820
And if you want to give 2% S's, you
could just add another comma here

1025
00:46:20,820 --> 00:46:23,490
and pass in another variable and
a third variable and even more,

1026
00:46:23,490 --> 00:46:26,730
thus formatting the
string even more detailed.

1027
00:46:26,730 --> 00:46:27,580
Question over here.

1028
00:46:27,580 --> 00:46:28,080
Yeah.

1029
00:46:28,080 --> 00:46:28,840
Other questions?

1030
00:46:28,840 --> 00:46:30,720
Yeah, in the back.

1031
00:46:30,720 --> 00:46:33,390
AUDIENCE: How do you make a
distinction between the placeholders

1032
00:46:33,390 --> 00:46:34,720
if you have different variables?

1033
00:46:34,720 --> 00:46:37,340
DAVID: How do you make a
distinction between the placeholders

1034
00:46:37,340 --> 00:46:38,690
if you have different variables?

1035
00:46:38,690 --> 00:46:40,410
It's the ordering from left to right.

1036
00:46:40,410 --> 00:46:42,710
So in this case, it's a
trivial example because there's

1037
00:46:42,710 --> 00:46:44,990
only one variable and one placeholder.

1038
00:46:44,990 --> 00:46:48,110
But if as you were hinting, I had
multiple percent S something something

1039
00:46:48,110 --> 00:46:50,540
something, percent S
something something something,

1040
00:46:50,540 --> 00:46:54,950
I would just make sure that I pass
printf the first variable comma

1041
00:46:54,950 --> 00:46:59,090
the second variable comma the third
variable and so forth left to right.

1042
00:46:59,090 --> 00:47:00,010
Other questions?

1043
00:47:00,010 --> 00:47:01,190
Yeah.

1044
00:47:01,190 --> 00:47:03,030
AUDIENCE: Why is there no backslash n?

1045
00:47:03,030 --> 00:47:03,830
DAVID: Oh, damn it.

1046
00:47:03,830 --> 00:47:06,080
Because I screwed up and
didn't include that and I

1047
00:47:06,080 --> 00:47:08,880
was going to fix it after class quickly.

1048
00:47:08,880 --> 00:47:10,920
Bug, it's a bug.

1049
00:47:10,920 --> 00:47:11,420
Yeah.

1050
00:47:11,420 --> 00:47:14,270
AUDIENCE: What if you wanted to
use the int twice in the string?

1051
00:47:14,270 --> 00:47:17,140
So you wanted to say,
hello, David, hi, David.

1052
00:47:17,140 --> 00:47:18,940
DAVID: Sure, same exact thing--

1053
00:47:18,940 --> 00:47:23,710
comma answer, comma answer with 2% S. If
you want to say the same variable twice

1054
00:47:23,710 --> 00:47:27,790
in two places for whatever reason,
two placeholders and then answer comma

1055
00:47:27,790 --> 00:47:30,180
answer to plug that in twice.

1056
00:47:30,180 --> 00:47:31,680
Other que-- yeah.

1057
00:47:31,680 --> 00:47:34,490
AUDIENCE: Is percent a universal
placeholder in terms of integers?

1058
00:47:34,490 --> 00:47:36,990
DAVID: No, and we're going to
see some others in just a bit.

1059
00:47:36,990 --> 00:47:38,150
It turns out there's others.

1060
00:47:38,150 --> 00:47:40,220
It's percent i integer,
and there's going

1061
00:47:40,220 --> 00:47:44,230
to be even more than that-- percent
c for a single character and more.

1062
00:47:44,230 --> 00:47:45,800
Other questions?

1063
00:47:45,800 --> 00:47:46,680
Yeah.

1064
00:47:46,680 --> 00:47:49,700
AUDIENCE: Since the backslash n is a
variable, would you put it after n?

1065
00:47:49,700 --> 00:47:51,200
So will you put it in the quotation?

1066
00:47:51,200 --> 00:47:51,700
DAVID: Good question.

1067
00:47:51,700 --> 00:47:54,190
If I did have correctly--
and if this weren't a PDF,

1068
00:47:54,190 --> 00:47:55,570
I would just edit it on the fly--

1069
00:47:55,570 --> 00:48:01,480
if I had the percent n, it always
has to go in the formatted string,

1070
00:48:01,480 --> 00:48:03,140
in the first argument.

1071
00:48:03,140 --> 00:48:06,460
So the only thing that comes
after printf's first argument

1072
00:48:06,460 --> 00:48:11,590
is optionally variable comma variable
comma variable comma variable.

1073
00:48:11,590 --> 00:48:14,620
Other questions?

1074
00:48:14,620 --> 00:48:18,150
so Let's go ahead and actually
do something with code.

1075
00:48:18,150 --> 00:48:20,200
I'm going to go ahead and
open up another window,

1076
00:48:20,200 --> 00:48:22,540
and this is a tool
called with CS50 Sandbox,

1077
00:48:22,540 --> 00:48:26,860
and this is a tool via the web by a
which you can actually play with code.

1078
00:48:26,860 --> 00:48:29,950
And I'll show in just a moment how
I get to this particular location,

1079
00:48:29,950 --> 00:48:33,050
but let me first explain the user
interface much like we started off

1080
00:48:33,050 --> 00:48:34,300
our conversation with Scratch.

1081
00:48:34,300 --> 00:48:35,860
So I need a place to write code.

1082
00:48:35,860 --> 00:48:38,080
The reality is I could
just use my own Mac.

1083
00:48:38,080 --> 00:48:39,700
I could just use my own PC.

1084
00:48:39,700 --> 00:48:42,530
Frankly, I could even use certain
mobile devices these days.

1085
00:48:42,530 --> 00:48:45,880
But then we would have hundreds
of other people in the class

1086
00:48:45,880 --> 00:48:47,680
all with slightly
different configurations

1087
00:48:47,680 --> 00:48:50,290
on their Max and their PCs
and their phones and the like.

1088
00:48:50,290 --> 00:48:53,170
And so everyone would have different
software and different settings,

1089
00:48:53,170 --> 00:48:54,730
and they just never works very well.

1090
00:48:54,730 --> 00:48:56,470
So at the beginning
of the course, we just

1091
00:48:56,470 --> 00:48:59,170
standardize everything by actually
using a web based environment

1092
00:48:59,170 --> 00:49:04,950
just like Scratch is, whereby we'll all
have access to the exact same computer

1093
00:49:04,950 --> 00:49:07,060
but virtualized in the so-called cloud.

1094
00:49:07,060 --> 00:49:09,010
If you've ever wondered
what the cloud is,

1095
00:49:09,010 --> 00:49:11,950
it just means other people's
server somewhere on the internet

1096
00:49:11,950 --> 00:49:14,710
that people can use for
free or to rent and not

1097
00:49:14,710 --> 00:49:17,480
have to host those physical
servers themselves.

1098
00:49:17,480 --> 00:49:21,610
So CS50 Sandbox, just like Scratch,
is a cloud based application

1099
00:49:21,610 --> 00:49:24,280
that someone else wrote
that's hosted on the internet,

1100
00:49:24,280 --> 00:49:27,190
and the user interface, at first
glance, looks just like this.

1101
00:49:27,190 --> 00:49:29,020
There are only two components to it.

1102
00:49:29,020 --> 00:49:32,510
At the top of the user
interface of CS50 Sandbox

1103
00:49:32,510 --> 00:49:35,140
is just a code editor, a
very simple text editor

1104
00:49:35,140 --> 00:49:38,410
similar in spirit to Google Docs
and Microsoft Word and so forth

1105
00:49:38,410 --> 00:49:39,140
but much simpler.

1106
00:49:39,140 --> 00:49:40,060
There's no formatting.

1107
00:49:40,060 --> 00:49:41,600
There's no bold facing and centering.

1108
00:49:41,600 --> 00:49:43,570
You can just type words of text.

1109
00:49:43,570 --> 00:49:45,910
Down here is the
so-called terminal window,

1110
00:49:45,910 --> 00:49:48,080
but we'll come back to
that in just a moment.

1111
00:49:48,080 --> 00:49:50,530
Let me go ahead and
write my first program.

1112
00:49:50,530 --> 00:49:57,460
Let me go ahead and write
include standard IO dot age

1113
00:49:57,460 --> 00:50:04,240
int main void open curly brace printf
hello world backslash and semi-colon,

1114
00:50:04,240 --> 00:50:05,470
done.

1115
00:50:05,470 --> 00:50:09,960
Now few people in this room could
probably whip up a apparent program

1116
00:50:09,960 --> 00:50:12,010
that quickly unless you
do have prior background.

1117
00:50:12,010 --> 00:50:15,490
And if you did take APCS or something
else, it looks kind of like Java

1118
00:50:15,490 --> 00:50:17,020
but not quite the same.

1119
00:50:17,020 --> 00:50:18,700
But this is my first program.

1120
00:50:18,700 --> 00:50:21,640
Now recall from earlier this
was the black and white program

1121
00:50:21,640 --> 00:50:24,250
we saw on the slide
just a little bit ago.

1122
00:50:24,250 --> 00:50:27,790
And even if you didn't quite appreciate
what all the funky syntax is doing,

1123
00:50:27,790 --> 00:50:31,000
all of us probably had the
intuition of what this program does,

1124
00:50:31,000 --> 00:50:34,480
which is just to print out the words
at the end of the day hello world.

1125
00:50:34,480 --> 00:50:38,170
And we'll tease apart in just a bit
what all these various lines are doing.

1126
00:50:38,170 --> 00:50:40,720
But the interesting part is
what's highlighted in green here,

1127
00:50:40,720 --> 00:50:44,140
and this is just one of the
features of CS50 Sandbox.

1128
00:50:44,140 --> 00:50:47,710
It will color code different
concepts within your code

1129
00:50:47,710 --> 00:50:49,190
so that they just jump out at you.

1130
00:50:49,190 --> 00:50:52,040
The colors aren't actually there.

1131
00:50:52,040 --> 00:50:53,920
You don't have to color
code things yourself.

1132
00:50:53,920 --> 00:50:56,790
It just does it automatically so
you can see the different components

1133
00:50:56,790 --> 00:51:00,950
just like MIT colorizes is the various
Scratch puzzle pieces the same.

1134
00:51:00,950 --> 00:51:05,830
So this is a program that
I want to call hello.

1135
00:51:05,830 --> 00:51:06,650
It's in a file.

1136
00:51:06,650 --> 00:51:09,060
This is just a tab up
top called hello dot C

1137
00:51:09,060 --> 00:51:11,230
because it turns out, when
you write a program in C,

1138
00:51:11,230 --> 00:51:16,930
you save it in files by human convention
whatever dot C as the file extension,

1139
00:51:16,930 --> 00:51:18,410
so to speak.

1140
00:51:18,410 --> 00:51:20,990
How do I run this program?

1141
00:51:20,990 --> 00:51:25,810
There's no green flag to
click, which Scratch gave us.

1142
00:51:25,810 --> 00:51:27,790
So how do I actually run the program.

1143
00:51:27,790 --> 00:51:31,780
And frankly, moreover, the green flag
seems to be the least of my concerns.

1144
00:51:31,780 --> 00:51:34,090
What is the language that
any computer understands

1145
00:51:34,090 --> 00:51:38,340
whether it's my Mac here or the
cloud server where this thing is?

1146
00:51:38,340 --> 00:51:39,810
Zeros and ones, right?

1147
00:51:39,810 --> 00:51:43,380
And we started with that overwhelming
slide of a lots of 0's and 1's, and

1148
00:51:43,380 --> 00:51:45,840
that is the point we need to get to.

1149
00:51:45,840 --> 00:51:49,740
But hopefully, we ourselves don't
have to write at that level of tedium.

1150
00:51:49,740 --> 00:51:52,680
So we need some way of
converting this code

1151
00:51:52,680 --> 00:51:57,600
from C, which we'll start calling source
code, which is the English like code we

1152
00:51:57,600 --> 00:52:01,170
see on the screen that's mildly
pleasurable to write as opposed

1153
00:52:01,170 --> 00:52:02,670
to just zeros and ones.

1154
00:52:02,670 --> 00:52:06,340
But we nonetheless need to convert
it somehow to zeros and ones.

1155
00:52:06,340 --> 00:52:09,040
And so the way we can do this
is essentially as follows.

1156
00:52:09,040 --> 00:52:14,340
If we have what we'll start calling
our source code, which can be written,

1157
00:52:14,340 --> 00:52:19,800
in our case, in C, but you can write
source code in Java, in C++, in Python,

1158
00:52:19,800 --> 00:52:21,080
in dozens of other language.

1159
00:52:21,080 --> 00:52:22,290
Source code's a generic term.

1160
00:52:22,290 --> 00:52:24,520
That just means the code
that we humans have written.

1161
00:52:24,520 --> 00:52:28,450
We need some way of converting
it into zeros and ones, which

1162
00:52:28,450 --> 00:52:30,750
henceforth we're just going
to call machine code, which

1163
00:52:30,750 --> 00:52:31,950
feels like a reasonable name.

1164
00:52:31,950 --> 00:52:34,590
It's the zeros and ones
that a machine understands.

1165
00:52:34,590 --> 00:52:37,530
How does a machine know what
zeros and ones to understand?

1166
00:52:37,530 --> 00:52:40,920
Well, that's the whole reasoning
behind having CPU, Central Processing

1167
00:52:40,920 --> 00:52:42,450
Unit, the brains of a computer.

1168
00:52:42,450 --> 00:52:44,610
They are just hardwired
at the factory, so

1169
00:52:44,610 --> 00:52:47,110
to speak, at Intel's
factory to understand

1170
00:52:47,110 --> 00:52:49,060
certain patterns of zeros and ones.

1171
00:52:49,060 --> 00:52:53,670
But the point for us now is we need to
take a source code, like the C program

1172
00:52:53,670 --> 00:52:56,190
I wrote a moment ago that's
supposed to print hello world,

1173
00:52:56,190 --> 00:53:00,330
and somehow convert it to machine code.

1174
00:53:00,330 --> 00:53:03,750
So it turns out this is the step
that humans who've come before us

1175
00:53:03,750 --> 00:53:04,800
have solved for us.

1176
00:53:04,800 --> 00:53:07,560
Other humans have
already written programs

1177
00:53:07,560 --> 00:53:10,920
that we're going to start
calling a compiler that allows us

1178
00:53:10,920 --> 00:53:13,650
to convert source code to machine code.

1179
00:53:13,650 --> 00:53:14,950
It's just one additional step.

1180
00:53:14,950 --> 00:53:16,920
This step did not exist
in Scratch, but we're

1181
00:53:16,920 --> 00:53:21,660
going to run a program that's generally
called a compiler that we pass

1182
00:53:21,660 --> 00:53:28,650
our program to as input, and we
get as output machine code, thereby

1183
00:53:28,650 --> 00:53:31,680
perfectly bringing us full circle
to what computer science is

1184
00:53:31,680 --> 00:53:33,990
is in now the context
of programming-- input

1185
00:53:33,990 --> 00:53:35,790
source code, outputs machine code.

1186
00:53:35,790 --> 00:53:39,090
The algorithm or the special software
we're going to use in just a moment is

1187
00:53:39,090 --> 00:53:42,300
called a compiler that just converts
one to the other so that none of us have

1188
00:53:42,300 --> 00:53:45,210
to ever think about or
write in 0's and 1's.

1189
00:53:45,210 --> 00:53:47,700
So it's a little old
school how you do this.

1190
00:53:47,700 --> 00:53:50,610
In Scratch, you obviously just
hit the green flag and MIT

1191
00:53:50,610 --> 00:53:52,780
and all those folks
took care of it for you.

1192
00:53:52,780 --> 00:53:55,920
We have to be a little
more manual about this,

1193
00:53:55,920 --> 00:53:59,130
and that's where the second piece
of CS50 Sandbox user interface

1194
00:53:59,130 --> 00:54:00,180
comes into play.

1195
00:54:00,180 --> 00:54:02,250
Notice I have a blinking prompt here.

1196
00:54:02,250 --> 00:54:04,960
There's dollar sign at left,
which is just a common convention.

1197
00:54:04,960 --> 00:54:09,930
A dollar sign tends to in these types
of computers represent a prompt.

1198
00:54:09,930 --> 00:54:13,020
It's waiting for me to type something,
and indeed it's literally blinking,

1199
00:54:13,020 --> 00:54:14,790
waiting for me to type something.

1200
00:54:14,790 --> 00:54:18,810
This is an example of a terminal window,
and your own iMac and your own PC

1201
00:54:18,810 --> 00:54:21,630
actually has or can't have
this exact same feature.

1202
00:54:21,630 --> 00:54:24,890
It's just all of us operate with
graphical user interfaces these days.

1203
00:54:24,890 --> 00:54:26,590
So we've got buttons
and menus and things

1204
00:54:26,590 --> 00:54:28,440
to drag and click, but back in the day--

1205
00:54:28,440 --> 00:54:32,520
and typically in programming-- you
don't bother with these aesthetics.

1206
00:54:32,520 --> 00:54:36,720
You actually get your hands dirtier
with just the keyboard alone typing

1207
00:54:36,720 --> 00:54:37,830
anything you want to do.

1208
00:54:37,830 --> 00:54:39,750
And at first, it might
feel like a regression.

1209
00:54:39,750 --> 00:54:43,200
Like, why are we giving up
all these beautiful amenities

1210
00:54:43,200 --> 00:54:44,950
of modern computers?

1211
00:54:44,950 --> 00:54:47,130
But it's more powerful,
and it's more explicit.

1212
00:54:47,130 --> 00:54:51,250
It lets you do exactly what you want to
do by sending commands to the computer.

1213
00:54:51,250 --> 00:54:52,450
So this is my terminal 1.

1214
00:54:52,450 --> 00:54:54,570
I can create others just
to have multiple windows,

1215
00:54:54,570 --> 00:54:58,590
but this is giving me access to
the underlying server that I now

1216
00:54:58,590 --> 00:54:59,740
have access to.

1217
00:54:59,740 --> 00:55:02,940
So if any of you, when it comes
time to the first problem set,

1218
00:55:02,940 --> 00:55:05,920
log into the same tool, you don't
all have the same environment.

1219
00:55:05,920 --> 00:55:10,650
You all have your own isolated copies of
the same software but your own storage

1220
00:55:10,650 --> 00:55:12,370
space, so to speak.

1221
00:55:12,370 --> 00:55:17,850
So I need to somehow convert
hello dot C to zeros and ones.

1222
00:55:17,850 --> 00:55:20,520
And the way I'm going to
do this is like this--

1223
00:55:20,520 --> 00:55:28,620
clang, which stands for C
language, hello dot C enter.

1224
00:55:28,620 --> 00:55:32,230
And the fact that I see nothing
happening is actually an amazing thing

1225
00:55:32,230 --> 00:55:35,280
because there's an infinite number of
things, frankly, that can go wrong,

1226
00:55:35,280 --> 00:55:36,990
and the computer will
happily yell at you

1227
00:55:36,990 --> 00:55:40,350
with cryptic looking error messages
if any of those things do go wrong.

1228
00:55:40,350 --> 00:55:43,740
So seeing nothing but another
blinking prompt with the dollar

1229
00:55:43,740 --> 00:55:45,060
sign is actually a good thing.

1230
00:55:45,060 --> 00:55:48,390
My code has somehow been
converted to zeros and ones.

1231
00:55:48,390 --> 00:55:50,250
Where are those zeros and ones?

1232
00:55:50,250 --> 00:55:54,360
Well, by convention, they are
stored in a file that's weirdly

1233
00:55:54,360 --> 00:55:57,870
and historically just called a
dot out, and we can see that.

1234
00:55:57,870 --> 00:56:00,270
If I click this folder
icon up here, you'll

1235
00:56:00,270 --> 00:56:06,000
actually see my file hello dot C and
another file now called a dot out.

1236
00:56:06,000 --> 00:56:09,030
It stands for assembly output,
but for historical reasons.

1237
00:56:09,030 --> 00:56:12,060
Now let me close the folder icon
because we're generally not going

1238
00:56:12,060 --> 00:56:14,440
to use the graphical user interface.

1239
00:56:14,440 --> 00:56:15,630
How do I run that program?

1240
00:56:15,630 --> 00:56:17,130
I couldn't just double
click on the icon.

1241
00:56:17,130 --> 00:56:17,850
This isn't a Mac.

1242
00:56:17,850 --> 00:56:18,930
This isn't a PC.

1243
00:56:18,930 --> 00:56:21,570
This is a cloud based Linux environment.

1244
00:56:21,570 --> 00:56:23,350
Linux is a super popular
operating system.

1245
00:56:23,350 --> 00:56:26,310
It happens to be used by lots of
computer scientists, lots of websites,

1246
00:56:26,310 --> 00:56:27,030
lots of servers.

1247
00:56:27,030 --> 00:56:29,820
In fact, almost every website
you visit these days is powered,

1248
00:56:29,820 --> 00:56:33,150
if not by Windows by Linux,
and variations thereof

1249
00:56:33,150 --> 00:56:35,580
called Unix and other flavors still.

1250
00:56:35,580 --> 00:56:38,070
It's just a very popular and
often free operating system

1251
00:56:38,070 --> 00:56:40,380
that CS50 Sandbox itself uses.

1252
00:56:40,380 --> 00:56:45,200
To run a file called a dot out
that's in this folder, so to speak,

1253
00:56:45,200 --> 00:56:47,370
even though you don't see
a graphical version of it.

1254
00:56:47,370 --> 00:56:50,820
You literally just type
dot slash a dot out.

1255
00:56:50,820 --> 00:56:55,170
Completely non-obvious and kind
of a stupid name for the program,

1256
00:56:55,170 --> 00:56:59,020
but this is the equivalent in your Mac
or PC of double clicking on an icon.

1257
00:56:59,020 --> 00:57:00,270
Let me go ahead and hit enter.

1258
00:57:00,270 --> 00:57:03,910
And when I do, I should
hopefully see what?

1259
00:57:03,910 --> 00:57:04,660
Hello world.

1260
00:57:04,660 --> 00:57:06,280
And here we go.

1261
00:57:06,280 --> 00:57:09,010
Wow, that's our first program.

1262
00:57:09,010 --> 00:57:11,200
It's not doing all that
much, but it's at least

1263
00:57:11,200 --> 00:57:13,100
doing what we promised it would do.

1264
00:57:13,100 --> 00:57:16,950
And this is the equivalent in Scratch of
just saying on the screen hello world.

1265
00:57:16,950 --> 00:57:18,910
Now to be fair, there
were more steps involved,

1266
00:57:18,910 --> 00:57:22,210
and God knows there was more
cryptic looking code to write.

1267
00:57:22,210 --> 00:57:24,400
But at the end of the
day all we've done now

1268
00:57:24,400 --> 00:57:27,190
is re-implement last week's
logic in this new language,

1269
00:57:27,190 --> 00:57:31,120
but we're now going to very quickly
introduce new puzzle pieces but in C.

1270
00:57:31,120 --> 00:57:33,800
But first let's solve
this minor headache.

1271
00:57:33,800 --> 00:57:35,980
I don't really want
to tell friends like,

1272
00:57:35,980 --> 00:57:39,040
hey, everyone, come run
my a dot out program.

1273
00:57:39,040 --> 00:57:40,300
Let's give it a real name.

1274
00:57:40,300 --> 00:57:42,130
Suppose I just want to
call my program hello

1275
00:57:42,130 --> 00:57:44,800
like you might download from the
App Store or Google Play Store.

1276
00:57:44,800 --> 00:57:46,510
Programs have names.

1277
00:57:46,510 --> 00:57:47,930
So how do I do that?

1278
00:57:47,930 --> 00:57:52,660
Well, it turns out in a terminal window,
the so-called command line environment,

1279
00:57:52,660 --> 00:57:55,330
which is just a fancy way of
saying you write lines of commands

1280
00:57:55,330 --> 00:57:57,580
with your keyboard,
you can actually pass

1281
00:57:57,580 --> 00:58:02,230
in what are called command line
arguments, additional inputs

1282
00:58:02,230 --> 00:58:06,490
to programs that are just words that
you type at your keyboard that tell it

1283
00:58:06,490 --> 00:58:07,240
how to behave.

1284
00:58:07,240 --> 00:58:10,700
So instead of just
running clang on hello dot

1285
00:58:10,700 --> 00:58:13,150
C, I'm actually going
to be more explicit

1286
00:58:13,150 --> 00:58:16,300
and I'm going to tell
clang please output--

1287
00:58:16,300 --> 00:58:19,540
as is implied by literally
typing dash 0 for output--

1288
00:58:19,540 --> 00:58:22,670
a file called hello instead.

1289
00:58:22,670 --> 00:58:24,100
So it's a little more verbose--

1290
00:58:24,100 --> 00:58:29,130
hello dash O hello-- or, sorry
clang dash O hello hello dot C.

1291
00:58:29,130 --> 00:58:31,960
But what this is going to
do now is still convert

1292
00:58:31,960 --> 00:58:33,760
source code to machine
code, but it's going

1293
00:58:33,760 --> 00:58:36,700
to save it in a file called hello.

1294
00:58:36,700 --> 00:58:40,480
And indeed now I have hello
dot C a dot out and hello as

1295
00:58:40,480 --> 00:58:42,940
pictured in the little
graphical folder there.

1296
00:58:42,940 --> 00:58:46,730
So now I can instead
run dot slash hello.

1297
00:58:46,730 --> 00:58:47,530
What should it say?

1298
00:58:47,530 --> 00:58:50,450
Hopefully the same, enter.

1299
00:58:50,450 --> 00:58:51,080
So that's it.

1300
00:58:51,080 --> 00:58:53,330
Those are called command
line arguments, and it's just

1301
00:58:53,330 --> 00:58:56,200
the old school way of
telling a text based command

1302
00:58:56,200 --> 00:58:58,580
how to behave a little bit
differently from its defaults.

1303
00:58:58,580 --> 00:59:01,090
But frankly, this is going
to get tedious quickly.

1304
00:59:01,090 --> 00:59:03,050
We aren't going to
want to write our code

1305
00:59:03,050 --> 00:59:06,140
and then every darn time we want to
convert it to zeros and ones to run it

1306
00:59:06,140 --> 00:59:10,280
actually remember these magical
incantations of commands.

1307
00:59:10,280 --> 00:59:13,070
And so humans have
abstracted these away too.

1308
00:59:13,070 --> 00:59:16,010
It turns out that, if you want to
make a program from source code

1309
00:59:16,010 --> 00:59:18,680
into machine code, there's
another command you can use.

1310
00:59:18,680 --> 00:59:21,530
And you can literally
type make hello, where

1311
00:59:21,530 --> 00:59:24,320
hello is the name of the
program you want to make,

1312
00:59:24,320 --> 00:59:28,400
this program, whose name is
make, will look for a file

1313
00:59:28,400 --> 00:59:34,520
by default called hello dot C, therefore
saving you the time of specifying it.

1314
00:59:34,520 --> 00:59:38,180
Hit Enter now, and, oh my
god, look what it just did.

1315
00:59:38,180 --> 00:59:42,950
It has even more configuration
options that are baked into it,

1316
00:59:42,950 --> 00:59:47,630
and we as CS50 staff, configured CS50
sandbox to have these various features.

1317
00:59:47,630 --> 00:59:50,300
And even though we're not going
to go into detail on them now,

1318
00:59:50,300 --> 00:59:52,320
I'm going to wave my hand
at what they actually do.

1319
00:59:52,320 --> 00:59:55,360
They just make additional features
possible that we'll eventually get to.

1320
00:59:55,360 --> 00:59:57,620
But this would be otherwise
the command that you all

1321
00:59:57,620 --> 01:00:01,520
do have to type in just two
or three or four weeks time,

1322
01:00:01,520 --> 01:00:03,110
and no one can ever remember that.

1323
01:00:03,110 --> 01:00:04,300
I certainly couldn't.

1324
01:00:04,300 --> 01:00:06,830
So Make just automates that for you.

1325
01:00:06,830 --> 01:00:10,020
But when you run Make,
Make is not a compiler.

1326
01:00:10,020 --> 01:00:14,910
Make is not the thing in the middle here
converting source code to machine code.

1327
01:00:14,910 --> 01:00:19,760
It's just a second program that
some humans wrote years ago that use

1328
01:00:19,760 --> 01:00:23,610
clang in an automated way
to achieve the same output.

1329
01:00:23,610 --> 01:00:25,740
Because people got tired
of typing stuff like this.

1330
01:00:25,740 --> 01:00:29,770
So someone made a program
called Make that does it for us.

1331
01:00:29,770 --> 01:00:32,340
Any questions?

1332
01:00:32,340 --> 01:00:34,980
Let's add a little bit
then to this program.

1333
01:00:34,980 --> 01:00:38,520
Instead of this version of
hello, let me get some user input

1334
01:00:38,520 --> 01:00:40,410
and actually do something with it.

1335
01:00:40,410 --> 01:00:43,590
Suppose I actually want to get the
user's name and then print that out.

1336
01:00:43,590 --> 01:00:46,050
Well, we saw the spoiler
for that just a moment ago,

1337
01:00:46,050 --> 01:00:48,330
but let me go ahead and
add to this program here.

1338
01:00:48,330 --> 01:00:51,960
Now I have a second line of code, and
I want to get a string from a user.

1339
01:00:51,960 --> 01:00:56,070
And with what function do I
get a string from the user?

1340
01:00:56,070 --> 01:00:58,380
Get string was the one,
and recall I can do get

1341
01:00:58,380 --> 01:01:01,380
underscore string open parenthesis.

1342
01:01:01,380 --> 01:01:05,700
And then I have to pass in an argument,
so to speak, like give me your name--

1343
01:01:05,700 --> 01:01:07,570
or actually, what did we say before?

1344
01:01:07,570 --> 01:01:12,030
What is your name, I think was
the prompt backslash n semi-colon.

1345
01:01:12,030 --> 01:01:13,830
Now it's not enough to
just get the string.

1346
01:01:13,830 --> 01:01:15,970
What do I want to do with it?

1347
01:01:15,970 --> 01:01:17,280
Yes, store in a variable.

1348
01:01:17,280 --> 01:01:18,870
What type of variable?

1349
01:01:18,870 --> 01:01:20,080
A string.

1350
01:01:20,080 --> 01:01:23,160
So I just need to go on the left
hand side of this line of code

1351
01:01:23,160 --> 01:01:25,320
and say, OK, well, give me a string.

1352
01:01:25,320 --> 01:01:28,470
I'll call it name, but I could
call it x or y or anything.

1353
01:01:28,470 --> 01:01:30,570
But name feels like a
good descriptor for it,

1354
01:01:30,570 --> 01:01:33,510
using a single equal sign
to copy from right to left.

1355
01:01:33,510 --> 01:01:35,200
And now I've got that.

1356
01:01:35,200 --> 01:01:38,910
Now it's not sufficient to just
store the value in the variable.

1357
01:01:38,910 --> 01:01:40,270
I need to print it out.

1358
01:01:40,270 --> 01:01:44,400
So let me start with this.

1359
01:01:44,400 --> 01:01:45,570
It autosaves, the Sandbox.

1360
01:01:45,570 --> 01:01:47,910
So I don't even have to go
up to File, Save or anything.

1361
01:01:47,910 --> 01:01:50,640
Let me go ahead and do make hello now--

1362
01:01:50,640 --> 01:01:54,960
oh uh, oh my god, look at
all these errors already.

1363
01:01:54,960 --> 01:01:58,470
So clearly something is wrong, as the
computer is fond of telling me in red.

1364
01:01:58,470 --> 01:02:00,270
And frankly, this is
where you very quickly

1365
01:02:00,270 --> 01:02:01,830
get derailed or kind
of freaked out because,

1366
01:02:01,830 --> 01:02:03,760
oh my god, I only wrote
two lines of code.

1367
01:02:03,760 --> 01:02:06,210
How do I have 20 lines
of errors somehow?

1368
01:02:06,210 --> 01:02:09,400
So the computer is kind
of as confused as you.

1369
01:02:09,400 --> 01:02:12,150
And the most important thing, when
you face this kind of situation

1370
01:02:12,150 --> 01:02:14,760
where it's just cryptic, erroneous
output, start at the top.

1371
01:02:14,760 --> 01:02:17,760
Even if your window's kind of small
and therefore a whole bunch of stuff

1372
01:02:17,760 --> 01:02:20,160
scrolls on the screen
quickly, scroll up to the top

1373
01:02:20,160 --> 01:02:22,860
because odds are there's one
mistake up at the very top

1374
01:02:22,860 --> 01:02:26,400
and that one mistake just had a
cascading effect on the compiler.

1375
01:02:26,400 --> 01:02:29,400
Then it just got really confused, and
it just kept spitting out messages

1376
01:02:29,400 --> 01:02:31,090
because it got tripped up early.

1377
01:02:31,090 --> 01:02:34,640
So let's scroll back up to the top here.

1378
01:02:34,640 --> 01:02:38,780
And here is the very long command
that I said make automates for you.

1379
01:02:38,780 --> 01:02:40,220
So that's not erroneous.

1380
01:02:40,220 --> 01:02:44,690
Here seems to be the first error,
and it's a little cryptic still.

1381
01:02:44,690 --> 01:02:46,720
But let's glean some information.

1382
01:02:46,720 --> 01:02:48,470
Here's a familiar phrase--

1383
01:02:48,470 --> 01:02:51,720
hello dot C. Let me go ahead
and zoom in on the bottom here.

1384
01:02:51,720 --> 01:02:54,290
So hello dot C recalls
the name of my file.

1385
01:02:54,290 --> 01:02:58,940
Albeit not obviously, clang is
telling me look at line 5 and then

1386
01:02:58,940 --> 01:03:00,330
your fifth character.

1387
01:03:00,330 --> 01:03:03,660
So this something colon something means
line number character or column number

1388
01:03:03,660 --> 01:03:05,210
if you're looking from left to right.

1389
01:03:05,210 --> 01:03:06,380
Error means error.

1390
01:03:06,380 --> 01:03:10,100
And then this is where things
get a little sophisticated.

1391
01:03:10,100 --> 01:03:13,850
Use of undeclared identifier string--

1392
01:03:13,850 --> 01:03:16,220
did you mean standard n?

1393
01:03:16,220 --> 01:03:19,820
No I didn't, but I do
recognize standard n,

1394
01:03:19,820 --> 01:03:22,970
or rather it seems similar to standard
I/O. But no, I didn't mean that.

1395
01:03:22,970 --> 01:03:25,510
I'm pretty sure this code is right.

1396
01:03:25,510 --> 01:03:27,050
Well, why am I getting this error?

1397
01:03:27,050 --> 01:03:31,610
It sounds like string, on line
five, fifth character, right there,

1398
01:03:31,610 --> 01:03:33,230
that is wrong.

1399
01:03:33,230 --> 01:03:36,700
Well, it turns out, there is
no such thing as a string.

1400
01:03:36,700 --> 01:03:40,820
C, the language, has integers,
and it has Booleans, it turns out.

1401
01:03:40,820 --> 01:03:43,010
And it has characters
and a few other things.

1402
01:03:43,010 --> 01:03:44,780
It actually doesn't have strings.

1403
01:03:44,780 --> 01:03:47,690
Strings is a word that's
useful to describe sequences

1404
01:03:47,690 --> 01:03:49,340
of characters, paragraphs, words.

1405
01:03:49,340 --> 01:03:51,080
But string is not a type.

1406
01:03:51,080 --> 01:03:54,110
It's not a type of variable
unless you make it so.

1407
01:03:54,110 --> 01:03:57,750
And in fact, this is one of
the simplifications we do.

1408
01:03:57,750 --> 01:04:00,800
In just the first couple of weeks of
the course to get us off the ground,

1409
01:04:00,800 --> 01:04:05,450
it turns out that we need to
add one line of code here.

1410
01:04:05,450 --> 01:04:09,350
We need to do, not only include standard
I/O-- which we'll explain in a moment--

1411
01:04:09,350 --> 01:04:13,450
but also CS50 so-called library.

1412
01:04:13,450 --> 01:04:17,150
So CS50 has a lot of humans involved
with it, and over time we've decided,

1413
01:04:17,150 --> 01:04:20,930
you know what, we could make the
first hour of CS50 a little easier

1414
01:04:20,930 --> 01:04:24,440
and the on ramp a little cleaner
for folks with no background

1415
01:04:24,440 --> 01:04:27,650
by just inventing a few features
ourselves such as the ability

1416
01:04:27,650 --> 01:04:29,100
to get strings from the user.

1417
01:04:29,100 --> 01:04:31,350
So it turns out get string
is also not a function that

1418
01:04:31,350 --> 01:04:35,630
comes with C. That is a custom puzzle
piece, so to speak, that CS50 made.

1419
01:04:35,630 --> 01:04:39,740
And where we created that
function is essentially in a file

1420
01:04:39,740 --> 01:04:41,300
called CS50 dot age.

1421
01:04:41,300 --> 01:04:44,540
And so by including dot
age, you now get access

1422
01:04:44,540 --> 01:04:47,940
to more puzzle pieces, if you
will, that we have created for you.

1423
01:04:47,940 --> 01:04:49,790
And it turns out this
line of code that has

1424
01:04:49,790 --> 01:04:53,510
been here before is also
giving you features, too.

1425
01:04:53,510 --> 01:04:56,010
We're just doing what
everyone does in programming,

1426
01:04:56,010 --> 01:04:59,540
which is solve a problem once and then
let other people use that solution.

1427
01:04:59,540 --> 01:05:00,710
Take a guess.

1428
01:05:00,710 --> 01:05:03,470
What functionality is
actually implemented

1429
01:05:03,470 --> 01:05:07,670
in a file called standard
I/O input output dot h?

1430
01:05:07,670 --> 01:05:11,870
This is just a file somewhere on the
server that actually does come with C,

1431
01:05:11,870 --> 01:05:15,150
and it provides you with
handy features like what?

1432
01:05:15,150 --> 01:05:17,100
Say again.

1433
01:05:17,100 --> 01:05:18,210
Once more.

1434
01:05:18,210 --> 01:05:19,010
Printf.

1435
01:05:19,010 --> 01:05:23,360
It turns out that the means by which
you are allowed to use a function

1436
01:05:23,360 --> 01:05:26,210
called printf here is
you have to include

1437
01:05:26,210 --> 01:05:28,310
the file in which it is declared.

1438
01:05:28,310 --> 01:05:32,060
So some humans, years ago, literally
wrote a function, a puzzle piece,

1439
01:05:32,060 --> 01:05:34,490
called printf, and they figured
out how to actually draw

1440
01:05:34,490 --> 01:05:35,810
characters on the screen.

1441
01:05:35,810 --> 01:05:38,780
They then stored information
about that function in a file

1442
01:05:38,780 --> 01:05:40,550
called standard IO dot age.

1443
01:05:40,550 --> 01:05:43,970
If I had not included that
seemingly cryptic line of code

1444
01:05:43,970 --> 01:05:48,020
at the very top of my previous program,
even that hello world program would not

1445
01:05:48,020 --> 01:05:50,770
have worked because clang,
the compiler, wouldn't

1446
01:05:50,770 --> 01:05:52,190
have known what I'm talking about.

1447
01:05:52,190 --> 01:05:52,970
What is printf?

1448
01:05:52,970 --> 01:05:55,700
I don't know what that
is unless you tell

1449
01:05:55,700 --> 01:05:58,160
it to also include this
file that humans wrote years

1450
01:05:58,160 --> 01:06:00,950
ago in which printf has been created.

1451
01:06:00,950 --> 01:06:05,360
And now if I want to use get string,
as well as the new keyword string,

1452
01:06:05,360 --> 01:06:08,240
I need to tell clang the
compiler, also go ahead

1453
01:06:08,240 --> 01:06:12,170
and look in CS50.h for more
functionality, such as string

1454
01:06:12,170 --> 01:06:13,470
and get string.

1455
01:06:13,470 --> 01:06:16,640
So let me go ahead now
and try this again.

1456
01:06:16,640 --> 01:06:20,450
I'm going to clear my terminal here
and just try that same command again--

1457
01:06:20,450 --> 01:06:25,030
make hello, enter, dammit.

1458
01:06:25,030 --> 01:06:26,250
Now I've got another error.

1459
01:06:26,250 --> 01:06:28,670
But, but, but, progress.

1460
01:06:28,670 --> 01:06:33,120
Well, no, just as many errors as
before somehow, but different ones.

1461
01:06:33,120 --> 01:06:36,670
Notice now-- wait, that was before.

1462
01:06:36,670 --> 01:06:37,480
Oh, no, I'm sorry.

1463
01:06:37,480 --> 01:06:38,420
It has fewer errors.

1464
01:06:38,420 --> 01:06:40,480
Here's where I ran the
command a moment ago,

1465
01:06:40,480 --> 01:06:43,360
and now I'm getting this error instead.

1466
01:06:43,360 --> 01:06:44,260
So progress.

1467
01:06:44,260 --> 01:06:45,730
Now my error is not on line 5.

1468
01:06:45,730 --> 01:06:49,660
It's on line 6, though fun
fact, line 6 used to be line 5.

1469
01:06:49,660 --> 01:06:52,420
So it's apparently still
involved in the problem.

1470
01:06:52,420 --> 01:06:54,160
So let's read the error message.

1471
01:06:54,160 --> 01:06:58,090
The problem is on line 6, which is
no surprising is that one there.

1472
01:06:58,090 --> 01:07:03,010
But this time it's different--
error, unused variable name.

1473
01:07:03,010 --> 01:07:06,520
That one I kind of understand
even without being a programmer.

1474
01:07:06,520 --> 01:07:08,960
What does that mean?

1475
01:07:08,960 --> 01:07:09,460
Yeah.

1476
01:07:12,900 --> 01:07:16,370
Maybe declare prior to using, but it
turns out this is how you declare it.

1477
01:07:16,370 --> 01:07:18,110
But I'm actually-- yeah.

1478
01:07:18,110 --> 01:07:20,700
AUDIENCE: You're not actually
using the variable you declared.

1479
01:07:20,700 --> 01:07:23,110
DAVID: Yeah, I'm just kind of
wasting the computer's time.

1480
01:07:23,110 --> 01:07:23,900
I'm creating it.

1481
01:07:23,900 --> 01:07:25,410
So line 6 on the left is correct.

1482
01:07:25,410 --> 01:07:27,680
Hey, computer, give
me a string variable,

1483
01:07:27,680 --> 01:07:29,960
and call it name and put a value in it.

1484
01:07:29,960 --> 01:07:32,240
But what's the point of that
exercise if you're never,

1485
01:07:32,240 --> 01:07:34,250
as you say, doing anything with it.

1486
01:07:34,250 --> 01:07:36,780
And in fact, recall from
the slide a moment ago,

1487
01:07:36,780 --> 01:07:38,220
how do I do something with it?

1488
01:07:38,220 --> 01:07:40,320
Well, this is not how
you do something with it.

1489
01:07:40,320 --> 01:07:42,830
If I go ahead and run this
program now successfully,

1490
01:07:42,830 --> 01:07:45,770
what would I actually see on the screen?

1491
01:07:45,770 --> 01:07:50,960
Literally hello name, H-E-L-L-O comma
space N-A-M-E, obviously not correct.

1492
01:07:50,960 --> 01:07:52,340
So how do I plug in the variable?

1493
01:07:52,340 --> 01:07:54,170
What was the trick?

1494
01:07:54,170 --> 01:07:57,420
Yeah, percent S for
string, a format code,

1495
01:07:57,420 --> 01:07:59,300
so to speak-- hence the name printf.

1496
01:07:59,300 --> 01:08:02,510
And then I need to pass a
second argument to printf,

1497
01:08:02,510 --> 01:08:06,170
and I do that with a comma and then the
name of the variable I want to plug in.

1498
01:08:06,170 --> 01:08:08,520
Now notice there are two
commas in this line here.

1499
01:08:08,520 --> 01:08:11,390
If I zoom in, notice there's
two commas, but there's only

1500
01:08:11,390 --> 01:08:14,180
two arguments or inputs to printf.

1501
01:08:14,180 --> 01:08:17,330
The input to a function is just
typically called an argument

1502
01:08:17,330 --> 01:08:19,230
or also called a parameter.

1503
01:08:19,230 --> 01:08:24,140
So there are two commas, but this one is
an English comma just separating hello

1504
01:08:24,140 --> 01:08:25,760
from the person's name.

1505
01:08:25,760 --> 01:08:29,900
This white comma here, color coded
because the Sandbox is doing the for me

1506
01:08:29,900 --> 01:08:32,840
is actually separating--
excuse me-- the first argument

1507
01:08:32,840 --> 01:08:34,800
from the second argument.

1508
01:08:34,800 --> 01:08:38,900
So now, for a third
time, make hello enter.

1509
01:08:38,900 --> 01:08:40,130
Oh my god, thank you.

1510
01:08:40,130 --> 01:08:41,120
Now it worked.

1511
01:08:41,120 --> 01:08:44,180
It still spit out this pretty
long, cryptic command in white,

1512
01:08:44,180 --> 01:08:44,840
but that's OK.

1513
01:08:44,840 --> 01:08:49,020
That is, again, the automated command
that Make is making possible for us.

1514
01:08:49,020 --> 01:08:52,400
But the fact that I see no red, no
errors, just another blinking prompt

1515
01:08:52,400 --> 01:08:54,480
means that my program has been made.

1516
01:08:54,480 --> 01:08:55,910
So let me go ahead and do--

1517
01:08:55,910 --> 01:08:59,670
how do I run a program
if it's called hello?

1518
01:08:59,670 --> 01:09:01,940
Yeah, dot slash hello,
and we'll see why you

1519
01:09:01,940 --> 01:09:03,490
have the stupid dot at the beginning.

1520
01:09:03,490 --> 01:09:05,830
It essentially means run
the program called hello

1521
01:09:05,830 --> 01:09:09,120
that's right here in your
current folder on the server--

1522
01:09:09,120 --> 01:09:10,350
dot slash hello.

1523
01:09:10,350 --> 01:09:11,100
What is your name?

1524
01:09:11,100 --> 01:09:12,350
Very nice.

1525
01:09:12,350 --> 01:09:14,380
David, enter.

1526
01:09:14,380 --> 01:09:15,520
Hello, David.

1527
01:09:15,520 --> 01:09:16,450
Interesting.

1528
01:09:16,450 --> 01:09:19,890
Let's make one tweak, because I did
this by accident earlier as you noted.

1529
01:09:19,890 --> 01:09:23,000
What if I left off for instance
one of these backslash n's

1530
01:09:23,000 --> 01:09:25,750
that's literally now
not telling the computer

1531
01:09:25,750 --> 01:09:27,710
to move the cursor to another line?

1532
01:09:27,710 --> 01:09:30,830
So let me go ahead
and rerun the program.

1533
01:09:30,830 --> 01:09:31,420
Wait a minute.

1534
01:09:31,420 --> 01:09:33,490
That looks the same.

1535
01:09:33,490 --> 01:09:37,270
I just changed the code, but it's
still behaving exactly the same.

1536
01:09:37,270 --> 01:09:40,180
Where's my confusion?

1537
01:09:40,180 --> 01:09:41,340
I didn't recompile it.

1538
01:09:41,340 --> 01:09:44,170
Unlike Scratch, which is amazing
because you just hit the green flag

1539
01:09:44,170 --> 01:09:46,890
and it runs the code again, we
have a second intermediate step.

1540
01:09:46,890 --> 01:09:48,580
I have to re-run the code.

1541
01:09:48,580 --> 01:09:50,080
Now how do you get out of a program?

1542
01:09:50,080 --> 01:09:51,030
I could just hit Enter.

1543
01:09:51,030 --> 01:09:53,930
You can also hit Control C for
cancel, and that will just get you out

1544
01:09:53,930 --> 01:09:55,620
of whatever confusion you're in.

1545
01:09:55,620 --> 01:09:58,050
Let me go ahead and rerun, make hello--

1546
01:09:58,050 --> 01:09:59,370
seems to be OK--

1547
01:09:59,370 --> 01:10:02,000
dot slash hello, enter.

1548
01:10:02,000 --> 01:10:05,040
OK, this is why I've had
all those backslash n's.

1549
01:10:05,040 --> 01:10:07,330
Let me zoom in on what's happening.

1550
01:10:07,330 --> 01:10:11,060
I mean, it doesn't look horrible,
but frankly it kind of rubs me

1551
01:10:11,060 --> 01:10:13,080
the wrong way if this
is what my program looks

1552
01:10:13,080 --> 01:10:14,570
like when I'm typing in user input.

1553
01:10:14,570 --> 01:10:15,870
I mean, this just looks stupid.

1554
01:10:15,870 --> 01:10:17,790
Minimally, I should add a space.

1555
01:10:17,790 --> 01:10:19,960
Maybe I can put a backslash
n to move the character.

1556
01:10:19,960 --> 01:10:21,180
This is user interface now.

1557
01:10:21,180 --> 01:10:22,340
This isn't really logic.

1558
01:10:22,340 --> 01:10:24,680
It's just aesthetics, but
I think this looks stupid.

1559
01:10:24,680 --> 01:10:27,350
So that's why I've had the
backslash n's there all the time,

1560
01:10:27,350 --> 01:10:30,930
but that's why they need to be there
to tell the computer to actually put

1561
01:10:30,930 --> 01:10:32,060
things where you want them.

1562
01:10:32,060 --> 01:10:34,310
Alternatively, you know
what, OK, I don't like that.

1563
01:10:34,310 --> 01:10:35,720
Control-C for cancel.

1564
01:10:35,720 --> 01:10:37,050
Let me put this one back.

1565
01:10:37,050 --> 01:10:39,140
What happens if I get rid of this one?

1566
01:10:39,140 --> 01:10:41,790
And let me go ahead and
recompile the code first

1567
01:10:41,790 --> 01:10:45,330
as you note dot slash hello enter.

1568
01:10:45,330 --> 01:10:50,340
OK, I've cleaned up that
aesthetic headache, enter.

1569
01:10:50,340 --> 01:10:54,460
I mean, it's not quite the same
problem, but this looks stupid too

1570
01:10:54,460 --> 01:10:56,760
because the dollar sign just
represents my prompt where

1571
01:10:56,760 --> 01:10:59,650
I'm supposed to type commands
and yet hello comma David prompt.

1572
01:10:59,650 --> 01:11:00,570
And that's just messy.

1573
01:11:00,570 --> 01:11:02,620
So this is why we've had
all of these new lines.

1574
01:11:02,620 --> 01:11:05,790
Now you asked earlier, what if you put
the new line elsewhere in the string.

1575
01:11:05,790 --> 01:11:06,970
Well, suppose I do that.

1576
01:11:06,970 --> 01:11:08,370
Suppose I put a couple of them.

1577
01:11:08,370 --> 01:11:11,080
Let me do this and no spaces whatsoever.

1578
01:11:11,080 --> 01:11:14,430
Now this is looking a little weird, but
the computer is just going to interpret

1579
01:11:14,430 --> 01:11:19,290
this literally-- print H-E-L-L-O comma
new line substitute in the string

1580
01:11:19,290 --> 01:11:21,400
for percent S then another new line.

1581
01:11:21,400 --> 01:11:25,840
So how many lines of output
is this going to display?

1582
01:11:25,840 --> 01:11:26,760
I heard four.

1583
01:11:29,540 --> 01:11:30,270
Other values?

1584
01:11:30,270 --> 01:11:30,890
Let's see.

1585
01:11:30,890 --> 01:11:33,880
Let's go ahead and
make hello and then run

1586
01:11:33,880 --> 01:11:39,340
dot slash hello, what is your name
as before enter hello comma new line

1587
01:11:39,340 --> 01:11:43,040
David-- so four total lines certainly
or just two lines from the computer

1588
01:11:43,040 --> 01:11:44,490
itself.

1589
01:11:44,490 --> 01:11:47,900
So just to recap then,
with code like this

1590
01:11:47,900 --> 01:11:51,950
how many functions have I used
in this particular program?

1591
01:11:54,530 --> 01:11:55,820
How many functions?

1592
01:11:58,940 --> 01:12:01,110
So it's two-- printf, which
we've been using and get

1593
01:12:01,110 --> 01:12:02,310
string, which is the new one.

1594
01:12:02,310 --> 01:12:05,370
Where is string declared?

1595
01:12:05,370 --> 01:12:10,540
CS50 dot h, printf meanwhile is declared
in standard IO.h standard input output.

1596
01:12:10,540 --> 01:12:14,770
Meanwhile, string, this data
type also comes from CS50 itself,

1597
01:12:14,770 --> 01:12:16,810
and then we've used the
format codes, and we've

1598
01:12:16,810 --> 01:12:18,710
use variables to
achieve the same result.

1599
01:12:18,710 --> 01:12:20,050
And let's just hammer this home.

1600
01:12:20,050 --> 01:12:23,120
Brian and Karim, do you mind
popping up for just a second?

1601
01:12:23,120 --> 01:12:24,020
Or who's there?

1602
01:12:24,020 --> 01:12:25,860
Erin, come on up.

1603
01:12:25,860 --> 01:12:27,820
So just to make this
clear because there is now

1604
01:12:27,820 --> 01:12:30,710
some terminology that we want to use.

1605
01:12:30,710 --> 01:12:31,210
Let's see.

1606
01:12:31,210 --> 01:12:32,380
Do you want to be--

1607
01:12:32,380 --> 01:12:33,700
you'll be get string.

1608
01:12:33,700 --> 01:12:37,250
So we have some name tags
here like you get at events.

1609
01:12:37,250 --> 01:12:41,990
So Erin shall be get underscore string.

1610
01:12:41,990 --> 01:12:45,130
If you want go ahead and put this on.

1611
01:12:45,130 --> 01:12:48,730
And Brian, you want to be printf.

1612
01:12:48,730 --> 01:12:51,010
So we won't act out all
of our actual programs

1613
01:12:51,010 --> 01:12:52,770
because this will
quickly become obvious.

1614
01:12:52,770 --> 01:12:53,830
So Brian is printf.

1615
01:12:53,830 --> 01:12:57,510
So this point though,
remains in that this is nice

1616
01:12:57,510 --> 01:12:59,560
that I have some colleagues
with whom I work here

1617
01:12:59,560 --> 01:13:04,130
because I don't really want to do all of
the hard work of making things happen.

1618
01:13:04,130 --> 01:13:06,820
And so if I'm instead the
programmer or the orchestrator

1619
01:13:06,820 --> 01:13:10,420
of a whole bunch of things happening,
I can actually implement this code now

1620
01:13:10,420 --> 01:13:11,200
more physically.

1621
01:13:11,200 --> 01:13:14,920
And let's focus, though, for just a
moment on what the key takeaways are.

1622
01:13:14,920 --> 01:13:17,920
One, functions can take input.

1623
01:13:17,920 --> 01:13:21,130
Those inputs are called
arguments or parameters,

1624
01:13:21,130 --> 01:13:23,140
and functions can return things.

1625
01:13:23,140 --> 01:13:24,870
They can have return values.

1626
01:13:24,870 --> 01:13:27,040
Printf, for instance,
does it take input?

1627
01:13:29,500 --> 01:13:31,210
What's the input to
printf, for instance?

1628
01:13:33,870 --> 01:13:34,980
Yeah, like hello world.

1629
01:13:34,980 --> 01:13:39,180
Whatever it is you want to print is
by definition the input to printf.

1630
01:13:39,180 --> 01:13:43,320
Does print return a value thus far?

1631
01:13:43,320 --> 01:13:45,220
It does do something on
the screen certainly.

1632
01:13:45,220 --> 01:13:47,100
It prints stuff on the
screen, but we haven't

1633
01:13:47,100 --> 01:13:51,300
seen it return something because
we haven't seen it with equal sign

1634
01:13:51,300 --> 01:13:51,890
to the left.

1635
01:13:51,890 --> 01:13:53,690
Now it turns out printf
does return things.

1636
01:13:53,690 --> 01:13:56,280
It's just not often that
useful to use, but we've only

1637
01:13:56,280 --> 01:13:59,640
seen printf for the moment as taking
inputs-- more on that another time.

1638
01:13:59,640 --> 01:14:03,710
Get string, meanwhile--
does get string take inputs?

1639
01:14:03,710 --> 01:14:05,850
How many inputs?

1640
01:14:05,850 --> 01:14:08,970
Just one, the prompt that
you want the human to see.

1641
01:14:08,970 --> 01:14:10,950
The first prompt I used
was what is your name.

1642
01:14:10,950 --> 01:14:12,450
I could make the prompt
anything, but that's

1643
01:14:12,450 --> 01:14:14,070
the question that get string is asking.

1644
01:14:14,070 --> 01:14:16,230
Does get string return a value?

1645
01:14:16,230 --> 01:14:16,830
It does.

1646
01:14:16,830 --> 01:14:20,340
That's of course in Scratch called
answer, hard coded as answer.

1647
01:14:20,340 --> 01:14:22,300
We can store in any variable we want.

1648
01:14:22,300 --> 01:14:24,420
So let me just go ahead
and implement this program.

1649
01:14:24,420 --> 01:14:29,580
Erin, go get me a string and ask
the person, what is their name.

1650
01:14:29,580 --> 01:14:30,750
So--

1651
01:14:30,750 --> 01:14:31,750
ERIN: What is your name?

1652
01:14:31,750 --> 01:14:32,710
AUDIENCE: Elizabeth.

1653
01:14:37,960 --> 01:14:40,510
DAVID: So she's writing
down Elizabeth now.

1654
01:14:40,510 --> 01:14:41,920
But Erin has taken input from me.

1655
01:14:41,920 --> 01:14:44,460
Erin, go get someone's name and
ask them, what is their name.

1656
01:14:44,460 --> 01:14:46,130
And now you've produce output for me.

1657
01:14:46,130 --> 01:14:47,170
Thank you.

1658
01:14:47,170 --> 01:14:49,420
This is the return value,
storing the value Elizabeth,

1659
01:14:49,420 --> 01:14:50,440
and I'm going to go
ahead and took it away

1660
01:14:50,440 --> 01:14:53,020
in a variable called name
like this piece of paper here.

1661
01:14:53,020 --> 01:14:55,950
OK, Brian, could you go ahead
and say hello Elizabeth.

1662
01:15:08,950 --> 01:15:11,200
So what's going on here?

1663
01:15:11,200 --> 01:15:13,180
I'm just doing less work.

1664
01:15:13,180 --> 01:15:14,680
I am writing this program--

1665
01:15:14,680 --> 01:15:17,280
Erin, go get someone's name,
Brian, could you print this out.

1666
01:15:17,280 --> 01:15:19,120
That's what I've been
doing, is programming,

1667
01:15:19,120 --> 01:15:22,180
just delegating functionality to
other functions or in this case

1668
01:15:22,180 --> 01:15:23,830
other humans who know how to do that.

1669
01:15:23,830 --> 01:15:26,620
And honestly, I don't have to
know how Erin got that name.

1670
01:15:26,620 --> 01:15:27,550
She just got it.

1671
01:15:27,550 --> 01:15:31,150
I don't have to know how Brian wrote
in that particular kind of style

1672
01:15:31,150 --> 01:15:32,590
of English on the screen.

1673
01:15:32,590 --> 01:15:36,520
I just know that he can do it,
and now my program is complete.

1674
01:15:36,520 --> 01:15:38,530
Thank you very much to
both of these two here.

1675
01:15:38,530 --> 01:15:41,780
We'll continue in just
a moment as follows.

1676
01:15:41,780 --> 01:15:44,230
So all this time, we've
been taking for granted

1677
01:15:44,230 --> 01:15:47,920
that we have an actual computer
on which we can execute code,

1678
01:15:47,920 --> 01:15:52,420
and I keep saying Intel inside that's
the silly slogan that you see inside

1679
01:15:52,420 --> 01:15:54,790
of most Macs and PCs with
the hardware they have.

1680
01:15:54,790 --> 01:15:57,470
But the CPU is just the
brains of the computer.

1681
01:15:57,470 --> 01:15:59,800
And at the end of the
day, recall that the goal

1682
01:15:59,800 --> 01:16:02,360
is to actually have the computer
turn something like this--

1683
01:16:02,360 --> 01:16:06,640
source code-- into actual
machine code, zeros and ones.

1684
01:16:06,640 --> 01:16:09,650
And that's all Clang was
actually doing for us.

1685
01:16:09,650 --> 01:16:12,610
Of course, we've only just scratched
the surface now of what we can do.

1686
01:16:12,610 --> 01:16:14,600
It turns out there's going
to be, not just these

1687
01:16:14,600 --> 01:16:17,980
commands that we can run,
but other features of C

1688
01:16:17,980 --> 01:16:19,690
and in particular the CS50 library.

1689
01:16:19,690 --> 01:16:21,610
We've only seen thus
far how to get a string,

1690
01:16:21,610 --> 01:16:23,940
but you can get integers and
characters and funky things

1691
01:16:23,940 --> 01:16:26,490
like floats and doubles, which
actually open a can of worms

1692
01:16:26,490 --> 01:16:28,780
as to problems that can
happen in a computer.

1693
01:16:28,780 --> 01:16:32,110
And it turns out you can store
different types of variables, not just

1694
01:16:32,110 --> 01:16:36,370
integers and strings, but bool for
Boolean and chars for characters.

1695
01:16:36,370 --> 01:16:38,320
And you can format
those things in printf.

1696
01:16:38,320 --> 01:16:42,250
We've only seen percent S. I
alluded to percent i earlier,

1697
01:16:42,250 --> 01:16:43,930
but there's a few other still.

1698
01:16:43,930 --> 01:16:45,690
But we've got a lot
of possibilities here.

1699
01:16:45,690 --> 01:16:48,610
But let's go ahead and take, say, a
five minute break to give everyone

1700
01:16:48,610 --> 01:16:51,440
bit of a respite, turn on some
music, and come back in five and dive

1701
01:16:51,440 --> 01:16:56,410
in deeper to more
sophisticated programs in C.

1702
01:16:56,410 --> 01:16:59,720
So recall we began by
comparing some Scratch

1703
01:16:59,720 --> 01:17:02,350
blocks against the corresponding
C code, but we didn't actually

1704
01:17:02,350 --> 01:17:05,230
use most of those blocks in C just yet.

1705
01:17:05,230 --> 01:17:08,950
So let's try out a number of examples,
some of which I'll write on the fly

1706
01:17:08,950 --> 01:17:11,110
in typing code out on my
own keyboard, some of which

1707
01:17:11,110 --> 01:17:12,860
we already have in the
course's web sites.

1708
01:17:12,860 --> 01:17:14,930
So we can just open
them to save some time.

1709
01:17:14,930 --> 01:17:16,720
But let me just draw
your attention to what

1710
01:17:16,720 --> 01:17:19,640
CS50 Sandbox is because this was the
step that I skipped over earlier.

1711
01:17:19,640 --> 01:17:23,110
CS50 Sandbox can be used to
program in bunches of languages.

1712
01:17:23,110 --> 01:17:25,420
We'll initially in the
semester use it for C.

1713
01:17:25,420 --> 01:17:29,710
But if you've written Java before or
Python or any number of languages,

1714
01:17:29,710 --> 01:17:33,010
when you go to
Sandbox.CS50.io, you can simply

1715
01:17:33,010 --> 01:17:34,720
choose the language
you want to write in.

1716
01:17:34,720 --> 01:17:36,700
And then at the bottom,
you'll see you can

1717
01:17:36,700 --> 01:17:39,260
specify the name of the
file you want to precreate.

1718
01:17:39,260 --> 01:17:43,840
So for instance, what I did earlier
was I selected C at top, and then

1719
01:17:43,840 --> 01:17:46,270
at the bottom I typed in
Hello dot C because that

1720
01:17:46,270 --> 01:17:47,740
was the name of the file I wanted.

1721
01:17:47,740 --> 01:17:48,820
And then I clicked start.

1722
01:17:48,820 --> 01:17:53,180
And what that led me to was precisely
the interface in which we wrote hello

1723
01:17:53,180 --> 01:17:57,220
dot C just a moment ago, where my
code editor appears on the top here,

1724
01:17:57,220 --> 01:17:59,380
my terminal window
appears at the bottom,

1725
01:17:59,380 --> 01:18:01,690
and then I'm allowed to
just start writing code.

1726
01:18:01,690 --> 01:18:03,620
So that's how we got to where we were.

1727
01:18:03,620 --> 01:18:06,580
And if you want to follow along
now with some of these examples,

1728
01:18:06,580 --> 01:18:09,280
note that on the course's website
we have all of them premade.

1729
01:18:09,280 --> 01:18:12,820
And you can actually click the
links on the course's web site

1730
01:18:12,820 --> 01:18:15,430
and open up your own copy
of a sandbox with that code.

1731
01:18:15,430 --> 01:18:18,310
So if the Wi-Fi cooperates, you're
welcome to tinker and play and run

1732
01:18:18,310 --> 01:18:19,050
the same commands.

1733
01:18:19,050 --> 01:18:21,660
But everything is also on
the course's website after.

1734
01:18:21,660 --> 01:18:23,660
So you needn't type everything out.

1735
01:18:23,660 --> 01:18:25,580
So let's go ahead and
do just a quick example.

1736
01:18:25,580 --> 01:18:29,590
I'm going to call this int dot
C just so that we can reinforce

1737
01:18:29,590 --> 01:18:31,480
some of what we did just a moment ago.

1738
01:18:31,480 --> 01:18:35,380
Rather than get a string like we did
with our hello example, let me go ahead

1739
01:18:35,380 --> 01:18:39,610
and just get, say, an
integer, and then print it out

1740
01:18:39,610 --> 01:18:41,160
just as we did print a name.

1741
01:18:41,160 --> 01:18:43,870
So I'm going to have to go ahead
and, just through muscle memory,

1742
01:18:43,870 --> 01:18:47,110
I remember that I need
standard IO dot h of the top

1743
01:18:47,110 --> 01:18:50,700
and then int main void
and then curly braces.

1744
01:18:50,700 --> 01:18:54,610
And then I can do the act of
actually getting the input.

1745
01:18:54,610 --> 01:18:56,830
So there was a function
before called get string.

1746
01:18:56,830 --> 01:18:58,660
It turns out there's
another function called

1747
01:18:58,660 --> 01:19:00,530
get int if you want to get an integer.

1748
01:19:00,530 --> 01:19:02,980
So I can actually call get
int, and I can say something

1749
01:19:02,980 --> 01:19:04,390
like integer is the prompt.

1750
01:19:04,390 --> 01:19:06,610
Like, hey, human, please
give me an integer.

1751
01:19:06,610 --> 01:19:09,110
I need a semi-colon at
the end of this line.

1752
01:19:09,110 --> 01:19:14,560
And then how do I actually store the
return value of get int in a variable?

1753
01:19:14,560 --> 01:19:17,740
Just as Erin handed me a
sheet of paper with a string,

1754
01:19:17,740 --> 01:19:22,510
I'm handed a sheet of paper with a
number, how do I store it somewhere?

1755
01:19:22,510 --> 01:19:26,470
What's should I literally
type line five here?

1756
01:19:26,470 --> 01:19:28,090
Int space and then number or something.

1757
01:19:28,090 --> 01:19:30,380
So I'm going to call it i
just because it's an integer,

1758
01:19:30,380 --> 01:19:32,250
but I could call it
number or anything else.

1759
01:19:32,250 --> 01:19:34,340
And then I'm going to go
ahead and print this out.

1760
01:19:34,340 --> 01:19:41,840
So printf-- let's say something
like hello i backslash n semi-colon.

1761
01:19:41,840 --> 01:19:43,040
Not quite correct, right?

1762
01:19:43,040 --> 01:19:45,250
This is going to literally
print hello comma.

1763
01:19:45,250 --> 01:19:47,000
How do I actually
substitute something in?

1764
01:19:47,000 --> 01:19:49,280
Well, we've only seen how
to substitute in strings,

1765
01:19:49,280 --> 01:19:51,340
but I think I spoiled
earlier the answer.

1766
01:19:51,340 --> 01:19:55,280
If you use percent i, that says,
hey, computer, put an integer here.

1767
01:19:55,280 --> 01:19:58,130
Then I need a second
argument to printf just

1768
01:19:58,130 --> 01:20:01,700
as we handed Brian an argument as well.

1769
01:20:01,700 --> 01:20:03,540
And I said i.

1770
01:20:03,540 --> 01:20:05,480
I want to say i here.

1771
01:20:05,480 --> 01:20:07,610
But this program isn't
quite correct yet.

1772
01:20:07,610 --> 01:20:10,910
It's in a file called int dot C.
I've included standard IO dot h.

1773
01:20:10,910 --> 01:20:13,160
It's in main, and so what is main?

1774
01:20:13,160 --> 01:20:15,740
Well, today were largely going
to wave our hands at that.

1775
01:20:15,740 --> 01:20:19,250
But int main void is
perhaps the most cryptic way

1776
01:20:19,250 --> 01:20:21,800
you can say the equivalent
of when green flag clicked.

1777
01:20:21,800 --> 01:20:24,050
That's all that does, and
we'll come back in the weeks

1778
01:20:24,050 --> 01:20:27,140
to come as to why it's int,
why it's main, why it's void.

1779
01:20:27,140 --> 01:20:29,270
But for now, humans
years ago just decided

1780
01:20:29,270 --> 01:20:32,870
that, when you're writing a program in
C and you want to start the program off,

1781
01:20:32,870 --> 01:20:35,910
you literally have to type int
main void with those parentheses

1782
01:20:35,910 --> 01:20:38,370
with those curly braces, and
it's the equivalent to Scratch

1783
01:20:38,370 --> 01:20:40,070
is when green flag clicked.

1784
01:20:40,070 --> 01:20:42,550
But this program will not
compile, and I don't even

1785
01:20:42,550 --> 01:20:44,600
want to induce the stress
of seeing those errors.

1786
01:20:44,600 --> 01:20:46,610
How do I void it?

1787
01:20:46,610 --> 01:20:50,300
Yeah, I need to teach the
computer that get int exists,

1788
01:20:50,300 --> 01:20:54,890
and I know how to do that from before
by including the CS50 so-called library.

1789
01:20:54,890 --> 01:20:57,550
Technically, CS50 dot
h is a header file.

1790
01:20:57,550 --> 01:21:01,490
Dot h means header, and it's
just a file containing C code

1791
01:21:01,490 --> 01:21:03,000
in which the functions are created.

1792
01:21:03,000 --> 01:21:06,590
More on that another time, but that
just gives us access to printf.

1793
01:21:06,590 --> 01:21:08,810
So if I've made no typos,
I should be able to compile

1794
01:21:08,810 --> 01:21:12,930
this program by running what command?

1795
01:21:12,930 --> 01:21:13,620
Make int.

1796
01:21:13,620 --> 01:21:14,790
I could do Clang.

1797
01:21:14,790 --> 01:21:18,540
I could do Clang dash O. But for now
I'm going to do it simpler with just

1798
01:21:18,540 --> 01:21:23,370
make int and let make automate the
process of compiling this program.

1799
01:21:23,370 --> 01:21:25,180
No error messages is good.

1800
01:21:25,180 --> 01:21:26,470
Let me go ahead and zoom in--

1801
01:21:26,470 --> 01:21:29,580
dot slash int I think
would run the program.

1802
01:21:29,580 --> 01:21:31,950
Integer, how about 42?

1803
01:21:31,950 --> 01:21:33,270
Hello 42.

1804
01:21:33,270 --> 01:21:34,610
And notice, I can save time now.

1805
01:21:34,610 --> 01:21:37,950
And if I want to run it again, I don't
have to do slash int all the time.

1806
01:21:37,950 --> 01:21:40,530
It turns out that in this
kind of Linux environment,

1807
01:21:40,530 --> 01:21:43,800
this operating system called Linux,
you can actually go up and down

1808
01:21:43,800 --> 01:21:46,880
and see previous commands you've
typed and some others that

1809
01:21:46,880 --> 01:21:48,370
happen to be system specific.

1810
01:21:48,370 --> 01:21:52,200
And if you just set up and enter, you
can run it again, type in 50 this time,

1811
01:21:52,200 --> 01:21:54,480
and see another output as well.

1812
01:21:54,480 --> 01:21:58,920
So any questions then on
just an example like that?

1813
01:21:58,920 --> 01:21:59,420
No?

1814
01:21:59,420 --> 01:22:02,330
Well, let me go ahead, and I'm going
to save time in this environment.

1815
01:22:02,330 --> 01:22:06,630
I can actually create files in here
if I want by clicking the folder icon,

1816
01:22:06,630 --> 01:22:07,440
clicking the plus.

1817
01:22:07,440 --> 01:22:10,030
And then I can actually say give
me a file called float dot C.

1818
01:22:10,030 --> 01:22:12,380
So this is equivalent to
going back to the main menu

1819
01:22:12,380 --> 01:22:13,370
and typing in the name of the file.

1820
01:22:13,370 --> 01:22:14,640
I'm just going to do it
a little more quickly

1821
01:22:14,640 --> 01:22:16,530
now in this graphical environment.

1822
01:22:16,530 --> 01:22:18,080
And I want to call it float dot C.

1823
01:22:18,080 --> 01:22:21,260
It's A bit of a weird name because
at least growing up you probably

1824
01:22:21,260 --> 01:22:23,390
learned maybe about integers.

1825
01:22:23,390 --> 01:22:25,550
You probably learned about
real numbers, numbers

1826
01:22:25,550 --> 01:22:27,950
that can have decimal points and
then things after the decimal point.

1827
01:22:27,950 --> 01:22:29,900
In a computer, those
things with decimal points

1828
01:22:29,900 --> 01:22:32,920
are called floating
point values, or floats.

1829
01:22:32,920 --> 01:22:35,510
And you can think of it as the
decimal point can kind of float

1830
01:22:35,510 --> 01:22:38,380
to the left or the right, depending
on how big or small the number is

1831
01:22:38,380 --> 01:22:40,940
or how precise the numbers
after the decimal point are.

1832
01:22:40,940 --> 01:22:41,960
That's a float.

1833
01:22:41,960 --> 01:22:44,390
So let me go ahead and implement
a very similar program--

1834
01:22:44,390 --> 01:22:50,620
include CS50 dot h include,
standard IO h int main void--

1835
01:22:50,620 --> 01:22:53,780
and this is after 20 years of doing
this that you can do it so quickly.

1836
01:22:53,780 --> 01:22:56,850
Now let me instead get
a float from the user--

1837
01:22:56,850 --> 01:23:00,170
so a real number that may very
well have a decimal point in it.

1838
01:23:00,170 --> 01:23:02,310
I'm going to do that
a little differently.

1839
01:23:02,310 --> 01:23:05,450
I'll zoom in, and I'm going to say,
hey, computer, give me a float,

1840
01:23:05,450 --> 01:23:07,250
as is the data type called--

1841
01:23:07,250 --> 01:23:09,180
not int, not string but float.

1842
01:23:09,180 --> 01:23:11,990
I'll call it f just because that
sounds like float, and it's nice

1843
01:23:11,990 --> 01:23:15,710
and succinct-- equals get float.

1844
01:23:15,710 --> 01:23:17,330
And then I'm just going to say float.

1845
01:23:17,330 --> 01:23:18,110
That's the prompt.

1846
01:23:18,110 --> 01:23:20,360
I could make the prompt
in green anything I want.

1847
01:23:20,360 --> 01:23:21,660
And now I'm going to print it--

1848
01:23:21,660 --> 01:23:25,610
printf hello f, but I don't want f.

1849
01:23:25,610 --> 01:23:28,340
I want to actually print out a
placeholder and you can probably

1850
01:23:28,340 --> 01:23:30,290
guess by now what the pattern is--

1851
01:23:30,290 --> 01:23:37,040
percent f for a float new
line comma f semi-colon.

1852
01:23:37,040 --> 01:23:40,880
So this is like the same program three
times now with a string, with an int,

1853
01:23:40,880 --> 01:23:41,550
and a float.

1854
01:23:41,550 --> 01:23:44,090
But again, it's just for some muscle
memory and going through the pattern,

1855
01:23:44,090 --> 01:23:45,920
but let's see what
happens differently here.

1856
01:23:45,920 --> 01:23:48,590
Let me go ahead and
type make float enter.

1857
01:23:48,590 --> 01:23:49,860
OK, good, no errors.

1858
01:23:49,860 --> 01:23:58,140
Let me zoom in and run this
now as dot slash float.

1859
01:23:58,140 --> 01:23:59,850
And let me go ahead
and type in a number.

1860
01:23:59,850 --> 01:24:01,590
I'm going to just say 42.

1861
01:24:01,590 --> 01:24:05,150
But the computer now has the
capability of storing more precision.

1862
01:24:05,150 --> 01:24:07,670
Before it was just an
integer by definition of int.

1863
01:24:07,670 --> 01:24:08,730
Now it's a float.

1864
01:24:08,730 --> 01:24:12,440
So even though it's pretty
precise, this 42.0000,

1865
01:24:12,440 --> 01:24:17,000
that's indeed a real number now,
storing some amount of precision there.

1866
01:24:17,000 --> 01:24:21,170
So it turns out though that we
can do more interesting math.

1867
01:24:21,170 --> 01:24:24,680
Let me go ahead and just
open this example in advance.

1868
01:24:24,680 --> 01:24:26,470
This one is going to
be called int dot C.

1869
01:24:26,470 --> 01:24:29,090
So then I don't have
to type everything out.

1870
01:24:29,090 --> 01:24:33,320
And in ints dot C, we're going to
see some math written in code that I

1871
01:24:33,320 --> 01:24:35,840
pre-created just to reinforce
that you can actually

1872
01:24:35,840 --> 01:24:37,820
do some basic arithmetic in a program.

1873
01:24:37,820 --> 01:24:41,050
I can make see more of the code
here by just scrolling down,

1874
01:24:41,050 --> 01:24:43,460
and let me scroll this up
so we can focus on main.

1875
01:24:43,460 --> 01:24:46,010
And let me zoom in on
the first few lines.

1876
01:24:46,010 --> 01:24:49,520
On this first line, I'm just getting
an int, and I'm calling it x.

1877
01:24:49,520 --> 01:24:51,360
We've not used a variable
called x recently.

1878
01:24:51,360 --> 01:24:51,980
But now we are.

1879
01:24:51,980 --> 01:24:54,470
It's no different logically than before.

1880
01:24:54,470 --> 01:24:55,670
Here get me another variable.

1881
01:24:55,670 --> 01:24:58,460
So we can see now that you can get
multiple variables from the user

1882
01:24:58,460 --> 01:24:59,510
just like in Scratch.

1883
01:24:59,510 --> 01:25:04,190
And now in these lines, in
green are just some format

1884
01:25:04,190 --> 01:25:06,860
strings-- just what do I
want printf to display?

1885
01:25:06,860 --> 01:25:12,080
I literally, in this highlighted line
here, want printf to display x plus y

1886
01:25:12,080 --> 01:25:13,910
equals something.

1887
01:25:13,910 --> 01:25:14,870
What is that something?

1888
01:25:14,870 --> 01:25:20,540
Well, notice what's cool about printf
is that, before it is passed in input,

1889
01:25:20,540 --> 01:25:22,540
you can perform simple
arithmetic operations.

1890
01:25:22,540 --> 01:25:25,640
So if you want to add x and y
together, literally do x plus y.

1891
01:25:25,640 --> 01:25:30,020
Then the sum of those numbers is what
will get handed to printf as its input.

1892
01:25:30,020 --> 01:25:32,930
Just like I handed Erin's piece
of paper to Brian as input,

1893
01:25:32,930 --> 01:25:37,250
I'm handing not x and y to
Brian in this case, but x plus y

1894
01:25:37,250 --> 01:25:39,410
or some value, the actual sum.

1895
01:25:39,410 --> 01:25:43,010
Similarly, subtraction is
the hyphen on your keyboard.

1896
01:25:43,010 --> 01:25:45,040
For multiplication, it's not an x.

1897
01:25:45,040 --> 01:25:46,280
That would be weird, xxy.

1898
01:25:46,280 --> 01:25:49,160
It's instead star, or an
asterisk on your keyboard.

1899
01:25:49,160 --> 01:25:52,220
Division is the single slash, and
then this one is a little funky,

1900
01:25:52,220 --> 01:25:53,970
but we'll come up with
some uses for this.

1901
01:25:53,970 --> 01:25:58,310
You can actually do modular arithmetic
or just more simply remainders.

1902
01:25:58,310 --> 01:26:05,490
If you do x percent y, you'll get
back the remainder of dividing x by y.

1903
01:26:05,490 --> 01:26:06,540
And what's the remainder?

1904
01:26:06,540 --> 01:26:14,030
So if x is 20 and y is 10, well, 20
divided by 10 goes in twice perfectly.

1905
01:26:14,030 --> 01:26:15,600
So remainder is 0, for instance.

1906
01:26:15,600 --> 01:26:16,580
But it's been a while.

1907
01:26:16,580 --> 01:26:18,620
So notice, though, what's curious here.

1908
01:26:18,620 --> 01:26:21,220
In this context, percent
is not a placeholder.

1909
01:26:21,220 --> 01:26:22,850
It's not percent S. It's not percent i.

1910
01:26:22,850 --> 01:26:26,840
It's not percent Notice it's not
inside of printf's format string.

1911
01:26:26,840 --> 01:26:29,900
This is just literally
math, a math operator

1912
01:26:29,900 --> 01:26:32,210
as is implied by the
different color blue there.

1913
01:26:32,210 --> 01:26:33,450
So if I actually run this--

1914
01:26:33,450 --> 01:26:35,500
let's go ahead and run this program.

1915
01:26:35,500 --> 01:26:37,340
I'm going to go ahead
and do our make ints--

1916
01:26:37,340 --> 01:26:39,200
plural because that's
the name of the file--

1917
01:26:39,200 --> 01:26:41,510
enter dot slash ints.

1918
01:26:41,510 --> 01:26:44,360
And let me zoom in and clear the screen.

1919
01:26:44,360 --> 01:26:45,290
Enter.

1920
01:26:45,290 --> 01:26:47,280
Give me a number.

1921
01:26:47,280 --> 01:26:48,120
2 I heard.

1922
01:26:48,120 --> 01:26:50,240
And another.

1923
01:26:50,240 --> 01:26:51,620
10 I heard.

1924
01:26:51,620 --> 01:26:58,920
So FYI, 2 plus 10 is 12, 2 minus
10 is negative 8, 2 times 10 is 20,

1925
01:26:58,920 --> 01:27:02,960
2 divided by 10 is--

1926
01:27:02,960 --> 01:27:07,460
2 mod y, or 2 and then take the
remainder when dividing by y

1927
01:27:07,460 --> 01:27:10,190
is what mod means is 2.

1928
01:27:10,190 --> 01:27:14,030
So I get four out of
five for correctness?

1929
01:27:14,030 --> 01:27:15,480
What's a little funky here?

1930
01:27:18,470 --> 01:27:22,590
Yeah, 2 divided by 10?

1931
01:27:22,590 --> 01:27:27,350
Like, I'm pretty sure that's like
2/10 or maybe one fifth or 0.2.

1932
01:27:27,350 --> 01:27:29,840
I mean, I'll take any
number of answers but not 0.

1933
01:27:29,840 --> 01:27:30,950
So what's going on?

1934
01:27:30,950 --> 01:27:32,660
Well, this is a matter
of representation.

1935
01:27:32,660 --> 01:27:35,180
It turns out in a computer
program, we decided

1936
01:27:35,180 --> 01:27:37,730
in advance I'm going to store ints.

1937
01:27:37,730 --> 01:27:40,040
An int is something that does
not have a decimal point.

1938
01:27:40,040 --> 01:27:42,920
And yet here I am rather
presumptuously trying

1939
01:27:42,920 --> 01:27:46,160
to do to 2, an integer,
divided by 10, an integer,

1940
01:27:46,160 --> 01:27:48,360
and expecting something
other than an integer.

1941
01:27:48,360 --> 01:27:52,650
No, I literally am doing
integer arithmetic.

1942
01:27:52,650 --> 01:27:55,580
So what's the computer apparently
doing just intuitively?

1943
01:27:55,580 --> 01:28:00,460
Why, when dividing x by y
as I did in this line here--

1944
01:28:00,460 --> 01:28:03,920
or specifically in this example
you proposed, 2 divide by 10--

1945
01:28:03,920 --> 01:28:08,000
where is my 2/10 going?

1946
01:28:08,000 --> 01:28:09,910
Yeah, it's technically what?

1947
01:28:09,910 --> 01:28:12,710
Supposed to be 0.2, or 0.2.

1948
01:28:12,710 --> 01:28:16,370
That's actually the solution
because, if it's 0.2 but integers

1949
01:28:16,370 --> 01:28:19,880
can't store decimal points or anything
after them, what do you have left?

1950
01:28:19,880 --> 01:28:21,830
Just the zero at the beginning.

1951
01:28:21,830 --> 01:28:24,800
So integer arithmetic is fine
if you're working with integers,

1952
01:28:24,800 --> 01:28:27,050
but if you want floating
point arithmetic,

1953
01:28:27,050 --> 01:28:29,130
you're going to need
to make some changes.

1954
01:28:29,130 --> 01:28:30,500
And so I can fix this.

1955
01:28:30,500 --> 01:28:33,740
In fact, let me go ahead and
write a different program here.

1956
01:28:33,740 --> 01:28:36,610
Let me go ahead and open up
from the course's website

1957
01:28:36,610 --> 01:28:43,580
floats dot C. That's going to give
me this example, which is implemented

1958
01:28:43,580 --> 01:28:46,220
using floating point values instead.

1959
01:28:46,220 --> 01:28:48,970
So once this loads, I'm going to
see a program I wrote in advance.

1960
01:28:48,970 --> 01:28:52,820
It's a little shorter because now I
only care about looking at one problem.

1961
01:28:52,820 --> 01:28:56,000
And notice now x and y are
now floats and not ints,

1962
01:28:56,000 --> 01:28:57,290
another data type that exists.

1963
01:28:57,290 --> 01:29:00,200
And I'm using get float, which
also comes from CS50's library.

1964
01:29:00,200 --> 01:29:03,230
And then this line is almost
the same, but you know what?

1965
01:29:03,230 --> 01:29:04,280
Let me let me tweak this.

1966
01:29:04,280 --> 01:29:06,110
Let me just make it exactly the same.

1967
01:29:06,110 --> 01:29:10,170
This line now that I've highlighted
is exactly the same as before.

1968
01:29:10,170 --> 01:29:12,210
So if I do type in the same number--

1969
01:29:12,210 --> 01:29:17,960
so let's go ahead and zoom in and
do make floats plural and dot slash

1970
01:29:17,960 --> 01:29:18,680
floats.

1971
01:29:18,680 --> 01:29:23,350
I'll give it 2 and 10, and I
should hopefully see what now?

1972
01:29:23,350 --> 01:29:25,090
0.2.

1973
01:29:25,090 --> 01:29:27,280
That's pretty good, pretty precise.

1974
01:29:27,280 --> 01:29:29,590
But you know what?

1975
01:29:29,590 --> 01:29:34,560
I hate to tell you, but
let's look a little farther.

1976
01:29:34,560 --> 01:29:36,270
It turns out by default,
when you percent

1977
01:29:36,270 --> 01:29:41,130
f, you only see a few decimal places,
like five or so it looks, by default.

1978
01:29:41,130 --> 01:29:43,260
Let me see a few more so.

1979
01:29:43,260 --> 01:29:47,880
This was one one, two,
three, four, five, six

1980
01:29:47,880 --> 01:29:49,250
points after the decimal point.

1981
01:29:49,250 --> 01:29:49,950
So you know what?

1982
01:29:49,950 --> 01:29:52,500
I'm going to say, hey, computer,
give me decimal points.

1983
01:29:52,500 --> 01:29:54,420
This looks completely
cryptic and you just

1984
01:29:54,420 --> 01:29:56,970
have to kind of remember this
or look it up if you forget.

1985
01:29:56,970 --> 01:30:00,720
If you put a dot and a number in
between the percent and the f,

1986
01:30:00,720 --> 01:30:03,180
that's the cryptic way of
telling the computer show

1987
01:30:03,180 --> 01:30:05,850
me a float but with this
many decimal places, please.

1988
01:30:05,850 --> 01:30:10,100
So that just gives me decimal places,
weird as the expression looks.

1989
01:30:10,100 --> 01:30:12,270
Now hopefully I'm just going
to see some more zeros.

1990
01:30:12,270 --> 01:30:15,450
So let me go ahead and make
floats, and let me go ahead

1991
01:30:15,450 --> 01:30:20,100
and zoom in and do dot
slash floats 2 10 enter.

1992
01:30:20,100 --> 01:30:22,930
OK, still correct.

1993
01:30:22,930 --> 01:30:25,320
Let me get a little curious.

1994
01:30:25,320 --> 01:30:28,230
Let's see a lot of
zeros, like 50 of them.

1995
01:30:28,230 --> 01:30:32,520
Let me go down here and do make
floats, because I changed the code,

1996
01:30:32,520 --> 01:30:36,900
dot slash floats 2 10.

1997
01:30:36,900 --> 01:30:41,250
Ha, your grade school
teachers lied to you.

1998
01:30:41,250 --> 01:30:49,650
2 divided by 10 is apparently
not 0.2000000 infinitely.

1999
01:30:49,650 --> 01:30:59,010
It's apparently
0.20000000298023223876953125 and then

2000
01:30:59,010 --> 01:31:00,060
all of those zeros.

2001
01:31:00,060 --> 01:31:03,100
What the hell is going on?

2002
01:31:03,100 --> 01:31:04,170
Where's the bug?

2003
01:31:04,170 --> 01:31:05,250
Where's my mistake?

2004
01:31:05,250 --> 01:31:06,950
Where's my misunderstanding?

2005
01:31:09,550 --> 01:31:13,080
What's the explanation for this?

2006
01:31:13,080 --> 01:31:18,210
Well, what if I told you that inside
of your computer is stuff like this?

2007
01:31:18,210 --> 01:31:21,300
This is RAM or memory, and you've
probably generally known this idea.

2008
01:31:21,300 --> 01:31:22,860
They just store files.

2009
01:31:22,860 --> 01:31:24,210
They store music and videos.

2010
01:31:24,210 --> 01:31:25,800
You need memory, some kind of space.

2011
01:31:25,800 --> 01:31:27,810
Hard disk space is permanent storage.

2012
01:31:27,810 --> 01:31:31,330
RAM, or Random Access
Memory, is temporary storage.

2013
01:31:31,330 --> 01:31:33,830
So when your laptop is open and
your desktop computers is on

2014
01:31:33,830 --> 01:31:36,750
or your phone is powered, you're
using RAM for all of the programs

2015
01:31:36,750 --> 01:31:37,710
you're running at once.

2016
01:31:37,710 --> 01:31:40,230
If you open a file, that
file is stored in RAM,

2017
01:31:40,230 --> 01:31:42,190
but it's permanently
stored on your hard drive.

2018
01:31:42,190 --> 01:31:43,730
So there's different types of memory.

2019
01:31:43,730 --> 01:31:45,360
But notice, this is zoomed in.

2020
01:31:45,360 --> 01:31:49,240
In reality, this is like couple of
inches wide and maybe an inch tall.

2021
01:31:49,240 --> 01:31:52,350
So it's pretty small, but it
doesn't really matter how big it is.

2022
01:31:52,350 --> 01:31:54,960
It just matters that
it's finite in size.

2023
01:31:54,960 --> 01:31:58,350
You have physical hardware on your
laps or in your pockets or at home

2024
01:31:58,350 --> 01:32:01,890
that only are so big and
therefore only have so many parts

2025
01:32:01,890 --> 01:32:04,800
and therefore only have
so many transistors

2026
01:32:04,800 --> 01:32:06,780
and other pieces of
hardware that's actually

2027
01:32:06,780 --> 01:32:08,890
doing the work of storing information.

2028
01:32:08,890 --> 01:32:13,620
And so if you only have a finite
amount of memory, how in the world

2029
01:32:13,620 --> 01:32:18,030
are we going to represent an
infinite number of numbers?

2030
01:32:18,030 --> 01:32:19,830
Because I do recall
from grade school I was

2031
01:32:19,830 --> 01:32:22,990
taught there is an infinite number of
numbers, certainly real numbers, where

2032
01:32:22,990 --> 01:32:25,090
the decimal point can go on forever.

2033
01:32:25,090 --> 01:32:28,620
That is a problem if you want to
represent all possible numbers

2034
01:32:28,620 --> 01:32:34,750
in the universe, which is infinitely
many, with a finite amount of hardware.

2035
01:32:34,750 --> 01:32:39,120
So at some point, the computer's
gotta start cutting some corners.

2036
01:32:39,120 --> 01:32:42,030
And so what you're really
seeing here is as close

2037
01:32:42,030 --> 01:32:46,650
as the computer can get to storing
that fraction for you precisely,

2038
01:32:46,650 --> 01:32:47,740
and I got a little greedy.

2039
01:32:47,740 --> 01:32:50,020
I looked a little too far to the right.

2040
01:32:50,020 --> 01:32:52,950
And granted, these are
infinitesimally small values.

2041
01:32:52,950 --> 01:32:55,940
It's not hugely, hugely
off, but it is off

2042
01:32:55,940 --> 01:32:58,060
because they can't expect
the computer to represent

2043
01:32:58,060 --> 01:33:01,480
an infinite number of values
using a finite amount of memory.

2044
01:33:01,480 --> 01:33:06,930
It's got to round off here or there
and be imprecise, so to speak.

2045
01:33:06,930 --> 01:33:07,890
So is this a problem?

2046
01:33:10,990 --> 01:33:13,660
I mean, we would never have known
this if I hadn't gotten greedy

2047
01:33:13,660 --> 01:33:18,570
and looked at 50 decimal places instead
of 7, which was already pretty precise.

2048
01:33:18,570 --> 01:33:19,320
Is this a problem?

2049
01:33:21,900 --> 01:33:23,730
Yeah, like why?

2050
01:33:23,730 --> 01:33:24,890
Why?

2051
01:33:24,890 --> 01:33:27,910
AUDIENCE: If you use the
equal function, [INAUDIBLE]..

2052
01:33:27,910 --> 01:33:29,210
DAVID: Yeah, that's a good one.

2053
01:33:29,210 --> 01:33:33,410
Logically, if I start using equals
equals to compare things for equality,

2054
01:33:33,410 --> 01:33:36,610
it's going to be really hard for me
to ever compare something for 2/10

2055
01:33:36,610 --> 01:33:38,660
as it's value because I'm
going to literally have

2056
01:33:38,660 --> 01:33:42,560
to remember or write down or figure
out this value and compare against that

2057
01:33:42,560 --> 01:33:45,180
and not just compare
more loosely against 0.2.

2058
01:33:45,180 --> 01:33:48,590
And that's true, you should actually
never compare floating point values

2059
01:33:48,590 --> 01:33:50,240
in code for equality.

2060
01:33:50,240 --> 01:33:53,270
I could probably get away with
less than or greater than,

2061
01:33:53,270 --> 01:33:57,350
but even then it's going to be
a little off from what I expect.

2062
01:33:57,350 --> 01:33:59,960
Why else might this
imprecision be worrisome?

2063
01:34:02,770 --> 01:34:05,830
When might you not want your
computer being imprecise?

2064
01:34:05,830 --> 01:34:06,640
What domains?

2065
01:34:06,640 --> 01:34:08,370
What worlds outside of a classroom?

2066
01:34:08,370 --> 01:34:10,060
Yeah?

2067
01:34:10,060 --> 01:34:10,680
What's that?

2068
01:34:10,680 --> 01:34:11,520
AUDIENCE: Rocket.

2069
01:34:11,520 --> 01:34:17,620
DAVID: Yeah, so rockets, or anything
involving math and physics and danger.

2070
01:34:17,620 --> 01:34:20,820
You don't want numbers to
be ever so slightly off.

2071
01:34:20,820 --> 01:34:22,990
And if you think about it,
rockets is a good example

2072
01:34:22,990 --> 01:34:26,080
because I don't know much about
rockets, but I know they go pretty fast

2073
01:34:26,080 --> 01:34:28,210
and there's probably angles
involved because you're

2074
01:34:28,210 --> 01:34:29,990
trying to keep them on a trajectory.

2075
01:34:29,990 --> 01:34:30,730
And that's fine.

2076
01:34:30,730 --> 01:34:32,710
But if your trajectory
is ever so slightly off

2077
01:34:32,710 --> 01:34:35,080
and something's going
really fast and really far,

2078
01:34:35,080 --> 01:34:40,090
I'm pretty sure that eventually those
small imprecisions start to add up.

2079
01:34:40,090 --> 01:34:42,820
And indeed, there's been
historical incidents

2080
01:34:42,820 --> 01:34:45,850
where that kind of imprecision
does, in fact, add up

2081
01:34:45,850 --> 01:34:49,550
in the realm of militaristic
operations or in financial operations.

2082
01:34:49,550 --> 01:34:52,780
In fact, if you've ever seen Office
Space or way back when Superman 3,

2083
01:34:52,780 --> 01:34:56,080
this is how some people made
some money because they just

2084
01:34:56,080 --> 01:34:59,980
kept all of the fractions of pennies
that computer systems were just

2085
01:34:59,980 --> 01:35:00,860
ignoring.

2086
01:35:00,860 --> 01:35:02,410
And eventually, they start to add up.

2087
01:35:02,410 --> 01:35:06,160
So long story short, any time
you have scientific or financial

2088
01:35:06,160 --> 01:35:10,270
or any sort of large data sets that
involve big numbers and lots of them

2089
01:35:10,270 --> 01:35:12,640
and lots of time, this is a problem.

2090
01:35:12,640 --> 01:35:16,270
And it almost suggests you shouldn't
you C or let alone computers

2091
01:35:16,270 --> 01:35:17,680
unless we actually address this.

2092
01:35:17,680 --> 01:35:20,680
Now as a spoiler, humans have
chipped away at this problem,

2093
01:35:20,680 --> 01:35:25,390
and you can use more and more
bits but not infinitely many bits.

2094
01:35:25,390 --> 01:35:27,390
At some point you have
to draw a line, but this

2095
01:35:27,390 --> 01:35:29,440
is why, for instance, a
stock exchange might only

2096
01:35:29,440 --> 01:35:31,360
represent two decimal
points of precision

2097
01:35:31,360 --> 01:35:35,000
for dollars or maybe four decimal points
to the thousandths place for dollars

2098
01:35:35,000 --> 01:35:35,500
and cents.

2099
01:35:35,500 --> 01:35:37,750
And they just have to decide,
that's all the precision

2100
01:35:37,750 --> 01:35:39,110
we can actually store precisely.

2101
01:35:39,110 --> 01:35:42,850
But you've got to decide how to handle
it and not just ignore the problem.

2102
01:35:42,850 --> 01:35:44,200
But we can do a little better.

2103
01:35:44,200 --> 01:35:44,950
You know what?

2104
01:35:44,950 --> 01:35:47,740
It turns out that in
most computers a float,

2105
01:35:47,740 --> 01:35:49,580
it takes up, yes, a
finite amount of space,

2106
01:35:49,580 --> 01:35:53,500
but very specifically 32
bits of space or 4 bytes.

2107
01:35:53,500 --> 01:35:54,940
A byte, recall, is 8 bits.

2108
01:35:54,940 --> 01:35:59,080
So 4 bytes is 32 bits, and that's
just a very common unit of measure.

2109
01:35:59,080 --> 01:36:00,130
But there's another one.

2110
01:36:00,130 --> 01:36:02,950
It turns out, if you
want twice as many bits,

2111
01:36:02,950 --> 01:36:06,520
you can literally use a
data type called double.

2112
01:36:06,520 --> 01:36:11,050
And in the CS50 Library, there
is a function called get double.

2113
01:36:11,050 --> 01:36:16,570
And if I go ahead and do it here,
I can now recompile this code,

2114
01:36:16,570 --> 01:36:20,320
make floats, even though they're
not technically float types anymore.

2115
01:36:20,320 --> 01:36:23,710
And let me go ahead and
do dot slash floats enter,

2116
01:36:23,710 --> 01:36:26,200
and let me type in 2 and 10.

2117
01:36:26,200 --> 01:36:28,960
And now it's still imprecise.

2118
01:36:28,960 --> 01:36:32,390
But notice, instead of seven
zeros, which I think I had before,

2119
01:36:32,390 --> 01:36:38,500
now I've got 1, 2, 3, 4, 5, 6, 7,
8, 9, 10, 11, 12, 13, 14, 15 zeros.

2120
01:36:38,500 --> 01:36:41,590
So I've kind of pushed the
problem further out, so to speak,

2121
01:36:41,590 --> 01:36:42,510
so it's more precise.

2122
01:36:42,510 --> 01:36:43,390
But it's not perfect.

2123
01:36:43,390 --> 01:36:45,790
You can't get certain
values perfect if you

2124
01:36:45,790 --> 01:36:49,270
want to be able to
represent an infinite range.

2125
01:36:49,270 --> 01:36:52,840
Any questions then about this?

2126
01:36:52,840 --> 01:36:54,680
And we'll come back as
to some implications.

2127
01:36:54,680 --> 01:36:56,110
Yeah, here.

2128
01:36:56,110 --> 01:36:57,990
AUDIENCE: So would it
always be better if you

2129
01:36:57,990 --> 01:36:59,890
use doubles because it's more precise?

2130
01:36:59,890 --> 01:37:00,770
DAVID: Good question.

2131
01:37:00,770 --> 01:37:03,380
Would always be better to use
doubles because they're more precise?

2132
01:37:03,380 --> 01:37:06,410
Short answer, yes, but we're going
to see thematically in this course

2133
01:37:06,410 --> 01:37:09,030
and computer science more generally
there's always a trade-off.

2134
01:37:09,030 --> 01:37:13,160
And yes, if you use a double, you
will avoid this problem a bit more,

2135
01:37:13,160 --> 01:37:15,880
but what price will
you pay, so to speak?

2136
01:37:15,880 --> 01:37:18,840
Maybe processing power because it's
got to deal with more bits at once,

2137
01:37:18,840 --> 01:37:22,130
and even more literally, more space.

2138
01:37:22,130 --> 01:37:24,090
I mean, sure we can take
your solution, but I'm

2139
01:37:24,090 --> 01:37:25,710
going to charge you twice as many bits.

2140
01:37:25,710 --> 01:37:28,740
And back in the day, decades ago,
when C was first being invented

2141
01:37:28,740 --> 01:37:32,640
and computers were really coming into
play, spending twice as many bits,

2142
01:37:32,640 --> 01:37:35,340
even if it's only 32
more tiny zeros and ones,

2143
01:37:35,340 --> 01:37:38,370
that was actually expensive literally
financially, and it adds up.

2144
01:37:38,370 --> 01:37:40,370
And even today, if you
want to spend more space,

2145
01:37:40,370 --> 01:37:42,000
that's fine, but you're going to spend.

2146
01:37:42,000 --> 01:37:43,950
More space, therefore
more money, and therefore

2147
01:37:43,950 --> 01:37:45,750
have less space available
for other things.

2148
01:37:45,750 --> 01:37:46,800
So it's just a trade-off.

2149
01:37:46,800 --> 01:37:51,150
And you have to decide,
as an intelligent human,

2150
01:37:51,150 --> 01:37:54,700
where the right inflection point
is between what's more important.

2151
01:37:54,700 --> 01:37:59,390
Let me open up a very different example
now called parity, just as an example.

2152
01:37:59,390 --> 01:38:05,820
And let me ask this d how do you
know if a number is even or odd?

2153
01:38:05,820 --> 01:38:07,660
What's the trick?

2154
01:38:07,660 --> 01:38:11,780
Yeah, if it's divided by
2-- so 0 and 2 and 4 and 6

2155
01:38:11,780 --> 01:38:15,140
are even because, if you divide
by 2, you don't get a remainder.

2156
01:38:15,140 --> 01:38:17,600
So actually, if you just want
to see a quick example of why

2157
01:38:17,600 --> 01:38:20,220
you might use a remainder, even
though it's out of context.

2158
01:38:20,220 --> 01:38:21,440
Here's an example for parity.

2159
01:38:21,440 --> 01:38:25,250
Parity is just a term referring
to even or odd in this context.

2160
01:38:25,250 --> 01:38:26,460
How might we use this?

2161
01:38:26,460 --> 01:38:29,570
Well, notice I can get an int
from the user up at the top.

2162
01:38:29,570 --> 01:38:31,970
I can then check the parity
of the integer-- is it even

2163
01:38:31,970 --> 01:38:33,410
or odd-- with syntax like this.

2164
01:38:33,410 --> 01:38:35,890
Now I'm combining some
of these operators

2165
01:38:35,890 --> 01:38:37,640
as you might be inclined intuitively.

2166
01:38:37,640 --> 01:38:42,710
If n, the number user typed
in, mod 2, or divided by

2167
01:38:42,710 --> 01:38:46,490
and then check the remainder of, but
that's a mouthful equals equals 0,

2168
01:38:46,490 --> 01:38:48,410
you just said it's an even number--

2169
01:38:48,410 --> 01:38:50,710
so print even else print odd.

2170
01:38:50,710 --> 01:38:52,550
Because what's the
possible other remainder?

2171
01:38:52,550 --> 01:38:58,280
If you do n or any value divided by 2,
you might get a remainder of 0 or 1.

2172
01:38:58,280 --> 01:39:02,120
I only have to check for one of
those, 0 because the else implies

2173
01:39:02,120 --> 01:39:02,870
the other thing.

2174
01:39:02,870 --> 01:39:04,520
So again, very simple example.

2175
01:39:04,520 --> 01:39:07,190
But honestly, all of us probably
have an intuitive understanding

2176
01:39:07,190 --> 01:39:08,330
of what's even and odd.

2177
01:39:08,330 --> 01:39:10,670
A computer needs to be
taught that, and so there's

2178
01:39:10,670 --> 01:39:13,020
a program that does exactly that.

2179
01:39:13,020 --> 01:39:16,230
Let me open up a larger
program called conditions,

2180
01:39:16,230 --> 01:39:19,070
and rather than type this one out,
because it's a few lines of code,

2181
01:39:19,070 --> 01:39:21,350
let me just open it up
because it concludes

2182
01:39:21,350 --> 01:39:23,990
exactly the code we saw a
little bit ago on the slide

2183
01:39:23,990 --> 01:39:27,110
when we compared it
to a similar C block.

2184
01:39:27,110 --> 01:39:31,070
In this program, in my main function--
let me focus on the first few lines

2185
01:39:31,070 --> 01:39:31,820
there--

2186
01:39:31,820 --> 01:39:35,840
I have an int called x that
I'm getting via get int,

2187
01:39:35,840 --> 01:39:38,510
another int called y that
I'm getting via get int,

2188
01:39:38,510 --> 01:39:40,970
and then I'm just doing
some simple comparisons.

2189
01:39:40,970 --> 01:39:43,100
We saw this again when we
compared it to Scratch,

2190
01:39:43,100 --> 01:39:46,820
but this is quite simply
that same code in context

2191
01:39:46,820 --> 01:39:49,980
rather than just seeing
it statically on a slide.

2192
01:39:49,980 --> 01:39:53,160
So let me go ahead and compile
this-- make conditions enter.

2193
01:39:53,160 --> 01:39:54,500
It seems to compile.

2194
01:39:54,500 --> 01:39:58,700
Let me zoom in and do dot
slash conditions enter.

2195
01:39:58,700 --> 01:40:02,270
x will be, say, 2 again, y will be 10.

2196
01:40:02,270 --> 01:40:03,710
x is indeed less than y.

2197
01:40:03,710 --> 01:40:07,340
If I run it again-- and I can save
time by hitting up through my history

2198
01:40:07,340 --> 01:40:08,420
and just hitting Enter.

2199
01:40:08,420 --> 01:40:12,930
Let's do 2 and 2, and indeed
x is equal to y and so forth.

2200
01:40:12,930 --> 01:40:15,890
So again, just the exact same
kind of code as before but now

2201
01:40:15,890 --> 01:40:17,810
in the context of a working program.

2202
01:40:17,810 --> 01:40:21,680
What if I actually wanted to get user
input kind of like our past student did

2203
01:40:21,680 --> 01:40:25,430
with getting a yes or no answers to
the apple and the cupcake question?

2204
01:40:25,430 --> 01:40:29,060
Well in answer dot C, it
turns out you can actually

2205
01:40:29,060 --> 01:40:33,650
get textual input from the user,
perhaps a simple yes or no or just y

2206
01:40:33,650 --> 01:40:35,300
or n for succinctness.

2207
01:40:35,300 --> 01:40:37,640
And in this case, if I just
get back a single character,

2208
01:40:37,640 --> 01:40:40,080
it turns out there's a separate
data type for character.

2209
01:40:40,080 --> 01:40:42,350
If you don't want a whole
string, like a whole word

2210
01:40:42,350 --> 01:40:45,320
or a paragraph or sentence or
whatever, you just want one character.

2211
01:40:45,320 --> 01:40:48,230
You can actually use what's
called a char or character.

2212
01:40:48,230 --> 01:40:54,020
And so here I'm using one other function
appropriately named called get char.

2213
01:40:54,020 --> 01:40:58,370
I'm storing it in a variable called C
because it's nice and succinct of type

2214
01:40:58,370 --> 01:41:01,520
char, and then notice this.

2215
01:41:01,520 --> 01:41:03,770
You might not have seen
this syntax before,

2216
01:41:03,770 --> 01:41:06,950
especially if you've never
programmed before even in Scratch.

2217
01:41:06,950 --> 01:41:10,070
But you might have seen this
block similar to this in Scratch.

2218
01:41:10,070 --> 01:41:14,170
What does the vertical double
bar probably imply here?

2219
01:41:14,170 --> 01:41:14,820
Or, that's it.

2220
01:41:14,820 --> 01:41:16,620
So in Scratch, it's
nice and user friendly.

2221
01:41:16,620 --> 01:41:19,100
They literally just say
O-R. In programming, it's

2222
01:41:19,100 --> 01:41:22,310
often the case that use just more
cryptic sequences of characters

2223
01:41:22,310 --> 01:41:24,500
and two vertical bars,
which are typically

2224
01:41:24,500 --> 01:41:26,870
above the Enter key on a US keyboard.

2225
01:41:26,870 --> 01:41:31,520
If C equals equals capital y or
C equals equals lowercase y--

2226
01:41:31,520 --> 01:41:35,430
let's assume that the user wanted
to say yes and go ahead and say yes.

2227
01:41:35,430 --> 01:41:39,230
Else if the user typed in n in
capitals or and in lowercase,

2228
01:41:39,230 --> 01:41:42,450
let's assume he or she meant
no and say no accordingly.

2229
01:41:42,450 --> 01:41:45,100
And what are we going to do otherwise?

2230
01:41:45,100 --> 01:41:47,000
Apparently nothing, and that's fine.

2231
01:41:47,000 --> 01:41:50,160
You don't need to have a default case
if you want the program to do nothing.

2232
01:41:50,160 --> 01:41:54,250
It might be a little confusing because
the user can type in some random word

2233
01:41:54,250 --> 01:41:56,620
and get no output, but
that's a design decision.

2234
01:41:56,620 --> 01:41:59,350
Logically this is just
how we might express this.

2235
01:42:02,880 --> 01:42:06,180
What about actually
building our own blocks?

2236
01:42:06,180 --> 01:42:11,280
Any questions, though,
before we start to create?

2237
01:42:11,280 --> 01:42:15,010
So recall that in Scratch
we had that cough example.

2238
01:42:15,010 --> 01:42:17,520
Let me go ahead and create
a file here real quickly

2239
01:42:17,520 --> 01:42:22,620
called cough zero dot C and just kind
of recreate what we did last week.

2240
01:42:22,620 --> 01:42:26,340
Include standard IO
dot h int main void--

2241
01:42:26,340 --> 01:42:27,900
again, just muscle memory now--

2242
01:42:27,900 --> 01:42:32,700
and then printf quote unquote
"cough" backslash n semi-colon.

2243
01:42:32,700 --> 01:42:33,450
And you know what?

2244
01:42:33,450 --> 01:42:37,740
Let me go ahead and cough not
once, but twice, three times.

2245
01:42:37,740 --> 01:42:39,810
The moment you start
copying and pasting,

2246
01:42:39,810 --> 01:42:42,460
you're probably not writing good code.

2247
01:42:42,460 --> 01:42:43,590
It's not very maintainable.

2248
01:42:43,590 --> 01:42:46,210
Now if I want to change the word or
translate it to another language,

2249
01:42:46,210 --> 01:42:47,700
I have to change it in three places.

2250
01:42:47,700 --> 01:42:49,890
We already decided
last week that was bad.

2251
01:42:49,890 --> 01:42:54,150
So what would be better in C
or in Scratch or in general

2252
01:42:54,150 --> 01:42:56,090
than this approach?

2253
01:42:56,090 --> 01:42:57,230
Yeah, so a for loop.

2254
01:42:57,230 --> 01:42:59,420
So let me do that let
me create another file.

2255
01:42:59,420 --> 01:43:02,950
I'm going to call this one cough
one dot C, is my second version.

2256
01:43:02,950 --> 01:43:06,540
Let me go ahead now and just
copy and paste the original code,

2257
01:43:06,540 --> 01:43:07,630
and let's just improve it.

2258
01:43:07,630 --> 01:43:11,260
Let's get rid of two of these, and
let's see if we can't express the 4.

2259
01:43:11,260 --> 01:43:13,120
So it was 4--

2260
01:43:13,120 --> 01:43:14,670
let me zoom in--

2261
01:43:14,670 --> 01:43:16,590
int i get 0.

2262
01:43:16,590 --> 01:43:18,250
i is less than some number.

2263
01:43:18,250 --> 01:43:19,160
Before it was 50.

2264
01:43:19,160 --> 01:43:20,850
Now I'm going to have it be 3.

2265
01:43:20,850 --> 01:43:27,430
i plus plus curly braces, and now let
me move the cough block inside of there

2266
01:43:27,430 --> 01:43:29,080
and indent it just to be pretty.

2267
01:43:29,080 --> 01:43:33,610
And notice stylistically, I've been
doing this instinctively for some time.

2268
01:43:33,610 --> 01:43:36,760
Everything's nicely indented
just to make it more readable,

2269
01:43:36,760 --> 01:43:39,760
quite like the Scratch blocks, even
though again a lot of white space

2270
01:43:39,760 --> 01:43:41,750
doesn't matter to the computer.

2271
01:43:41,750 --> 01:43:43,840
So if I go ahead and run this--

2272
01:43:43,840 --> 01:43:46,150
let me pull up the terminal
window so I can see it.

2273
01:43:46,150 --> 01:43:49,360
Make cough one, enter--

2274
01:43:49,360 --> 01:43:53,590
looks good-- dot slash
cough one cough cough cough.

2275
01:43:53,590 --> 01:43:57,220
That's good, but recall that we
actually improved this design further

2276
01:43:57,220 --> 01:43:58,540
by abstracting it away.

2277
01:43:58,540 --> 01:44:00,790
Let me go ahead and make
my own function now.

2278
01:44:00,790 --> 01:44:05,870
Let me go ahead and open
up a new file, cough 2

2279
01:44:05,870 --> 01:44:10,060
dot C, just like I had
another scratch program.

2280
01:44:10,060 --> 01:44:19,550
Again, include standard IO dot h
int main void, and then in here

2281
01:44:19,550 --> 01:44:21,650
let me go ahead and do what?

2282
01:44:21,650 --> 01:44:29,990
Well, for int i get 0, i less than
3, i plus plus plus curly braces.

2283
01:44:29,990 --> 01:44:32,660
Then let me go ahead
and just call cough.

2284
01:44:32,660 --> 01:44:35,900
It would be nice if cough existed, but
unfortunately cough does not exist.

2285
01:44:35,900 --> 01:44:37,370
It's not in the CS50 library even.

2286
01:44:37,370 --> 01:44:38,840
So that's not going to help us.

2287
01:44:38,840 --> 01:44:40,900
I have to make my own function.

2288
01:44:40,900 --> 01:44:42,740
So in Scratch, you went
to the block's thing

2289
01:44:42,740 --> 01:44:45,080
and you make your own block
and the big prompt comes up

2290
01:44:45,080 --> 01:44:46,430
and you make your new puzzle piece.

2291
01:44:46,430 --> 01:44:48,760
Here we're going to have to
be a little more deliberate,

2292
01:44:48,760 --> 01:44:51,980
and it turns out you
can do it like this.

2293
01:44:51,980 --> 01:44:54,350
Some of these details will
be non-obvious at first,

2294
01:44:54,350 --> 01:44:57,050
but I'm going to go ahead
and call the function cough.

2295
01:44:57,050 --> 01:44:59,930
And cough at the moment does
not need to take any inputs.

2296
01:44:59,930 --> 01:45:01,460
So the key word there is void.

2297
01:45:01,460 --> 01:45:02,960
And we've actually seen that before.

2298
01:45:02,960 --> 01:45:04,820
Main also has not been
taking any inputs.

2299
01:45:04,820 --> 01:45:07,840
That's why we had the word void,
but more on that another time.

2300
01:45:07,840 --> 01:45:09,890
And cough is not going to
return anything either.

2301
01:45:09,890 --> 01:45:12,170
It's going to print on the
screen just like Brian did.

2302
01:45:12,170 --> 01:45:14,810
But Brian, recall, didn't hand
me anything back physically.

2303
01:45:14,810 --> 01:45:16,530
So there's no return value.

2304
01:45:16,530 --> 01:45:19,640
So I'm going to say void
to the left of cough.

2305
01:45:19,640 --> 01:45:23,030
So for today's purposes, this just
means that cough neither takes

2306
01:45:23,030 --> 01:45:25,820
input nor returns a value as output.

2307
01:45:25,820 --> 01:45:28,020
That's it, void, void.

2308
01:45:28,020 --> 01:45:30,770
Now as the body of that
function, so to speak,

2309
01:45:30,770 --> 01:45:35,570
I'm just going to go ahead and say quite
simply cough backslash n semi-colon.

2310
01:45:35,570 --> 01:45:36,170
That's it.

2311
01:45:36,170 --> 01:45:38,840
So now I have a puzzle piece, if
you will, whose purpose in life

2312
01:45:38,840 --> 01:45:42,980
is to cough, which means now I can
magically just call it by its name

2313
01:45:42,980 --> 01:45:45,930
up here as many times as I want.

2314
01:45:45,930 --> 01:45:47,740
So let's go ahead and compile this.

2315
01:45:47,740 --> 01:45:48,830
I'm really on a good roll.

2316
01:45:48,830 --> 01:45:55,390
Everything's been working out great so
far-- make cough 2, enter, red errors.

2317
01:45:55,390 --> 01:45:58,890
So this is interesting, and this kind
of reminds me of the previous error.

2318
01:45:58,890 --> 01:46:02,630
So first of all, what
line is my error on?

2319
01:46:02,630 --> 01:46:06,530
Seven and character nine, if you
care, but it's seven, on line seven--

2320
01:46:06,530 --> 01:46:09,900
implicit declaration of function
cough is invalid in C99.

2321
01:46:09,900 --> 01:46:14,570
C99 is referring to literally 1999
when this version of C was invented,

2322
01:46:14,570 --> 01:46:17,720
and so implicit declaration
of function cough.

2323
01:46:17,720 --> 01:46:20,240
But it's right here.

2324
01:46:20,240 --> 01:46:21,740
OK, wait a minute.

2325
01:46:21,740 --> 01:46:25,490
Instinct, let me just move this.

2326
01:46:25,490 --> 01:46:26,750
Let me just put it up top.

2327
01:46:26,750 --> 01:46:28,230
Let's see what happens.

2328
01:46:28,230 --> 01:46:30,800
Make cough 2-- oh my god.

2329
01:46:30,800 --> 01:46:32,630
That fixed it.

2330
01:46:32,630 --> 01:46:34,460
Why?

2331
01:46:34,460 --> 01:46:37,790
Even if you've never programmed
before, reason through intuitively

2332
01:46:37,790 --> 01:46:39,400
why this solved something.

2333
01:46:39,400 --> 01:46:41,690
AUDIENCE: You are holding
a function that you

2334
01:46:41,690 --> 01:46:43,520
have had been declared previously.

2335
01:46:43,520 --> 01:46:48,060
So even though you are making it
void, you at least have [INAUDIBLE]..

2336
01:46:48,060 --> 01:46:49,020
DAVID: Exactly.

2337
01:46:49,020 --> 01:46:53,730
Because I previously was trying
to use cough early on line 7,

2338
01:46:53,730 --> 01:46:55,770
but I was only teaching
the computer what cough

2339
01:46:55,770 --> 01:46:57,630
was farther down in the file.

2340
01:46:57,630 --> 01:46:58,830
Frankly C is kind of dumb.

2341
01:46:58,830 --> 01:47:01,240
It literally reads your code
top to bottom left or right.

2342
01:47:01,240 --> 01:47:04,080
And if you try to do something
before you've taught the computer how

2343
01:47:04,080 --> 01:47:07,140
to do that, you're going to get
that kind of undeclared identifier

2344
01:47:07,140 --> 01:47:09,520
because it just doesn't
know what the word is yet.

2345
01:47:09,520 --> 01:47:11,110
Now in Scratch, this isn't a big deal.

2346
01:47:11,110 --> 01:47:13,190
You just move the puzzle
pieces anywhere you want.

2347
01:47:13,190 --> 01:47:15,870
Order of blocks physically on
the screen does not matter.

2348
01:47:15,870 --> 01:47:17,100
But in C, it does.

2349
01:47:17,100 --> 01:47:19,350
But frankly, this
seems a little annoying

2350
01:47:19,350 --> 01:47:23,700
that now the main program here keeps
getting pushed farther and farther

2351
01:47:23,700 --> 01:47:26,790
down the more kind of complexity
I want to add to my program.

2352
01:47:26,790 --> 01:47:28,350
So there's another solution.

2353
01:47:28,350 --> 01:47:30,350
Let me actually go ahead
and put this back where

2354
01:47:30,350 --> 01:47:32,850
it is because I'm a little particular.

2355
01:47:32,850 --> 01:47:37,280
I just like by convention main to be at
the top, and frankly that's good style.

2356
01:47:37,280 --> 01:47:40,080
If main is the most important
function in your program by default--

2357
01:47:40,080 --> 01:47:44,820
because it is the main function and it's
what gets called per earlier by default

2358
01:47:44,820 --> 01:47:45,960
by the computer--

2359
01:47:45,960 --> 01:47:48,140
why am I going to push
it all the way down just

2360
01:47:48,140 --> 01:47:50,940
to work around this stupid detail?

2361
01:47:50,940 --> 01:47:55,530
Well, I just need to teach the
computer what the function is,

2362
01:47:55,530 --> 01:48:01,090
and I can do that a little
redundantly by just saying this.

2363
01:48:01,090 --> 01:48:04,600
This is what we're going to call
the prototype for a function.

2364
01:48:04,600 --> 01:48:07,600
If you literally just
copy the very first line

2365
01:48:07,600 --> 01:48:12,160
of it that has its name, its inputs
if any, and its output if any,

2366
01:48:12,160 --> 01:48:13,900
that's a prototype semi-colon.

2367
01:48:13,900 --> 01:48:16,180
It's literally copy paste
from the function itself,

2368
01:48:16,180 --> 01:48:21,130
but this is now enough of a hint to
say, hey, computer, this shell exists.

2369
01:48:21,130 --> 01:48:25,330
This is enough information for you
to then call it because the computer,

2370
01:48:25,330 --> 01:48:28,330
so long as ir has seen the
function's name before, it's

2371
01:48:28,330 --> 01:48:34,040
OK if the zeros and ones, so to speak,
that implement it come a little later.

2372
01:48:34,040 --> 01:48:37,400
And so that's the more conventional
way to solve that problem.

2373
01:48:37,400 --> 01:48:41,470
So just intuitively then,
take a guess, if it's not

2374
01:48:41,470 --> 01:48:48,550
too much of a indirect leap, what is in
standard I/O h, what is in CS50 dot h.

2375
01:48:51,470 --> 01:48:54,120
Those kinds d we'll
call them declarations.

2376
01:48:54,120 --> 01:48:59,060
So literally in standard IO
dot h is a line of code that

2377
01:48:59,060 --> 01:49:02,390
teaches the computer
what printf's inputs are

2378
01:49:02,390 --> 01:49:04,580
and what printf's output is if any.

2379
01:49:04,580 --> 01:49:06,920
In CS50 dot h, there is
literally a line of code

2380
01:49:06,920 --> 01:49:11,060
that tells the computer what get
strings input is and what its output is.

2381
01:49:11,060 --> 01:49:14,990
And the same for get int and get
float and get char and others--

2382
01:49:14,990 --> 01:49:16,860
that's all that's in those header files.

2383
01:49:16,860 --> 01:49:18,740
The zeros and ones, so
to speak, are actually

2384
01:49:18,740 --> 01:49:23,090
in files literally called
standard IO dot C and CS50 dot C,

2385
01:49:23,090 --> 01:49:24,860
although that's technically source code.

2386
01:49:24,860 --> 01:49:28,160
The zeros and ones are in a compiled
file elsewhere on the system.

2387
01:49:28,160 --> 01:49:30,610
But all of these things we've
been taking for granted,

2388
01:49:30,610 --> 01:49:32,360
now hopefully it makes
a little more sense

2389
01:49:32,360 --> 01:49:34,110
because, the fact that
I'm doing the sharp

2390
01:49:34,110 --> 01:49:36,590
include at the top, that's
just a solution to a problem.

2391
01:49:36,590 --> 01:49:40,640
In that file is enough information
to teach the computer what's printf

2392
01:49:40,640 --> 01:49:44,030
or what get string and
other things are so

2393
01:49:44,030 --> 01:49:47,780
that I don't need to bother
moving things around myself

2394
01:49:47,780 --> 01:49:51,080
or copying and pasting whoever
wrote printf, his or her code,

2395
01:49:51,080 --> 01:49:52,460
into my program.

2396
01:49:52,460 --> 01:49:54,950
Now let's do one final
example with coughing

2397
01:49:54,950 --> 01:49:57,860
and go ahead and call this
call this cough 3 dot C

2398
01:49:57,860 --> 01:50:01,100
and go ahead and paste my same code as
a moment ago just to get us started.

2399
01:50:01,100 --> 01:50:03,560
And recall that the last
step of our cough example

2400
01:50:03,560 --> 01:50:06,170
last week was to actually
give cough an input.

2401
01:50:06,170 --> 01:50:08,780
I'd kind of like to
whittle this code down

2402
01:50:08,780 --> 01:50:13,010
to literally cough 3 because this
is a really nice abstraction.

2403
01:50:13,010 --> 01:50:15,590
I don't want main to have to
think about how many times--

2404
01:50:15,590 --> 01:50:16,940
just cough three times.

2405
01:50:16,940 --> 01:50:19,470
That's a nice, useful human abstraction.

2406
01:50:19,470 --> 01:50:22,020
Now let's put the
functionality down here.

2407
01:50:22,020 --> 01:50:24,590
So if I want cough to
be able to tolerate

2408
01:50:24,590 --> 01:50:29,300
an input like 3, which mentions of
void presumably needs to change?

2409
01:50:29,300 --> 01:50:31,130
The one on the left or the right?

2410
01:50:31,130 --> 01:50:33,390
The right, the one
inside the parentheses.

2411
01:50:33,390 --> 01:50:37,830
And it turns out, just like you can
declare variables inside of a function,

2412
01:50:37,830 --> 01:50:42,810
as we've done, so can you declare
arguments to a function like this.

2413
01:50:42,810 --> 01:50:46,110
So you can call it anything you want,
though the data type matters, but this

2414
01:50:46,110 --> 01:50:49,950
is now saying, hey, computer,
cough does not return a value,

2415
01:50:49,950 --> 01:50:52,410
like Erin did return a piece of paper.

2416
01:50:52,410 --> 01:50:55,410
Hey, computer, cough
does take one input.

2417
01:50:55,410 --> 01:50:57,630
It's an integer and just call it n.

2418
01:50:57,630 --> 01:51:00,700
And now that you've done this, now
you can have a line of code in here

2419
01:51:00,700 --> 01:51:01,200
like this.

2420
01:51:01,200 --> 01:51:09,990
For int i get 0, i is
less than n i plus plus--

2421
01:51:09,990 --> 01:51:13,380
and then, OK, off by keystrokes here.

2422
01:51:13,380 --> 01:51:16,420
Then I can move this inside
here, indent it nicely.

2423
01:51:16,420 --> 01:51:19,230
And now notice, all of
the complexity of coughing

2424
01:51:19,230 --> 01:51:22,270
has been factored out into a
function, my own puzzle piece,

2425
01:51:22,270 --> 01:51:26,520
if you will, that even takes an
argument so that now you can literally,

2426
01:51:26,520 --> 01:51:28,890
if I move this far away
and out of mind, now

2427
01:51:28,890 --> 01:51:32,370
your program is getting pretty
interesting because it really

2428
01:51:32,370 --> 01:51:33,570
just does what it says.

2429
01:51:33,570 --> 01:51:37,110
And this is a nice functional
abstraction, if you will,

2430
01:51:37,110 --> 01:51:42,220
so that now I have a new verb, a new
action, a new function called cough.

2431
01:51:42,220 --> 01:51:44,170
Any questions on that one?

2432
01:51:44,170 --> 01:51:46,800
Yeah.

2433
01:51:46,800 --> 01:51:47,520
Sorry, say again.

2434
01:51:47,520 --> 01:51:49,230
AUDIENCE: What integer
would main return?

2435
01:51:49,230 --> 01:51:50,520
DAVID: What integer would main return?

2436
01:51:50,520 --> 01:51:52,060
It turns out we'll come back to this.

2437
01:51:52,060 --> 01:51:54,360
It's going to return 0
almost always by default,

2438
01:51:54,360 --> 01:51:57,270
but that leaves you with almost an
infinite number of non-zero values

2439
01:51:57,270 --> 01:52:00,010
which represent all of the
many things that can go wrong.

2440
01:52:00,010 --> 01:52:03,040
So more on that when we
start creating more mistakes.

2441
01:52:03,040 --> 01:52:04,350
Let's look at one other.

2442
01:52:04,350 --> 01:52:07,020
Let me go ahead and open
this file in advance

2443
01:52:07,020 --> 01:52:10,770
myself called positive dot
C. Suppose that I'm not

2444
01:52:10,770 --> 01:52:13,470
content to just have access to get int.

2445
01:52:13,470 --> 01:52:15,930
I want a function called
get positive int because,

2446
01:52:15,930 --> 01:52:17,760
for whatever reason,
my program, my game,

2447
01:52:17,760 --> 01:52:19,960
my whatever needs to
know a positive value.

2448
01:52:19,960 --> 01:52:22,280
Maybe I'm asking the user
how many players are there,

2449
01:52:22,280 --> 01:52:23,580
and that shouldn't be negative.

2450
01:52:23,580 --> 01:52:26,220
It should be a positive integer
like one or two or more.

2451
01:52:26,220 --> 01:52:31,110
So it turns out I could write a
program if I want that looks like this.

2452
01:52:31,110 --> 01:52:36,900
Call on this line here a function called
get positive int, pass it in a prompt,

2453
01:52:36,900 --> 01:52:40,380
and then store the value, still in
an integer, on the left hand side,

2454
01:52:40,380 --> 01:52:42,870
and then just go ahead and print it out.

2455
01:52:42,870 --> 01:52:47,280
Get positive int has this
prototype at the top of the file.

2456
01:52:47,280 --> 01:52:50,950
Notice this is not a function that
comes with CS50s library, CS50 dot h.

2457
01:52:50,950 --> 01:52:52,620
The function is called get positive int.

2458
01:52:52,620 --> 01:52:56,010
As you would hope, it returns
an int, and it takes a string

2459
01:52:56,010 --> 01:52:59,130
as it's prompt, whatever words
you want the human to see.

2460
01:52:59,130 --> 01:53:03,060
Let's scroll down now, and this
one looks a little more involved,

2461
01:53:03,060 --> 01:53:05,910
and this is not a
feature that Scratch has.

2462
01:53:05,910 --> 01:53:07,140
But let's take a look.

2463
01:53:07,140 --> 01:53:10,050
The first line is
identical to the prototype

2464
01:53:10,050 --> 01:53:11,910
because I literally
copied and pasted it.

2465
01:53:11,910 --> 01:53:15,700
Everything between these
brackets is the function itself.

2466
01:53:15,700 --> 01:53:18,050
And here, to answer someone's
question from earlier on,

2467
01:53:18,050 --> 01:53:21,690
do you have to declare a variable
and then use it right away?

2468
01:53:21,690 --> 01:53:24,420
No, and that's actually a
helpful solution to a problem

2469
01:53:24,420 --> 01:53:25,960
that we'll see in a moment.

2470
01:53:25,960 --> 01:53:28,710
Notice here this new keyword--
didn't see it before--

2471
01:53:28,710 --> 01:53:33,090
do the following while n is less than 1.

2472
01:53:33,090 --> 01:53:36,870
Previously, we saw a while
loop and we saw a for loop.

2473
01:53:36,870 --> 01:53:38,650
We did not see a do while loop.

2474
01:53:38,650 --> 01:53:41,730
And a do while loop, while it
sounds obviously similar to a while

2475
01:53:41,730 --> 01:53:44,190
loop, what seems a little different?

2476
01:53:44,190 --> 01:53:48,900
When I had that forever block
earlier translated to while true,

2477
01:53:48,900 --> 01:53:51,690
what was the order of operations?

2478
01:53:51,690 --> 01:53:55,260
Did we check the condition, the
true, and then print hello world?

2479
01:53:55,260 --> 01:53:59,770
Or did we just print hello world
and then check the condition?

2480
01:53:59,770 --> 01:54:02,320
Yeah, you might not recall
precisely, but I did actually--

2481
01:54:02,320 --> 01:54:05,830
I checked is true true, and
we all said yes obviously.

2482
01:54:05,830 --> 01:54:08,590
Printf-- is it true?

2483
01:54:08,590 --> 01:54:11,110
Printf-- so it checked
the condition first.

2484
01:54:11,110 --> 01:54:14,140
You might infer then this
loop is a little different.

2485
01:54:14,140 --> 01:54:15,910
It has another word, do.

2486
01:54:15,910 --> 01:54:20,980
This is literally going to do this
first and then check the condition

2487
01:54:20,980 --> 01:54:23,300
and only do it again if
the condition is true.

2488
01:54:23,300 --> 01:54:26,470
So it's a nice way of just flipping
things around in terms of order

2489
01:54:26,470 --> 01:54:31,210
to do something at least once
rather than potentially never at all

2490
01:54:31,210 --> 01:54:32,690
like was the case earlier.

2491
01:54:32,690 --> 01:54:34,030
So what are we doing?

2492
01:54:34,030 --> 01:54:37,030
Get an int, passing in
this prompt, store it in n.

2493
01:54:37,030 --> 01:54:40,330
And if the user types in a
value that's less than 1,

2494
01:54:40,330 --> 01:54:44,350
is this going to be true or
false, if n is less than 1?

2495
01:54:44,350 --> 01:54:49,210
So if the human types
in 0, is 0 less than 1?

2496
01:54:49,210 --> 01:54:53,560
True, yes, so what happens, you go
back to the do and you do it again.

2497
01:54:53,560 --> 01:54:56,860
If the user types in negative
1, is negative 1 less than 1?

2498
01:54:56,860 --> 01:54:57,970
Yes or true.

2499
01:54:57,970 --> 01:54:58,990
So you do it again.

2500
01:54:58,990 --> 01:55:01,720
If he or she types in
negative 2, again, again.

2501
01:55:01,720 --> 01:55:03,520
What if he or she types in 50?

2502
01:55:03,520 --> 01:55:05,710
Well, 50 is not less than one.

2503
01:55:05,710 --> 01:55:07,520
So this is false.

2504
01:55:07,520 --> 01:55:10,670
And so then you proceed to the
next line of code altogether.

2505
01:55:10,670 --> 01:55:12,760
But what's interesting
about the next line of code

2506
01:55:12,760 --> 01:55:17,800
is that, unlike the cough example,
which had void as its return type,

2507
01:55:17,800 --> 01:55:20,470
get positive int by default
it's supposed to return an int,

2508
01:55:20,470 --> 01:55:24,220
just like, again, Erin handed me a
piece of paper with a string on it.

2509
01:55:24,220 --> 01:55:27,370
And so here, if I want my
own custom function called

2510
01:55:27,370 --> 01:55:29,350
get positive int to
return value, there's

2511
01:55:29,350 --> 01:55:32,530
another word in C. You
literally write return and then

2512
01:55:32,530 --> 01:55:34,840
the name of the variable
or the value that you

2513
01:55:34,840 --> 01:55:39,370
want to hand back on a metaphorical
piece of paper to whatever code

2514
01:55:39,370 --> 01:55:41,470
is using this.

2515
01:55:41,470 --> 01:55:43,420
So what's this oddity?

2516
01:55:43,420 --> 01:55:46,870
Why can I not do this?

2517
01:55:46,870 --> 01:55:51,890
If I were to mimic the code
we wrote earlier like this,

2518
01:55:51,890 --> 01:55:55,840
why does this line of code
not work just logically using

2519
01:55:55,840 --> 01:56:00,470
some of the mental models
that we've had thus far?

2520
01:56:00,470 --> 01:56:01,930
AUDIENCE: Declaring the code again.

2521
01:56:01,930 --> 01:56:02,630
DAVID: Say again.

2522
01:56:02,630 --> 01:56:04,270
AUDIENCE: Declaring again and again.

2523
01:56:04,270 --> 01:56:06,320
DAVID: Yeah, so declaring
just means creating,

2524
01:56:06,320 --> 01:56:08,440
is the fancy way in
programming of saying creating.

2525
01:56:08,440 --> 01:56:11,230
So this says, hey, computer,
give me an integer, call it n,

2526
01:56:11,230 --> 01:56:13,230
and set it equal to the
return value of get int.

2527
01:56:13,230 --> 01:56:17,160
So whatever the function or Erin
hands me back, put it over here.

2528
01:56:17,160 --> 01:56:20,840
But the problem is that
in C variables have scope.

2529
01:56:20,840 --> 01:56:23,680
Scope is a fancy way of
saying they only exist in

2530
01:56:23,680 --> 01:56:28,250
between the curly braces between
which they were declared.

2531
01:56:28,250 --> 01:56:32,330
So that means that this
variable n literally only

2532
01:56:32,330 --> 01:56:36,050
exists between here and here, and
then it just kind of goes away.

2533
01:56:36,050 --> 01:56:37,970
The computer doesn't
know about it anymore.

2534
01:56:37,970 --> 01:56:40,160
But that's a problem
because, on what line number

2535
01:56:40,160 --> 01:56:43,790
do we actually need to know n?

2536
01:56:43,790 --> 01:56:47,460
It looks like 21, and that's
outside the curly braces.

2537
01:56:47,460 --> 01:56:49,880
So just based on that
basic definition, scope

2538
01:56:49,880 --> 01:56:52,430
is the two curly braces between
which a variable is declared.

2539
01:56:52,430 --> 01:56:53,810
It doesn't exist outside of them.

2540
01:56:53,810 --> 01:56:55,080
This code just won't work.

2541
01:56:55,080 --> 01:56:57,750
And I'll fix it later so that you
see the correct error message.

2542
01:56:57,750 --> 01:56:58,970
Why does this not work?

2543
01:56:58,970 --> 01:57:01,860
Well, you're declaring n
inside of those curly braces.

2544
01:57:01,860 --> 01:57:03,080
So how do you avoid this?

2545
01:57:03,080 --> 01:57:07,190
Well, it turns out, as someone posited
earlier, just declare it by itself

2546
01:57:07,190 --> 01:57:09,180
without even giving it a value.

2547
01:57:09,180 --> 01:57:12,570
And indeed the syntax for that
is just to do half of a thought--

2548
01:57:12,570 --> 01:57:14,090
int n semi-colon.

2549
01:57:14,090 --> 01:57:16,010
It has no value that we know yet.

2550
01:57:16,010 --> 01:57:18,620
It has a garbage value, but
more on that another time.

2551
01:57:18,620 --> 01:57:19,640
But it does now exist.

2552
01:57:19,640 --> 01:57:22,970
And now notice which curly
braces does it exist within--

2553
01:57:22,970 --> 01:57:27,280
this one and this one, which means
now it's accessible everywhere.

2554
01:57:27,280 --> 01:57:29,780
And if you in your Scratch
programs actually used variables,

2555
01:57:29,780 --> 01:57:31,690
you might have noticed
that you had to choose.

2556
01:57:31,690 --> 01:57:35,300
You had to make a decision for
this sprite or for all sprites.

2557
01:57:35,300 --> 01:57:39,680
That was an allusion to what's
called in programming a local

2558
01:57:39,680 --> 01:57:40,880
or a global variable.

2559
01:57:40,880 --> 01:57:43,550
These are still local, and we'll
come back to this term earlier.

2560
01:57:43,550 --> 01:57:47,690
But it has to do with scope because, if
you had specified for this sprite only,

2561
01:57:47,690 --> 01:57:51,610
MIT would have only let you use that
variable for that specific sprite,

2562
01:57:51,610 --> 01:57:55,010
that cat or sheep or whatever
it was you were programming.

2563
01:57:55,010 --> 01:57:59,120
Just as in C, this now means
n can be used here and here

2564
01:57:59,120 --> 01:58:02,510
but not elsewhere like
higher up in my program.

2565
01:58:02,510 --> 01:58:05,510
That's the matter of scope.

2566
01:58:05,510 --> 01:58:09,140
So let's now see what
can go wrong beyond that.

2567
01:58:09,140 --> 01:58:12,370
Let me go ahead and open up
this because it turns out,

2568
01:58:12,370 --> 01:58:15,340
when programming, there is
other issues that can happen,

2569
01:58:15,340 --> 01:58:18,760
not just floating point in precision,
as I described it as earlier.

2570
01:58:18,760 --> 01:58:23,620
It turns out that there's other problems
that can go wrong even with integers

2571
01:58:23,620 --> 01:58:25,120
that we kind of avoided altogether.

2572
01:58:25,120 --> 01:58:29,770
So recall that we started talking about
1, 2, and 3 and why it's 123 last week.

2573
01:58:29,770 --> 01:58:33,700
Well, what happens in
decimal if you add 1 to 123?

2574
01:58:33,700 --> 01:58:35,140
What number do you get?

2575
01:58:35,140 --> 01:58:35,840
Obviously, 124.

2576
01:58:35,840 --> 01:58:39,860
If we do it again, 125, 26 27, 28, 29.

2577
01:58:39,860 --> 01:58:44,440
What happens in decimal
if I add 1 to a 9?

2578
01:58:44,440 --> 01:58:47,770
Well, I should get 10, but that's
not how we would write this.

2579
01:58:47,770 --> 01:58:50,920
You put down the 0 instead,
and you carry the 1.

2580
01:58:50,920 --> 01:58:53,290
Remember those mental heuristics?

2581
01:58:53,290 --> 01:58:54,460
So that's all we did there.

2582
01:58:54,460 --> 01:58:55,930
And then it's 2 plus 1.

2583
01:58:55,930 --> 01:59:02,440
So that's why 129 plus 1 is 130
because you put the 0, you carry the 1,

2584
01:59:02,440 --> 01:59:03,080
and so forth.

2585
01:59:03,080 --> 01:59:04,930
So we just all do that intuitively now.

2586
01:59:04,930 --> 01:59:07,690
But this has implications
for what computers do too

2587
01:59:07,690 --> 01:59:11,440
because suppose that we consider
a bigger number like 999.

2588
01:59:11,440 --> 01:59:15,160
And so what do you get
when you add 1 to 999?

2589
01:59:15,160 --> 01:59:19,510
Well, you carry the 1, you carry
the 1, and you get hopefully 1,000.

2590
01:59:19,510 --> 01:59:24,280
But what if your computer only
has space for three digits?

2591
01:59:24,280 --> 01:59:26,440
Or what if your phone or
what if your alarm clock

2592
01:59:26,440 --> 01:59:28,510
or whatever the device
is literally only has

2593
01:59:28,510 --> 01:59:37,070
room for 3 digits, what is 999 plus 1
if your hardware only has three digits?

2594
01:59:37,070 --> 01:59:38,510
Well, it's apparently 0.

2595
01:59:38,510 --> 01:59:44,000
So you get this overflow 998, 999, 0.

2596
01:59:44,000 --> 01:59:45,560
It overflows, so to speak.

2597
01:59:45,560 --> 01:59:49,610
The one kind of falls off conceptually,
and you roll over to the next value,

2598
01:59:49,610 --> 01:59:51,720
which is 000.

2599
01:59:51,720 --> 01:59:53,820
So what about in binary?

2600
01:59:53,820 --> 01:59:57,440
What number is this in binary if you
translated the decimal in your head?

2601
01:59:57,440 --> 02:00:01,970
And remember, it's the ones column,
the twos columns, and the fours column.

2602
02:00:01,970 --> 02:00:03,500
So this was 7 in binary--

2603
02:00:03,500 --> 02:00:07,350
1, so it's 4 plus 2
plus 1, so 7 in binary.

2604
02:00:07,350 --> 02:00:09,320
So how do you do arithmetic with binary?

2605
02:00:09,320 --> 02:00:10,530
It's actually the same thing.

2606
02:00:10,530 --> 02:00:14,500
It's just you don't have twos or
threes or nines or anything in between.

2607
02:00:14,500 --> 02:00:15,710
You just have ones and zeros.

2608
02:00:15,710 --> 02:00:19,370
So what do you get
when you add 1 to 111?

2609
02:00:19,370 --> 02:00:20,600
Well, it's the same idea.

2610
02:00:20,600 --> 02:00:23,360
You put down a 0 and you
carry the 1 because 1 plus 1

2611
02:00:23,360 --> 02:00:25,910
you want to say 2 in
decimal, but there is no 2.

2612
02:00:25,910 --> 02:00:27,140
So it rolls over to 0.

2613
02:00:27,140 --> 02:00:28,200
But you carry the 1.

2614
02:00:28,200 --> 02:00:32,000
1 plus 1 is 2, but, OK,
that's 0, carry the 1.

2615
02:00:32,000 --> 02:00:32,960
1 plus 1, that's 2.

2616
02:00:32,960 --> 02:00:33,830
But I don't have a 2.

2617
02:00:33,830 --> 02:00:35,590
So I go back to 0, carry the 1.

2618
02:00:35,590 --> 02:00:41,700
So in binary, if you only have
three bytes or bits rather,

2619
02:00:41,700 --> 02:00:47,090
if you only have three bits, what do
you get when you add 1 to 7 in binary?

2620
02:00:47,090 --> 02:00:48,590
You apparently get 0.

2621
02:00:48,590 --> 02:00:50,070
And now it's getting more real.

2622
02:00:50,070 --> 02:00:52,460
In my computer, in my phone,
in all of your hardware

2623
02:00:52,460 --> 02:00:54,920
it's just a finite amount of
memory, RAM, that little chip

2624
02:00:54,920 --> 02:00:57,350
that I showed on the screen
with all the little circuits.

2625
02:00:57,350 --> 02:01:01,760
And that has more than 3 bits of
memory certainly, but it is finite.

2626
02:01:01,760 --> 02:01:04,460
And if we're only using, as a
matter of convention, 32 bits

2627
02:01:04,460 --> 02:01:07,820
to represent things or 64 bits, maybe
if we use doubles or something else

2628
02:01:07,820 --> 02:01:11,780
called a long-- a long is a 64-bit
integer, whereas an integer is

2629
02:01:11,780 --> 02:01:13,760
typically 32 bits.

2630
02:01:13,760 --> 02:01:17,150
It seems that, at some
point, numbers might overflow

2631
02:01:17,150 --> 02:01:19,630
and we're going to actually
have some, so to speak,

2632
02:01:19,630 --> 02:01:22,550
imprecision-- ergo, integer overflow.

2633
02:01:22,550 --> 02:01:25,770
So you can actually see this or
defenses against this in the real world.

2634
02:01:25,770 --> 02:01:30,080
So this is a screenshot from a game that
is common on a few different platforms,

2635
02:01:30,080 --> 02:01:33,910
and it's a game that allows you to
accumulate coins or points really,

2636
02:01:33,910 --> 02:01:35,370
or little Lego pieces.

2637
02:01:35,370 --> 02:01:38,120
And if you accumulate these points,
you'll notice that eventually,

2638
02:01:38,120 --> 02:01:43,040
if you have way too much free time, you
can only score so high in this game.

2639
02:01:43,040 --> 02:01:45,110
What's the highest score
apparently, according

2640
02:01:45,110 --> 02:01:48,500
to the screenshot from whoever took
this after playing for too many hours?

2641
02:01:48,500 --> 02:01:50,540
Wasn't me.

2642
02:01:50,540 --> 02:01:53,960
4 million-- no, 4 billion, 4 billion.

2643
02:01:53,960 --> 02:01:55,220
Why is that?

2644
02:01:55,220 --> 02:01:58,760
Well, it turns out that, if numbers
and computers, as I've proposed,

2645
02:01:58,760 --> 02:02:01,010
are generally stored using 32 bits.

2646
02:02:01,010 --> 02:02:04,220
That kind of invites the question, well,
how high can you count with 32 bits?

2647
02:02:04,220 --> 02:02:07,730
Well, 32 bits means you
have 32 zeros and ones.

2648
02:02:07,730 --> 02:02:10,850
The biggest they could be
is like 11111, 32 ones.

2649
02:02:10,850 --> 02:02:14,600
And if you actually do the math using
our little columns and so forth,

2650
02:02:14,600 --> 02:02:17,960
it's roughly 4 billion, a
little bigger than 4 billion.

2651
02:02:17,960 --> 02:02:20,130
So the authors of this
Lego game just decided,

2652
02:02:20,130 --> 02:02:22,400
you know what, let's just
say that the maximum number

2653
02:02:22,400 --> 02:02:26,010
of points or coins you can accumulate
in this Lego game is 4 billion even.

2654
02:02:26,010 --> 02:02:26,510
Why?

2655
02:02:26,510 --> 02:02:30,440
It just looks even cleaner than
whatever the actual value is.

2656
02:02:30,440 --> 02:02:31,340
But why?

2657
02:02:31,340 --> 02:02:37,880
How many bits are they using to store
your score in this game presumably?

2658
02:02:37,880 --> 02:02:40,330
32 bits or 4 bytes, and
that's just convention.

2659
02:02:40,330 --> 02:02:42,290
Whatever language they
programmed this game is,

2660
02:02:42,290 --> 02:02:46,730
probably has a data type called
an int, and that int by convention

2661
02:02:46,730 --> 02:02:47,810
uses 32 bits.

2662
02:02:47,810 --> 02:02:51,050
So at some point, they had to
decide, we can either use more memory

2663
02:02:51,050 --> 02:02:52,550
as you proposed earlier for doubles.

2664
02:02:52,550 --> 02:02:53,470
Let's use 64 bits.

2665
02:02:53,470 --> 02:02:55,850
Then you can have crazy numbers
of hours playing the game

2666
02:02:55,850 --> 02:02:57,220
and getting more and more points.

2667
02:02:57,220 --> 02:03:00,300
Or we can just say that's enough
points to accumulate in the game.

2668
02:03:00,300 --> 02:03:02,180
Now that's when you
actually anticipate this.

2669
02:03:02,180 --> 02:03:04,160
This doesn't always actually happen.

2670
02:03:04,160 --> 02:03:08,090
If we go ahead and take a
look at some example code--

2671
02:03:08,090 --> 02:03:12,860
let me go ahead and open up
overflow dot C. In this program

2672
02:03:12,860 --> 02:03:17,230
here, you'll see line 8
the slash slash syntax,

2673
02:03:17,230 --> 02:03:18,780
and I've had a bunch of these so far.

2674
02:03:18,780 --> 02:03:20,180
But I haven't actually mentioned them.

2675
02:03:20,180 --> 02:03:23,470
It turns out in C, just in Scratch-- the
odds are you didn't notice this little

2676
02:03:23,470 --> 02:03:24,320
feature of Scratch--

2677
02:03:24,320 --> 02:03:25,900
you can have what are called comments.

2678
02:03:25,900 --> 02:03:29,210
A comment is just a note to
yourself, to your TF, to your friend,

2679
02:03:29,210 --> 02:03:31,870
to your colleague, with whoever
whom you're writing code with.

2680
02:03:31,870 --> 02:03:35,510
And it's just a note to self to
remind yourself of what the code does.

2681
02:03:35,510 --> 02:03:38,900
Without this line, I could once,
I'm comfortable enough programming,

2682
02:03:38,900 --> 02:03:40,820
figure out what these
lines of code are doing.

2683
02:03:40,820 --> 02:03:43,280
But frankly, that's a waste
of time I wrote the code once.

2684
02:03:43,280 --> 02:03:46,070
And if I look at it weeks or months
later or someone else wrote it,

2685
02:03:46,070 --> 02:03:47,280
just tell me what it does.

2686
02:03:47,280 --> 02:03:52,430
So a comment in a program is just like
a nice summary of a few lines of code,

2687
02:03:52,430 --> 02:03:54,470
or it's a summary in
English or whatever spoken

2688
02:03:54,470 --> 02:03:58,660
language that describes what
otherwise a cryptic looking code

2689
02:03:58,660 --> 02:03:59,660
might actually be doing.

2690
02:03:59,660 --> 02:04:02,660
So you don't have to think too hard
about it to understand a program.

2691
02:04:02,660 --> 02:04:06,770
So iteratively double i-- iteratively
just means loopingly, again and again

2692
02:04:06,770 --> 02:04:07,940
and again.

2693
02:04:07,940 --> 02:04:08,750
This is funky.

2694
02:04:08,750 --> 02:04:11,920
We didn't see this, before but
you might guess what it does.

2695
02:04:11,920 --> 02:04:14,830
What the star equals do?

2696
02:04:14,830 --> 02:04:15,520
It does double.

2697
02:04:15,520 --> 02:04:18,700
It's like plus equals
adds 1, star equals

2698
02:04:18,700 --> 02:04:20,650
doubles if the value on the right is 2.

2699
02:04:20,650 --> 02:04:26,140
So this is going to start printing
1 then 2 then 4 and 8 and so forth.

2700
02:04:26,140 --> 02:04:27,730
And notice this function.

2701
02:04:27,730 --> 02:04:28,600
It's called sleep.

2702
02:04:28,600 --> 02:04:30,700
It literally is going
to sleep for a second,

2703
02:04:30,700 --> 02:04:34,600
and that sleep function has a prototype
that someone else wrote in a file

2704
02:04:34,600 --> 02:04:36,760
called uni standard dot h.

2705
02:04:36,760 --> 02:04:39,170
I only know that by looking
it up in the documentation.

2706
02:04:39,170 --> 02:04:41,500
But that's a new file just for sleeping.

2707
02:04:41,500 --> 02:04:44,700
Make overflow, which is apt here.

2708
02:04:44,700 --> 02:04:47,200
And let me go ahead and make
the terminal window even bigger

2709
02:04:47,200 --> 02:04:51,230
for this one-- dot slash overflow.

2710
02:04:51,230 --> 02:04:54,040
OK, it's going.

2711
02:04:54,040 --> 02:04:54,550
It's going.

2712
02:04:54,550 --> 02:04:56,550
It's going to go faster
and faster, so to speak,

2713
02:04:56,550 --> 02:05:02,060
because we're adding more and
more each time by doubling.

2714
02:05:02,060 --> 02:05:06,310
2000, 4000, 8000, 16,000--

2715
02:05:06,310 --> 02:05:10,170
it's still going-- 64,000, 65,000.

2716
02:05:10,170 --> 02:05:11,930
Now we're into the millions--

2717
02:05:11,930 --> 02:05:15,390
2 million, 4, 8, 16 million.

2718
02:05:15,390 --> 02:05:21,360
It's getting bigger and bigger,
all of these big numbers.

2719
02:05:21,360 --> 02:05:23,340
Ooh, interesting.

2720
02:05:23,340 --> 02:05:25,870
What just happened?

2721
02:05:25,870 --> 02:05:28,930
So it turns out, if you double numbers
big enough, you get 0 eventually,

2722
02:05:28,930 --> 02:05:30,930
also something you
probably weren't taught.

2723
02:05:30,930 --> 02:05:32,020
So what actually happened?

2724
02:05:32,020 --> 02:05:33,850
Control-C, we'll cancel this.

2725
02:05:33,850 --> 02:05:34,450
What happened?

2726
02:05:34,450 --> 02:05:38,380
I mean, the program is trying to tell
me, even though it's a little cryptic,

2727
02:05:38,380 --> 02:05:39,700
signed integer overflow.

2728
02:05:39,700 --> 02:05:42,380
Signed just means it went from
positive to negative essentially.

2729
02:05:42,380 --> 02:05:45,160
So what happened?

2730
02:05:45,160 --> 02:05:46,140
What's that?

2731
02:05:46,140 --> 02:05:47,190
Yeah, it ran out of bits.

2732
02:05:47,190 --> 02:05:49,270
I'm doubling the number
again and again and again.

2733
02:05:49,270 --> 02:05:53,620
And at some point, we carried the
one so to speak and it was a 33rd 1,

2734
02:05:53,620 --> 02:05:55,810
therefore past the
boundaries of a 32-bit value,

2735
02:05:55,810 --> 02:05:58,810
and it just rolled over to apparently
a negative because at some point--

2736
02:05:58,810 --> 02:06:00,140
and we haven't talked about it--

2737
02:06:00,140 --> 02:06:03,710
you can use like the leftmost bit in
some sense to say positive or negative.

2738
02:06:03,710 --> 02:06:05,380
We've just talked about positive so far.

2739
02:06:05,380 --> 02:06:07,250
And then at that point,
frankly, the computer

2740
02:06:07,250 --> 02:06:10,280
just gave up not really knowing
what you intended beyond that.

2741
02:06:10,280 --> 02:06:13,660
So if you don't write code
to handle this situation

2742
02:06:13,660 --> 02:06:17,950
and make sure that your numbers are less
than 4 billion before you roll over,

2743
02:06:17,950 --> 02:06:19,420
just bugs will happen.

2744
02:06:19,420 --> 02:06:23,960
And this might seem contrived here,
but this happened not too long ago.

2745
02:06:23,960 --> 02:06:26,770
So 1999 was just before
a lot of people thought

2746
02:06:26,770 --> 02:06:30,440
the world was going to end
because of the so-called Y2K bug,

2747
02:06:30,440 --> 02:06:34,240
and it really wasn't so much a bug
as it was lack of forethought or lack

2748
02:06:34,240 --> 02:06:35,290
of features.

2749
02:06:35,290 --> 02:06:37,310
What was the Y2K problem in a nutshell?

2750
02:06:41,430 --> 02:06:42,630
Someone want to propose?

2751
02:06:42,630 --> 02:06:44,510
Even in a non-technical sense, yeah.

2752
02:06:44,510 --> 02:06:47,750
AUDIENCE: Computers couldn't
display the number 2000.

2753
02:06:47,750 --> 02:06:50,840
DAVID: Yeah, so let me summarize here.

2754
02:06:50,840 --> 02:06:54,410
So if they are only using
two digits to display values,

2755
02:06:54,410 --> 02:06:59,600
you could confuse the year 2000
with actually the year 1900 because,

2756
02:06:59,600 --> 02:07:04,100
long story short, what humans did
kind of reasonably decades ago was--

2757
02:07:04,100 --> 02:07:05,240
space was expensive.

2758
02:07:05,240 --> 02:07:06,680
Computers were expensive.

2759
02:07:06,680 --> 02:07:10,280
Memory was not as abundant as
it is now with all the cloud

2760
02:07:10,280 --> 02:07:11,300
storage and the like.

2761
02:07:11,300 --> 02:07:12,060
So you know what?

2762
02:07:12,060 --> 02:07:18,230
If it was like 1970, do we really
care about 1969, 1968, let alone 1900?

2763
02:07:18,230 --> 02:07:21,440
Not really let's just assume
we're all in the 1900s

2764
02:07:21,440 --> 02:07:24,320
and never show or store one 9.

2765
02:07:24,320 --> 02:07:26,480
Let's just store two
digits for every year.

2766
02:07:26,480 --> 02:07:30,210
So 70 is '70 99 is 1999.

2767
02:07:30,210 --> 02:07:33,560
But the problem is the
humans ended up running code

2768
02:07:33,560 --> 02:07:37,880
that they wrote years ago,
decades ago way longer than humans

2769
02:07:37,880 --> 02:07:38,950
thought they might why.

2770
02:07:38,950 --> 02:07:41,330
Well, it's expensive, it's
time consuming to change code,

2771
02:07:41,330 --> 02:07:42,210
the code is working.

2772
02:07:42,210 --> 02:07:43,470
Why try to break it?

2773
02:07:43,470 --> 02:07:46,800
Problem is, too, as people
aged in and passed away,

2774
02:07:46,800 --> 02:07:49,640
there's fewer and fewer people that
even knew the languages in which

2775
02:07:49,640 --> 02:07:51,030
those programs were written in.

2776
02:07:51,030 --> 02:07:53,150
And so now who's going to
even update the software?

2777
02:07:53,150 --> 02:07:57,080
So lots of problems were
feared, and this really just

2778
02:07:57,080 --> 02:08:01,880
boils down to because 1999
might have overflowed to not

2779
02:08:01,880 --> 02:08:05,070
zero per se but an implicit 1900.

2780
02:08:05,070 --> 02:08:07,370
And indeed, this definitely
happened, though not nearly

2781
02:08:07,370 --> 02:08:08,960
on the scale as people thought.

2782
02:08:08,960 --> 02:08:11,720
But it does happen in even more
real terms just a few years ago.

2783
02:08:11,720 --> 02:08:15,410
This is a Boeing 787,
an actual airplane that

2784
02:08:15,410 --> 02:08:17,540
had to be grounded for
some amount of time

2785
02:08:17,540 --> 02:08:20,810
because it had a programming error.

2786
02:08:20,810 --> 02:08:23,960
And its summarized here
in an online article.

2787
02:08:23,960 --> 02:08:29,270
A 787 airplane that has been
powered continuously for 248 days,

2788
02:08:29,270 --> 02:08:34,010
it turns out was the warning, can
lose all of its electrical power

2789
02:08:34,010 --> 02:08:37,610
due to the generator
going into fail safe mode.

2790
02:08:37,610 --> 02:08:38,270
Why is that?

2791
02:08:38,270 --> 02:08:41,300
This condition is caused
by a software counter

2792
02:08:41,300 --> 02:08:44,660
internal to the generator
that will overflow

2793
02:08:44,660 --> 02:08:48,350
after 248 days of continuous power.

2794
02:08:48,350 --> 02:08:49,910
So translate that.

2795
02:08:49,910 --> 02:08:53,810
That just means there's software
running in the Boeing's actual 787s.

2796
02:08:53,810 --> 02:08:55,700
They were using 32-bit integers.

2797
02:08:55,700 --> 02:08:59,180
They were using those integers
to store hundredths of seconds.

2798
02:08:59,180 --> 02:09:04,940
And at some point if you leave your
plane on for 248 days, each of which

2799
02:09:04,940 --> 02:09:09,500
has 24 hours, 60 minutes in an
hour, 60 seconds in a minute,

2800
02:09:09,500 --> 02:09:15,410
and 100 tenths of a seconds or 100 one
hundredths of a second in every second,

2801
02:09:15,410 --> 02:09:19,460
that product of multiplying
things out gets big pretty fast.

2802
02:09:19,460 --> 02:09:24,320
And on day 249, planes
theoretically would shut down even

2803
02:09:24,320 --> 02:09:26,660
in the middle of flight
for very real reasons

2804
02:09:26,660 --> 02:09:28,580
because a really big
number rolls over to zero

2805
02:09:28,580 --> 02:09:30,500
and that confused the generator.

2806
02:09:30,500 --> 02:09:34,550
And these are actual
smart airplane engineers

2807
02:09:34,550 --> 02:09:36,860
making these kinds of
mistakes because of software,

2808
02:09:36,860 --> 02:09:39,650
not anticipating one line of code
or some number of lines of code.

2809
02:09:39,650 --> 02:09:42,560
Or, as you proposed, why
didn't they just use more bits?

2810
02:09:42,560 --> 02:09:44,630
And again, these are very real concerns.

2811
02:09:44,630 --> 02:09:48,740
So this was thankfully addressed and
solved, but not before of course there

2812
02:09:48,740 --> 02:09:50,000
was quite the scare there.

2813
02:09:50,000 --> 02:09:53,960
So it turns out, in an older game,
this was the game of Civilization.

2814
02:09:53,960 --> 02:09:56,990
It turns out that one of the
characters as whom you can play,

2815
02:09:56,990 --> 02:10:00,380
Gandhi, is actually not as
peaceful a character in the game

2816
02:10:00,380 --> 02:10:01,890
is as you might think.

2817
02:10:01,890 --> 02:10:04,550
And let's for context just
take a look here for a second.

2818
02:10:04,550 --> 02:10:10,640
If we actually take a look at
some more binary, this in binary

2819
02:10:10,640 --> 02:10:12,920
is what number in decimal?

2820
02:10:12,920 --> 02:10:13,730
OK, 1.

2821
02:10:13,730 --> 02:10:14,930
And this is 8-bit.

2822
02:10:14,930 --> 02:10:15,970
So it's a full byte.

2823
02:10:15,970 --> 02:10:16,880
8 bits is a byte--

2824
02:10:16,880 --> 02:10:19,320
1, 2, 3, 4, 5, 6, 7, 8.

2825
02:10:19,320 --> 02:10:24,650
So what do you get if you do a 1 minus--

2826
02:10:24,650 --> 02:10:27,780
well, if you subtract 1 from
this, you obviously get what?

2827
02:10:27,780 --> 02:10:28,400
All zeros.

2828
02:10:28,400 --> 02:10:30,170
So 1 minus 1 is just 0.

2829
02:10:30,170 --> 02:10:34,550
What if you subtract 2 from this value?

2830
02:10:34,550 --> 02:10:36,400
What happens?

2831
02:10:36,400 --> 02:10:39,340
This is actually called integer
underflow, which is just the opposite,

2832
02:10:39,340 --> 02:10:41,840
but there's really not too many
options to think about this.

2833
02:10:41,840 --> 02:10:43,310
If you only have zeros
and ones, you can probably

2834
02:10:43,310 --> 02:10:45,200
imagine what the bad scenario is.

2835
02:10:45,200 --> 02:10:50,710
If 0000001, if you subtract 1, goes
to zeros, and then you do it again,

2836
02:10:50,710 --> 02:10:57,440
you now underflow, which just brings
you around to the opposite 11111111.

2837
02:10:57,440 --> 02:11:01,660
So if you have 8 ones, what
value is that if you do the math?

2838
02:11:01,660 --> 02:11:04,480
Ones, twos, fours, eight 16s.

2839
02:11:04,480 --> 02:11:07,600
It turns out it's 255 if you
actually do all the math.

2840
02:11:07,600 --> 02:11:10,210
So it turns out that
this game Civilization

2841
02:11:10,210 --> 02:11:13,330
was using a single byte to
represent every character's

2842
02:11:13,330 --> 02:11:15,190
level of aggressiveness in the game.

2843
02:11:15,190 --> 02:11:17,650
And Gandhi's was, as you
would expect, by default

2844
02:11:17,650 --> 02:11:20,620
initialized to 1, very non-aggressive.

2845
02:11:20,620 --> 02:11:23,740
Unfortunately, in this
game of Civilization,

2846
02:11:23,740 --> 02:11:27,880
when a player adopts democracy
in his or her civilization,

2847
02:11:27,880 --> 02:11:32,230
their aggression would be
automatically reduced by two.

2848
02:11:32,230 --> 02:11:36,470
And so if Gandhi went democratic, his
aggression wouldn't go to negative 1.

2849
02:11:36,470 --> 02:11:40,090
It looped back around to the
ludicrously high figure of 255,

2850
02:11:40,090 --> 02:11:44,370
making him as aggressive as a
civilization could possibly be.

2851
02:11:44,370 --> 02:11:48,380
So less impactful, to be sure, than
something like the airplane example,

2852
02:11:48,380 --> 02:11:50,140
but these problems are omnipresent.

2853
02:11:50,140 --> 02:11:52,480
And if you start to keep an
eye out in the popular media

2854
02:11:52,480 --> 02:11:54,550
or when there are bugs
or hacks or exploits,

2855
02:11:54,550 --> 02:12:00,940
it's so often because a programmer
has made a mistake in his or her code.

2856
02:12:00,940 --> 02:12:04,480
They didn't anticipate a scenario or
they made maybe reasonable decisions

2857
02:12:04,480 --> 02:12:06,640
years ago, but that
eventually proved to be

2858
02:12:06,640 --> 02:12:10,060
naive in that we're still running the
same code, numbers are getting too big,

2859
02:12:10,060 --> 02:12:11,240
their math is wrong.

2860
02:12:11,240 --> 02:12:12,650
And so very real things happen.

2861
02:12:12,650 --> 02:12:14,900
But what's most important
for us is just understanding

2862
02:12:14,900 --> 02:12:17,300
how and why those things happen.

2863
02:12:17,300 --> 02:12:19,100
And so what will we
do in the days ahead?

2864
02:12:19,100 --> 02:12:21,850
So the next homework assignment, as with
Scratch, will be to program something

2865
02:12:21,850 --> 02:12:23,950
but this time in C. You
will use an environment

2866
02:12:23,950 --> 02:12:27,220
called CS50 lab, which essentially
is CS50 sandbox, with which we've

2867
02:12:27,220 --> 02:12:28,240
been tinkering today.

2868
02:12:28,240 --> 02:12:31,260
But it adds to it the instructions
and the specification of the problems

2869
02:12:31,260 --> 02:12:32,350
that you'll want to solve.

2870
02:12:32,350 --> 02:12:34,810
And it'll hold your hands initially
through some of these steps.

2871
02:12:34,810 --> 02:12:36,680
You don't need to have written
everything down and memorized

2872
02:12:36,680 --> 02:12:39,190
everything I typed today, but
do feel free in the meantime

2873
02:12:39,190 --> 02:12:42,250
to go to the course's website and
play with any of those examples.

2874
02:12:42,250 --> 02:12:46,010
Among the challenges ahead will be
to recreate some snippets of games

2875
02:12:46,010 --> 02:12:49,060
from yesteryear, thinking about how
things you might have seen growing up

2876
02:12:49,060 --> 02:12:50,860
can be translated to actual code.

2877
02:12:50,860 --> 02:12:54,100
And undoubtedly, among the first things
you'll experience, is frustration.

2878
02:12:54,100 --> 02:12:56,980
You'll forget the stupid semi-colon
or where does the parentheses go?

2879
02:12:56,980 --> 02:12:58,030
And you'll have to look back at code.

2880
02:12:58,030 --> 02:13:00,310
But keep in mind, none
of that stuff matters.

2881
02:13:00,310 --> 02:13:03,730
It's absolutely frustrating initially,
but what's most important is the ideas

2882
02:13:03,730 --> 02:13:05,710
and, honestly, the
sense of gratification

2883
02:13:05,710 --> 02:13:08,020
that you, like all of
CS50 staff before you,

2884
02:13:08,020 --> 02:13:11,110
ultimately feel when actually building
and creating something of your own.

2885
02:13:11,110 --> 02:13:14,460
Let's call it a day there,
and we'll see you next time.

