1
00:00:00,000 --> 00:00:25,980
[音乐] 

2
00:00:30,020 --> 00:00:43,270
[音乐] 

3
00:00:46,010 --> 00:00:49,600
[掌声] 

4
00:00:47,170 --> 00:00:51,890
[音乐] 

5
00:00:49,600 --> 00:00:54,199
这是cs50 

6
00:00:51,890 --> 00:00:55,789
然后这是第 6 讲 ，你记得 

7
00:00:54,199 --> 00:00:58,280
上周我们推出了网络 

8
00:00:55,789 --> 00:00:59,449
通过HTML 和CSS或在。编程

9
00:00:58,280 --> 00:01:01,219
至少我们没有的构建块 

10
00:00:59,449 --> 00:01:03,469
实际上还有编程的能力

11
00:01:01,219 --> 00:01:05,330
它只是标记HTML和CSS 

12
00:01:03,469 --> 00:01:07,130
其风格化， 但我们介绍 

13
00:01:05,330 --> 00:01:09,409
这个比喻是上周的一个协议 

14
00:01:07,130 --> 00:01:11,509
叫做tcp / ip ，我们把它联系起来 

15
00:01:09,409 --> 00:01:13,490
当然是一个信封，在这个信封上 

16
00:01:11,509 --> 00:01:15,319
在前面几乎至少有两个 

17
00:01:13,490 --> 00:01:17,330
的 信息 ，如果有人件

18
00:01:15,319 --> 00:01:20,270
记得这两件作品 是 什么 

19
00:01:17,330 --> 00:01:22,479
其他人的信息 

20
00:01:20,270 --> 00:01:24,770
我们最近没有听到的是耶 

21
00:01:22,479 --> 00:01:26,539
是的IP 地址是一个数字地址 

22
00:01:24,770 --> 00:01:28,369
唯一 标识您的计算机 

23
00:01:26,539 --> 00:01:32,509
和别人的电脑和一个 

24
00:01:28,369 --> 00:01:34,869
如果你还记得其他的事哦来吧 

25
00:01:32,509 --> 00:01:37,549
谁像两分钟 前一样 好吧 是 的 

26
00:01:34,869 --> 00:01:39,170
端口号所以另一个数字更短 

27
00:01:37,549 --> 00:01:43,009
数字只是80或者数字 

28
00:01:39,170 --> 00:01:45,319
443指的是湿HTTP或HTTPS或 

29
00:01:43,009 --> 00:01:46,729
其他号码，如25电子邮件和 

30
00:01:45,319 --> 00:01:48,709
像这样独特的一起

31
00:01:46,729 --> 00:01:50,780
地址允许您发送 信息 

32
00:01:48,709 --> 00:01:52,759
不仅是一台 特定的电脑， 还有一 台电脑 

33
00:01:50,780 --> 00:01:55,160
在那上面 运行的特定服务 

34
00:01:52,759 --> 00:01:57,110
电脑，以实际 

35
00:01:55,160 --> 00:01:59,750
从该服务器请求信息 

36
00:01:57,110 --> 00:02:01,759
这是另一个称为HTTP的协议 

37
00:01:59,750 --> 00:02:03,860
这是超文本传输​​协议

38
00:02:01,759 --> 00:02:05,750
什么是信封 内部 所以什么时候 

39
00:02:03,860 --> 00:02:07,879
服务器以隐喻的方式打开它 

40
00:02:05,750 --> 00:02:10,340
看里面这是命令 

41
00:02:07,879 --> 00:02:12,140
该服务器读取以便决定 

42
00:02:10,340 --> 00:02:14,480
什么应该实际回应和

43
00:02:12,140 --> 00:02:16,550
所以这里的要求是告诉你 的 

44
00:02:14,480 --> 00:02:18,430
服务器， 也称为dub-dub-dub 

45
00:02:16,550 --> 00:02:22,099
example.com在这个特定的例子中 

46
00:02:18,430 --> 00:02:24,560
发送回 自己的内容 

47
00:02:22,099 --> 00:02:31,069
如果我是的话，信封给我和我的笔记本电脑

48
00:02:24,560 --> 00:02:32,840
要求这个特定的 网页和 

49
00:02:31,069 --> 00:02:35,959
别人哪个网页专门 

50
00:02:32,840 --> 00:02:37,909
大概是的，所以index.html我们 

51
00:02:35,959 --> 00:02:40,580
上周刚刚往往 是 

52
00:02:37,909 --> 00:02:42,530
Web服务器上的默认文件名 

53
00:02:40,580 --> 00:02:43,610
这只是 默认 和 选定 页面 

54
00:02:42,530 --> 00:02:45,290
它不必 被称为这个 

55
00:02:43,610 --> 00:02:47,030
这是一个人类的惯例，其余部分

56
00:02:45,290 --> 00:02:48,709
这只是一个字面上的动词 

57
00:02:47,030 --> 00:02:50,900
我这个文件只是 告诉了 

58
00:02:48,709 --> 00:02:52,819
服务器我说的是什么版本的HTTP 

59
00:02:50,900 --> 00:02:55,219
人类可以在马托格罗索改进和 

60
00:02:52,819 --> 00:02:56,180
随着时间的推移升级， 但这会告诉我们 

61
00:02:55,219 --> 00:02:58,890
要返回的服务器

62
00:02:56,180 --> 00:03:00,660
index.html 同时我们看到了更多 

63
00:02:58,890 --> 00:03:02,690
我们时复杂的查询

64
00:03:00,660 --> 00:03:05,190
开始谈论 谷歌和任何 

65
00:03:02,690 --> 00:03:07,200
网站， 有不 只是一个 前端 

66
00:03:05,190 --> 00:03:09,300
像HTML和CSS，但也是一个 后端 

67
00:03:07,200 --> 00:03:10,830
后端是逻辑的所在 

68
00:03:09,300 --> 00:03:13,050
服务器所在的位置和 

69
00:03:10,830 --> 00:03:15,780
有趣的工作 最终等等 

70
00:03:13,050 --> 00:03:18,060
这个斜线搜索表明某种 

71
00:03:15,780 --> 00:03:19,800
从谷歌服务器上运行的软件 

72
00:03:18,060 --> 00:03:21,780
上周 只是回应 

73
00:03:19,800 --> 00:03:25,380
请求以及问号Q是什么 

74
00:03:21,780 --> 00:03:27,680
等于猫做或代表那 

75
00:03:25,380 --> 00:03:27,680
示范

76
00:03:27,830 --> 00:03:32,010
是的用户输入所以问号

77
00:03:30,420 --> 00:03:34,980
只是说这是文件名 或 

78
00:03:32,010 --> 00:03:37,920
这里的URL是用户输入 q 

79
00:03:34,980 --> 00:03:39,720
只是字面上的HTTP参数或 

80
00:03:37,920 --> 00:03:41,910
输入拉里和谢尔盖的创始人 

81
00:03:39,720 --> 00:03:43,860
谷歌在20 年前 决定 将 

82
00:03:41,910 --> 00:03:45,900
表示查询的用户输入q 

83
00:03:43,860 --> 00:03:48,000
等于只是意味着他们查询了 

84
00:03:45,900 --> 00:03:49,350
输入的人是猫而是人

85
00:03:48,000 --> 00:03:52,020
甚至不必一次打字 

86
00:03:49,350 --> 00:03:55,940
如果你真的想要了解HTTP 

87
00:03:52,020 --> 00:03:58,800
要成为一个书呆子，你可以去WWE 

88
00:03:55,940 --> 00:04:00,420
问号Q等于猫 ，它会 

89
00:03:58,800 --> 00:04:01,890
诱导你搜索， 因为在 

90
00:04:00,420 --> 00:04:04,050
所有浏览器都是 当天的结束

91
00:04:01,890 --> 00:04:05,550
当你有这些网络表格时 这样做 

92
00:04:04,050 --> 00:04:06,990
你现在有 能力创造它 

93
00:04:05,550 --> 00:04:09,900
只是自动化 过程 

94
00:04:06,990 --> 00:04:12,030
现在生成这些HTTP消息 

95
00:04:09,900 --> 00:04:14,910
服务器希望回复一条消息 

96
00:04:12,030 --> 00:04:17,250
你永远不会真正看到HTTP 200 

97
00:04:14,910 --> 00:04:19,460
当然 ，字面意思是好的 

98
00:04:17,250 --> 00:04:23,600
我们很多人都看到过以外的数字 

99
00:04:19,460 --> 00:04:26,460
200看起来像404意味着什么

100
00:04:23,600 --> 00:04:28,740
文件未找到现在为什么 人类 

101
00:04:26,460 --> 00:04:30,660
多年前决定告诉人类告诉 

102
00:04:28,740 --> 00:04:32,490
其他人类这个数字值得代码 

103
00:04:30,660 --> 00:04:34,200
我是说这是无趣的 

104
00:04:32,490 --> 00:04:36,810
细节但世界无论出于何种原因

105
00:04:34,200 --> 00:04:38,490
已经在许多网站上透露了404但它 

106
00:04:36,810 --> 00:04:41,100
只是意味着一切都是一样的 

107
00:04:38,490 --> 00:04:42,600
不行， 你可能 找不到文件 

108
00:04:41,100 --> 00:04:44,760
看到这样的其他东西，我们看到了这个 

109
00:04:42,600 --> 00:04:46,350
事实上哈佛很奇怪 

110
00:04:44,760 --> 00:04:48,390
哈佛现在已永久迁移

111
00:04:46,350 --> 00:04:52,170
哈佛是在回应 某些 

112
00:04:48,390 --> 00:04:57,230
使用HTTP 301 s进行查询

113
00:04:52,170 --> 00:04:59,160
实现什么功能或效果是什么 

114
00:04:57,230 --> 00:05:01,200
重定向，所以这是一种

115
00:04:59,160 --> 00:05:02,580
描述它的低级方式，但301 

116
00:05:01,200 --> 00:05:04,560
即使它说永久移动

117
00:05:02,580 --> 00:05:06,450
这是一个更具技术性的暗示

118
00:05:04,560 --> 00:05:08,669
浏览器说哈佛搬不动了

119
00:05:06,450 --> 00:05:09,630
你刚刚来自哪个网址但是 

120
00:05:08,669 --> 00:05:11,460
这个网址 

121
00:05:09,630 --> 00:05:13,260
通常而且现在可能是哈佛大学 

122
00:05:11,460 --> 00:05:15,390
如果你回想起重定向我的东西 

123
00:05:13,260 --> 00:05:20,010
如果我不在该 URL，则为URL 

124
00:05:15,390 --> 00:05:21,600
我可能在哪里，所以也许平静如果 

125
00:05:20,010 --> 00:05:23,460
他们实际拥有 多个域名 

126
00:05:21,600 --> 00:05:27,690
我们正在重定向，这可能会起作用 

127
00:05:23,460 --> 00:05:29,610
别的， 是的， 也许我只是输入 

128
00:05:27,690 --> 00:05:32,030
HTTP和哈佛的利益 

129
00:05:29,610 --> 00:05:35,310
安全想要 强制我的浏览器 

130
00:05:32,030 --> 00:05:38,070
请求我再次请求此页面 

131
00:05:35,310 --> 00:05:40,200
HTTP 有时 该 网站可能在前面加上 

132
00:05:38,070 --> 00:05:42,540
www，如果你没有输入或 

133
00:05:40,200 --> 00:05:43,890
你 可以在任何地方重定向 

134
00:05:42,540 --> 00:05:46,110
事实上， 如果你去看一个swifty区域 

135
00:05:43,890 --> 00:05:48,510
只需 输入 哈佛的 cs50 网站 

136
00:05:46,110 --> 00:05:50,850
edu会看到您要重定向的网址

137
00:05:48,510 --> 00:05:53,100
一个更具体的页面 因 

138
00:05:50,850 --> 00:05:55,440
一年中的时间， 所以我们使用 这些技巧 

139
00:05:53,100 --> 00:05:57,810
找不到404可能看起来像 这样 

140
00:05:55,440 --> 00:05:59,910
但更深层次的隐喻

141
00:05:57,810 --> 00:06:02,010
信封的实际内容

142
00:05:59,910 --> 00:06:03,930
网页， 所以你不仅回到 这些 

143
00:06:02,010 --> 00:06:06,300
在它们中调用的HTTP标头

144
00:06:03,930 --> 00:06:09,840
最重要的回答可以这么说但是你 

145
00:06:06,300 --> 00:06:11,550
还可以获得HTML另一种语言

146
00:06:09,840 --> 00:06:12,840
我们实际看了一下这个

147
00:06:11,550 --> 00:06:15,690
语言，但不是编程语言 

148
00:06:12,840 --> 00:06:18,000
这些 标签告诉浏览器究竟 是什么 

149
00:06:15,690 --> 00:06:20,070
为了渲染， 我们介绍了这个 

150
00:06:18,000 --> 00:06:29,160
样式标签虽然是什么让我们这样做 

151
00:06:20,070 --> 00:06:30,900
要做那个 HTML单独没有使用 

152
00:06:29,160 --> 00:06:32,880
CSS 美化 网站， 只是做 

153
00:06:30,900 --> 00:06:36,030
它更好的HTML大部分是 关于 

154
00:06:32,880 --> 00:06:37,590
结构和标记内容 

155
00:06:36,030 --> 00:06:39,870
您的网页的方式 

156
00:06:37,590 --> 00:06:41,550
浏览器发现有用，但CSS确实如此

157
00:06:39,870 --> 00:06:43,410
为了用户的利益最终 

158
00:06:41,550 --> 00:06:44,730
在他或她眼中的一天，因为它真的 

159
00:06:43,410 --> 00:06:46,200
让你控制字体大小和 

160
00:06:44,730 --> 00:06:47,250
定位和低级别的东西 

161
00:06:46,200 --> 00:06:49,320
你可能已经开始摆弄 

162
00:06:47,250 --> 00:06:50,820
现在设置了最新的问题

163
00:06:49,320 --> 00:06:53,490
我们可能会提议你 

164
00:06:50,820 --> 00:06:55,830
不应该只是开始在里面键入CSS 

165
00:06:53,490 --> 00:06:57,090
您的HTML 页面，因为它只是 一个 

166
00:06:55,830 --> 00:06:58,860
你的维护 难度加大 

167
00:06:57,090 --> 00:07:00,630
例子越来越复杂， 所以你 

168
00:06:58,860 --> 00:07:02,160
可能会考虑它并且你做的几率很高 

169
00:07:00,630 --> 00:07:03,840
这对于问题集是因为何时 

170
00:07:02,160 --> 00:07:06,240
如果你有相同的主页，请创建一个主页

171
00:07:03,840 --> 00:07:08,040
CSS 样式跨 多个文件 吧 

172
00:07:06,240 --> 00:07:09,630
会非常愚蠢和低效 

173
00:07:08,040 --> 00:07:12,060
一次又一次地复制和粘贴它们 

174
00:07:09,630 --> 00:07:13,920
你最后可以将它们排除在外 

175
00:07:12,060 --> 00:07:15,420
我们上次看了JavaScript 

176
00:07:13,920 --> 00:07:17,520
另一种编程语言 

177
00:07:15,420 --> 00:07:19,620
超级类似于 C至少 在第一 

178
00:07:17,520 --> 00:07:21,120
一瞥， 但它实际上已经摆脱了很多 

179
00:07:19,620 --> 00:07:23,129
像下层的头痛一样 

180
00:07:21,120 --> 00:07:24,330
指针和内存地址

181
00:07:23,129 --> 00:07:26,669
我们已经在 最近的 挣扎 

182
00:07:24,330 --> 00:07:28,589
几周， 但最重要的是我们如何使用 

183
00:07:26,669 --> 00:07:31,319
所以你可以考虑像这样的网页 

184
00:07:28,589 --> 00:07:32,729
这 就像你的浏览器加载一样 

185
00:07:31,319 --> 00:07:34,169
它只是一个树形结构 

186
00:07:32,729 --> 00:07:35,969
回想几个星期我们的 

187
00:07:34,169 --> 00:07:38,639
讨论数据结构和每个 

188
00:07:35,969 --> 00:07:40,860
在我们看到的树中的这些节点

189
00:07:38,639 --> 00:07:43,199
JavaScript可以被操纵和通过 

190
00:07:40,860 --> 00:07:45,989
写代码的原理非常简单

191
00:07:43,199 --> 00:07:48,119
修改了现有的树 

192
00:07:45,989 --> 00:07:49,830
计算机在浏览器的内存意味着 

193
00:07:48,119 --> 00:07:51,689
你可以做出更有活力的事情 

194
00:07:49,830 --> 00:07:53,099
像Gmail和Facebook和任何数字 

195
00:07:51,689 --> 00:07:55,199
不断变化的网站 

196
00:07:53,099 --> 00:07:57,449
你 还没有为这个问题做这件事 

197
00:07:55,199 --> 00:07:59,759
设置你 刚才所作 的静态网页 

198
00:07:57,449 --> 00:08:01,499
硬编码HTML和CSS，但开始 

199
00:07:59,759 --> 00:08:03,479
下周 我们一旦感谢这一点 

200
00:08:01,499 --> 00:08:04,919
一周Python的词汇表就可以了 

201
00:08:03,479 --> 00:08:06,529
开始让事情变得更有活力 

202
00:08:04,919 --> 00:08:08,669
然后甚至 重新 发挥作用 

203
00:08:06,529 --> 00:08:11,909
JavaScript带来了各种各样的 

204
00:08:08,669 --> 00:08:13,169
线程在一起并包括 

205
00:08:11,909 --> 00:08:15,029
JavaScript 回忆我们 使用了a 

206
00:08:13,169 --> 00:08:16,949
脚本标记在顶部 或我们考虑它 

207
00:08:15,029 --> 00:08:19,110
出一个文件或在某些情况下它 

208
00:08:16,949 --> 00:08:21,569
移动它是必要的或有益的 

209
00:08:19,110 --> 00:08:23,849
到 文件 的底部 或因素 

210
00:08:21,569 --> 00:08:26,759
那样的， 但更多的是在 那个 

211
00:08:23,849 --> 00:08:41,399
所以在上周或之后有任何问题

212
00:08:26,759 --> 00:08:43,409
HTTP HTML CSS或tcp / ip是的好

213
00:08:41,399 --> 00:08:45,060
问题所以在什么情况下你会提出 

214
00:08:43,409 --> 00:08:47,519
脚本标记在顶部而不是在 

215
00:08:45,060 --> 00:08:50,100
如果你 写的代码是底部

216
00:08:47,519 --> 00:08:51,689
JavaScript 操纵Dom树 

217
00:08:50,100 --> 00:08:54,060
我有屏幕一会儿就好了上

218
00:08:51,689 --> 00:08:57,240
之前的问题 是那棵树需要的 

219
00:08:54,060 --> 00:08:59,279
存在代码执行时 ，如果 

220
00:08:57,240 --> 00:09:01,709
例如，你有JavaScript代码 

221
00:08:59,279 --> 00:09:04,680
这是在 您的页面 的头部 但是 

222
00:09:01,709 --> 00:09:06,420
树中的节点是您想要的标记 

223
00:09:04,680 --> 00:09:08,009
操纵和改变事物为红色 

224
00:09:06,420 --> 00:09:10,110
像我们上周所做的那样，绿色到蓝色 

225
00:09:08,009 --> 00:09:12,120
或者让事情在这里眨眼或下降 

226
00:09:10,110 --> 00:09:14,250
您无法编写 代码 的页面 

227
00:09:12,120 --> 00:09:15,779
在这里，让它 改变一切 

228
00:09:14,250 --> 00:09:17,939
在这里翻页，因为它正在发生 

229
00:09:15,779 --> 00:09:19,290
在精神上看起来如此相似

230
00:09:17,939 --> 00:09:21,089
事情必须在右边发生 

231
00:09:19,290 --> 00:09:24,240
订购， 如果你想 改变一些东西 

232
00:09:21,089 --> 00:09:26,370
在这里你的代码 至少需要 

233
00:09:24,240 --> 00:09:28,439
到这里， 或者 你需要 使用一些 

234
00:09:26,370 --> 00:09:30,540
更高级的技巧说我会 

235
00:09:28,439 --> 00:09:32,430
把我的代码写在这里， 但等一下 

236
00:09:30,540 --> 00:09:35,040
在执行之前的几秒钟直到 

237
00:09:32,430 --> 00:09:36,120
整个芽页面加载最多 

238
00:09:35,040 --> 00:09:36,600
我们看到的例子 是 

239
00:09:36,120 --> 00:09:38,009
不在里面 

240
00:09:36,600 --> 00:09:41,370
舒宾 我们也许会回到这个 地步 

241
00:09:38,009 --> 00:09:42,779
不久 没事 让我们现在就 

242
00:09:41,370 --> 00:09:44,850
和 我们上次做 的一样 

243
00:09:42,779 --> 00:09:46,500
通过引入一种语言 的方法 

244
00:09:44,850 --> 00:09:48,000
另一个你会记得我们当然 

245
00:09:46,500 --> 00:09:49,589
从头开始整个学期 

246
00:09:48,000 --> 00:09:51,329
然后我们过了几个星期 

247
00:09:49,589 --> 00:09:53,100
现在回来看看上周我们做了一些

248
00:09:51,329 --> 00:09:54,990
与JavaScript比较让我们做 

249
00:09:53,100 --> 00:09:56,160
同样简单的Python 然后 

250
00:09:54,990 --> 00:09:58,110
花更多时间在键盘上 

251
00:09:56,160 --> 00:10:00,959
比较两者，看看究竟是什么

252
00:09:58,110 --> 00:10:02,550
关于 这些，为什么在 不同的 

253
00:10:00,959 --> 00:10:06,240
我们首先有另一种语言

254
00:10:02,550 --> 00:10:07,980
scratch C JavaScript Python 

255
00:10:06,240 --> 00:10:09,630
更不用说HTML和CSS了

256
00:10:07,980 --> 00:10:11,940
不同的目的， 比如我们为什么 

257
00:10:09,630 --> 00:10:13,860
所有这些非法语言已经成为 原因 

258
00:10:11,940 --> 00:10:16,769
不是人类只是决定这就是它 

259
00:10:13,860 --> 00:10:20,040
我们都在使用刮擦， 我们都在 使用 

260
00:10:16,769 --> 00:10:24,240
C或JavaScript 或Python 可能是什么 

261
00:10:20,040 --> 00:10:26,370
背后 的直觉 ， 为什么会有 

262
00:10:24,240 --> 00:10:31,819
这么多该死的语言更不用说了 

263
00:10:26,370 --> 00:10:33,839
这一门课程是的，再说一次 

264
00:10:31,819 --> 00:10:35,069
是的，不同的是有益的

265
00:10:33,839 --> 00:10:36,180
不同的事情， 这可能会发生 

266
00:10:35,069 --> 00:10:37,740
没有说什么的 

267
00:10:36,180 --> 00:10:39,569
划伤它是如此直观它是如此 

268
00:10:37,740 --> 00:10:41,399
这样的图形和动画

269
00:10:39,569 --> 00:10:42,959
感觉拼图是那样的 

270
00:10:41,399 --> 00:10:44,310
语言本身就是基于谜题

271
00:10:42,959 --> 00:10:46,110
碎片和拖放 

272
00:10:44,310 --> 00:10:48,930
所以也许语言定制 

273
00:10:46,110 --> 00:10:51,300
某些应用程序但是就是这样

274
00:10:48,930 --> 00:10:52,769
这对于JavaScript中的 C Python来说是正确的

275
00:10:51,300 --> 00:11:01,939
这些都是 基于文本的语言我们会 

276
00:10:52,769 --> 00:11:01,939
看到不同的抽象层次 

277
00:11:08,100 --> 00:11:15,059
好的东西，他们可以相机 

278
00:11:23,730 --> 00:11:27,280
一般好把它回 

279
00:11:25,900 --> 00:11:29,200
抽象一定道理看到 的是 

280
00:11:27,280 --> 00:11:31,180
确实像 字面意义上的 非常 低级 

281
00:11:29,200 --> 00:11:32,950
有能力操纵记忆 

282
00:11:31,180 --> 00:11:34,240
并通过指针等等， 这就是 

283
00:11:32,950 --> 00:11:35,860
很棒， 因为你 可以做任何事情 

284
00:11:34,240 --> 00:11:38,050
想要用电脑，但它来了 

285
00:11:35,860 --> 00:11:39,820
成本 高，风险 大，成本高 

286
00:11:38,050 --> 00:11:42,640
人类的时间就像是痛苦 的 

287
00:11:39,820 --> 00:11:46,300
有时写那种代码 过于 它 

288
00:11:42,640 --> 00:11:48,220
它也是非常危险的， 因为 如果你 

289
00:11:46,300 --> 00:11:49,990
犯 了一个错误，即使 是一个简单的错误 

290
00:11:48,220 --> 00:11:51,190
整台电脑可能会崩溃而我们没有 

291
00:11:49,990 --> 00:11:53,290
看看这个例子但你可以做 

292
00:11:51,190 --> 00:11:55,300
在你的代码容易受到黑客如果 

293
00:11:53,290 --> 00:11:56,920
他或她 能以某种方式利用一个 

294
00:11:55,300 --> 00:11:58,450
与内存相关的bug并阅读所有内容

295
00:11:56,920 --> 00:12:00,220
你的程序中的 密码 或 其他东西 

296
00:11:58,450 --> 00:12:01,810
就 这样，强大的力量来了 

297
00:12:00,220 --> 00:12:04,570
这是一种很重要的责任 

298
00:12:01,810 --> 00:12:06,340
C的 口头禅在 这里，但JavaScript我们 

299
00:12:04,570 --> 00:12:07,990
锯让我们可以做更多的事情 

300
00:12:06,340 --> 00:12:09,310
像没有指针一样的 高级别 

301
00:12:07,990 --> 00:12:10,990
没有记忆，我们没有谈论

302
00:12:09,310 --> 00:12:12,790
我们谈到的 那个层面的 事情 

303
00:12:10,990 --> 00:12:14,730
在一棵树的水平上的东西

304
00:12:12,790 --> 00:12:16,810
记忆和改变颜色和 

305
00:12:14,730 --> 00:12:18,940
在屏幕上的东西定位 

306
00:12:16,810 --> 00:12:22,030
这确实是 现在 更高级别的 python 

307
00:12:18,940 --> 00:12:23,650
它不一定是以网络为中心的 

308
00:12:22,030 --> 00:12:25,600
更多的是一种多用途语言的人 

309
00:12:23,650 --> 00:12:27,640
使用 python 编写 命令行 

310
00:12:25,600 --> 00:12:29,140
像我们这样的计划很快就会在 

311
00:12:27,640 --> 00:12:31,150
键盘就像我们一直用 c 做的那样 

312
00:12:29,140 --> 00:12:33,430
你也可以 使用它，我们会看到 

313
00:12:31,150 --> 00:12:35,410
下周 要生成其他语言 

314
00:12:33,430 --> 00:12:37,360
下周我们 将用 Python 编写代码 

315
00:12:35,410 --> 00:12:40,240
我们即将看到的语言 

316
00:12:37,360 --> 00:12:41,800
生成另一种语言HTML和CSS 

317
00:12:40,240 --> 00:12:43,930
有些人可能会注意到你的 

318
00:12:41,800 --> 00:12:46,240
您有一些冗余的主页 

319
00:12:43,930 --> 00:12:47,890
你可能有类似的标签或类似 

320
00:12:46,240 --> 00:12:50,230
结构可能是一个类似的菜单 

321
00:12:47,890 --> 00:12:51,910
页面 Python和其他语言将 

322
00:12:50,230 --> 00:12:53,860
让我们把它分解出来并 产生 

323
00:12:51,910 --> 00:12:55,990
那些 共性更容易 

324
00:12:53,860 --> 00:12:58,270
在许多其他 事情中 ，它 也是 

325
00:12:55,990 --> 00:12:59,770
可以说更简单，更快速地写作 

326
00:12:58,270 --> 00:13:02,440
因为它带来了更多 

327
00:12:59,770 --> 00:13:04,150
我们很快就会看到这些功能

328
00:13:02,440 --> 00:13:07,690
你知道让我这么做的事让 我走了 

329
00:13:04,150 --> 00:13:09,820
提前开放 cs50 IDE让我走了 

330
00:13:07,690 --> 00:13:11,470
提前创建一个新文件 

331
00:13:09,820 --> 00:13:13,150
我们最近的问题集的好奇心

332
00:13:11,470 --> 00:13:17,500
什么可能是最多的 

333
00:13:13,150 --> 00:13:19,800
挑战你编写好的程序 

334
00:13:17,500 --> 00:13:22,210
什么其他的裂缝是一个很好的

335
00:13:19,800 --> 00:13:23,710
调整大小恢复是的绝对是

336
00:13:22,210 --> 00:13:25,060
法医学和更多的人可能 

337
00:13:23,710 --> 00:13:27,160
确实恢复并调整大小让我们接受

338
00:13:25,060 --> 00:13:28,870
调整例如所以让我先走 

339
00:13:27,160 --> 00:13:31,570
在一个名为写一个 程序 

340
00:13:28,870 --> 00:13:34,720
调整 PI for Python而不是dot C. 

341
00:13:31,570 --> 00:13:36,819
看看我们能不能花几个小时

342
00:13:34,720 --> 00:13:38,979
你可能没有看到几天

343
00:13:36,819 --> 00:13:42,489
实施大小调整让我继续前进 

344
00:13:38,979 --> 00:13:43,869
并且这样做 我会继续前进，让我们 

345
00:13:42,489 --> 00:13:46,569
首先我要导入一些 

346
00:13:43,869 --> 00:13:48,910
Python和Python 一起提供的功能

347
00:13:46,569 --> 00:13:51,609
我要继续说，从姐姐那里说 

348
00:13:48,910 --> 00:13:54,819
导入argh V，我要继续 前进 

349
00:13:51,609 --> 00:13:56,199
也可以从PIL导入图像做我的 

350
00:13:54,819 --> 00:13:57,819
知道这些是什么 我们会取笑 

351
00:13:56,199 --> 00:14:00,399
这一刻分开然后让我 

352
00:13:57,819 --> 00:14:04,119
只是检查是否长度相当 

353
00:14:00,399 --> 00:14:05,979
如果argh V的长度不相等 

354
00:14:04,119 --> 00:14:07,929
四，我要继续前进 

355
00:14:05,979 --> 00:14:12,279
用户并说出该程序的用法 

356
00:14:07,929 --> 00:14:14,019
是Python 调整大小的op i和文件输出 

357
00:14:12,279 --> 00:14:15,699
文件， 所以即使其中一些 应该 

358
00:14:14,019 --> 00:14:17,859
看起来神秘莫测

359
00:14:15,699 --> 00:14:19,839
共同点是 你 从C 回忆起来的 

360
00:14:17,859 --> 00:14:21,519
和我们打印的这个用法字符串 

361
00:14:19,839 --> 00:14:23,319
什么时候出错了 

362
00:14:21,519 --> 00:14:25,269
在精神上 与C和C看起来非常相似 

363
00:14:23,319 --> 00:14:27,129
如果你重新调整我们做了什么

364
00:14:25,269 --> 00:14:28,959
实现调整大小就像不那么舒服

365
00:14:27,129 --> 00:14:31,179
版本增加东西的大小

366
00:14:28,959 --> 00:14:35,319
你可能声明了一个像N这样的变量 

367
00:14:31,179 --> 00:14:37,209
得到了sis dot或者更确切地说是我们的 V支架 

368
00:14:35,319 --> 00:14:38,679
一个 可以 访问它我 会去 

369
00:14:37,209 --> 00:14:40,629
提前转换或转换为 

370
00:14:38,679 --> 00:14:42,819
一个int你可能有一个in文件 

371
00:14:40,629 --> 00:14:44,589
变量，给你访问 喜欢 

372
00:14:42,819 --> 00:14:46,569
argh b2你可能有一个文件 

373
00:14:44,589 --> 00:14:48,850
变量，使您可以访问 我们的v3 

374
00:14:46,569 --> 00:14:50,799
等等，结果在Python中 

375
00:14:48,850 --> 00:14:52,509
如果你知道我实际可以使用的是什么 

376
00:14:50,799 --> 00:14:54,369
其他人拥有的 库代码 

377
00:14:52,509 --> 00:14:56,859
写的让我想出 一个变量 

378
00:14:54,369 --> 00:14:59,889
像在文件中一样调用这是我的 

379
00:14:56,859 --> 00:15:01,779
输入图像，这将是相同的图像 

380
00:14:59,889 --> 00:15:04,119
点开，因为我想 开 这个 

381
00:15:01,779 --> 00:15:05,949
在文件中调用的东西然后是宽度 

382
00:15:04,119 --> 00:15:08,470
让我得到的宽度高度 

383
00:15:05,949 --> 00:15:10,839
通过输入图像的现有图像 

384
00:15:08,470 --> 00:15:13,149
大小然后让我继续做一个新的 

385
00:15:10,839 --> 00:15:16,029
图像进行图像我称之为这是 

386
00:15:13,149 --> 00:15:18,429
将等于调用a的输入图像 

387
00:15:16,029 --> 00:15:21,069
调整大小功能并执行宽度 

388
00:15:18,429 --> 00:15:24,039
次数n 是人的 数字 

389
00:15:21,069 --> 00:15:25,779
大概H 中输入的N高度倍 

390
00:15:24,039 --> 00:15:27,489
这是人类输入的数字

391
00:15:25,779 --> 00:15:33,089
然后让我继续前进，然后保存 

392
00:15:27,489 --> 00:15:37,199
out文件如下out文件 好了 

393
00:15:33,089 --> 00:15:37,199
问题集3 

394
00:15:37,300 --> 00:15:42,580
tada 好吧要么真的很兴奋，要么 

395
00:15:41,140 --> 00:15:44,860
也许真的很沮丧 

396
00:15:42,580 --> 00:15:47,380
用你正确的语言吧 

397
00:15:44,860 --> 00:15:49,420
说你能解决 问题吗？ 

398
00:15:47,380 --> 00:15:51,610
我现在很容易就是 一 点点 

399
00:15:49,420 --> 00:15:52,960
不诚实，因为我也在利用 

400
00:15:51,610 --> 00:15:55,000
什么被称为图书馆 ，我们有 

401
00:15:52,960 --> 00:15:56,290
访问 这些C和我们无疑 

402
00:15:55,000 --> 00:15:59,200
可以挖得更深一些， 对 

403
00:15:56,290 --> 00:16:00,640
互联网进入其他人的可用 

404
00:15:59,200 --> 00:16:04,060
代码也许 发现 库 

405
00:16:00,640 --> 00:16:06,070
位图文件，但请注意没有 

406
00:16:04,060 --> 00:16:07,840
处理填充现在没有 

407
00:16:06,070 --> 00:16:09,790
处理数组没有交易 

408
00:16:07,840 --> 00:16:12,340
有记忆因为我正在使用右边 

409
00:16:09,790 --> 00:16:14,500
的工具的工作 ，如果我写了这 

410
00:16:12,340 --> 00:16:16,510
正确编码，让我穿过我的 

411
00:16:14,500 --> 00:16:20,050
手指，我没有做任何错别字让 

412
00:16:16,510 --> 00:16:23,170
我继续在这里给自己一份副本 

413
00:16:20,050 --> 00:16:24,910
我带来了 我这么笑脸的

414
00:16:23,170 --> 00:16:26,260
这是最后一个小小的形象 

415
00:16:24,910 --> 00:16:29,140
本周让我继续 前进， 在 打开 该 

416
00:16:26,260 --> 00:16:31,360
IDE 笑脸超 小只是几个 

417
00:16:29,140 --> 00:16:33,370
像素那里，现在让我继续前进 ， 

418
00:16:31,360 --> 00:16:33,790
运行Python ， 我们会在一个 

419
00:16:33,370 --> 00:16:35,620
时刻

420
00:16:33,790 --> 00:16:38,770
调整大小让我们增加一个因素 

421
00:16:35,620 --> 00:16:42,070
10增加笑脸，并调用它 

422
00:16:38,770 --> 00:16:45,220
BMP 现在让我继续 开放 点 

423
00:16:42,070 --> 00:16:47,950
BMP 和瞧它确实似乎有效 

424
00:16:45,220 --> 00:16:50,500
好吧 没有时髦的颜色也不奇怪 

425
00:16:47,950 --> 00:16:50,980
尺寸没有填充没有填充所有

426
00:16:50,500 --> 00:16:53,620
事

427
00:16:50,980 --> 00:16:55,690
它只是现在Python 所以你可能 

428
00:16:53,620 --> 00:16:57,340
收集一些正在发生的 逻辑 

429
00:16:55,690 --> 00:16:59,650
在这里， 但其中一些 当然应该和 

430
00:16:57,340 --> 00:17:01,450
可能看起来很神奇 所以让我们使用 

431
00:16:59,650 --> 00:17:03,010
今天要 分开和欣赏 

432
00:17:01,450 --> 00:17:05,050
不仅仅是你可以用另一个做什么 

433
00:17:03,010 --> 00:17:06,250
像 Python这样的语言， 但它是如何的 

434
00:17:05,050 --> 00:17:09,100
相似和 不同，如何 

435
00:17:06,250 --> 00:17:11,320
实际上建立在 像C 这样的东西上 

436
00:17:09,100 --> 00:17:12,700
让我们做一些比较， 所以第一

437
00:17:11,320 --> 00:17:13,780
我们可以看到它 不是一个巨大的 

438
00:17:12,700 --> 00:17:16,510
拉伸介绍另一个

439
00:17:13,780 --> 00:17:17,890
语言 如此迅速如此记得， 在 

440
00:17:16,510 --> 00:17:18,910
如果我们想设置一个变量，请抓一点

441
00:17:17,890 --> 00:17:20,589
喜欢反对 零 

442
00:17:18,910 --> 00:17:23,290
你可以简单地做这样的事情

443
00:17:20,589 --> 00:17:24,430
在C我们左边 设置它等于零 

444
00:17:23,290 --> 00:17:26,410
将 在这里 做同样的 事情在 

445
00:17:24,430 --> 00:17:28,000
在JavaScript中，这反而看起来 

446
00:17:26,410 --> 00:17:30,880
我们做 了 什么有点不同

447
00:17:28,000 --> 00:17:33,250
JavaScript 是的，我们使用let代替 

448
00:17:30,880 --> 00:17:34,720
因为我们没有明确指定

449
00:17:33,250 --> 00:17:36,520
类型，但我们需要告诉 计算机 

450
00:17:34,720 --> 00:17:40,410
让我把这个变量叫做 

451
00:17:36,520 --> 00:17:43,240
Python中的计数器就是这样 

452
00:17:40,410 --> 00:17:45,520
所以我们仍然摆脱了这种类型 

453
00:17:43,240 --> 00:17:47,650
我们已经摆脱了任何关于 let的 提及 

454
00:17:45,520 --> 00:17:51,010
或另一个关键字，我们已经摆脱 

455
00:17:47,650 --> 00:17:53,440
或许最令人欣慰的

456
00:17:51,010 --> 00:17:55,390
分号不再是分号 

457
00:17:53,440 --> 00:17:56,650
在路上没有更多的花括号

458
00:17:55,390 --> 00:17:59,260
你到目前为止见过它们

459
00:17:56,650 --> 00:18:00,700
这就是C JavaScript，现在是Python 

460
00:17:59,260 --> 00:18:02,380
那么这样的 事情呢？ 

461
00:18:00,700 --> 00:18:04,000
如果你想 增加一个 

462
00:18:02,380 --> 00:18:06,190
一个人反击， 你会使用一个块 

463
00:18:04,000 --> 00:18:08,200
像在 C，我们会 做同样的 

464
00:18:06,190 --> 00:18:13,300
JavaScript中的代码就在 这里 

465
00:18:08,200 --> 00:18:14,770
它在右边看起来有什么不同 

466
00:18:13,300 --> 00:18:16,450
你可能没有案件 

467
00:18:14,770 --> 00:18:18,220
尚未有机会 使用它但是 

468
00:18:16,450 --> 00:18:20,680
其中一种启示 

469
00:18:18,220 --> 00:18:23,380
JavaScript也是JavaScript 

470
00:18:20,680 --> 00:18:25,990
尽管如此，这是完全相同的 

471
00:18:23,380 --> 00:18:27,580
是Python 所以它几乎相同但是 

472
00:18:25,990 --> 00:18:29,980
我已经摆脱 了分号， 但是 

473
00:18:27,580 --> 00:18:31,600
逻辑是完全相同的设置计数器 

474
00:18:29,980 --> 00:18:33,790
左 等于不管它是在 

475
00:18:31,600 --> 00:18:37,470
正确加上一个额外的价值 

476
00:18:33,790 --> 00:18:39,400
关于这个在C中有什么影响 

477
00:18:37,470 --> 00:18:41,020
递增变量所以这是

478
00:18:39,400 --> 00:18:43,390
完全一样，这是一个很好的 

479
00:18:41,020 --> 00:18:44,950
做反击的速记符号 

480
00:18:43,390 --> 00:18:46,420
等于计数器再加上一个 得到的 

481
00:18:44,950 --> 00:18:48,700
打字有点单调乏味 

482
00:18:46,420 --> 00:18:50,590
JavaScript中的语法相同，你可以 

483
00:18:48,700 --> 00:18:53,520
可能在Python中猜测它会发生什么 

484
00:18:50,590 --> 00:18:55,330
看起来 像 减去 相同的 东西 

485
00:18:53,520 --> 00:18:56,980
分号可以，所以非常好 

486
00:18:55,330 --> 00:18:58,480
到目前为止，语言只保留 

487
00:18:56,980 --> 00:19:00,610
如果你愿意，可以修剪和修剪

488
00:18:58,480 --> 00:19:02,650
在C回忆我们可以做的加分 

489
00:19:00,610 --> 00:19:04,780
加上这是另一个技巧 

490
00:19:02,650 --> 00:19:06,970
自动化 相同的流程javascript 

491
00:19:04,780 --> 00:19:08,680
允许相同的，如果你真的 

492
00:19:06,970 --> 00:19:10,630
像这样的语法， 我无法告诉你 一个 

493
00:19:08,680 --> 00:19:12,220
用于Python的幻灯片不存在 不行 

494
00:19:10,630 --> 00:19:14,410
更长时间加上加号所以我们付了一个 

495
00:19:12,220 --> 00:19:15,850
价格的Python 的作者没有 

496
00:19:14,410 --> 00:19:17,440
用语言包括这个但是那个 

497
00:19:15,850 --> 00:19:19,510
好吧，我们至少有这个 

498
00:19:17,440 --> 00:19:21,550
不太可怕，所以我们还有什么看 

499
00:19:19,510 --> 00:19:24,190
在最后一次像这样的条件 

500
00:19:21,550 --> 00:19:26,170
比较X是否小于Y和C 

501
00:19:24,190 --> 00:19:29,200
看起来在JavaScript中看起来像这样 

502
00:19:26,170 --> 00:19:33,810
就像在Python中看起来一样 

503
00:19:29,200 --> 00:19:36,790
这样的花括号就这样消失了 

504
00:19:33,810 --> 00:19:39,010
添加的是 冒号，你看 不到 

505
00:19:36,790 --> 00:19:41,080
但是缩进是否会发生 

506
00:19:39,010 --> 00:19:43,420
重要的，所以任你是 一个 

507
00:19:41,080 --> 00:19:45,430
风格50和 小的快速和 松散 

508
00:19:43,420 --> 00:19:46,870
就像我们已经看到了它办公时间所有的 

509
00:19:45,430 --> 00:19:47,980
你的代码然而你的代码很多 

510
00:19:46,870 --> 00:19:49,690
因任何原因而写的都是 

511
00:19:47,980 --> 00:19:51,760
在左边对齐，什么都没有 

512
00:19:49,690 --> 00:19:53,290
实际上缩进现在蟒蛇不去了 

513
00:19:51,760 --> 00:19:55,600
容忍Python需要 

514
00:19:53,290 --> 00:19:57,190
逻辑缩进，所以这是 

515
00:19:55,600 --> 00:19:59,470
实际上是一个风格的特征 

516
00:19:57,190 --> 00:20:01,600
它强迫你 采用 语言 

517
00:19:59,470 --> 00:20:03,610
因为代码的视觉风格习惯

518
00:20:01,600 --> 00:20:04,870
如果你没有缩进，就不会运行

519
00:20:03,610 --> 00:20:06,610
它适当的任何 

520
00:20:04,870 --> 00:20:08,890
如果X 小于Y ，那就会发生 

521
00:20:06,610 --> 00:20:10,750
需要缩进说 四个 空格 

522
00:20:08,890 --> 00:20:12,640
在那下面： 

523
00:20:10,750 --> 00:20:14,230
我们在 C 或中 看到了什么？ 

524
00:20:12,640 --> 00:20:16,090
我们有 这个块 四个ifs和 

525
00:20:14,230 --> 00:20:18,460
别人的和C，它看起来像这样 

526
00:20:16,090 --> 00:20:21,010
JavaScript 在Python中看起来像这样 

527
00:20:18,460 --> 00:20:22,930
尽管如此， 它看起来会像这样 

528
00:20:21,010 --> 00:20:24,910
每个冒号 下面的缩进

529
00:20:22,930 --> 00:20:27,670
当我们 有三路 时，这怎么样？ 

530
00:20:24,910 --> 00:20:29,710
如果别的岔路 ，如果别人 用 C它 

531
00:20:27,670 --> 00:20:32,920
像这样的JavaScript 看着 

532
00:20:29,710 --> 00:20:35,200
Python中的相同内容看起来有点时髦 

533
00:20:32,920 --> 00:20:37,300
如果放三个就会看起来像这样 

534
00:20:35,200 --> 00:20:39,309
这次冒号也是我们还有什么 

535
00:20:37,300 --> 00:20:42,190
在C中看着永远的循环 

536
00:20:39,309 --> 00:20:45,550
在JavaScript中你可以使用 

537
00:20:42,190 --> 00:20:47,710
Python中的语法几乎相同

538
00:20:45,550 --> 00:20:49,660
同样消失或增加了花括号 

539
00:20:47,710 --> 00:20:53,440
如果你 ，结肠和一点点微妙 

540
00:20:49,660 --> 00:20:55,690
注意到真假 都是正确的 

541
00:20:53,440 --> 00:20:57,700
名词，如果你将资本T资本F是 

542
00:20:55,690 --> 00:20:59,410
写 一个for循环的必要条件

543
00:20:57,700 --> 00:21:02,080
所以在刮 ，我们可以很容易说 

544
00:20:59,410 --> 00:21:03,400
重复这50次C和JavaScript是 

545
00:21:02,080 --> 00:21:06,309
有点迂腐 ，你必须这样做 

546
00:21:03,400 --> 00:21:07,660
初始化 增量 并检查两个C. 

547
00:21:06,309 --> 00:21:09,700
和JavaScript采用相同的 方法 

548
00:21:07,660 --> 00:21:12,520
虽然在JavaScript中我们当然使用 

549
00:21:09,700 --> 00:21:14,380
让而不是int Python有点 

550
00:21:12,520 --> 00:21:17,440
更简洁，虽然有点少 

551
00:21:14,380 --> 00:21:21,130
你一步一步地明确地做到这一点 

552
00:21:17,440 --> 00:21:23,650
因为我的 方式是 50 

553
00:21:21,130 --> 00:21:25,660
说开始迭代 零 计数全部 

554
00:21:23,650 --> 00:21:28,240
通往但不 包括50的方式 

555
00:21:25,660 --> 00:21:29,679
从而为您提供一系列的价值 

556
00:21:28,240 --> 00:21:32,290
这是最 可能 的一个

557
00:21:29,679 --> 00:21:34,600
到目前为止很奇怪， 但还是多一点 

558
00:21:32,290 --> 00:21:36,760
简洁地写在C中我们有这么多 

559
00:21:34,600 --> 00:21:38,740
数据类型bool char double float int 

560
00:21:36,760 --> 00:21:40,390
我们的最后一个长串

561
00:21:38,740 --> 00:21:42,040
当然来自cs50库和 

562
00:21:40,390 --> 00:21:44,050
还有其他你 可以在C中使用的 

563
00:21:42,040 --> 00:21:46,059
你可能还记得问题集3 

564
00:21:44,050 --> 00:21:47,980
或许在Python中，我们 会 做空 

565
00:21:46,059 --> 00:21:49,480
这个列表至少最初只是为了 

566
00:21:47,980 --> 00:21:51,790
我们将在Python中使用这些数据类型 

567
00:21:49,480 --> 00:21:54,400
对于真/假浮标有多头

568
00:21:51,790 --> 00:21:56,890
实数intz为整数然后 

569
00:21:54,400 --> 00:21:59,080
Strings的搅拌器只是一点点 

570
00:21:56,890 --> 00:22:00,880
简洁， 但确实存在 搅拌 

571
00:21:59,080 --> 00:22:03,670
在Python中 它是 一个真实的东西， 它不是一个 

572
00:22:00,880 --> 00:22:05,440
cs50 另外还有其他数据类型 

573
00:22:03,670 --> 00:22:07,300
实际上这就是Python附带的 

574
00:22:05,440 --> 00:22:08,740
语言变得强大的地方 

575
00:22:07,300 --> 00:22:11,620
你们谁从Java 来了 

576
00:22:08,740 --> 00:22:13,090
背景或C ++那些 是 子集 

577
00:22:11,620 --> 00:22:14,890
在你面前编程的你 

578
00:22:13,090 --> 00:22:16,480
比较有特色的Python 一样 

579
00:22:14,890 --> 00:22:18,650
你用我们的 其他 语言 做的 

580
00:22:16,480 --> 00:22:20,690
没有在C 和 

581
00:22:18,650 --> 00:22:23,300
Python你有字典或哈希 

582
00:22:20,690 --> 00:22:25,640
您有 列表的表是数组 

583
00:22:23,300 --> 00:22:27,200
但这可以自动调整你的大小 

584
00:22:25,640 --> 00:22:29,330
不必事先决定多大 

585
00:22:27,200 --> 00:22:31,940
或者它们是 我们刚刚看到它的范围 

586
00:22:29,330 --> 00:22:33,530
像 他们 的50 设置在一个范围内的值的

587
00:22:31,940 --> 00:22:35,690
数学意义上它是一个集合 

588
00:22:33,530 --> 00:22:37,940
确保你没有的东西 

589
00:22:35,690 --> 00:22:39,980
然后在该集合中 重复 

590
00:22:37,940 --> 00:22:41,840
元组是一个事物的组合样 

591
00:22:39,980 --> 00:22:44,120
当你有X逗号Y时，喜欢数学 

592
00:22:41,840 --> 00:22:45,920
或任何时候你的纬度逗号经度

593
00:22:44,120 --> 00:22:48,170
有成对或三倍或更多的东西 

594
00:22:45,920 --> 00:22:50,240
那些被称为元组， 那些是 

595
00:22:48,170 --> 00:22:52,880
常见于数学课程和高级课程 

596
00:22:50,240 --> 00:22:54,650
CS 理论课也是如此，但我们确实给出了 

597
00:22:52,880 --> 00:22:57,080
你至少 在这第一个 星期 我们 

598
00:22:54,650 --> 00:22:59,390
从cs50看Python 的 一些功能 

599
00:22:57,080 --> 00:23:01,880
其中get float get int得到 

600
00:22:59,390 --> 00:23:03,320
表现完全像 他们的字符串

601
00:23:01,880 --> 00:23:05,150
SI同行， 这只是进展 

602
00:23:03,320 --> 00:23:07,550
让我们 开始编写 代码 

603
00:23:05,150 --> 00:23:09,770
让人想起我们最后几个人做了什么 

604
00:23:07,550 --> 00:23:11,390
几周， 但让我们考虑一下 会发生 什么 

605
00:23:09,770 --> 00:23:14,270
我们即将开始写作时改变 

606
00:23:11,390 --> 00:23:16,040
你想要的 时候我们自己的C程序 

607
00:23:14,270 --> 00:23:18,530
使用CS50库，您当然 

608
00:23:16,040 --> 00:23:20,210
包含其语法的头文件

609
00:23:18,530 --> 00:23:21,470
要改变Python ，以便 

610
00:23:20,210 --> 00:23:23,960
这个第一周你想要使用的 

611
00:23:21,470 --> 00:23:27,320
cs50库， 你要改为说 

612
00:23:23,960 --> 00:23:29,150
从cs50导入然后是逗号 

613
00:23:27,320 --> 00:23:31,520
功能分隔的列表， 你 

614
00:23:29,150 --> 00:23:33,170
想要导入或使用你的代码 

615
00:23:31,520 --> 00:23:35,000
它的 语法 更精确一点 

616
00:23:33,170 --> 00:23:36,770
这不是说给 我一切 给予 

617
00:23:35,000 --> 00:23:38,810
我这个和另一 件事， 如果 

618
00:23:36,770 --> 00:23:40,730
要使用一个或多个 你可以 

619
00:23:38,810 --> 00:23:42,080
用逗号分隔它们作为旁边 

620
00:23:40,730 --> 00:23:43,490
尤其是那些看过Python的人 

621
00:23:42,080 --> 00:23:45,920
之前有其他 方法 可以做到这一点 

622
00:23:43,490 --> 00:23:47,390
这有很多方法 

623
00:23:45,920 --> 00:23:49,250
也许是我们最相似的 

624
00:23:47,390 --> 00:23:51,890
今天的目的你还有什么其他的目的

625
00:23:49,250 --> 00:23:54,230
必须在C中知道你必须编译 

626
00:23:51,890 --> 00:23:56,120
你的代码和clang一样 

627
00:23:54,230 --> 00:23:58,280
这个然后你运行你的程序

628
00:23:56,120 --> 00:23:59,930
点斜线你好或更 简单地你做了 

629
00:23:58,280 --> 00:24:01,430
打招呼然后 我们弄明白了 

630
00:23:59,930 --> 00:24:03,980
在IDE或IDE中为您命令

631
00:24:01,430 --> 00:24:06,080
你将会使用Python中的沙盒或实验室

632
00:24:03,980 --> 00:24:07,430
您可以在需要时跳过编译步骤 

633
00:24:06,080 --> 00:24:09,560
用 Python运行一个程序 你要去 

634
00:24:07,430 --> 00:24:11,240
做你刚才做的 事情 

635
00:24:09,560 --> 00:24:13,670
只是要 运行该命令Python和 

636
00:24:11,240 --> 00:24:15,830
那么 ， 你想要 的文件 的 名称 

637
00:24:13,670 --> 00:24:18,500
运行 ， 这样做 的原因 是因为 

638
00:24:15,830 --> 00:24:20,810
跟随 C召回的世界我们 

639
00:24:18,500 --> 00:24:23,680
有这种管道的过程，其中 的 

640
00:24:20,810 --> 00:24:26,060
我们有源代码作为 输入和 

641
00:24:23,680 --> 00:24:30,110
那么我们想 赶快 点 

642
00:24:26,060 --> 00:24:31,970
机器代码为零和一个 什么 

643
00:24:30,110 --> 00:24:32,480
站在源代码和。之间

644
00:24:31,970 --> 00:24:36,950
机

645
00:24:32,480 --> 00:24:38,930
只是为了清楚什么过程是的 

646
00:24:36,950 --> 00:24:40,970
编译所以我们有一个编译器

647
00:24:38,930 --> 00:24:43,520
中间人的目的是生命

648
00:24:40,970 --> 00:24:45,500
将一种语言翻译成的定义

649
00:24:43,520 --> 00:24:47,570
另一个 碰巧是像英国人一样 

650
00:24:45,500 --> 00:24:48,950
计算机语言，但语言 

651
00:24:47,570 --> 00:24:50,870
编译器是一个总称，只是 

652
00:24:48,950 --> 00:24:53,750
将一件事转换成另一件事等等 

653
00:24:50,870 --> 00:24:55,130
这条管道对 C 这个样子和 

654
00:24:53,750 --> 00:24:57,350
这就是为什么你必须运行clang 

655
00:24:55,130 --> 00:24:59,180
明确或让你不得不诱导 

656
00:24:57,350 --> 00:25:00,410
那个中间人操作转换了 

657
00:24:59,180 --> 00:25:03,410
语言到计算机的东西 

658
00:25:00,410 --> 00:25:06,260
了解Python和其他语言 

659
00:25:03,410 --> 00:25:07,760
通常不会 编译 相同的 

660
00:25:06,260 --> 00:25:10,490
一般说他们的方式

661
00:25:07,760 --> 00:25:12,050
解释，你不编译

662
00:25:10,490 --> 00:25:14,660
他们分成0和1 然后运行 

663
00:25:12,050 --> 00:25:16,280
您改为 运行 程序的程序 

664
00:25:14,660 --> 00:25:19,220
其他人写的叫做Python 

665
00:25:16,280 --> 00:25:21,050
根据定义，该计划是一个 

666
00:25:19,220 --> 00:25:22,670
口译员和口译员 

667
00:25:21,050 --> 00:25:24,740
生活中的目的就是这个词所暗示的 

668
00:25:22,670 --> 00:25:26,720
从上到下阅读你的代码 

669
00:25:24,740 --> 00:25:29,420
是的，只是做你所说的 

670
00:25:26,720 --> 00:25:32,060
它 通过一步一步 做一步 ，而不 

671
00:25:29,420 --> 00:25:33,770
做转换的前期工作 

672
00:25:32,060 --> 00:25:35,600
事物归于零和人类 

673
00:25:33,770 --> 00:25:37,490
世界，如果我说英语和某人 

674
00:25:35,600 --> 00:25:38,810
那里讲西班牙语，我们不会说话

675
00:25:37,490 --> 00:25:40,460
彼此的语言我们可能会提出一个

676
00:25:38,810 --> 00:25:42,290
我们之间的第三人显然是一个 

677
00:25:40,460 --> 00:25:42,950
人类翻译的作用 非常大 

678
00:25:42,290 --> 00:25:44,690
类似 

679
00:25:42,950 --> 00:25:45,920
解释听我的话，然后 

680
00:25:44,690 --> 00:25:47,330
将其转化为某种东西 

681
00:25:45,920 --> 00:25:49,100
电脑理解，但它没有得到 

682
00:25:47,330 --> 00:25:51,230
变成零和 它只是来自 

683
00:25:49,100 --> 00:25:53,000
一个直接到另一个所以 

684
00:25:51,230 --> 00:25:54,290
Python中的区别在于你 

685
00:25:53,000 --> 00:25:56,290
还是要编写源代码 

686
00:25:54,290 --> 00:25:59,270
就像我很快为调整大小做的那样 

687
00:25:56,290 --> 00:26:03,550
最终我们想要真正得到它 

688
00:25:59,270 --> 00:26:06,890
为程序 调用了一个 翻译 ， 

689
00:26:03,550 --> 00:26:10,010
所以这一步理想上就是 这样 

690
00:26:06,890 --> 00:26:11,930
但作为一个旁边的Python 是一个漂亮的 

691
00:26:10,010 --> 00:26:13,790
复杂的语言，即使 

692
00:26:11,930 --> 00:26:16,160
我们很高兴能够运行它 

693
00:26:13,790 --> 00:26:19,310
一个步骤 ， 而不是 这两个步骤 

694
00:26:16,160 --> 00:26:21,800
实际上还有一些魔法 

695
00:26:19,310 --> 00:26:23,990
怎么回事 引擎盖 下 ，为 

696
00:26:21,800 --> 00:26:26,360
好奇有 实际上是 

697
00:26:23,990 --> 00:26:28,370
编译器 构建的 性能 原因 

698
00:26:26,360 --> 00:26:30,860
到实际 将其转换为Python的Python 

699
00:26:28,370 --> 00:26:32,920
中介称为 字节码 

700
00:26:30,860 --> 00:26:35,390
和字节代码实际上是什么

701
00:26:32,920 --> 00:26:38,390
解释，所以这就是 Python的 原因 

702
00:26:35,390 --> 00:26:40,100
虽然可能比C慢

703
00:26:38,390 --> 00:26:42,230
某些任务，因为你不去 

704
00:26:40,100 --> 00:26:43,670
低级别的 零和一能 

705
00:26:42,230 --> 00:26:45,410
实际 业务中使用

706
00:26:43,670 --> 00:26:46,279
应用程序和热门网站和

707
00:26:45,410 --> 00:26:48,830
这样的

708
00:26:46,279 --> 00:26:51,379
真的很好 ，所以它可以 

709
00:26:48,830 --> 00:26:53,779
表现也很好，但 更多 

710
00:26:51,379 --> 00:26:55,580
有点 说， 所以 说 

711
00:26:53,779 --> 00:26:57,919
如果这是差异不是

712
00:26:55,580 --> 00:26:59,359
只在语法上而且在机械上

713
00:26:57,919 --> 00:27:01,729
让我们继续，然后写一个 

714
00:26:59,359 --> 00:27:04,279
程序让我继续前进 

715
00:27:01,729 --> 00:27:05,479
在IDE 让我 从 接近我们的例子 

716
00:27:04,279 --> 00:27:07,099
之前和让我们开始更简单 

717
00:27:05,479 --> 00:27:07,489
因为调整大小是一口气 

718
00:27:07,099 --> 00:27:08,690
一旦

719
00:27:07,489 --> 00:27:11,869
让我继续创建一个名为的文件 

720
00:27:08,690 --> 00:27:13,820
你好dot pi而不是写这个 

721
00:27:11,869 --> 00:27:16,129
程序用 C让我继续前进 ，只是 

722
00:27:13,820 --> 00:27:20,450
写的 Hello World 让我们继续前进 ， 

723
00:27:16,129 --> 00:27:22,609
做这个 打印你好世界 做的那是我的 

724
00:27:20,450 --> 00:27:24,349
Python中的第一个程序，真的是我的 

725
00:27:22,609 --> 00:27:26,690
Python中的第一个程序不是那种 

726
00:27:24,349 --> 00:27:29,809
因为调整大小而出来摆动

727
00:27:26,690 --> 00:27:33,559
不存在这个文件，这 是在 

728
00:27:29,809 --> 00:27:35,570
像hello dot C这样的 东西 没有 

729
00:27:33,559 --> 00:27:39,589
这里需要的主要功能还有什么

730
00:27:35,570 --> 00:27:40,969
缺少那里没有提到printf 

731
00:27:39,589 --> 00:27:43,399
相反，打印 是一点点 

732
00:27:40,969 --> 00:27:45,289
更加 人性化 ，没有提及 

733
00:27:43,399 --> 00:27:47,210
头文件或库的顶部

734
00:27:45,289 --> 00:27:51,409
我 正好潜入的文件

735
00:27:47,210 --> 00:27:57,049
并得到它是啊没有分号是什么 

736
00:27:51,409 --> 00:27:59,840
别的，还有什么 

737
00:27:57,049 --> 00:28:01,940
没有反斜杠-n 我 可能没有运行它 

738
00:27:59,840 --> 00:28:03,320
，但是我想我会得到 免费 

739
00:28:01,940 --> 00:28:06,549
这次用Python我不一定要 

740
00:28:03,320 --> 00:28:06,549
如此明确的是另一只手在这里

741
00:28:07,600 --> 00:28:11,590
printf中有没有F的 东西 

742
00:28:10,909 --> 00:28:14,989
其他 

743
00:28:11,590 --> 00:28:16,759
没有，是的，没有缩进 

744
00:28:14,989 --> 00:28:18,350
虽然公平， 但只有一条线 

745
00:28:16,759 --> 00:28:19,220
但是没有缩进是公平的 

746
00:28:18,350 --> 00:28:21,169
这很公平 

747
00:28:19,220 --> 00:28:22,820
那里也没有花括号

748
00:28:21,169 --> 00:28:25,159
没有提到intz没有提到

749
00:28:22,820 --> 00:28:27,529
我的意思是我的上帝， 为什么不是我们 

750
00:28:25,159 --> 00:28:29,929
这是最后一次，所以这是 

751
00:28:27,529 --> 00:28:32,539
为什么语言进化了人们 意识到 

752
00:28:29,929 --> 00:28:33,919
年前喜欢 GC作为服务好 了 

753
00:28:32,539 --> 00:28:36,080
字体如何理解指针和

754
00:28:33,919 --> 00:28:37,429
语法好吧我得到了 它但是我的上帝了 

755
00:28:36,080 --> 00:28:39,019
甚至连 写作 也 都很乏味 

756
00:28:37,429 --> 00:28:42,080
最简单的程序因为我必须这样做 

757
00:28:39,019 --> 00:28:44,179
hash包括标准的IOH int main 

758
00:28:42,080 --> 00:28:45,529
我的意思是所有 这些句法 

759
00:28:44,179 --> 00:28:47,149
阻碍的开销

760
00:28:45,529 --> 00:28:48,919
你只是 做你关心的工作 

761
00:28:47,149 --> 00:28:51,769
这里最简单的形式就是这样

762
00:28:48,919 --> 00:28:54,169
打印HelloWorld 所以 Python 和很多 

763
00:28:51,769 --> 00:28:56,989
其中更现代的语言Ruby 

764
00:28:54,169 --> 00:28:58,460
而PHP 和其他人只是摆脱了很多 

765
00:28:56,989 --> 00:29:00,710
这个开销让你可以 

766
00:28:58,460 --> 00:29:03,109
马上 开始 工作更快 

767
00:29:00,710 --> 00:29:04,999
让我怎么继续前进， 在 运行 C 本 

768
00:29:03,109 --> 00:29:07,369
回想起我会像点斜线一样

769
00:29:04,999 --> 00:29:09,169
你好， 但我们 只是说了一下 

770
00:29:07,369 --> 00:29:12,559
以前这不是正确的方法怎么做 

771
00:29:09,169 --> 00:29:14,059
我去运行这个程序是的，所以我跑了 

772
00:29:12,559 --> 00:29:16,580
字面意思是一个程序 

773
00:29:14,059 --> 00:29:18,200
巧合地称之为Python本身

774
00:29:16,580 --> 00:29:19,190
是那个人 的翻译 

775
00:29:18,200 --> 00:29:21,200
我和我之间的中间

776
00:29:19,190 --> 00:29:23,600
讲西班牙语的朋友，只是 有 

777
00:29:21,200 --> 00:29:26,389
将hello dot PI转换成任何东西 

778
00:29:23,600 --> 00:29:28,070
计算机本身也能理解

779
00:29:26,389 --> 00:29:30,409
确实 我们有你好的世界和 

780
00:29:28,070 --> 00:29:32,330
你注意到我没有反斜杠

781
00:29:30,409 --> 00:29:34,580
代码，但我正在将 光标移动到 

782
00:29:32,330 --> 00:29:36,049
新行，所以Python决定 你 知道 

783
00:29:34,580 --> 00:29:38,210
拥有新东西真是太常见了 

784
00:29:36,049 --> 00:29:39,799
我们只是添加那些行，默认情况下 没有 

785
00:29:38,210 --> 00:29:41,570
我们要付出的代价就是它

786
00:29:39,799 --> 00:29:43,580
有点讨厌 摆脱他们但是 

787
00:29:41,570 --> 00:29:45,019
我们会看到，在一个 有点太使 

788
00:29:43,580 --> 00:29:46,639
只是一个权利让我们做 

789
00:29:45,019 --> 00:29:48,919
另一个 只是 最简单的一个 

790
00:29:46,639 --> 00:29:51,409
可能的程序让我们继续前进 

791
00:29:48,919 --> 00:29:54,409
说一点点发烧友 

792
00:29:51,409 --> 00:29:57,799
允许我们做一些事情 比 这 更 

793
00:29:54,409 --> 00:29:59,779
所以 让我们 继续说吧，不要比较 

794
00:29:57,799 --> 00:30:02,149
就是这样，但实际上让我们得到一些

795
00:29:59,779 --> 00:30:03,739
用户输入所以对于用户输入 有一个 

796
00:30:02,149 --> 00:30:05,090
很少有方法可以做到这一点我们会做cs50 

797
00:30:03,739 --> 00:30:06,950
最初的方式， 但这些都是训练 

798
00:30:05,090 --> 00:30:08,359
我们将在本周使用这些车轮 

799
00:30:06,950 --> 00:30:11,149
一个星期之后我们 就把它们 拿走 了 

800
00:30:08,359 --> 00:30:12,950
把我们从 C连接 到PI 

801
00:30:11,149 --> 00:30:14,899
让我继续， 把这个字符串称为0 

802
00:30:12,950 --> 00:30:17,929
PI，因为我正在 处理字符串和 

803
00:30:14,899 --> 00:30:20,240
让我继续，让我做一个 

804
00:30:17,929 --> 00:30:22,100
变量getstring 让我提示 

805
00:30:20,240 --> 00:30:23,960
人为他或她的名字这样和 

806
00:30:22,100 --> 00:30:26,330
然后让我继续 打招呼 

807
00:30:23,960 --> 00:30:28,100
某某所以 ，现在我只需要 

808
00:30:26,330 --> 00:30:30,470
考虑 如何 打印出他们的名字和 

809
00:30:28,100 --> 00:30:33,649
在 Python我其实只是做到 这一点 我 

810
00:30:30,470 --> 00:30:35,779
不需要做％s我不需要放 

811
00:30:33,649 --> 00:30:37,879
一秒或我确实需要再写第二个逗号 

812
00:30:35,779 --> 00:30:39,950
在这里，但我可以做到这一点这是 一个 

813
00:30:37,879 --> 00:30:44,029
更简单，这是不正确的 

814
00:30:39,950 --> 00:30:45,499
我不是在练习我所说的 

815
00:30:44,029 --> 00:30:48,379
去掉的 F只打印 你想要什么 

816
00:30:45,499 --> 00:30:49,669
印刷确实如此通知显然是一个 

817
00:30:48,379 --> 00:30:52,399
变量， 因为我正在分配它 

818
00:30:49,669 --> 00:30:54,110
价值从右到左 但请注意 

819
00:30:52,399 --> 00:30:55,940
我 没有指定python的类型 

820
00:30:54,110 --> 00:30:58,129
确实有类型 stur我们说的是 

821
00:30:55,940 --> 00:30:59,720
字符串等效， 但你不必 

822
00:30:58,129 --> 00:31:01,039
像 JavaScript 一样提及Python 

823
00:30:59,720 --> 00:31:02,749
即使 没有 ，也要弄明白 

824
00:31:01,039 --> 00:31:08,480
关键字像let，但我需要 添加 

825
00:31:02,749 --> 00:31:10,070
有一点是什么 ，是 的 ，是的 

826
00:31:08,480 --> 00:31:11,809
cs50的事情，我们只会去 

827
00:31:10,070 --> 00:31:13,669
使用 它 一个星期 但我确实需要 

828
00:31:11,809 --> 00:31:15,309
以语法来导入它 

829
00:31:13,669 --> 00:31:17,899
这是从cs50 库中说的 

830
00:31:15,309 --> 00:31:19,789
导入一个名为 getstring I 的函数 

831
00:31:17,899 --> 00:31:21,470
不需要再用逗号导入

832
00:31:19,789 --> 00:31:23,710
这是 该计划的面孔 

833
00:31:21,470 --> 00:31:23,710
是啊

834
00:31:30,809 --> 00:31:37,559
谢谢没有说明

835
00:31:34,710 --> 00:31:39,210
啊， 当然让我 回到 这一个 

836
00:31:37,559 --> 00:31:41,250
第二个让我们先运行这个程序 

837
00:31:39,210 --> 00:31:43,200
premon that确实做了我们的事 

838
00:31:41,250 --> 00:31:49,950
上周见过，让我 继续吧 

839
00:31:43,200 --> 00:31:52,140
在这里做这个 字符串的 python 

840
00:31:49,950 --> 00:31:53,370
零 让我继续前进， 这只是 

841
00:31:52,140 --> 00:31:55,470
等我的名字，所以我会输入 

842
00:31:53,370 --> 00:31:57,149
大卫打招呼 大卫，但你的 建议 

843
00:31:55,470 --> 00:31:59,220
如果你想翻转这个怎么办？ 

844
00:31:57,149 --> 00:32:02,990
好吧，我想说的是 

845
00:31:59,220 --> 00:32:05,520
人的名字 ，然后像 

846
00:32:02,990 --> 00:32:07,140
你好，因为 我很 高兴 看到 

847
00:32:05,520 --> 00:32:09,179
相反，让我们看看这是做什么的 

848
00:32:07,140 --> 00:32:12,450
现在 让我继续 和运行Python 

849
00:32:09,179 --> 00:32:15,000
字符串0类型在我的名字 ，它几乎 

850
00:32:12,450 --> 00:32:17,610
我认为你的意图，但有一个 

851
00:32:15,000 --> 00:32:19,350
至少这是一个美学错误 

852
00:32:17,610 --> 00:32:20,850
似乎与蟒蛇打印功能你

853
00:32:19,350 --> 00:32:22,770
不需要像占位符一样使用占位符 

854
00:32:20,850 --> 00:32:26,669
百分比，但它似乎 

855
00:32:22,770 --> 00:32:29,039
在你 之后擅自为你增添空间 

856
00:32:26,669 --> 00:32:32,100
你传递的所有东西作为输入 

857
00:32:29,039 --> 00:32:33,840
打印自己所以注意打印是 

858
00:32:32,100 --> 00:32:37,230
根据 要求采取多少论点

859
00:32:33,840 --> 00:32:43,919
这突出显示的部分有多少 

860
00:32:37,230 --> 00:32:46,860
争论你可能会推断- 是的 - 

861
00:32:43,919 --> 00:32:48,480
一个是逗号，其余的是 

862
00:32:46,860 --> 00:32:49,950
绿色突出显示的是什么 

863
00:32:48,480 --> 00:32:51,480
那里有第二个逗号，但它是

864
00:32:49,950 --> 00:32:53,760
在字符串里面， 所以我可以看到 

865
00:32:51,480 --> 00:32:55,169
这 不大不小的红鲱鱼 有 

866
00:32:53,760 --> 00:32:56,370
这里只有两个论点，但似乎

867
00:32:55,169 --> 00:32:57,600
该打印功能 ，你会 

868
00:32:56,370 --> 00:32:59,460
通过阅读该文档了解这一点 

869
00:32:57,600 --> 00:33:01,289
如果你传了两三个或更多 

870
00:32:59,460 --> 00:33:02,820
参数它打印所有这些但是 

871
00:33:01,289 --> 00:33:03,899
用一个空格分隔它们

872
00:33:02,820 --> 00:33:05,730
这不太对，所以这 是 

873
00:33:03,899 --> 00:33:07,470
实际上 清洁的 动力很大 

874
00:33:05,730 --> 00:33:09,779
如果我想要 真正提高 ， 那就这样做 

875
00:33:07,470 --> 00:33:11,940
这个程序并整理 一下 

876
00:33:09,779 --> 00:33:14,220
让我这样一个版本在这里 让 

877
00:33:11,940 --> 00:33:16,679
我创建另一个名为say string的文件 

878
00:33:14,220 --> 00:33:18,779
一个点pi 让我从我们开始的地方开始 

879
00:33:16,679 --> 00:33:21,090
在刚才 ，让我实际 使用 

880
00:33:18,779 --> 00:33:23,970
一个类似于C的占位符，如果我愿意的话 

881
00:33:21,090 --> 00:33:27,270
比如你好 ，所以它转过来了 

882
00:33:23,970 --> 00:33:30,539
实际上你可以说嘿 Python放了 

883
00:33:27,270 --> 00:33:34,200
但是，这里有一个名为s的变量

884
00:33:30,539 --> 00:33:36,419
如果我按原样运行 它们仍然会 

885
00:33:34,200 --> 00:33:37,909
这是一个尚未完全解决的错误 

886
00:33:36,419 --> 00:33:40,380
当我现在点击进入并 输入我的名字 

887
00:33:37,909 --> 00:33:43,230
好吧， 这显然是 愚蠢的 

888
00:33:40,380 --> 00:33:45,480
所以我似乎需要告诉Python 

889
00:33:43,230 --> 00:33:48,149
我正在 传递的 这个字符串 

890
00:33:45,480 --> 00:33:48,480
你好逗号，所以是格式化的

891
00:33:48,149 --> 00:33:50,160
串

892
00:33:48,480 --> 00:33:52,380
这是一个占位符流 ，它应该 

893
00:33:50,160 --> 00:33:54,450
做一些改变，这是 一个 

894
00:33:52,380 --> 00:33:56,400
在语法上 有点奇怪的神秘 感 

895
00:33:54,450 --> 00:34:00,299
Python， 但你在Python中这样做的方式 

896
00:33:56,400 --> 00:34:02,880
你 在字符串本身 之前放了一个F. 

897
00:34:00,299 --> 00:34:04,710
所以我很抱歉我们应该摆脱它 

898
00:34:02,880 --> 00:34:06,390
F片刻，所以你刚才叫它 

899
00:34:04,710 --> 00:34:08,460
打印然后我们重复使用不同的F 

900
00:34:06,390 --> 00:34:10,020
在这里， 它的 呆头呆脑 的语法 

901
00:34:08,460 --> 00:34:12,359
诚然， 但这只是 意味着嘿 

902
00:34:10,020 --> 00:34:13,560
python 以下双引号或 

903
00:34:12,359 --> 00:34:15,899
您将要 看到的 单引号 

904
00:34:13,560 --> 00:34:17,399
应该由您 特殊 格式化 

905
00:34:15,899 --> 00:34:19,230
方式，它实际上是在 

906
00:34:17,399 --> 00:34:21,330
尽管如此， 字符串的开头

907
00:34:19,230 --> 00:34:23,369
确实看起来很奇怪， 但如果 我现在 

908
00:34:21,330 --> 00:34:25,889
重新运行此Python字符串 并键入 

909
00:34:23,369 --> 00:34:27,810
我现在的 名字 现在它取代了 

910
00:34:25,889 --> 00:34:30,090
这样我就可以甩掉它周围的逻辑 多少 

911
00:34:27,810 --> 00:34:30,869
现在更灵活，做一些事情

912
00:34:30,090 --> 00:34:32,850
你好 

913
00:34:30,869 --> 00:34:35,340
因为现在我传递了 一个论点 

914
00:34:32,850 --> 00:34:36,990
那个印刷品会为我格式化，所以当 我 

915
00:34:35,340 --> 00:34:39,270
现在输入我的名字，我不会 得到 

916
00:34:36,990 --> 00:34:41,369
多余的空间，现在我有

917
00:34:39,270 --> 00:34:43,590
以上的格式完全控制

918
00:34:41,369 --> 00:34:45,450
字符串 所以你知道对不起一两个 

919
00:34:43,590 --> 00:34:47,280
前进脚步退一步 也许和 

920
00:34:45,450 --> 00:34:48,929
战术但它确实让我们 做 

921
00:34:47,280 --> 00:34:51,030
我们希望我们做什么， 我们可以写 

922
00:34:48,929 --> 00:34:52,859
使用int和float的同一程序 

923
00:34:51,030 --> 00:34:54,359
get int和get float看起来完全一样

924
00:34:52,859 --> 00:34:56,399
同样你 不需要担心 

925
00:34:54,359 --> 00:34:58,170
％s 与 百分比I对比 

926
00:34:56,399 --> 00:35:00,530
F你只需输入 变量即可 

927
00:34:58,170 --> 00:35:03,240
这些花括号 里面 的 名字 

928
00:35:00,530 --> 00:35:05,730
好吧让我 继续做一些 

929
00:35:03,240 --> 00:35:07,080
快速数学 让我继续 这样做 

930
00:35:05,730 --> 00:35:09,540
让我继续 创建 一个 新文件 

931
00:35:07,080 --> 00:35:12,060
我们称之为 停止 我 的整数 

932
00:35:09,540 --> 00:35:16,560
让我继续前进并获得此访问权限 

933
00:35:12,060 --> 00:35:19,020
如何将cs50 库的get int 

934
00:35:16,560 --> 00:35:19,770
然后 存在的方法或功能

935
00:35:19,020 --> 00:35:21,480
我继续并声明一个变量 

936
00:35:19,770 --> 00:35:23,790
调用X并从用户获取一个int 

937
00:35:21,480 --> 00:35:25,050
然后只是提示他或她的X. 

938
00:35:23,790 --> 00:35:27,420
让我继续做同样的事情 

939
00:35:25,050 --> 00:35:29,100
并且也从他们那里得到Y. 

940
00:35:27,420 --> 00:35:31,040
然后在这里让我做一些 

941
00:35:29,100 --> 00:35:34,320
简单的数学，我们 这样做了回来 

942
00:35:31,040 --> 00:35:36,920
第一周通过印刷如下 让我 

943
00:35:34,320 --> 00:35:39,600
继续打印出X加y 

944
00:35:36,920 --> 00:35:42,240
等于，这就是现在的酷

945
00:35:39,600 --> 00:35:46,109
这个花括号功能你可以 

946
00:35:42,240 --> 00:35:47,790
实际上不只是变量名称而是 

947
00:35:46,109 --> 00:35:49,890
你可以在那里做简单的操作 

948
00:35:47,790 --> 00:35:52,050
我也可以在里面做数学 

949
00:35:49,890 --> 00:35:53,940
这些花括号和打印出 

950
00:35:52,050 --> 00:35:55,200
值，但 当然这本身就是 

951
00:35:53,940 --> 00:35:57,660
要字面打印花括号 

952
00:35:55,200 --> 00:35:59,670
我有什么要添加的，所以它看起来像 

953
00:35:57,660 --> 00:36:01,440
有点奇怪，但现在这将解决 

954
00:35:59,670 --> 00:36:02,430
这个问题它将按字面打印 X. 

955
00:36:01,440 --> 00:36:08,190
再加上你

956
00:36:02,430 --> 00:36:10,260
等于不管实际 的 总和格式 

957
00:36:08,190 --> 00:36:12,690
格式化以下字符串对我来说 很好 

958
00:36:10,260 --> 00:36:16,140
问题让我们做几个复制粘贴 

959
00:36:12,690 --> 00:36:18,390
但是在这里改变操作员f X. 

960
00:36:16,140 --> 00:36:20,910
减去我想知道这看起来是什么

961
00:36:18,390 --> 00:36:23,339
像 X说 我们上次做了 什么 

962
00:36:20,910 --> 00:36:26,790
乘以YI想要做那个数学 

963
00:36:23,339 --> 00:36:29,640
我也可以分开然后我们有 

964
00:36:26,790 --> 00:36:32,010
还有一个是模数或模块化的 

965
00:36:29,640 --> 00:36:33,839
召回的算术是％ 

966
00:36:32,010 --> 00:36:35,339
在语法上它看起来是一样的 

967
00:36:33,839 --> 00:36:36,599
我们只是添加 这个大括号 

968
00:36:35,339 --> 00:36:38,280
仅用于打印功能的表示法

969
00:36:36,599 --> 00:36:41,190
现在 让我继续 运行这个 

970
00:36:38,280 --> 00:36:46,980
停止嗨的Python，让 我继续 

971
00:36:41,190 --> 00:36:50,670
并 做一个并说 2所以 1加2 是 3 1 

972
00:36:46,980 --> 00:36:54,720
减2是负1 1倍2 是2 1 

973
00:36:50,670 --> 00:36:57,900
除以2是0.5和 1 然后除以 

974
00:36:54,720 --> 00:37:00,809
2 ， 其余的是1，所以我认为 

975
00:36:57,900 --> 00:37:02,670
这会以数学方式检出， 但是 你 

976
00:37:00,809 --> 00:37:05,150
其中一个应该有点惊讶 

977
00:37:02,670 --> 00:37:05,150
这些结果

978
00:37:05,329 --> 00:37:12,960
再说一遍，我得到了漂浮 

979
00:37:09,900 --> 00:37:15,750
Python本身似乎修复了一个bug 

980
00:37:12,960 --> 00:37:18,180
在 C本身 ，当你在C中发生了什么 

981
00:37:15,750 --> 00:37:21,690
将一个 整数除以2整数 

982
00:37:18,180 --> 00:37:22,920
在C中你会得到另一个整数 

983
00:37:21,690 --> 00:37:24,089
什么是你能得到的最接近的整数

984
00:37:22,920 --> 00:37:27,510
表示没有小数 

985
00:37:24,089 --> 00:37:28,920
点 零，因为 PI C会 

986
00:37:27,510 --> 00:37:31,470
截断小数后的所有内容

987
00:37:28,920 --> 00:37:33,150
但是Python似乎解决了这个问题 

988
00:37:31,470 --> 00:37:34,799
问题，这 实际上有点 

989
00:37:33,150 --> 00:37:36,270
最近的现象， 这是一个巨大的现象

990
00:37:34,799 --> 00:37:38,430
宗教辩论至于是否或不 

991
00:37:36,270 --> 00:37:41,280
你应该保持历史 

992
00:37:38,430 --> 00:37:43,020
分区的定义是楼层 

993
00:37:41,280 --> 00:37:44,700
可以这么说或者我们应该做一个 

994
00:37:43,020 --> 00:37:45,720
真正的分裂就像我们都长大了一样

995
00:37:44,700 --> 00:37:47,670
在学校学习 

996
00:37:45,720 --> 00:37:50,099
Python 采用后一种方法制作 

997
00:37:47,670 --> 00:37:51,690
分裂意味分裂真正 分裂 

998
00:37:50,099 --> 00:37:53,819
如果你划分2英寸，你会回来 

999
00:37:51,690 --> 00:37:55,170
浮动当然这是一个 问题，如果 

1000
00:37:53,819 --> 00:37:57,000
人们想要 编写 假设的 代码 

1001
00:37:55,170 --> 00:37:59,579
它会被 截断 

1002
00:37:57,000 --> 00:38:01,049
实际上是一个强大的功能所以它 

1003
00:37:59,579 --> 00:38:02,940
事实证明，你不会非常糟糕 

1004
00:38:01,049 --> 00:38:04,980
很多时候使用这个但是 

1005
00:38:02,940 --> 00:38:07,099
如果 ，世界上的妥协是 好的 

1006
00:38:04,980 --> 00:38:10,170
你真的想要 的 旧行为 

1007
00:38:07,099 --> 00:38:12,869
我们将在Python中进行分割

1008
00:38:10,170 --> 00:38:13,950
对你来说你 必须 使用两个斜杠 

1009
00:38:12,869 --> 00:38:15,869
这两个步骤再一次 

1010
00:38:13,950 --> 00:38:17,460
前 进一步， 但它就在那里 

1011
00:38:15,869 --> 00:38:20,099
问题仍然可以在 同一个 亟待解决 

1012
00:38:17,460 --> 00:38:22,680
方式， 如果我保存并重新运行它 

1013
00:38:20,099 --> 00:38:25,200
相同的代码1和2，现在我回到0 

1014
00:38:22,680 --> 00:38:27,720
正如我在C中所做的那样 

1015
00:38:25,200 --> 00:38:29,460
一定的适用性 ，让我们做一个 其他 

1016
00:38:27,720 --> 00:38:31,410
示例现在涉及一些数字和

1017
00:38:29,460 --> 00:38:34,410
让我继续前进，称这个浮点数 

1018
00:38:31,410 --> 00:38:37,200
pi让我做 同样的事情 

1019
00:38:34,410 --> 00:38:38,730
这次cs50 import get float所以我可以 

1020
00:38:37,200 --> 00:38:40,619
处理浮点值让我 

1021
00:38:38,730 --> 00:38:42,599
声明变量X并 得到一个浮点数 

1022
00:38:40,619 --> 00:38:44,249
我们会要求用户输入 一个 变量X，则 

1023
00:38:42,599 --> 00:38:46,259
让我们继续前进并获得 另一个浮动 

1024
00:38:44,249 --> 00:38:47,940
就像之前称之为Y但这一次 

1025
00:38:46,259 --> 00:38:49,559
他们两个确实是漂浮然后让 

1026
00:38:47,940 --> 00:38:52,170
我继续做一些数学X加y 

1027
00:38:49,559 --> 00:38:53,849
等于Z给自己一个第三个变量

1028
00:38:52,170 --> 00:38:57,259
然后让我 继续 打印 

1029
00:38:53,849 --> 00:39:00,869
输出类似的消息 X 除以y 

1030
00:38:57,259 --> 00:39:03,269
等于Z 好了，让我继续吧 

1031
00:39:00,869 --> 00:39:07,740
并保存这个清除我的终端并做 

1032
00:39:03,269 --> 00:39:10,339
Python漂浮此时 停止PI 1/10 

1033
00:39:07,740 --> 00:39:12,720
我该死的， 我怎么解决这个问题 

1034
00:39:10,339 --> 00:39:14,849
好吧， 所以只需要简单的F就可以了 

1035
00:39:12,720 --> 00:39:19,470
格式字符串没什么大不了的，所以让我们重新运行 

1036
00:39:14,849 --> 00:39:24,499
这一个10好的 whoo-hoo那是一个新的 

1037
00:39:19,470 --> 00:39:24,499
一个在那里发生了什么

1038
00:39:29,420 --> 00:39:35,059
我确实定义了Z和 它 的 阵容 

1039
00:39:31,700 --> 00:39:36,680
是你的评论 我用X加y但是 

1040
00:39:35,059 --> 00:39:39,740
我想哦，我知道 

1041
00:39:36,680 --> 00:39:45,099
好的我很抱歉让你好，如果 

1042
00:39:39,740 --> 00:39:46,250
我们可以解决这个问题 ，让我们呃很抱歉 ， 

1043
00:39:45,099 --> 00:39:50,980
好的

1044
00:39:46,250 --> 00:39:53,290
所以110 毫米还是错的 

1045
00:39:50,980 --> 00:39:58,220
好的抓住，谢谢你

1046
00:39:53,290 --> 00:40:07,150
为什么是一加二十 一或一加 

1047
00:39:58,220 --> 00:40:07,150
十一点等等等等抱歉 

1048
00:40:07,700 --> 00:40:11,930
[笑声] 

1049
00:40:09,700 --> 00:40:14,690
让 我回到 我早先的 观点 

1050
00:40:11,930 --> 00:40:20,990
我有多累， 所以这 是 正确的 

1051
00:40:14,690 --> 00:40:23,690
Python 正确地做了Matt什么没关系 

1052
00:40:20,990 --> 00:40:25,609
可怕的没事那么现在 让我们做 

1053
00:40:23,690 --> 00:40:27,200
分裂， 并试图说明一点 

1054
00:40:25,609 --> 00:40:32,829
我 想 我昨晚要迟到了 

1055
00:40:27,200 --> 00:40:36,079
如果我 按预期 做 1/10好1/10 

1056
00:40:32,829 --> 00:40:38,240
确实在这里工作所以这是0.1 

1057
00:40:36,079 --> 00:40:39,700
正确但记得在 C让我挖 

1058
00:40:38,240 --> 00:40:41,960
我自己都记住并看到了 

1059
00:40:39,700 --> 00:40:43,790
如果我们挖得更深，会发生什么

1060
00:40:41,960 --> 00:40:45,589
我们看起来有点过 了第一个 

1061
00:40:43,790 --> 00:40:47,480
小数点所以我该怎么做呢 

1062
00:40:45,589 --> 00:40:49,760
Python 它实际上非常相似 

1063
00:40:47,480 --> 00:40:52,640
我继续前进，而不只是展示自己 Z. 

1064
00:40:49,760 --> 00:40:54,950
但请继续 打印 两个 让我们说 

1065
00:40:52,640 --> 00:40:56,930
两个小数位相同的值 

1066
00:40:54,950 --> 00:40:58,970
这里的语法很奇怪，它与之不同 

1067
00:40:56,930 --> 00:41:00,920
C但你真的拿了变量 

1068
00:40:58,970 --> 00:41:02,839
要格式化 你把一个冒号 

1069
00:41:00,920 --> 00:41:04,579
然后一个点，因为你想 

1070
00:41:02,839 --> 00:41:07,010
调整点，然后你想说 

1071
00:41:04,579 --> 00:41:09,950
有点像F这样说 

1072
00:41:07,010 --> 00:41:12,470
嘿Python格式化变量 

1073
00:41:09,950 --> 00:41:14,450
结肠左侧使用两个 

1074
00:41:12,470 --> 00:41:16,040
小数点，顺便说一下 

1075
00:41:14,450 --> 00:41:17,630
浮点值所以这个F有一个 

1076
00:41:16,040 --> 00:41:20,750
不同的意思这是 F在浮动 

1077
00:41:17,630 --> 00:41:23,930
左边的F 是格式， 所以让我 

1078
00:41:20,750 --> 00:41:25,490
继续运行这个1/10然后 好吧 

1079
00:41:23,930 --> 00:41:28,960
看起来还不错，让我们做吧 

1080
00:41:25,490 --> 00:41:31,670
三位小数 除了重新运行它 

1081
00:41:28,960 --> 00:41:34,250
1/10仍然相当不错让我们得到一个 

1082
00:41:31,670 --> 00:41:37,549
小野心让我们做50小数 

1083
00:41:34,250 --> 00:41:39,829
排在1/10并且该死的 

1084
00:41:37,549 --> 00:41:41,990
Python没有 修复这个基础 

1085
00:41:39,829 --> 00:41:44,290
问题所以我们 将此问题描述为 

1086
00:41:41,990 --> 00:41:44,290
什么

1087
00:41:44,700 --> 00:41:51,520
什么是类似的流行语来排序 

1088
00:41:47,050 --> 00:41:53,560
的 解释或原谅这个问题，这是 

1089
00:41:51,520 --> 00:41:55,420
一个与精神有关的整数溢出 

1090
00:41:53,560 --> 00:41:56,740
整数溢出字面上发生时

1091
00:41:55,420 --> 00:41:58,210
你做了很多补充 

1092
00:41:56,740 --> 00:42:00,420
从一个大的东西滚滚而来的东西

1093
00:41:58,210 --> 00:42:09,400
价值小到 甚至消极 

1094
00:42:00,420 --> 00:42:11,350
精神相似是的，如果你想要的话

1095
00:42:09,400 --> 00:42:13,060
拥有 无限 的精确度 

1096
00:42:11,350 --> 00:42:14,950
一路走来， 你需要一个无限的 

1097
00:42:13,060 --> 00:42:16,390
内存量， 没有Mac或一块 

1098
00:42:14,950 --> 00:42:18,400
你的手机数量无限

1099
00:42:16,390 --> 00:42:20,140
记忆在某一点画出一条线 

1100
00:42:18,400 --> 00:42:23,290
沙子，你只能这么精确 

1101
00:42:20,140 --> 00:42:25,240
所以不精确是模拟的 

1102
00:42:23,290 --> 00:42:26,650
浮点世界溢出召回

1103
00:42:25,240 --> 00:42:28,570
如果你只有一个有限的数字 

1104
00:42:26,650 --> 00:42:30,370
位的，你可以做真的很好 高达 

1105
00:42:28,570 --> 00:42:32,410
点，但最终还是 电脑达人 

1106
00:42:30,370 --> 00:42:33,910
来估计价值为它你 

1107
00:42:32,410 --> 00:42:36,040
因为你无法代表无限 

1108
00:42:33,910 --> 00:42:38,800
值的数量， 所以这是 相同的 

1109
00:42:36,040 --> 00:42:40,750
Python从根本上说也是有限的

1110
00:42:38,800 --> 00:42:42,340
和C这样的其他语言一样 

1111
00:42:40,750 --> 00:42:44,530
没有摆脱所有这些问题但是 

1112
00:42:42,340 --> 00:42:46,390
坦率地说，在数据科学和世界

1113
00:42:44,530 --> 00:42:48,010
分析它当然很重要 

1114
00:42:46,390 --> 00:42:49,780
有精确的数学，所以有 

1115
00:42:48,010 --> 00:42:51,880
这个问题的解决方案， 但它 

1116
00:42:49,780 --> 00:42:54,010
需要特殊的库通常使用 

1117
00:42:51,880 --> 00:42:56,200
导入允许你的东西 

1118
00:42:54,010 --> 00:42:58,510
只要 你想超过使用尽可能多的内存

1119
00:42:56,200 --> 00:43:00,460
只是默认的内存量 所以 

1120
00:42:58,510 --> 00:43:01,870
那个问题仍然存在让 我 

1121
00:43:00,460 --> 00:43:05,830
继续开放另一个例子 

1122
00:43:01,870 --> 00:43:09,040
在这里 ，事实上在C你会记得那 

1123
00:43:05,830 --> 00:43:13,750
我们在这里有一个例子，我们有一个

1124
00:43:09,040 --> 00:43:16,000
程序称为溢出点C和通知 

1125
00:43:13,750 --> 00:43:19,900
这个代码在C中用了几个星期

1126
00:43:16,000 --> 00:43:21,460
回来只是倍增 我再见 - 再见 - 再见 - 

1127
00:43:19,900 --> 00:43:24,400
所以它正在进行取幂

1128
00:43:21,460 --> 00:43:26,560
说1 - 2 -  4 -  8 16 32 64等 

1129
00:43:24,400 --> 00:43:28,930
如果我们等了很久，发生了什么 

1130
00:43:26,560 --> 00:43:34,000
足够了，看了几个这个节目 

1131
00:43:28,930 --> 00:43:37,630
几个星期以后是的，我们打了大约五个 

1132
00:43:34,000 --> 00:43:39,070
十亿或四十亿或更确切地说我们

1133
00:43:37,630 --> 00:43:40,330
技术上打击我认为20亿 和 

1134
00:43:39,070 --> 00:43:41,950
然后它滚了过来，实际上 

1135
00:43:40,330 --> 00:43:43,450
创造 了一个问题所以让我真正做到 

1136
00:43:41,950 --> 00:43:45,160
这让我继续前进 并溢出 

1137
00:43:43,450 --> 00:43:47,020
所以我们可以证明这一点 

1138
00:43:45,160 --> 00:43:48,790
您早些时候有关整数溢出 

1139
00:43:47,020 --> 00:43:51,340
确实是这个让我 继续前进 

1140
00:43:48,790 --> 00:43:52,690
现在， 运行溢出 我会扩展我的 

1141
00:43:51,340 --> 00:43:55,780
窗口， 所以我们可以适应 更多 

1142
00:43:52,690 --> 00:43:59,380
在屏幕上，因为这运行 

1143
00:43:55,780 --> 00:44:01,480
哎呦让我解决这个问题我们开始吧 ，让我 

1144
00:43:59,380 --> 00:44:05,530
继续，溢出，现在一个 

1145
00:44:01,480 --> 00:44:07,720
两个四8 一六三二年 等 

1146
00:44:05,530 --> 00:44:09,160
它开始有点慢，但是 

1147
00:44:07,720 --> 00:44:11,050
加倍和加倍会让我们感到兴奋 

1148
00:44:09,160 --> 00:44:12,580
这很快就 达到 了很大的价值 

1149
00:44:11,050 --> 00:44:15,370
一旦我们击中， 确实 会溢出 

1150
00:44:12,580 --> 00:44:22,840
大约20亿为什么为什么20亿给 

1151
00:44:15,370 --> 00:44:24,340
或者用 C中 的那个值来取消是的 

1152
00:44:22,840 --> 00:44:26,290
这是一个整数多少可以存储 的Cuz 

1153
00:44:24,340 --> 00:44:28,600
我们调用C一个int通常是32 

1154
00:44:26,290 --> 00:44:30,670
比特或4个字节，32位，你可以 

1155
00:44:28,600 --> 00:44:32,650
代表40亿个 可能的价值观 

1156
00:44:30,670 --> 00:44:34,360
如果这些值中有一半是 正数 

1157
00:44:32,650 --> 00:44:35,680
其中有一半是负 它代表 

1158
00:44:34,360 --> 00:44:38,380
理由是 你可以计算的最高 

1159
00:44:35,680 --> 00:44:40,120
大概是20亿 ，实际上是我们 

1160
00:44:38,380 --> 00:44:42,700
尝试计数只是 一个 翻番 

1161
00:44:40,120 --> 00:44:44,410
十亿，我们溢出，所以 你的观点 

1162
00:44:42,700 --> 00:44:46,270
到了你的观点，早先的溢出仍然是 

1163
00:44:44,410 --> 00:44:48,370
一个问题，但在整数的背景下 

1164
00:44:46,270 --> 00:44:51,000
但现在让我们尝试的 Python版本 

1165
00:44:48,370 --> 00:44:53,740
这让我现在继续 开放 

1166
00:44:51,000 --> 00:44:55,090
溢出pi这是我写的一个程序 

1167
00:44:53,740 --> 00:44:56,650
提前它在课程 网站上 

1168
00:44:55,090 --> 00:44:59,920
像往常一样，如果你 想看一看 

1169
00:44:56,650 --> 00:45:03,760
更密切，如果我进入这个文件

1170
00:44:59,920 --> 00:45:05,710
在第一周溢出点 PI 我们看到这一点 

1171
00:45:03,760 --> 00:45:07,210
代码所以几乎相同但 注意 

1172
00:45:05,710 --> 00:45:09,640
我正在 使用另一个 我们没有的图书馆 

1173
00:45:07,210 --> 00:45:11,230
从时间进口之前就看到了它的飞跃 

1174
00:45:09,640 --> 00:45:12,940
有点可爱所以这让我 睡觉 

1175
00:45:11,230 --> 00:45:14,470
一秒钟， 那将变得单调而乏味 

1176
00:45:12,940 --> 00:45:16,830
很快，但没关系，让我们这样做 

1177
00:45:14,470 --> 00:45:20,230
如果我进入源 6目录， 请快速 

1178
00:45:16,830 --> 00:45:22,900
第 1 周 并运行溢出点的python 

1179
00:45:20,230 --> 00:45:25,240
pi它的功能相同或相同 

1180
00:45:22,900 --> 00:45:26,830
程序功能但老实说这个 

1181
00:45:25,240 --> 00:45:29,380
让我们走得 有点乏味 

1182
00:45:26,830 --> 00:45:31,600
提前，不要每隔一秒睡一觉 

1183
00:45:29,380 --> 00:45:35,080
时间保存和重新加载让我们运行 

1184
00:45:31,600 --> 00:45:38,830
事情哇 看 它去 

1185
00:45:35,080 --> 00:45:42,880
只有在 那里查找它是什么 

1186
00:45:38,830 --> 00:45:44,950
做不同的事情， 它的数量很多 

1187
00:45:42,880 --> 00:45:51,030
高于 2个 千亿所以，什么才是你 

1188
00:45:44,950 --> 00:45:51,030
推断Python中的整数再说一遍 

1189
00:45:53,900 --> 00:45:57,690
好吧， 一个 整数 被定义为 相当 一个 

1190
00:45:56,280 --> 00:45:58,110
比特数，确实是这样的 

1191
00:45:57,690 --> 00:45:59,670
案件 

1192
00:45:58,110 --> 00:46:00,780
Python实际上不是这个的原因

1193
00:45:59,670 --> 00:46:02,970
慢是因为我们运行 

1194
00:46:00,780 --> 00:46:04,530
基于Web的 IDE和 Internet本身 就是 

1195
00:46:02,970 --> 00:46:05,880
有点慢，所以发生了什么 

1196
00:46:04,530 --> 00:46:07,170
这里只是互联网进入 

1197
00:46:05,880 --> 00:46:09,480
方式， 但足以说明这一点 

1198
00:46:07,170 --> 00:46:11,700
Python 正在以更高的方式计算 

1199
00:46:09,480 --> 00:46:13,380
而不是C，这就是你获得的力量

1200
00:46:11,700 --> 00:46:15,030
通过 使用更大的数据类型，我们可以 

1201
00:46:13,380 --> 00:46:17,040
我们可以用C做过这个

1202
00:46:15,030 --> 00:46:19,170
例如Long， 但注意到 

1203
00:46:17,040 --> 00:46:21,150
Python你默认提供更多 

1204
00:46:19,170 --> 00:46:22,740
箱子让我们继续前进 ，并采取 

1205
00:46:21,150 --> 00:46:24,150
在这里休息5分钟，当我们恢复时 

1206
00:46:22,740 --> 00:46:26,610
我们将介绍一些更多的语法和 

1207
00:46:24,150 --> 00:46:28,140
解决了一些更多的问题没事 如此 

1208
00:46:26,610 --> 00:46:29,940
让我们来看看其他几个

1209
00:46:28,140 --> 00:46:31,800
与 我们 相比的例子

1210
00:46:29,940 --> 00:46:34,110
在第一 周 回来 看看几个 

1211
00:46:31,800 --> 00:46:35,910
从第二周和第三周开始 

1212
00:46:34,110 --> 00:46:37,650
看看最终的语法 

1213
00:46:35,910 --> 00:46:39,420
但Python和Python的一些功能

1214
00:46:37,650 --> 00:46:41,220
当然我们需要 表达 的 能力 

1215
00:46:39,420 --> 00:46:43,080
我们有条件或逻辑地 

1216
00:46:41,220 --> 00:46:44,670
有了控制流程，所以让我提出建议 

1217
00:46:43,080 --> 00:46:46,800
这是一个快速的程序， 我们只是 

1218
00:46:44,670 --> 00:46:48,930
调用条件点PI 让人想起 

1219
00:46:46,800 --> 00:46:52,050
条件dot c前一段时间让我走了 

1220
00:46:48,930 --> 00:46:54,660
进取，从CS50进口 得到 诠释 这个 

1221
00:46:52,050 --> 00:46:56,910
时间，让自己 有 得到 另一个 X 

1222
00:46:54,660 --> 00:46:59,730
来自 用户的 int x 然后 让我继续 

1223
00:46:56,910 --> 00:47:01,260
并要求他们为GET为 Y 从 

1224
00:46:59,730 --> 00:47:03,480
用户，然后让我继续前进 ，只是 

1225
00:47:01,260 --> 00:47:05,550
根据我们的比较比较它们 

1226
00:47:03,480 --> 00:47:08,280
我会简单地说 

1227
00:47:05,550 --> 00:47:11,520
如果X 小于 Y，然后继续前进 ， 

1228
00:47:08,280 --> 00:47:14,970
打印输出例如打印X更少 

1229
00:47:11,520 --> 00:47:16,920
比如我们几周前做的那样， 如果是X ，那就是Y. 

1230
00:47:14,970 --> 00:47:20,790
大于Y我们可以继续前进 

1231
00:47:16,920 --> 00:47:22,590
打印出 X大于Y然后 

1232
00:47:20,790 --> 00:47:24,810
我们仍然可以有第三个条件 

1233
00:47:22,590 --> 00:47:26,640
只是我可以看到我们打印出来的地方 

1234
00:47:24,810 --> 00:47:29,400
例如X的逻辑结论 

1235
00:47:26,640 --> 00:47:31,650
等于 Y所以只是指出 一些 

1236
00:47:29,400 --> 00:47:33,060
缩进 的差异 是如此 

1237
00:47:31,650 --> 00:47:34,830
现在很重要，而且必须如此 

1238
00:47:33,060 --> 00:47:36,210
一致的你不能有 四个空格 

1239
00:47:34,830 --> 00:47:38,010
例如，你必须拥有三个

1240
00:47:36,210 --> 00:47:40,140
四个一律 ， 我已经 得到 了 通知 方式 

1241
00:47:38,010 --> 00:47:42,090
冒号一直在那里， 但请注意 

1242
00:47:40,140 --> 00:47:42,660
我 不需要 任何 括号 

1243
00:47:42,090 --> 00:47:45,390
再 

1244
00:47:42,660 --> 00:47:47,700
Python和Python 有点像 

1245
00:47:45,390 --> 00:47:49,530
流行语pythonic有一个pythonic 

1246
00:47:47,700 --> 00:47:52,350
你可以做的事情的方式

1247
00:47:49,530 --> 00:47:54,660
X周围的括号小于Y或X. 

1248
00:47:52,350 --> 00:47:56,550
比C更大，但是它 

1249
00:47:54,660 --> 00:47:57,780
在逻辑上可以说没有添加任何东西

1250
00:47:56,550 --> 00:47:59,820
如果它不能使你的代码更多 

1251
00:47:57,780 --> 00:48:01,380
可读性 不会使您的代码混乱 

1252
00:47:59,820 --> 00:48:03,510
额外的字符，所以这是一个

1253
00:48:01,380 --> 00:48:04,440
一般的经验法则现在 python很多 

1254
00:48:03,510 --> 00:48:06,750
更多修剪

1255
00:48:04,440 --> 00:48:08,250
当谈到语法只介绍 

1256
00:48:06,750 --> 00:48:10,849
当它真正解决了一个问题 

1257
00:48:08,250 --> 00:48:13,230
在这种情况下，它并不是真的 

1258
00:48:10,849 --> 00:48:14,550
症状的线条 被分组 

1259
00:48:13,230 --> 00:48:17,220
一起到一个X到一个 

1260
00:48:14,550 --> 00:48:18,599
未来一到下一个 ，如果你要放 

1261
00:48:17,220 --> 00:48:20,640
像 在传统之间线 

1262
00:48:18,599 --> 00:48:21,510
这将打破代码 没有根本 

1263
00:48:20,640 --> 00:48:23,369
我可以拥有尽可能多的空白空间 

1264
00:48:21,510 --> 00:48:25,079
如果我想添加 ，我想要垂直

1265
00:48:23,369 --> 00:48:26,790
确实有些评论我可以做到 这一点 

1266
00:48:25,079 --> 00:48:28,589
为什么我们不这样做， 实际上是因为 

1267
00:48:26,790 --> 00:48:30,420
Python的注释语法有点儿 

1268
00:48:28,589 --> 00:48:32,130
看到我们养成了不同的习惯 

1269
00:48:30,420 --> 00:48:33,630
做斜线斜杠Python它实际上是一个 

1270
00:48:32,130 --> 00:48:36,329
更简洁， 你可以使用一个 

1271
00:48:33,630 --> 00:48:39,390
单散，你可以说从 GET X 

1272
00:48:36,329 --> 00:48:40,650
用户在这里我可以说来自这里的用户Y. 

1273
00:48:39,390 --> 00:48:43,530
然后我可以说类似的东西 

1274
00:48:40,650 --> 00:48:45,060
比较X和 y，如果我真的想要 

1275
00:48:43,530 --> 00:48:46,740
我可以在这里发表评论 

1276
00:48:45,060 --> 00:48:47,940
完全没问题， 但我会坚持下去 

1277
00:48:46,740 --> 00:48:50,400
这个特别的更紧凑 

1278
00:48:47,940 --> 00:48:52,410
例如任何有关的问题 

1279
00:48:50,400 --> 00:48:55,619
条件语法或我们只是 

1280
00:48:52,410 --> 00:48:58,230
在这里完成， 让我鞭打 

1281
00:48:55,619 --> 00:49:00,180
另一个例子 这次 做了一些 

1282
00:48:58,230 --> 00:49:02,280
比较这次让我创造一个 

1283
00:49:00,180 --> 00:49:03,780
文件称为答案点 PI 

1284
00:49:02,280 --> 00:49:05,940
让人想起我们做的一个简单的例子 

1285
00:49:03,780 --> 00:49:08,700
几周前叫答案点C让我走了 

1286
00:49:05,940 --> 00:49:11,700
提前和从cs50导入获取字符串 

1287
00:49:08,700 --> 00:49:13,380
这一次让我继续 使用 

1288
00:49:11,700 --> 00:49:15,030
声明变量C并让我继续 

1289
00:49:13,380 --> 00:49:17,520
并从用户呐喊中获取一个字符串 

1290
00:49:15,030 --> 00:49:19,170
从用户得到一个字符串 的 

1291
00:49:17,520 --> 00:49:20,579
回答我们的任何问题 

1292
00:49:19,170 --> 00:49:22,200
关心， 如果它的意思 是 

1293
00:49:20,579 --> 00:49:27,300
喜欢是/否答案让我们检查一下 

1294
00:49:22,200 --> 00:49:29,760
如果C等于 Y或 C等于 

1295
00:49:27,300 --> 00:49:32,490
等于小Y然后继续 说 

1296
00:49:29,760 --> 00:49:34,200
只是为了 示范 是的 

1297
00:49:32,490 --> 00:49:38,579
因为人类可能意味着 

1298
00:49:34,200 --> 00:49:41,010
L如果C等于n大写 n或C 

1299
00:49:38,579 --> 00:49:43,770
等于小n然后继续 前进 

1300
00:49:41,010 --> 00:49:46,470
打印出来的例如没那么短 

1301
00:49:43,770 --> 00:49:48,480
程序，但有些 是 什么 

1302
00:49:46,470 --> 00:49:50,880
很好地说明了与众不同的东西 

1303
00:49:48,480 --> 00:49:54,940
在这些第5到8行与C之间 

1304
00:49:50,880 --> 00:49:57,460
几个星期前是的

1305
00:49:54,940 --> 00:49:59,200
是的，没有一个愚蠢的竖条或 

1306
00:49:57,460 --> 00:50:01,630
如果你愿意，可以使用＆符号＆符号

1307
00:49:59,200 --> 00:50:03,579
做某件事，或者或者，它 只是 一起 

1308
00:50:01,630 --> 00:50:06,430
说和，或者很像刮痕

1309
00:50:03,579 --> 00:50:09,510
实际上几周前就注意到 了 

1310
00:50:06,430 --> 00:50:13,119
我们比较字符串结果 

1311
00:50:09,510 --> 00:50:15,220
Python 没有字符本身 看 

1312
00:50:13,119 --> 00:50:17,140
确实有char单字符 Python 

1313
00:50:15,220 --> 00:50:19,059
只有字符串并且有字符串

1314
00:50:17,140 --> 00:50:20,619
漂浮，然后一些更好的东西， 但 

1315
00:50:19,059 --> 00:50:23,289
它没有字符 所以我就是这样 

1316
00:50:20,619 --> 00:50:25,210
故意使用字符串，但当我们 

1317
00:50:23,289 --> 00:50:29,500
使用字符串，看看我们如何比较

1318
00:50:25,210 --> 00:50:31,630
由于两个字符串搅拌正确 

1319
00:50:29,500 --> 00:50:33,490
整个讨厌的指针比较

1320
00:50:31,630 --> 00:50:34,450
事情很好，现在在Python中证明了 

1321
00:50:33,490 --> 00:50:36,510
你想比较两个字符串 

1322
00:50:34,450 --> 00:50:39,220
字符逐字符 

1323
00:50:36,510 --> 00:50:42,160
等于等于回来，它完全正确 

1324
00:50:39,220 --> 00:50:43,960
你期望它做什么，即使它是一个 

1325
00:50:42,160 --> 00:50:47,049
完整的话所以，如果你真的在检查

1326
00:50:43,960 --> 00:50:49,420
例如是或是来自 

1327
00:50:47,049 --> 00:50:51,369
人类你仍然可以使用平等 

1328
00:50:49,420 --> 00:50:52,809
好吧， 即使它比现在更多 

1329
00:50:51,369 --> 00:50:54,220
性格， 这是一个很棒的功能 

1330
00:50:52,809 --> 00:50:57,130
它也只是使 代码更多 

1331
00:50:54,220 --> 00:50:59,380
可读且更容易编写正确 

1332
00:50:57,130 --> 00:51:02,049
好了， 所以现在回想起来 

1333
00:50:59,380 --> 00:51:03,430
在PI NC，我们花了一点 时间 

1334
00:51:02,049 --> 00:51:05,319
以及从头开始看一看

1335
00:51:03,430 --> 00:51:07,900
关于所有人咳嗽的几个例子 

1336
00:51:05,319 --> 00:51:10,150
事实上 ， 事实上在Python和 C和 

1337
00:51:07,900 --> 00:51:11,920
而在刮擦和C中，我们做了零 

1338
00:51:10,150 --> 00:51:13,359
看起来有点像这样的例子

1339
00:51:11,920 --> 00:51:15,369
如果你想模拟的概念 

1340
00:51:13,359 --> 00:51:17,200
划伤你可能咳嗽的猫

1341
00:51:15,369 --> 00:51:19,059
当然这样做然后如果他会的话 

1342
00:51:17,200 --> 00:51:20,440
拨打三次，你可能做到这一点 ， 

1343
00:51:19,059 --> 00:51:22,390
我们跑了这个，它只是做了coff coff 

1344
00:51:20,440 --> 00:51:23,890
coff在屏幕上并不会打扰 

1345
00:51:22,390 --> 00:51:26,020
运行它，因为它只会 做 

1346
00:51:23,890 --> 00:51:28,299
但这是糟糕的设计我们声称好几周 

1347
00:51:26,020 --> 00:51:32,319
为什么这是 坏事的要点是 什么？ 

1348
00:51:28,299 --> 00:51:33,880
设计我的意思是我真的复制和 

1349
00:51:32,319 --> 00:51:35,680
粘贴它，如果你是的可能性 

1350
00:51:33,880 --> 00:51:36,789
曾经 在cs50或者在 

1351
00:51:35,680 --> 00:51:38,170
你可以更普遍地编程

1352
00:51:36,789 --> 00:51:39,760
可能有点懒， 而且有 

1353
00:51:38,170 --> 00:51:41,440
一个更好的方法，它更多 

1354
00:51:39,760 --> 00:51:44,380
当然可以做到这一点 

1355
00:51:41,440 --> 00:51:48,069
我们几周前都在介绍

1356
00:51:44,380 --> 00:51:50,289
而在C中，COFF的能力就是 这个 

1357
00:51:48,069 --> 00:51:52,329
时间做一个循环，我可以做一个循环 

1358
00:51:50,289 --> 00:51:55,270
Python N和 C略有不同

1359
00:51:52,329 --> 00:51:57,880
但对于我在三个范围内继续前进 

1360
00:51:55,270 --> 00:51:59,799
并打印出 Koff所以语法为 

1361
00:51:57,880 --> 00:52:01,150
for循环有点不同但是它 

1362
00:51:59,799 --> 00:52:03,369
尽管如此，还是很简单 

1363
00:52:01,150 --> 00:52:05,799
你还记得你用于变量 

1364
00:52:03,369 --> 00:52:08,180
然后命名介词in 然后 

1365
00:52:05,799 --> 00:52:09,859
带 括号的单词范围 和它 

1366
00:52:08,180 --> 00:52:11,809
括号和值想要 

1367
00:52:09,859 --> 00:52:14,960
关心，但后来我们看到了 

1368
00:52:11,809 --> 00:52:17,000
机会召回实际上是抽象的

1369
00:52:14,960 --> 00:52:18,380
咳嗽至少咳嗽 

1370
00:52:17,000 --> 00:52:20,270
在我们的文本形式中，它 只是行为 

1371
00:52:18,380 --> 00:52:23,030
印刷的东西， 所以我们介绍 

1372
00:52:20,270 --> 00:52:26,359
不久前的版本二 以下 

1373
00:52:23,030 --> 00:52:28,400
咳嗽的方法我反而定义了 

1374
00:52:26,359 --> 00:52:29,839
一个叫做咳嗽的功能 

1375
00:52:28,400 --> 00:52:31,190
为我咳嗽， 我们还没有见过这个 

1376
00:52:29,839 --> 00:52:33,440
在Python中你如何定义一个 

1377
00:52:31,190 --> 00:52:34,940
Python中的函数叫做 cough put 

1378
00:52:33,440 --> 00:52:37,309
另一种方式如何制作 自己的 

1379
00:52:34,940 --> 00:52:39,740
正如我们所做的那样定制拼图

1380
00:52:37,309 --> 00:52:42,140
你很好地划定死亡 

1381
00:52:39,740 --> 00:52:43,490
然后你就完成 了你的工作 

1382
00:52:42,140 --> 00:52:44,809
想要通过缩进来做它

1383
00:52:43,490 --> 00:52:46,400
属于那的代码行

1384
00:52:44,809 --> 00:52:48,530
功能所以没有返回值 

1385
00:52:46,400 --> 00:52:50,690
没有必要 输入 

1386
00:52:48,530 --> 00:52:52,369
那一刻，但我们确实有结肠和我们 

1387
00:52:50,690 --> 00:52:54,559
缩进没有花括号 

1388
00:52:52,369 --> 00:52:56,599
没有其他我现在如何使用它 

1389
00:52:54,559 --> 00:52:59,480
功能很好这里​​我们有几个 

1390
00:52:56,599 --> 00:53:02,000
程序中的风格选项

1391
00:52:59,480 --> 00:53:04,450
调用此函数的最简单方法是

1392
00:53:02,000 --> 00:53:08,900
是很简单像这样继续前进 ， 

1393
00:53:04,450 --> 00:53:11,270
因为我在范围3现在继续前进和 COFF 

1394
00:53:08,900 --> 00:53:13,040
这应该看起来 有点奇怪 

1395
00:53:11,270 --> 00:53:14,540
看起来确实有点草率， 但让我们 

1396
00:53:13,040 --> 00:53:18,170
看看它是否有效，如果我继续前进并 运行 

1397
00:53:14,540 --> 00:53:20,510
似乎 是咳嗽 到点 pi的 Python 

1398
00:53:18,170 --> 00:53:24,470
coff coff coff 但 我说这是一个 

1399
00:53:20,510 --> 00:53:28,670
有点奇怪，因为 我在做什么 

1400
00:53:24,470 --> 00:53:31,940
现在与 C有很大不同

1401
00:53:28,670 --> 00:53:33,950
不，我只是没有主要功能

1402
00:53:31,940 --> 00:53:34,400
在左边有一些代码

1403
00:53:33,950 --> 00:53:36,230
屏幕 

1404
00:53:34,400 --> 00:53:38,450
可是我有一个函数在这里 和 

1405
00:53:36,230 --> 00:53:40,130
Python 这 没关系因为 你正在使用 

1406
00:53:38,450 --> 00:53:41,480
翻译并阅读文件顶部 

1407
00:53:40,130 --> 00:53:43,160
从左到右，你没有 

1408
00:53:41,480 --> 00:53:45,140
严格要求一个名为main的函数

1409
00:53:43,160 --> 00:53:46,790
它只会解释 你的 所有 

1410
00:53:45,140 --> 00:53:48,650
代码和 场景时的定义 

1411
00:53:46,790 --> 00:53:50,150
一个功能好吧它会说好的 

1412
00:53:48,650 --> 00:53:52,640
得到它我现在知道动词COFF是什么 

1413
00:53:50,150 --> 00:53:55,040
意味着我会在任何时候 看到它 

1414
00:53:52,640 --> 00:53:57,290
在这里，但我们会碰到 一个 

1415
00:53:55,040 --> 00:53:59,390
问题，如果我确实做了我的 

1416
00:53:57,290 --> 00:54:01,549
第一直觉是要放的

1417
00:53:59,390 --> 00:54:04,130
我的逻辑是我程序的主要部分

1418
00:54:01,549 --> 00:54:05,599
在顶部并在此处定义COFF 

1419
00:54:04,130 --> 00:54:07,970
让我们看看会发生什么让我缩小 

1420
00:54:05,599 --> 00:54:10,309
让我继续，重新 咳嗽点到点 

1421
00:54:07,970 --> 00:54:11,660
pi现在我们开始看到 第一个了 

1422
00:54:10,309 --> 00:54:13,490
我们的错误信息， 他们会 

1423
00:54:11,660 --> 00:54:16,160
乍一看看起来就像神秘 一样 

1424
00:54:13,490 --> 00:54:18,079
作为一个铿锵，让工作放心 

1425
00:54:16,160 --> 00:54:20,059
这种 帮助50可使用Python错误帮助 

1426
00:54:18,079 --> 00:54:21,890
消息以及但是让我们只是尝试 

1427
00:54:20,059 --> 00:54:24,830
解析我的理解

1428
00:54:21,890 --> 00:54:27,770
两个pi线2和模块无论如何 

1429
00:54:24,830 --> 00:54:30,140
是名称错误 名称COFF未定义 

1430
00:54:27,770 --> 00:54:32,390
那么什么是你的直觉在这里那是什么 

1431
00:54:30,140 --> 00:54:34,310
真的是什么 解释 

1432
00:54:32,390 --> 00:54:37,760
错误，因为 咖啡明确 定义 

1433
00:54:34,310 --> 00:54:42,470
字面意思是定义def动词吧 

1434
00:54:37,760 --> 00:54:44,060
现在网上有什么是的我是 

1435
00:54:42,470 --> 00:54:46,040
试图在它定义之前调用它 

1436
00:54:44,060 --> 00:54:47,720
Python试图抓住我 

1437
00:54:46,040 --> 00:54:49,280
从字面上看 ，它会做到最好 

1438
00:54:47,720 --> 00:54:50,600
底部从左到右 ， 如果它不 

1439
00:54:49,280 --> 00:54:52,130
直到底部看到它的东西

1440
00:54:50,600 --> 00:54:53,960
应该是在顶部做的 

1441
00:54:52,130 --> 00:54:55,490
只是不去 工作， 所以有一个 

1442
00:54:53,960 --> 00:54:57,380
对此的解决方案， 它开始得到一个 

1443
00:54:55,490 --> 00:54:59,390
有点丑，但它更普遍 

1444
00:54:57,380 --> 00:55:01,460
解决方案，事实证明， 即使 

1445
00:54:59,390 --> 00:55:03,590
在Python程序中不需要main 

1446
00:55:01,460 --> 00:55:04,220
许多程序员只 创建一个 

1447
00:55:03,590 --> 00:55:06,560
尽管如此， 

1448
00:55:04,220 --> 00:55:08,600
为 解决这方面的问题，并 

1449
00:55:06,560 --> 00:55:11,840
他们专门做这样的事情

1450
00:55:08,600 --> 00:55:14,770
def main然后在它下面它们缩进 

1451
00:55:11,840 --> 00:55:17,690
那里的一切，然后你需要一个 

1452
00:55:14,770 --> 00:55:19,940
具体功能解决了这个问题

1453
00:55:17,690 --> 00:55:22,220
现在我已经定义了main和我 

1454
00:55:19,940 --> 00:55:24,290
定义了理论上解决的 COFF 

1455
00:55:22,220 --> 00:55:25,850
这个问题就像它 在CI中所做的那样 

1456
00:55:24,290 --> 00:55:27,320
没有 原型的 概念 

1457
00:55:25,850 --> 00:55:29,480
Python 不是 解决方案 

1458
00:55:27,320 --> 00:55:32,360
复制粘贴 函数 的名称 

1459
00:55:29,480 --> 00:55:34,580
以上但是当我现在这样做时 

1460
00:55:32,360 --> 00:55:37,790
什么也没有发生 ，但 我没有 摆脱 

1461
00:55:34,580 --> 00:55:38,960
错误所以只是因为 这个 原因 

1462
00:55:37,790 --> 00:55:41,000
也许特别是如果你从来没有 

1463
00:55:38,960 --> 00:55:47,090
编程Python之前为什么可能

1464
00:55:41,000 --> 00:55:49,610
什么都没发生，没有打电话 

1465
00:55:47,090 --> 00:55:51,800
主要是的， 而在C和坦率地说 

1466
00:55:49,610 --> 00:55:54,170
Java 和几 列 C ++和其他几个 

1467
00:55:51,800 --> 00:55:56,780
语言主要是特殊的它只是得到 

1468
00:55:54,170 --> 00:55:59,060
默认情况下在Python main中调用不是 

1469
00:55:56,780 --> 00:56:00,650
特别是我刚刚选择了这个名字 

1470
00:55:59,060 --> 00:56:02,660
因为有这么多 其他语言使用它 

1471
00:56:00,650 --> 00:56:05,150
但如果 没有 特别的意义 

1472
00:56:02,660 --> 00:56:05,750
你想打电话给主，你必须这样做

1473
00:56:05,150 --> 00:56:07,490
你自己 

1474
00:56:05,750 --> 00:56:10,400
所以这确实有点奇怪 

1475
00:56:07,490 --> 00:56:12,320
但你可以在这里做到这一点 

1476
00:56:10,400 --> 00:56:14,360
因为你的代码将被 执行到顶部 

1477
00:56:12,320 --> 00:56:16,460
按 时间线 从左到右 排列 

1478
00:56:14,360 --> 00:56:18,020
达到10 都是主要的定义 

1479
00:56:16,460 --> 00:56:19,940
和COFF已被定义，这意味着 

1480
00:56:18,020 --> 00:56:22,550
如果 我现在 走下去，你会很高兴

1481
00:56:19,940 --> 00:56:24,860
现在运行咳嗽2的蟒蛇吧 

1482
00:56:22,550 --> 00:56:27,740
现在实际工作 顺便说一句 ，这是 

1483
00:56:24,860 --> 00:56:29,990
如果你是大多数人，不是pythonic 

1484
00:56:27,740 --> 00:56:35,000
如果名称实际上做到 这一点 

1485
00:56:29,990 --> 00:56:35,750
等于等于主然后做到这一点，这是 

1486
00:56:35,000 --> 00:56:36,980
为了低 

1487
00:56:35,750 --> 00:56:38,810
我们是让我挥挥手力的原因 

1488
00:56:36,980 --> 00:56:40,400
手来 ，但今天长话短说 

1489
00:56:38,810 --> 00:56:42,320
这个神秘的加入了 

1490
00:56:40,400 --> 00:56:43,850
line 解决了我们遇到的其他问题 

1491
00:56:42,320 --> 00:56:45,890
这个周末 不会去旅行 

1492
00:56:43,850 --> 00:56:48,110
可能是下一个所以这是常见的方式 

1493
00:56:45,890 --> 00:56:49,760
要做到这一点， 但 如果你只是忽略 了 

1494
00:56:48,110 --> 00:56:51,290
这个神秘的代码的效果是 

1495
00:56:49,760 --> 00:56:53,000
只是为了给自己打电话 

1496
00:56:51,290 --> 00:56:54,380
你的文件的底部，所以当我们开始 

1497
00:56:53,000 --> 00:56:55,820
写 这个 更有趣的 节目 

1498
00:56:54,380 --> 00:56:57,170
如果，这将成为传统 

1499
00:56:55,820 --> 00:56:57,710
你想开始写作和 

1500
00:56:57,170 --> 00:56:59,750
等等

1501
00:56:57,710 --> 00:57:01,490
写一篇文章会让你受益匪浅

1502
00:56:59,750 --> 00:57:03,980
主要功能和更多代码 

1503
00:57:01,490 --> 00:57:07,310
有那么让我们做一个 最后的例子 

1504
00:57:03,980 --> 00:57:09,170
咖啡 ， 实际上现在 是 参数 

1505
00:57:07,310 --> 00:57:11,330
正如我们几周前所做的那样 

1506
00:57:09,170 --> 00:57:13,640
划伤， 看到这将 咳嗽3pi 

1507
00:57:11,330 --> 00:57:15,620
让我开始，因为我做 了一点点 

1508
00:57:13,640 --> 00:57:17,750
以前， 但我想我想 实现这一目标 

1509
00:57:15,620 --> 00:57:21,020
效果我想让电脑 咳嗽 

1510
00:57:17,750 --> 00:57:23,240
我现在通过输入三次

1511
00:57:21,020 --> 00:57:24,890
确实需要修改咳嗽来取一个 

1512
00:57:23,240 --> 00:57:26,960
输入和CI会 说 

1513
00:57:24,890 --> 00:57:29,480
一些 如int n，而是你没有 

1514
00:57:26,960 --> 00:57:31,400
你只需要在Python中指定数据类型

1515
00:57:29,480 --> 00:57:32,540
必须指定参数名称或 

1516
00:57:31,400 --> 00:57:35,540
参数名称，这样很好 

1517
00:57:32,540 --> 00:57:37,790
简单，现在在这里 咳嗽 是 

1518
00:57:35,540 --> 00:57:41,750
我应该在哪里说我 

1519
00:57:37,790 --> 00:57:43,400
三个范围做到这一点，但事实并非如此 

1520
00:57:41,750 --> 00:57:46,130
我想要的是什么固定的 

1521
00:57:43,400 --> 00:57:47,810
在这里， 是的，我现在可以 通过 

1522
00:57:46,130 --> 00:57:48,980
结束 所以范围只是一个功能 

1523
00:57:47,810 --> 00:57:51,230
我接受了一个争论 

1524
00:57:48,980 --> 00:57:53,540
硬编码是 三个因为但是 

1525
00:57:51,230 --> 00:57:55,070
你可以在概括它也 使 

1526
00:57:53,540 --> 00:57:57,080
现在每一次我们讨论 

1527
00:57:55,070 --> 00:57:59,300
抽象几周和几周前 我们做 

1528
00:57:57,080 --> 00:58:00,800
有一种漂亮的版本 

1529
00:57:59,300 --> 00:58:03,380
咳嗽，即使它看起来像 

1530
00:58:00,800 --> 00:58:04,670
更加神秘， 但一步一步走 

1531
00:58:03,380 --> 00:58:06,830
我们是否达到了主力的目的 

1532
00:58:04,670 --> 00:58:08,510
抽取 咳嗽的功能 

1533
00:58:06,830 --> 00:58:10,160
做了很多次，现在的 

1534
00:58:08,510 --> 00:58:11,780
实现细节隐藏在 

1535
00:58:10,160 --> 00:58:13,370
这个 定制拼图如果你愿意和 

1536
00:58:11,780 --> 00:58:15,140
这两条线的全部很多

1537
00:58:13,370 --> 00:58:17,120
底部刚 开始整个执行 

1538
00:58:15,140 --> 00:58:22,990
该计划，但这 是 唯一的东西 

1539
00:58:17,120 --> 00:58:22,990
这真的是Python特有的现在是的 

1540
00:58:26,620 --> 00:58:33,500
可能与 我的 COFF功能上使用

1541
00:58:30,380 --> 00:58:36,170
第11行是的，你绝对可以做到 

1542
00:58:33,500 --> 00:58:38,720
例如，摆脱主要 

1543
00:58:36,170 --> 00:58:40,220
再一次， 这只是一个约会 

1544
00:58:38,720 --> 00:58:41,660
开始写更具特异性的 cated 

1545
00:58:40,220 --> 00:58:43,220
具有您应该具有的功能的程序

1546
00:58:41,660 --> 00:58:50,540
可能介绍主要只是为了保持它

1547
00:58:43,220 --> 00:58:53,540
整洁你来，你可以做到那一点 

1548
00:58:50,540 --> 00:58:57,350
你开始 像非pythonic一样 

1549
00:58:53,540 --> 00:58:59,840
是的，你可以做Koff 3，但人们 会 

1550
00:58:57,350 --> 00:59:00,830
你 那副 因为 它只是 不 

1551
00:58:59,840 --> 00:59:03,530
这样做了 

1552
00:59:00,830 --> 00:59:05,860
这就是pythonic 意味着是的 

1553
00:59:03,530 --> 00:59:05,860
问题

1554
00:59:15,540 --> 00:59:19,380
不是在这种情况下 所以现在的顺序是 

1555
00:59:18,540 --> 00:59:22,410
好的 

1556
00:59:19,380 --> 00:59:24,210
因为第一个Python正在 看到这里 

1557
00:59:22,410 --> 00:59:25,320
主要的定义 好吧我明白了 

1558
00:59:24,210 --> 00:59:27,420
然后它说这是 

1559
00:59:25,320 --> 00:59:28,800
咖啡的定义好吧我明白了 

1560
00:59:27,420 --> 00:59:31,200
它实际上并没有调用那些 

1561
00:59:28,800 --> 00:59:33,210
功能还有Python错误 

1562
00:59:31,200 --> 00:59:35,130
只抛出它所谓的 运行时 

1563
00:59:33,210 --> 00:59:37,560
运行程序的时间 

1564
00:59:35,130 --> 00:59:39,990
仅在调用main时才表示

1565
00:59:37,560 --> 00:59:41,940
Python 实际上执行 第四 行 和 

1566
00:59:39,990 --> 00:59:44,040
然后看哦我需要 调用一个 函数 

1567
00:59:41,940 --> 00:59:45,570
叫做COFF，但这 没关系， 因为 它 

1568
00:59:44,040 --> 00:59:48,420
看到它前面时， 它首先 读取 

1569
00:59:45,570 --> 00:59:50,460
文件从上到下， 所以它很重要 

1570
00:59:48,420 --> 00:59:53,640
该功能被称为 不到哪里 

1571
00:59:50,460 --> 00:59:57,330
本身在文件中出现的顺序 

1572
00:59:53,640 --> 01:00:08,130
他们被称为其他所有问题 

1573
00:59:57,330 --> 01:00:10,140
是的 我 怎么 定义n是一个 

1574
01:00:08,130 --> 01:00:11,640
整数这是 Python的好处 

1575
01:00:10,140 --> 01:00:13,980
如果你想要一个变量或参数 

1576
01:00:11,640 --> 01:00:15,960
刚开始使用它而不提及 

1577
01:00:13,980 --> 01:00:18,480
它的数据类型所以我放入 了 这个事实 

1578
01:00:15,960 --> 01:00:20,670
在此函数的括号中表示 

1579
01:00:18,480 --> 01:00:22,500
嘿Python让 这个功能采取 

1580
01:00:20,670 --> 01:00:24,900
输入称为n，它实际上可以 

1581
01:00:22,500 --> 01:00:27,240
float字符串中的任何数据类型或甚至 

1582
01:00:24,900 --> 01:00:29,580
其他 东西由我来决定 使用它 

1583
01:00:27,240 --> 01:00:33,000
负责任地作为一个数字并称之为 

1584
01:00:29,580 --> 01:00:38,550
负责任地提出一些好问题

1585
01:00:33,000 --> 01:00:40,050
是啊是确实有可能 的 

1586
01:00:38,550 --> 01:00:42,960
变量改变类型的好 

1587
01:00:40,050 --> 01:00:46,020
观察所以是蟒蛇 是 不是 

1588
01:00:42,960 --> 01:00:47,280
强类型语言可以这么说 C是 

1589
01:00:46,020 --> 01:00:48,810
强烈打字，如果你做 

1590
01:00:47,280 --> 01:00:51,570
什么东西， 并在其中保持int 

1591
01:00:48,810 --> 01:00:53,340
永远Python是松散的类型 ，由此 

1592
01:00:51,570 --> 01:00:54,840
X 最初可以是 int，但如果你 

1593
01:00:53,340 --> 01:00:57,270
真想把它变成一个字符串你 

1594
01:00:54,840 --> 01:00:59,550
可以，但 那里 的惯例 

1595
01:00:57,270 --> 01:01:02,070
是的，你可以这样做， 但不要那样 做 

1596
01:00:59,550 --> 01:01:03,750
所以 python坦率地就是那种 

1597
01:01:02,070 --> 01:01:05,550
成为一个 成年人的 傲慢 

1598
01:01:03,750 --> 01:01:07,110
像是的语言， 你可以这样做 但是 

1599
01:01:05,550 --> 01:01:08,850
只是不喜欢我们为什么要这样做 

1600
01:01:07,110 --> 01:01:09,960
保护你自己，等等

1601
01:01:08,850 --> 01:01:12,090
这意味着你需要多一点 

1602
01:01:09,960 --> 01:01:13,950
对此负责， 但 又有 

1603
01:01:12,090 --> 01:01:16,320
争论两种方式减少 

1604
01:01:13,950 --> 01:01:18,060
C会遇到的潜在错误

1605
01:01:16,320 --> 01:01:19,950
你和这就是人类 开始的 地方 

1606
01:01:18,060 --> 01:01:21,840
不同意上行和下行

1607
01:01:19,950 --> 01:01:24,090
语言是否应该是语言

1608
01:01:21,840 --> 01:01:26,880
强烈或松散或甚至不打字 

1609
01:01:24,090 --> 01:01:28,800
一点都不好看，让我们看看 

1610
01:01:26,880 --> 01:01:30,660
在一个范例，这 是超级共同 

1611
01:01:28,800 --> 01:01:32,220
看我们什么时候想再做一次 

1612
01:01:30,660 --> 01:01:33,960
再次看看它 究竟是 怎样 的 

1613
01:01:32,220 --> 01:01:36,060
现在用Python做的很少

1614
01:01:33,960 --> 01:01:38,250
让我继续 ，宣布创造一个锅 

1615
01:01:36,060 --> 01:01:40,380
一个名为正 PI的文件并继续 

1616
01:01:38,250 --> 01:01:42,960
并快速写一个程序

1617
01:01:40,380 --> 01:01:45,120
这里所以从CS50让我继续前进 ， 

1618
01:01:42,960 --> 01:01:46,620
import get int所以我们可以得到整数 

1619
01:01:45,120 --> 01:01:49,920
来自用户 让我继续前进并定义 

1620
01:01:46,620 --> 01:01:52,830
一个主要 功能，只是 我做了哪个 

1621
01:01:49,920 --> 01:01:55,770
将是我的变量获得积极的 int 

1622
01:01:52,830 --> 01:01:58,290
并像我们几周那样询问用户 

1623
01:01:55,770 --> 01:02:00,330
如果你记得一个正整数 

1624
01:01:58,290 --> 01:02:02,760
然后就是前进而且非常 

1625
01:02:00,330 --> 01:02:04,410
无聊地将它打印出来就是这样 

1626
01:02:02,760 --> 01:02:06,300
这个计划确实让我继续前进 

1627
01:02:04,410 --> 01:02:08,130
而且只是 回味 而已 

1628
01:02:06,300 --> 01:02:09,900
完全可以复制粘贴这个神秘的东西 

1629
01:02:08,130 --> 01:02:12,330
看着字符串，我们只是疏忽了 

1630
01:02:09,900 --> 01:02:15,210
没有告诉你大多数人的表现 

1631
01:02:12,330 --> 01:02:17,610
这样，如果我这样做， 这是 一个完整的 

1632
01:02:15,210 --> 01:02:21,900
程序除了什么事实 

1633
01:02:17,610 --> 01:02:23,580
不存在但是得到积极的int 

1634
01:02:21,900 --> 01:02:24,930
可能不存在就像它一样 

1635
01:02:23,580 --> 01:02:26,850
在一个星期没有，因为我们必须 

1636
01:02:24,930 --> 01:02:28,410
发明它自己 进入存在 但是 

1637
01:02:26,850 --> 01:02:30,150
得到积极的int不是，只是为了 

1638
01:02:28,410 --> 01:02:33,240
演示着我们试试这个Python 

1639
01:02:30,150 --> 01:02:35,670
一个+ 那个 PI通知我们有名称错误 得到 

1640
01:02:33,240 --> 01:02:37,530
积极的int没有定义好， 所以我们可以 

1641
01:02:35,670 --> 01:02:41,130
修复我们可以字面定义或

1642
01:02:37,530 --> 01:02:42,960
确定所以得到积极的东西它会 

1643
01:02:41,130 --> 01:02:44,520
从用户 那里获取提示

1644
01:02:42,960 --> 01:02:46,440
几个星期前你 想要的字符串

1645
01:02:44,520 --> 01:02:49,530
向他或她展示， 现在让我 走 

1646
01:02:46,440 --> 01:02:52,050
领先并获得一个正 整数 什么 

1647
01:02:49,530 --> 01:02:54,120
我们使用的编程结构类型

1648
01:02:52,050 --> 01:02:57,090
在C中一次又一次地做某事

1649
01:02:54,120 --> 01:02:58,800
再一次肯定但更多的循环 

1650
01:02:57,090 --> 01:03:01,110
特别是至少要做点什么

1651
01:02:58,800 --> 01:03:03,650
一次又一次又一次又一次 

1652
01:03:01,110 --> 01:03:07,500
再次，如果他们不合作do-while 

1653
01:03:03,650 --> 01:03:09,660
在Python中 没有做到 这么方便 

1654
01:03:07,500 --> 01:03:11,610
功能对于用户输入不存在，因此 

1655
01:03:09,660 --> 01:03:13,770
这很好 ，我们 只是需要解决这个问题 

1656
01:03:11,610 --> 01:03:15,240
不同而诚实地用C你可以 

1657
01:03:13,770 --> 01:03:16,980
已经解决了这个问题 你 不同 

1658
01:03:15,240 --> 01:03:18,570
在我们可以 采取的 时候不需要做 

1659
01:03:16,980 --> 01:03:20,760
它远离你C可以把它 带走 

1660
01:03:18,570 --> 01:03:22,320
你仍然可以解决所有问题 

1661
01:03:20,760 --> 01:03:24,630
我们在过去几周里使用了for 

1662
01:03:22,320 --> 01:03:26,490
只是 循环或 while循环 

1663
01:03:24,630 --> 01:03:28,410
是一个很好用的功能， 但我们可以 

1664
01:03:26,490 --> 01:03:30,510
模拟它和pythonic方式 

1665
01:03:28,410 --> 01:03:32,940
这样做是 故意的 

1666
01:03:30,510 --> 01:03:35,250
因为你做了一个无限循环

1667
01:03:32,940 --> 01:03:37,050
想要循环但是逻辑 

1668
01:03:35,250 --> 01:03:38,820
会给我一个无限循环 

1669
01:03:37,050 --> 01:03:40,740
当我的时候 ， 我会突破 它 

1670
01:03:38,820 --> 01:03:42,599
准备跳出 来 ，这将是 

1671
01:03:40,740 --> 01:03:44,819
秋天的约会

1672
01:03:42,599 --> 01:03:46,829
是真的就这样继续 ，并声明 

1673
01:03:44,819 --> 01:03:48,720
名为n的变量从中获取一个int 

1674
01:03:46,829 --> 01:03:51,059
用户并传入相同的提示，以便获取 

1675
01:03:48,720 --> 01:03:53,489
在我们写的工作人员提示是什么

1676
01:03:51,059 --> 01:03:56,190
我输入这里只是复制/粘贴 

1677
01:03:53,489 --> 01:03:57,809
从C 版再到什么 

1678
01:03:56,190 --> 01:03:59,819
我想要突破的情况 

1679
01:03:57,809 --> 01:04:03,329
如果 函数是这个无限循环 

1680
01:03:59,819 --> 01:04:05,729
被 称为获得积极因为如果 

1681
01:04:03,329 --> 01:04:07,829
n是大于 零的话，我有 

1682
01:04:05,729 --> 01:04:10,019
关键字突破还只是像我一样 在 

1683
01:04:07,829 --> 01:04:12,210
CI 可以突破这个 循环然后 

1684
01:04:10,019 --> 01:04:14,549
一旦我这样做，我可以继续 ， 只是 

1685
01:04:12,210 --> 01:04:16,410
我可以 返回n或者那件事 

1686
01:04:14,549 --> 01:04:18,509
我可以稍微凝聚一点 

1687
01:04:16,410 --> 01:04:20,609
返回并立即收紧 

1688
01:04:18,509 --> 01:04:22,349
只是一点点有多种方法可做 

1689
01:04:20,609 --> 01:04:24,690
否则它只会循环 

1690
01:04:22,349 --> 01:04:26,789
永远循环，让我 现在继续 

1691
01:04:24,690 --> 01:04:29,849
并 通过 Python 运行正面的dot pi 

1692
01:04:26,789 --> 01:04:33,569
也可以 是负 1的正整数

1693
01:04:29,849 --> 01:04:35,339
负2 0 ok 1现在确实如此 

1694
01:04:33,569 --> 01:04:36,660
合作所以这只是 一个普通的 

1695
01:04:35,339 --> 01:04:38,609
范式， 这是一种事情 

1696
01:04:36,660 --> 01:04:39,779
学习一门新语言 时 

1697
01:04:38,609 --> 01:04:41,309
老实说，往往会让人失望 

1698
01:04:39,779 --> 01:04:42,900
最初你需要学习 

1699
01:04:41,309 --> 01:04:44,489
JavaScript做你需要的事情的方式 

1700
01:04:42,900 --> 01:04:45,749
学习Python的做事方式 

1701
01:04:44,489 --> 01:04:47,700
但是你开始注意到这些 

1702
01:04:45,749 --> 01:04:48,839
任何时候 所谓的 设计模式 

1703
01:04:47,700 --> 01:04:50,460
Python你想再做一次 

1704
01:04:48,839 --> 01:04:51,869
再次是的你想要循环，但如果 

1705
01:04:50,460 --> 01:04:54,119
你想也许做一些事情

1706
01:04:51,869 --> 01:04:55,769
绝对一次，也许 你 又 

1707
01:04:54,119 --> 01:04:57,390
仍然只是使用一个循环，但你 

1708
01:04:55,769 --> 01:04:59,099
故意诱导典型的 

1709
01:04:57,390 --> 01:05:00,960
无限循环，只是突破 它 

1710
01:04:59,099 --> 01:05:01,289
当你准备好这么一个很普通的时候 

1711
01:05:00,960 --> 01:05:03,509
途径

1712
01:05:01,289 --> 01:05:07,319
所以并非一切都按字面翻译 

1713
01:05:03,509 --> 01:05:12,950
从C来回回答任何问题

1714
01:05:07,319 --> 01:05:12,950
在那是啊和回来 

1715
01:05:23,180 --> 01:05:27,049
真的很好的问题是这个 

1716
01:05:25,069 --> 01:05:29,569
相反，声明的方法更可取

1717
01:05:27,049 --> 01:05:31,700
也许在这里是一个 相等 的 变量 

1718
01:05:29,569 --> 01:05:34,460
一些已知的值，如 零或诸如此类 

1719
01:05:31,700 --> 01:05:36,499
然后更新它 显示答案是 

1720
01:05:34,460 --> 01:05:38,719
因为你的方法是正确的 

1721
01:05:36,499 --> 01:05:39,920
不是因为设计得好

1722
01:05:38,719 --> 01:05:42,229
这没有必要 

1723
01:05:39,920 --> 01:05:44,029
和pythonic的方式， 真的在 

1724
01:05:42,229 --> 01:05:45,499
精心设计的做大多数事情的方法 

1725
01:05:44,029 --> 01:05:46,789
尽可能少用线条 

1726
01:05:45,499 --> 01:05:48,529
只要它仍然可读和 

1727
01:05:46,789 --> 01:05:50,029
可以理解的， 我会认为 这 

1728
01:05:48,529 --> 01:05:51,650
一旦你对 这个 感到满意 

1729
01:05:50,029 --> 01:05:53,930
语法， 但这确实带来 了一个 

1730
01:05:51,650 --> 01:05:57,319
关于另一个话题的有趣观点 

1731
01:05:53,930 --> 01:05:59,749
在C范围 内现在已经消失了 

1732
01:05:57,319 --> 01:06:02,660
至少我们以前看过它的 范围 

1733
01:05:59,749 --> 01:06:04,489
指变量所在的位置和我们 

1734
01:06:02,660 --> 01:06:06,499
它之间基本上是随便定义的

1735
01:06:04,489 --> 01:06:07,789
两个花括号最近打开 

1736
01:06:06,499 --> 01:06:09,829
花括号没有花括号

1737
01:06:07,789 --> 01:06:12,619
所以它变成了变量 

1738
01:06:09,829 --> 01:06:16,069
默认情况下，有功能范围使这里

1739
01:06:12,619 --> 01:06:18,079
当您在第9行 申报 n时，您可以 使用 

1740
01:06:16,069 --> 01:06:20,989
它在第10行的 Python中，你知道 

1741
01:06:18,079 --> 01:06:23,269
你甚至可以用它上线12 连 

1742
01:06:20,989 --> 01:06:25,579
虽然它是在这里声明的

1743
01:06:23,269 --> 01:06:27,680
循环更高， 所以一旦你声明了一个 

1744
01:06:25,579 --> 01:06:29,749
这行上的变量你可以 使用它 

1745
01:06:27,680 --> 01:06:31,700
在 其后的任何地方

1746
01:06:29,749 --> 01:06:33,079
同样的功能所以在某种意义上它是 

1747
01:06:31,700 --> 01:06:34,249
一点不马虎，你允许 

1748
01:06:33,079 --> 01:06:36,140
这样做，但另一方面 它是非常的 

1749
01:06:34,249 --> 01:06:37,489
方便，因为你没有 

1750
01:06:36,140 --> 01:06:39,619
处理像声明 这样的 事情 

1751
01:06:37,489 --> 01:06:41,660
这里的变量只是为了使用 它 

1752
01:06:39,619 --> 01:06:44,269
在这里 ，这是一个较少的 想法 

1753
01:06:41,660 --> 01:06:46,700
所有的权利，让我们来看看只是一个 

1754
01:06:44,269 --> 01:06:48,979
从2周几个例子，其中我们 

1755
01:06:46,700 --> 01:06:50,930
更多介绍了数组和字符串

1756
01:06:48,979 --> 01:06:52,819
一般来看看现在 发生了 什么 变化 

1757
01:06:50,930 --> 01:06:54,880
你会记得在第二周 

1758
01:06:52,819 --> 01:06:56,989
也许我们 约 了一个例子 

1759
01:06:54,880 --> 01:06:59,089
资本，让我继续前进， 

1760
01:06:56,989 --> 01:07:00,799
看第三个版本的第二个 

1761
01:06:59,089 --> 01:07:02,839
大写的 两个但转换为 

1762
01:07:00,799 --> 01:07:05,150
Python 生活中的目的就是采取 

1763
01:07:02,839 --> 01:07:07,279
来自用户的输入并且只是 大写 

1764
01:07:05,150 --> 01:07:09,109
如果我输入，那么其中的 每一个字符 

1765
01:07:07,279 --> 01:07:11,479
我的全名 小写应该来了 

1766
01:07:09,109 --> 01:07:13,400
从cs50 返回全部大写 

1767
01:07:11,479 --> 01:07:13,999
图书馆让我继续前进并导入get 

1768
01:07:13,400 --> 01:07:15,559
串

1769
01:07:13,999 --> 01:07:17,420
所以我有一些来自用户的输入

1770
01:07:15,559 --> 01:07:20,239
然后让我继续前进， 得到 一个 

1771
01:07:17,420 --> 01:07:23,479
来自用户的字符串， 如他们的名字和 

1772
01:07:20,239 --> 01:07:26,930
然后我想继续前进并大写 

1773
01:07:23,479 --> 01:07:29,749
一切都让我继续前进 

1774
01:07:26,930 --> 01:07:31,969
这是CI中的一个奇特的功能 

1775
01:07:29,749 --> 01:07:34,190
本来就像一个for int我就是零 

1776
01:07:31,969 --> 01:07:35,869
我不是英镑，我的意思是你

1777
01:07:34,190 --> 01:07:36,920
记住 迭代 的范例 

1778
01:07:35,869 --> 01:07:38,420
串

1779
01:07:36,920 --> 01:07:42,530
蟒蛇真是太 舒服了 

1780
01:07:38,420 --> 01:07:45,140
在s中看到会导致循环结束 

1781
01:07:42,530 --> 01:07:47,660
字符串s让你访问每一个 

1782
01:07:45,140 --> 01:07:50,120
一次打电话给 那个角色

1783
01:07:47,660 --> 01:07:53,150
变量C等我想要的是什么 

1784
01:07:50,120 --> 01:07:55,040
做一个婴儿 的初步 步骤 

1785
01:07:53,150 --> 01:07:57,140
如果您将 打印出C，请执行步骤 

1786
01:07:55,040 --> 01:08:00,320
只是为了看看会发生什么 让我继续前进 

1787
01:07:57,140 --> 01:08:02,450
在这里做Python的 大写 - 

1788
01:08:00,320 --> 01:08:04,520
让我继续， 输入我的名字 

1789
01:08:02,450 --> 01:08:07,250
小写好吧，为什么 会显示 

1790
01:08:04,520 --> 01:08:10,640
像一个角色一样垂直向上

1791
01:08:07,250 --> 01:08:12,620
每行现在你得到 了免费的在线 免费 

1792
01:08:10,640 --> 01:08:14,420
这一次新线让我们看看你是怎么回事 

1793
01:08:12,620 --> 01:08:17,270
可以禁用它 看起来 很愚蠢 

1794
01:08:14,420 --> 01:08:19,820
说实话，但你说结束等于报价 

1795
01:08:17,270 --> 01:08:22,070
unquote 从而揭示了一个新的特征 

1796
01:08:19,820 --> 01:08:25,070
C 没有它的Python 转向 

1797
01:08:22,070 --> 01:08:26,750
认为Python 不仅具有位置性 

1798
01:08:25,070 --> 01:08:28,400
你 所谓的论据

1799
01:08:26,750 --> 01:08:30,170
只需在逗号之间传递参数

1800
01:08:28,400 --> 01:08:33,470
这就是我们 用 C做什么，但 

1801
01:08:30,170 --> 01:08:35,780
蟒蛇也命名参数 ，从而 

1802
01:08:33,470 --> 01:08:38,090
您可以指定参数的名称

1803
01:08:35,780 --> 01:08:40,280
比一个等号然后价值和 

1804
01:08:38,090 --> 01:08:43,010
命名参数的功率， 即使 

1805
01:08:40,280 --> 01:08:45,260
这是一个很小的例子意味着你 

1806
01:08:43,010 --> 01:08:47,300
有时可以传入你的论点 

1807
01:08:45,260 --> 01:08:48,800
任何你不必记住你的订单

1808
01:08:47,300 --> 01:08:50,810
不必拉起cs50手册或者 

1809
01:08:48,800 --> 01:08:52,970
man页面记住了什么是顺序 

1810
01:08:50,810 --> 01:08:55,310
你可以通过的所有这些论点 

1811
01:08:52,970 --> 01:08:57,320
它们以任何顺序但通过指定 

1812
01:08:55,310 --> 01:08:59,840
参数的名称和等号 

1813
01:08:57,320 --> 01:09:01,820
它的价值和Python 也是如此 

1814
01:08:59,840 --> 01:09:03,290
显然有可选参数 

1815
01:09:01,820 --> 01:09:05,600
到目前为止， 我从来没有 这样 做过 

1816
01:09:03,290 --> 01:09:08,600
输入了单词end和等号

1817
01:09:05,600 --> 01:09:10,580
但Python支持的是默认值 

1818
01:09:08,600 --> 01:09:13,190
参数的值，所以如果你看 

1819
01:09:10,580 --> 01:09:15,740
在这个Python的文档 中 

1820
01:09:13,190 --> 01:09:17,480
相当于这个神秘的序列

1821
01:09:15,740 --> 01:09:19,760
这相当于默认值 

1822
01:09:17,480 --> 01:09:23,150
行为，这是键入 这些 方法都 

1823
01:09:19,760 --> 01:09:24,920
在所有和三个馅饼的 印刷品 

1824
01:09:23,150 --> 01:09:27,050
你应该结束每一行的功能 

1825
01:09:24,920 --> 01:09:29,000
因此，如果是这个默认字符

1826
01:09:27,050 --> 01:09:30,260
你 想要 覆盖 它 你可以 

1827
01:09:29,000 --> 01:09:33,050
将其更改为空字符串 

1828
01:09:30,260 --> 01:09:36,770
引用 - 取消引用 ，如果我现在再次运行它 

1829
01:09:33,050 --> 01:09:37,280
现在用我的名字来完成它 

1830
01:09:36,770 --> 01:09:39,050
得到它

1831
01:09:37,280 --> 01:09:42,050
就像那个角色一样 

1832
01:09:39,050 --> 01:09:44,330
你可以做像哈哈哈哈这样奇怪的事情 

1833
01:09:42,050 --> 01:09:48,020
不是你我不知道你为什么 

1834
01:09:44,330 --> 01:09:49,460
跟着那个但是我的意思是 那个 

1835
01:09:48,020 --> 01:09:50,869
完全相同的事情， 因为你只是 

1836
01:09:49,460 --> 01:09:52,880
改变结束的行 

1837
01:09:50,869 --> 01:09:55,130
不要这样做，而是做其他事情 

1838
01:09:52,880 --> 01:09:57,050
这与它相反，所以假设我想要 

1839
01:09:55,130 --> 01:10:00,560
现在把 它 的 第一个字符 大写 

1840
01:09:57,050 --> 01:10:03,590
事实证明，Python 中的字符串是 

1841
01:10:00,560 --> 01:10:05,719
比C和C中的字符串更强大

1842
01:10:03,590 --> 01:10:07,610
没有那是骗人的字符串权 

1843
01:10:05,719 --> 01:10:09,590
它只是一系列人物 

1844
01:10:07,610 --> 01:10:12,320
由内存中的地址引用

1845
01:10:09,590 --> 01:10:13,940
Python字符串是它的实际对象 

1846
01:10:12,320 --> 01:10:15,860
一个数据结构，如果你考虑 

1847
01:10:13,940 --> 01:10:17,750
看到我们已经结束了 

1848
01:10:15,860 --> 01:10:19,670
我们看看位于 C节点和结构及 

1849
01:10:17,750 --> 01:10:21,889
学生结构，像一个字符串和 

1850
01:10:19,670 --> 01:10:23,000
python就像这个容器里面的 

1851
01:10:21,889 --> 01:10:24,590
哪个都是 那些 

1852
01:10:23,000 --> 01:10:27,050
字符，但在容器或 

1853
01:10:24,590 --> 01:10:29,150
结构也是内置的功能 

1854
01:10:27,050 --> 01:10:31,040
你可以只是一个字符串的 功能 

1855
01:10:29,150 --> 01:10:33,590
如此在C中打电话我们会说 

1856
01:10:31,040 --> 01:10:35,690
像两个鞋面 然后通过的东西 

1857
01:10:33,590 --> 01:10:38,119
作为输入提供给函数调用两个上 

1858
01:10:35,690 --> 01:10:40,489
我们关心Python的角色

1859
01:10:38,119 --> 01:10:43,070
有点翻转字符串的逻辑

1860
01:10:40,489 --> 01:10:44,750
配有内置的功能， 

1861
01:10:43,070 --> 01:10:47,869
允许你对给定的操作 

1862
01:10:44,750 --> 01:10:49,610
字符自动在 Python中 如此 

1863
01:10:47,869 --> 01:10:51,590
语法实际上就是角色本身

1864
01:10:49,610 --> 01:10:53,659
使用点符号， 因为它是一个 

1865
01:10:51,590 --> 01:10:54,710
结构，然后你可以字面上 做 

1866
01:10:53,659 --> 01:10:57,860
哎呀

1867
01:10:54,710 --> 01:11:01,690
你可以，所以你可以清楚地做上层 

1868
01:10:57,860 --> 01:11:05,690
所以这就是说内置在字符串中 

1869
01:11:01,690 --> 01:11:07,790
Python中的类型是一堆 功能 

1870
01:11:05,690 --> 01:11:09,409
其中一个是名为upper的函数 

1871
01:11:07,790 --> 01:11:10,940
与 你怎么称呼它的语法是 

1872
01:11:09,409 --> 01:11:13,610
变量 的名称或名称 

1873
01:11:10,940 --> 01:11:15,619
函数open 的 字符串点名称 

1874
01:11:13,610 --> 01:11:17,480
帕伦关闭了帕伦，而这只是现在 

1875
01:11:15,619 --> 01:11:19,550
范式没有C类型库 

1876
01:11:17,480 --> 01:11:21,199
那些没有两个上限或两个

1877
01:11:19,550 --> 01:11:23,080
现在内置于字符串中的功能 

1878
01:11:21,199 --> 01:11:24,949
本身，这 是一个例子 

1879
01:11:23,080 --> 01:11:26,570
封装或更一般地 

1880
01:11:24,949 --> 01:11:27,889
面向对象编程的东西

1881
01:11:26,570 --> 01:11:31,250
如果你把 喜欢 的一类，你会探索 

1882
01:11:27,889 --> 01:11:33,500
cs50一个烘焙到数据类型 

1883
01:11:31,250 --> 01:11:35,540
本身所有 铁路相关 

1884
01:11:33,500 --> 01:11:38,179
功能并没有降低他们 

1885
01:11:35,540 --> 01:11:40,010
另一个库，所以如果我打扫 一下通过 

1886
01:11:38,179 --> 01:11:42,320
只需移动我的名字即可将光标移动到 

1887
01:11:40,010 --> 01:11:44,630
下一行现在希望你能 

1888
01:11:42,320 --> 01:11:46,940
确实看到大卫输入所有大写字母 

1889
01:11:44,630 --> 01:11:48,349
和以前一样的想法 

1890
01:11:46,940 --> 01:11:50,420
这个长度是一个字符串 

1891
01:11:48,349 --> 01:11:51,440
非常琐碎，但 如果我进去，让我们 

1892
01:11:50,420 --> 01:11:54,949
我继续创建 一个名为的文件 

1893
01:11:51,440 --> 01:11:57,199
如果我想看到的话，那就是 dot pi的英镑 

1894
01:11:54,949 --> 01:11:59,239
cs50 import 获取的字符串长度

1895
01:11:57,199 --> 01:12:00,889
就像 我们之前做的那样让我离开 

1896
01:11:59,239 --> 01:12:02,869
提前为我自己找一个字符串 

1897
01:12:00,889 --> 01:12:04,579
我的名字再次，然后在这里，如果 我想 

1898
01:12:02,869 --> 01:12:06,379
在Python中打印字符串的长度 

1899
01:12:04,579 --> 01:12:08,149
你看到你会说英镑 

1900
01:12:06,379 --> 01:12:10,729
Python它与你有点不同

1901
01:12:08,149 --> 01:12:12,019
实际上只是说阿姨Len的长度如此 

1902
01:12:10,729 --> 01:12:15,679
如果我继续前进并通过它 

1903
01:12:12,019 --> 01:12:17,510
纯正的英镑类型以我的名字命名 

1904
01:12:15,679 --> 01:12:18,979
希望我确实看到五个和那里 

1905
01:12:17,510 --> 01:12:21,579
没有你需要关心的 想法 

1906
01:12:18,979 --> 01:12:25,510
像反斜杠零 ， 以 

1907
01:12:21,579 --> 01:12:25,510
终止字符串是的 

1908
01:12:30,800 --> 01:12:36,619
事实上没有， 所以这是一个非常好的 

1909
01:12:34,010 --> 01:12:38,510
观察让我们倒回实际上 

1910
01:12:36,619 --> 01:12:40,129
改善这一点，而 不仅仅是 

1911
01:12:38,510 --> 01:12:42,739
把它翻译成我们的 

1912
01:12:40,129 --> 01:12:45,949
C中的比较例子 让我继续 

1913
01:12:42,739 --> 01:12:49,429
在这里，实际上说你知道什么是 

1914
01:12:45,949 --> 01:12:51,649
得到s，然后让我 打印 

1915
01:12:49,429 --> 01:12:53,149
也许让我们看看会发生什么 让我 

1916
01:12:51,649 --> 01:12:57,469
回到 这里然后运行Python if 

1917
01:12:53,149 --> 01:12:58,820
资本化 进入 大卫和它 

1918
01:12:57,469 --> 01:13:00,260
在整个弦乐上运作良好 

1919
01:12:58,820 --> 01:13:04,249
直觉和老实说我不需要 

1920
01:13:00,260 --> 01:13:07,129
这样做我可以说 是 相当高 

1921
01:13:04,249 --> 01:13:10,879
在这里，真的削减这一点，做 

1922
01:13:07,129 --> 01:13:13,249
我 名字 的大写型Python 

1923
01:13:10,879 --> 01:13:15,589
这仍然有效，如果我真的想 

1924
01:13:13,249 --> 01:13:18,559
可以看上我甚至都不需要（7）。 我 

1925
01:13:15,589 --> 01:13:20,780
可以把这摆脱这个摆脱 

1926
01:13:18,559 --> 01:13:22,249
这里立即呼叫 用户 上层 

1927
01:13:20,780 --> 01:13:24,859
输入和Whittle这个降到了 

1928
01:13:22,249 --> 01:13:26,689
大卫的单行类型和 工作 

1929
01:13:24,859 --> 01:13:28,969
所以你只是 得到很多很多 很多 

1930
01:13:26,689 --> 01:13:30,679
更具表现力的好问题 和 

1931
01:13:28,969 --> 01:13:33,469
所以你怎么 知道这样的 事情 

1932
01:13:30,679 --> 01:13:35,149
除了 谷歌将会 存在这种情况 

1933
01:13:33,469 --> 01:13:36,739
在这种情况下真的成为你的朋友

1934
01:13:35,149 --> 01:13:38,570
你现在想 知道 

1935
01:13:36,739 --> 01:13:40,159
有不同 版本 的Python 

1936
01:13:38,570 --> 01:13:41,869
世界是一种坚持，是 

1937
01:13:40,159 --> 01:13:43,820
仍然使用很多人版本二 

1938
01:13:41,869 --> 01:13:45,739
Python的历史很多年了 

1939
01:13:43,820 --> 01:13:47,300
现在我们正在使用三个版本，这 

1940
01:13:45,739 --> 01:13:49,550
它是世界的走向 ，确实 

1941
01:13:47,300 --> 01:13:50,959
Python 二将被正式弃用 

1942
01:13:49,550 --> 01:13:52,969
或在几年内逐步淘汰

1943
01:13:50,959 --> 01:13:54,289
理论上所以当你谷歌你 

1944
01:13:52,969 --> 01:13:55,519
只是想要注意 这一点 

1945
01:13:54,289 --> 01:13:57,349
你也不小心走自己的路 

1946
01:13:55,519 --> 01:13:59,089
旧教程旧文档和

1947
01:13:57,349 --> 01:14:03,109
像这样让我继续 谷歌 

1948
01:13:59,089 --> 01:14:04,399
Python 三弦或搅拌和上部 

1949
01:14:03,109 --> 01:14:06,800
只是为了看看我能否到达

1950
01:14:04,399 --> 01:14:09,800
这里有文档，你有很多 

1951
01:14:06,800 --> 01:14:11,030
教程，但如果我们在这里关注什么 

1952
01:14:09,800 --> 01:14:12,139
你通常会想看看 

1953
01:14:11,030 --> 01:14:15,319
至少 对于官方 

1954
01:14:12,139 --> 01:14:17,449
文档是你看到的Python文档 

1955
01:14:15,319 --> 01:14:18,360
在URL中它是 版本 3，那是 

1956
01:14:17,449 --> 01:14:19,409
我们想去的地方 

1957
01:14:18,360 --> 01:14:21,330
所以让我继续点击这个 

1958
01:14:19,409 --> 01:14:24,000
常见的字符串运算符，我会 

1959
01:14:21,330 --> 01:14:25,980
放弃这个我认为 个人蟒蛇 

1960
01:14:24,000 --> 01:14:27,600
文档不是非常新手

1961
01:14:25,980 --> 01:14:29,280
友好，就像它写得相当神秘

1962
01:14:27,600 --> 01:14:31,260
你有点必须真正去挖掘 

1963
01:14:29,280 --> 01:14:32,699
了解某些事情 很好 

1964
01:14:31,260 --> 01:14:33,750
随着时间的推移，你会感到很舒服

1965
01:14:32,699 --> 01:14:35,850
但如果你感觉有点儿 

1966
01:14:33,750 --> 01:14:37,770
哦，我的 上帝，我 只是想要 淹没 

1967
01:14:35,850 --> 01:14:41,070
像大家一样了解鞋帮 

1968
01:14:37,770 --> 01:14:42,869
这样- 所以 命令F的ctrl F是 

1969
01:14:41,070 --> 01:14:46,560
你的朋友上层让我继续前进 

1970
01:14:42,869 --> 01:14:50,400
搜索这一点 ，它实际上不是 上 

1971
01:14:46,560 --> 01:14:52,830
此页面作为 其字符串字符串方法 

1972
01:14:50,400 --> 01:14:54,480
这里我们去字符串方法好吧 

1973
01:14:52,830 --> 01:14:58,080
字符串方法让我继续前进， 

1974
01:14:54,480 --> 01:15:00,119
这里搜索上下都是 

1975
01:14:58,080 --> 01:15:02,340
公约将这样的文件

1976
01:15:00,119 --> 01:15:04,469
是有 问题的数据类型 的名称 

1977
01:15:02,340 --> 01:15:06,210
搅拌 字符串函数的名称 

1978
01:15:04,469 --> 01:15:07,830
在这里它会在括号中告诉你是否 

1979
01:15:06,210 --> 01:15:09,869
它需要任何参数，但事实并非如此 

1980
01:15:07,830 --> 01:15:11,400
所以它返回一个字符串的副本 

1981
01:15:09,869 --> 01:15:13,290
与所有套装字符

1982
01:15:11,400 --> 01:15:14,699
转换为大写只是意味着 

1983
01:15:13,290 --> 01:15:16,949
基本上字母表的字母 

1984
01:15:14,699 --> 01:15:18,449
然后是一些额外的文档 

1985
01:15:16,949 --> 01:15:20,070
等等相当低级别 

1986
01:15:18,449 --> 01:15:22,110
很快这些都是 等价 

1987
01:15:20,070 --> 01:15:24,119
手册页中没有cs50 

1988
01:15:22,110 --> 01:15:25,710
Python的参考仅适用于C语言 

1989
01:15:24,119 --> 01:15:27,540
所以才意识到这就是这个 

1990
01:15:25,710 --> 01:15:29,340
文件可用 ，你会 

1991
01:15:27,540 --> 01:15:31,230
注意那里有一串功能条 

1992
01:15:29,340 --> 01:15:33,780
实际上是一种流行的或L 

1993
01:15:31,230 --> 01:15:35,369
如果你有白色条带或我们的条带

1994
01:15:33,780 --> 01:15:36,690
一行开头或结尾 的空格

1995
01:15:35,369 --> 01:15:38,760
因为这些你的 人类得到了一点点 

1996
01:15:36,690 --> 01:15:40,710
马虎或文件中有新行 

1997
01:15:38,760 --> 01:15:42,480
你可以在字符串上调用strip并获取 

1998
01:15:40,710 --> 01:15:44,460
摆脱空白的左侧和 右侧 

1999
01:15:42,480 --> 01:15:45,510
有点清理它 非常 有用 

2000
01:15:44,460 --> 01:15:47,010
对于数据科学这样的事情

2001
01:15:45,510 --> 01:15:48,900
数据的应用和分析 

2002
01:15:47,010 --> 01:15:50,670
你只是清理 杂乱的数据所以 

2003
01:15:48,900 --> 01:15:52,590
许多类似的功能都是内置的 

2004
01:15:50,670 --> 01:15:54,659
你 没事 让我们一起来看看 

2005
01:15:52,590 --> 01:15:57,239
在其他一些让人想起的例子中 

2006
01:15:54,659 --> 01:15:58,830
我们在C中所具有的功能就是这样 

2007
01:15:57,239 --> 01:16:00,449
一个人在这里假设我 想写一个 

2008
01:15:58,830 --> 01:16:03,090
采用命令行的程序 

2009
01:16:00,449 --> 01:16:06,300
争论很像我们调整大小

2010
01:16:03,090 --> 01:16:08,040
从cs50开始今天的故事

2011
01:16:06,300 --> 01:16:10,380
我们甚至不使用cs50 库 

2012
01:16:08,040 --> 01:16:13,170
如果你想访问argh，让我们这样做

2013
01:16:10,380 --> 01:16:19,500
费用召回，看起来像这样 

2014
01:16:13,170 --> 01:16:21,690
int argc string Arg V看起来像 

2015
01:16:19,500 --> 01:16:23,790
不幸的是，如果你是这样的话 

2016
01:16:21,690 --> 01:16:25,380
如果 你 不使用main那就太好了 

2017
01:16:23,790 --> 01:16:27,090
仍然可以使用命令行参数 和 

2018
01:16:25,380 --> 01:16:28,530
你可以，但你 必须输入他们 这是 

2019
01:16:27,090 --> 01:16:32,010
一个为您 提供访问权限的库

2020
01:16:28,530 --> 01:16:32,350
从 囊肿或系统库中你可以 

2021
01:16:32,010 --> 01:16:34,210
在 

2022
01:16:32,350 --> 01:16:35,830
或Arg V 和Python， 它给你 

2023
01:16:34,210 --> 01:16:37,660
访问命令行参数作为 

2024
01:16:35,830 --> 01:16:40,960
功能然后你可以说 类似的东西 

2025
01:16:37,660 --> 01:16:43,540
这个如果Arc V的长度是多少 

2026
01:16:40,960 --> 01:16:46,840
只是数组调用，C等于等于 

2027
01:16:43,540 --> 01:16:48,430
两个 然后继续 打招呼和 

2028
01:16:46,840 --> 01:16:52,660
让我们继续打印出来 

2029
01:16:48,430 --> 01:16:56,200
在精氨酸v一个类型的用户否则 我们 

2030
01:16:52,660 --> 01:16:58,090
只是在默认情况下打个招呼世界所以在 

2031
01:16:56,200 --> 01:17:00,100
英语如果用户发生了什么 

2032
01:16:58,090 --> 01:17:00,820
键入的 命令行 参数说 

2033
01:17:00,100 --> 01:17:03,100
你好

2034
01:17:00,820 --> 01:17:04,840
如果人类没有打字， 那么某某 

2035
01:17:03,100 --> 01:17:07,390
在一个命令行参数中 

2036
01:17:04,840 --> 01:17:09,640
只是说默认你好世界 所以让 

2037
01:17:07,390 --> 01:17:12,760
我保存这个做 Arg v1的 Python 或 

2038
01:17:09,640 --> 01:17:14,920
相反 为零输入没关系我没有输入 

2039
01:17:12,760 --> 01:17:17,460
在命令之后的一个词现在让我们这样做 

2040
01:17:14,920 --> 01:17:20,080
它又一次 ，我将输入Brian的名字 

2041
01:17:17,460 --> 01:17:23,770
进入你好布莱恩让我们再做一次 

2042
01:17:20,080 --> 01:17:25,690
Veronica Veronica 现在 进入 那里 

2043
01:17:23,770 --> 01:17:28,300
东西是 不太一样 

2044
01:17:25,690 --> 01:17:32,290
看我输入了多少单词

2045
01:17:28,300 --> 01:17:37,480
提示三 如此建议 

2046
01:17:32,290 --> 01:17:38,710
这是我们的V 0 V 1和我们的V 2 和 

2047
01:17:37,480 --> 01:17:42,100
但我正在打印 

2048
01:17:38,710 --> 01:17:44,500
Arg v1不是arg v2所以 我怎么 想 

2049
01:17:42,100 --> 01:17:48,280
关于这个代码是正确的，但它是 

2050
01:17:44,500 --> 01:17:50,410
与C不同，Arg V是什么 

2051
01:17:48,280 --> 01:17:59,260
在运行命令时技术上存储

2052
01:17:50,410 --> 01:18:04,210
像这样记住让我们在 C或者中 倒带 

2053
01:17:59,260 --> 01:18:05,820
v-0存储 了文件 的名称 或 

2054
01:18:04,210 --> 01:18:08,170
您刚刚 运行 的程序的名称

2055
01:18:05,820 --> 01:18:10,300
注意我刚刚运行的程序是 

2056
01:18:08,170 --> 01:18:13,150
称为Python ，所以你会想 

2057
01:18:10,300 --> 01:18:14,860
艺术 V-0将不得不 在Python的，但 

2058
01:18:13,150 --> 01:18:16,540
它不是因为 我 注意到了 

2059
01:18:14,860 --> 01:18:18,580
打印我们的 v1 你会 认为那是 

2060
01:18:16,540 --> 01:18:21,640
0-1你会认为我 刚刚打招呼 

2061
01:18:18,580 --> 01:18:24,760
argh V 0点PI，但我没有ar1 b1 我 

2062
01:18:21,640 --> 01:18:26,470
清楚地印在Veronica或Brian上 

2063
01:18:24,760 --> 01:18:29,050
它的原因是器官是0 

2064
01:18:26,470 --> 01:18:31,300
这意味着 这 就像艺术 v- 1 

2065
01:18:29,050 --> 01:18:33,160
python 被排除在 参数之外 

2066
01:18:31,300 --> 01:18:35,140
矢量，因为它被称为命令行 

2067
01:18:33,160 --> 01:18:36,610
参数不包括的名称 

2068
01:18:35,140 --> 01:18:39,040
翻译， 但否则它的工作原理 

2069
01:18:36,610 --> 01:18:41,880
因为它在 一个 做一次完全一样 

2070
01:18:39,040 --> 01:18:43,780
时间和通知也与这个新 的 

2071
01:18:41,880 --> 01:18:45,820
建议注意你能做什么

2072
01:18:43,780 --> 01:18:49,329
只要你有访问 数组 

2073
01:18:45,820 --> 01:18:52,480
如果我进入我们的v1点 馅饼 和 

2074
01:18:49,329 --> 01:18:55,810
再次导入Arg V 让我 继续吧 

2075
01:18:52,480 --> 01:18:58,449
只是你 知道 Arg V中的 4s 

2076
01:18:55,810 --> 01:19:00,579
提前打印出来的确如此 

2077
01:18:58,449 --> 01:19:03,940
简洁是 什么让我这么做 

2078
01:19:00,579 --> 01:19:05,770
继续做Arg V 1的Python进入

2079
01:19:03,940 --> 01:19:08,139
它只是打印出 的名称 

2080
01:19:05,770 --> 01:19:10,750
文件如果我继续说foo bar Baz 

2081
01:19:08,139 --> 01:19:12,460
三颗，打印出 所有的 随机单词 

2082
01:19:10,750 --> 01:19:14,320
那些话，所以有什么强大的

2083
01:19:12,460 --> 01:19:16,780
老实说，Python就是循环 

2084
01:19:14,320 --> 01:19:19,179
没有int 我不到加上任何一个 

2085
01:19:16,780 --> 01:19:21,489
你只是说给 我一个名为s的变量 

2086
01:19:19,179 --> 01:19:22,989
并遍历整个 

2087
01:19:21,489 --> 01:19:25,510
在推定的右边的东西

2088
01:19:22,989 --> 01:19:27,489
这种情况下你可以成为一个阵列

2089
01:19:25,510 --> 01:19:30,219
如果我 愿意的 话比那更强大 

2090
01:19:27,489 --> 01:19:31,929
在C周前看看中的人物 

2091
01:19:30,219 --> 01:19:35,619
这些字符串让我做弧v2点我 

2092
01:19:31,929 --> 01:19:40,030
假设这会迭代每个

2093
01:19:35,619 --> 01:19:45,070
在艺术V中的字符串， 然后在这里迭代 

2094
01:19:40,030 --> 01:19:49,449
我可以 为C做的每一个角色

2095
01:19:45,070 --> 01:19:52,000
在可现在打印出的性格让 

2096
01:19:49,449 --> 01:19:54,790
现在，当我运行这个相同的命令 ，但是 ， 

2097
01:19:52,000 --> 01:19:59,320
arc v2 dot 我注意到会发生什么 

2098
01:19:54,790 --> 01:20:01,510
让我稍微提一下吧 

2099
01:19:59,320 --> 01:20:04,119
打印每个单词的每个字符

2100
01:20:01,510 --> 01:20:06,310
一次一个，但这次是这样做的 

2101
01:20:04,119 --> 01:20:08,579
基于使用这两个for循环 所以 

2102
01:20:06,310 --> 01:20:11,079
当你有一个时 ，这是什么意思

2103
01:20:08,579 --> 01:20:12,610
我们称之为数组你可以迭代 

2104
01:20:11,079 --> 01:20:14,110
当你 在数组中的所有内容

2105
01:20:12,610 --> 01:20:15,969
有一个字符串， 你可以 迭代每一个 

2106
01:20:14,110 --> 01:20:17,440
字符串中的字符 ，这 是 

2107
01:20:15,969 --> 01:20:19,810
Python 只是奇妙的地方 

2108
01:20:17,440 --> 01:20:23,530
灵活地一次又一次地这样做

2109
01:20:19,810 --> 01:20:25,599
好吧，让我们来看看让我们看看 

2110
01:20:23,530 --> 01:20:27,790
比较我们已复制的字符串 

2111
01:20:25,599 --> 01:20:28,719
串，让我们继续前进， 在 执行此操作 

2112
01:20:27,790 --> 01:20:30,400
蟒蛇

2113
01:20:28,719 --> 01:20:32,500
回想起我们碰到了一个像

2114
01:20:30,400 --> 01:20:34,239
C的基本限制，它会 

2115
01:20:32,500 --> 01:20:36,849
我们有例子时似乎编程

2116
01:20:34,239 --> 01:20:38,770
在当天称为掉期和无交换

2117
01:20:36,849 --> 01:20:40,900
我刚刚尝试交换两个

2118
01:20:38,770 --> 01:20:43,150
值x和y并记得我 

2119
01:20:40,900 --> 01:20:45,429
像X这样的硬编码是1和 Y. 

2120
01:20:43,150 --> 01:20:49,630
是2，整个目标只是为了 

2121
01:20:45,429 --> 01:20:51,610
首先说X就是这样 - 而且这样的Y就是这样 

2122
01:20:49,630 --> 01:20:54,010
让我继续 这样 做 

2123
01:20:51,610 --> 01:20:56,440
格式字符串， 然后我想打印 

2124
01:20:54,010 --> 01:20:59,560
这又是我在这里的某个地方 

2125
01:20:56,440 --> 01:21:00,970
想要交换X和 Y 以便标点符号 

2126
01:20:59,560 --> 01:21:02,680
我们对 什么 的 探索 

2127
01:21:00,970 --> 01:21:05,380
如果你 想交换两个， Python可以 做 

2128
01:21:02,680 --> 01:21:08,680
变量x和y 这很好只是 做了 

2129
01:21:05,380 --> 01:21:10,990
和它的 这片神奇的贝壳游戏 

2130
01:21:08,680 --> 01:21:12,790
从技术上讲 ，它只适用于Python 

2131
01:21:10,990 --> 01:21:15,370
这些 就是 所谓的元组 

2132
01:21:12,790 --> 01:21:16,900
留下 它是一个X逗号 Y对它的纬度 

2133
01:21:15,370 --> 01:21:19,810
逗号经度所以有一个实际的 

2134
01:21:16,900 --> 01:21:21,820
什么是潜在的心理模型

2135
01:21:19,810 --> 01:21:23,200
在这里，但 实际上 你是字面意思 

2136
01:21:21,820 --> 01:21:25,360
切换它们，你不需要 

2137
01:21:23,200 --> 01:21:28,810
临时变量Python语言 

2138
01:21:25,360 --> 01:21:30,460
好好照顾你 

2139
01:21:28,810 --> 01:21:32,440
让我们来看一个更强大的功能 

2140
01:21:30,460 --> 01:21:34,600
还是这一次 使用 ，但什么 

2141
01:21:32,440 --> 01:21:37,870
我刚才 真的叫了一个清单 

2142
01:21:34,600 --> 01:21:39,550
我们以Arg V 0 1 2为例 

2143
01:21:37,870 --> 01:21:41,800
而我正在称他们为我们的数组 

2144
01:21:39,550 --> 01:21:44,860
它们不再是Python的数组了 

2145
01:21:41,800 --> 01:21:46,660
没有数组Python有列表和

2146
01:21:44,860 --> 01:21:48,850
列表听起来让人想起链接列表 

2147
01:21:46,660 --> 01:21:51,160
事实上，他们使用的是Python 

2148
01:21:48,850 --> 01:21:52,810
您没有的可调整大小的列表

2149
01:21:51,160 --> 01:21:53,680
提前决定他们 有 多大 或者 

2150
01:21:52,810 --> 01:21:55,900
它们有多小

2151
01:21:53,680 --> 01:21:57,520
他们会为你成长和缩小

2152
01:21:55,900 --> 01:21:58,480
就像链接列表一样， 但是你 

2153
01:21:57,520 --> 01:22:01,830
不必编写链表 

2154
01:21:58,480 --> 01:22:01,830
亲爱的，是的 

2155
01:22:04,320 --> 01:22:14,230
当然可以让我打开 那个文件 

2156
01:22:13,360 --> 01:22:23,800
RV1 

2157
01:22:14,230 --> 01:22:26,230
这一个哦，这一个在这里是的你 

2158
01:22:23,800 --> 01:22:27,579
仍然可以这么ar 我称它为阵列 

2159
01:22:26,230 --> 01:22:29,829
但刚才这是一个白色的谎言

2160
01:22:27,579 --> 01:22:31,389
它实际上是一个列表链接列表但是 

2161
01:22:29,829 --> 01:22:33,039
而C中的链表却没有 

2162
01:22:31,389 --> 01:22:34,360
允许您使用 方括号 你 

2163
01:22:33,039 --> 01:22:36,130
必须使用for 循环或 while循环 

2164
01:22:34,360 --> 01:22:38,199
迭代整个 事情来寻找 

2165
01:22:36,130 --> 01:22:40,179
你在 Python中寻找的是什么

2166
01:22:38,199 --> 01:22:41,619
你可以使用的东西就在列表中 

2167
01:22:40,179 --> 01:22:47,590
是方括号来得到那个 

2168
01:22:41,619 --> 01:22:49,090
特定元素哦，我可以拥有， 我 

2169
01:22:47,590 --> 01:22:52,690
我没有使用F只是因为坦率地说 

2170
01:22:49,090 --> 01:22:54,909
说它最终变得丑陋但是是的 

2171
01:22:52,690 --> 01:22:56,769
我本可以做到这一点来实现 

2172
01:22:54,909 --> 01:22:59,710
它只是开始完全相同的 效果 

2173
01:22:56,769 --> 01:23:02,409
看起来很神秘， 所以让我们真的 

2174
01:22:59,710 --> 01:23:04,960
引入一个本身就是数据的列表 

2175
01:23:02,409 --> 01:23:08,289
键入Python 以及 语言 

2176
01:23:04,960 --> 01:23:10,329
像C ++和Java，如果你们有些人 

2177
01:23:08,289 --> 01:23:12,429
那个背景也在列表中 

2178
01:23:10,329 --> 01:23:14,019
dot pi 让我继续前进 吧 

2179
01:23:12,429 --> 01:23:16,150
下面让我先从中 导入 

2180
01:23:14,019 --> 01:23:17,650
cs50库 获取 int 以便我们可以获得 

2181
01:23:16,150 --> 01:23:18,670
来自用户的一寸让我付出 

2182
01:23:17,650 --> 01:23:24,070
我自己一个阵

2183
01:23:18,670 --> 01:23:25,960
又名现在是Python 中 的列表， 所以在C中你 

2184
01:23:24,070 --> 01:23:27,460
无法真正表达这个想法 

2185
01:23:25,960 --> 01:23:30,190
Python如果你想要一个名为的变量 

2186
01:23:27,460 --> 01:23:32,409
数字，你想初始化它 

2187
01:23:30,190 --> 01:23:34,239
一个空的列表， 你真的 打开了 

2188
01:23:32,409 --> 01:23:36,460
托架闭括号 中 没有数 

2189
01:23:34,239 --> 01:23:39,429
他们之间和之前没有分号 

2190
01:23:36,460 --> 01:23:41,230
让我们现在永远做以下事情，直到 

2191
01:23:39,429 --> 01:23:43,389
我打破了 这个让我继续前进 

2192
01:23:41,230 --> 01:23:45,489
得到的只是由 来自 用户的 数量 

2193
01:23:43,389 --> 01:23:49,030
问他们一些号码然后让我 

2194
01:23:45,489 --> 01:23:50,619
如果没有号码继续说出来 

2195
01:23:49,030 --> 01:23:52,179
对此，这是 暂时的 

2196
01:23:50,619 --> 01:23:54,639
只是让我通过击打退出 

2197
01:23:52,179 --> 01:23:56,289
ctrl D正如我们所讨论的那样简单

2198
01:23:54,639 --> 01:23:59,050
虽然回来了， 但这 只是一个UI功能 

2199
01:23:56,289 --> 01:24:01,800
所以这就是我想的那种酷 

2200
01:23:59,050 --> 01:24:04,179
我想实现的概念 

2201
01:24:01,800 --> 01:24:06,010
检查是否点亮了该号码

2202
01:24:04,179 --> 01:24:08,260
输入的用户已在列表中 

2203
01:24:06,010 --> 01:24:09,610
如果没有，我会继续前进 

2204
01:24:08,260 --> 01:24:13,749
并且这样做但首先让我们这样做 

2205
01:24:09,610 --> 01:24:15,999
数字点附加数字，这是一个 

2206
01:24:13,749 --> 01:24:17,950
新功能所以我想在这里做什么 

2207
01:24:15,999 --> 01:24:20,830
数字的数量 

2208
01:24:17,950 --> 01:24:22,930
在一秒钟让 我继续 打印 

2209
01:24:20,830 --> 01:24:25,660
这个节目有多少是有抱负的 

2210
01:24:22,930 --> 01:24:27,550
在最顶层做我正在导入get 

2211
01:24:25,660 --> 01:24:29,470
我正好在最下方 

2212
01:24:27,550 --> 01:24:31,690
给自己一个空阵列现在称为 

2213
01:24:29,470 --> 01:24:34,030
一个名为数字的列表然后我做了 

2214
01:24:31,690 --> 01:24:35,800
以下永远继续前进并获得 

2215
01:24:34,030 --> 01:24:37,510
用户的号码， 如果他或 她 

2216
01:24:35,800 --> 01:24:39,370
实际上并没有输入数字只是休息 

2217
01:24:37,510 --> 01:24:41,350
出 这个程序做，但 

2218
01:24:39,370 --> 01:24:43,930
这是新功能，就像使用 

2219
01:24:41,350 --> 01:24:45,430
字符串它们是对象可以 这么说 

2220
01:24:43,930 --> 01:24:48,310
他们是 具有数据结构

2221
01:24:45,430 --> 01:24:50,140
内置的函数，所以列表有 

2222
01:24:48,310 --> 01:24:52,330
内置的功能实际上是一个 

2223
01:24:50,140 --> 01:24:54,340
每一个Python列表内部功能

2224
01:24:52,330 --> 01:24:56,290
叫做追加，字面意思就是这样 

2225
01:24:54,340 --> 01:24:59,080
你打电话追加，这取决于什么 

2226
01:24:56,290 --> 01:25:02,460
它的输入 是 列表 本身 

2227
01:24:59,080 --> 01:25:04,810
如此用C，你可能不得不 使用 上 

2228
01:25:02,460 --> 01:25:06,910
realloc 你可能不得不 添加 

2229
01:25:04,810 --> 01:25:08,290
列表 末尾 的东西都没有 

2230
01:25:06,910 --> 01:25:10,030
这种情况发生在高处 

2231
01:25:08,290 --> 01:25:12,160
等级，你说这个附加到列表中 

2232
01:25:10,030 --> 01:25:14,740
让语言照顾它 

2233
01:25:12,160 --> 01:25:16,720
然后你在这里 我保持 一致 

2234
01:25:14,740 --> 01:25:18,370
它最后的方式只是说 

2235
01:25:16,720 --> 01:25:20,410
数字的数字，如迭代全部 

2236
01:25:18,370 --> 01:25:22,690
列表中的木材和打印出来的 

2237
01:25:20,410 --> 01:25:25,750
一次一个让我 试试这个 让我 

2238
01:25:22,690 --> 01:25:28,210
在这里下来做python这是 

2239
01:25:25,750 --> 01:25:32,110
列表操作嗨，让我继续 打字 

2240
01:25:28,210 --> 01:25:33,910
在一个像13 42 50的数字，我会 

2241
01:25:32,110 --> 01:25:36,190
击中控制D这 意味着 我就是它 

2242
01:25:33,910 --> 01:25:37,780
完成了，我们看到 了三个 数字 

2243
01:25:36,190 --> 01:25:39,340
它看起来有点 愚蠢， 因为你 

2244
01:25:37,780 --> 01:25:43,180
知道我认为我需要在 这里 打印 

2245
01:25:39,340 --> 01:25:46,240
让我们解决这个让我重新运行这个13 42 

2246
01:25:43,180 --> 01:25:48,970
50 控制D 我们每 行 一个 

2247
01:25:46,240 --> 01:25:50,950
但是这个程序真的很有用 

2248
01:25:48,970 --> 01:25:53,680
有点像我想要的臭虫 

2249
01:25:50,950 --> 01:25:55,240
独特的数字现在我有 三个13但是 

2250
01:25:53,680 --> 01:25:56,770
理想情况下只需要每个副本 

2251
01:25:55,240 --> 01:25:58,840
我想要什么原因 

2252
01:25:56,770 --> 01:26:01,600
独特性很好注意你多么容易

2253
01:25:58,840 --> 01:26:04,570
可以表达如果我的目标是什么 

2254
01:26:01,600 --> 01:26:06,640
只有条件地添加一个数字 

2255
01:26:04,570 --> 01:26:09,160
号码列表，如果它不是已经 存在 

2256
01:26:06,640 --> 01:26:10,960
你会怎样在C中 做到 这一点你有 一个 

2257
01:26:09,160 --> 01:26:13,090
数组称为数字，你想

2258
01:26:10,960 --> 01:26:16,930
第一次检查是该数组中的数字 

2259
01:26:13,090 --> 01:26:18,040
你会在英语 for循环做

2260
01:26:16,930 --> 01:26:20,050
对，你可能从左边开始 

2261
01:26:18,040 --> 01:26:21,430
遍历整个数组寻找 

2262
01:26:20,050 --> 01:26:23,470
数字， 然后 结束真或 

2263
01:26:21,430 --> 01:26:24,730
假它在那里 它并不难，但是 

2264
01:26:23,470 --> 01:26:26,650
如果 要写更多内容会 有点烦人 

2265
01:26:24,730 --> 01:26:30,130
代码情侣行四行for for 

2266
01:26:26,650 --> 01:26:31,580
循环Python 中 只是说你的意思，如果 

2267
01:26:30,130 --> 01:26:35,870
数不 

2268
01:26:31,580 --> 01:26:38,060
数字吊坠 ，它读得很多 

2269
01:26:35,870 --> 01:26:40,160
更像是在 这一天结束 

2270
01:26:38,060 --> 01:26:42,830
一些舒曼写了for循环 

2271
01:26:40,160 --> 01:26:44,630
做那个操作，但我们更多的perp 

2272
01:26:42,830 --> 01:26:47,090
现代程序员现在可以说是否

2273
01:26:44,630 --> 01:26:48,920
数字不是数字 吊坠 等等 

2274
01:26:47,090 --> 01:26:51,230
它意味着阅读更多英语 

2275
01:26:48,920 --> 01:26:54,650
让我们现在试试十三 十三 

2276
01:26:51,230 --> 01:26:56,300
五十完成现在我只得到一份 

2277
01:26:54,650 --> 01:26:58,160
十三，因为它正在检查 

2278
01:26:56,300 --> 01:27:01,130
对我来说， 现在运行时间仍然是一个 

2279
01:26:58,160 --> 01:27:03,050
问题从理论上 考虑 你的意思 

2280
01:27:01,130 --> 01:27:04,880
还在浪费一些时间寻找一个 

2281
01:27:03,050 --> 01:27:06,470
数字， 因为有人写了代码 

2282
01:27:04,880 --> 01:27:08,210
可能是线性搜索也许它是二进制的

2283
01:27:06,470 --> 01:27:09,710
搜索它是否排序但有人写道 

2284
01:27:08,210 --> 01:27:11,210
那个代码，但重点是这些 

2285
01:27:09,710 --> 01:27:13,460
更高级的 语言这些更现代 

2286
01:27:11,210 --> 01:27:15,770
Python之类的语言不是我们的 

2287
01:27:13,460 --> 01:27:17,390
问题必然只会成为我们的问题

2288
01:27:15,770 --> 01:27:19,160
问题如果程序 太慢了 

2289
01:27:17,390 --> 01:27:23,240
由于某种原因， 我们真的需要 

2290
01:27:19,160 --> 01:27:25,040
深入了解为什么 好的 杂草 

2291
01:27:23,240 --> 01:27:26,570
从句法上看最后一个特征 

2292
01:27:25,040 --> 01:27:28,700
在我们尝试这个更广泛的之前 

2293
01:27:26,570 --> 01:27:30,620
问题让我继续 保存文件 

2294
01:27:28,700 --> 01:27:32,600
称为struct zero dot I 

2295
01:27:30,620 --> 01:27:34,520
让人联想到struct 0 dot C的几个 

2296
01:27:32,600 --> 01:27:37,820
几个星期后，让我继续前进 

2297
01:27:34,520 --> 01:27:39,650
cs50 库导入获取字符串 let 

2298
01:27:37,820 --> 01:27:41,630
我继续给自己一个阵列 

2299
01:27:39,650 --> 01:27:43,580
这次称学生为空 

2300
01:27:41,630 --> 01:27:45,110
或者一个名为学生的名单然后让 

2301
01:27:43,580 --> 01:27:48,080
为了这个缘故， 我 得到三个学生 

2302
01:27:45,110 --> 01:27:50,480
讨论 所以我在范围变换3 

2303
01:27:48,080 --> 01:27:52,970
这只是迭代三次让我走 

2304
01:27:50,480 --> 01:27:55,700
未来，并要求 用户输入 姓名 ，以便 

2305
01:27:52,970 --> 01:27:56,840
得到字符串然后问他们的名字 

2306
01:27:55,700 --> 01:27:59,240
让我继续前进，要求他们 

2307
01:27:56,840 --> 01:28:01,820
宿舍和继续前进，取得字符串 

2308
01:27:59,240 --> 01:28:03,620
宿舍然后那就够了 我 

2309
01:28:01,820 --> 01:28:04,130
继续把学生追加到我的 

2310
01:28:03,620 --> 01:28:08,150
名单

2311
01:28:04,130 --> 01:28:10,040
所以学生们用笔，但我不是

2312
01:28:08,150 --> 01:28:11,570
有一个学生结构，但现在有 

2313
01:28:10,040 --> 01:28:13,970
我们可以通过很多方式来解决这个问题 

2314
01:28:11,570 --> 01:28:17,450
提出最简单的一个 

2315
01:28:13,970 --> 01:28:20,030
Python你可以声 明哈希表 

2316
01:28:17,450 --> 01:28:21,710
奇妙只是一个哈希表只是 

2317
01:28:20,030 --> 01:28:23,390
一组关键值对和我 

2318
01:28:21,710 --> 01:28:26,150
在我的 例子中 ，我会争论这一点 

2319
01:28:23,390 --> 01:28:28,340
我有钥匙 和价值观， 我有一个名字 

2320
01:28:26,150 --> 01:28:28,790
这是一个关键，像 大卫 一样的价值 

2321
01:28:28,340 --> 01:28:31,550
管他呢

2322
01:28:28,790 --> 01:28:33,920
另一个叫做宿舍的关键，然后是一个 值 

2323
01:28:31,550 --> 01:28:36,050
这就好比 马修的或其它地方 和 

2324
01:28:33,920 --> 01:28:37,610
所以关键和价值也会 如此 

2325
01:28:36,050 --> 01:28:39,800
如果我能为自己创造 一个很好的话

2326
01:28:37,610 --> 01:28:41,660
哈希表甚至尝试这个问题 

2327
01:28:39,800 --> 01:28:43,430
这使我能够很好地存储这些数据 

2328
01:28:41,660 --> 01:28:44,060
事实证明， 我可以做到 

2329
01:28:43,430 --> 01:28:45,420
那 

2330
01:28:44,060 --> 01:28:48,000
我可以继续创造 

2331
01:28:45,420 --> 01:28:50,190
使用卷曲砖的对象称为学生

2332
01:28:48,000 --> 01:28:53,160
括号表示法 ，你可以字面上 

2333
01:28:50,190 --> 01:28:55,980
做到这一点 的名称应为一个键， 

2334
01:28:53,160 --> 01:28:57,840
现在它要花上价值宿舍 

2335
01:28:55,980 --> 01:29:00,210
应该是另一个关键，它会采取

2336
01:28:57,840 --> 01:29:03,179
在那个价值上 所以我可以称之为 

2337
01:29:00,210 --> 01:29:04,830
任何我想要的 X和Y 并拥有价值观 

2338
01:29:03,179 --> 01:29:07,380
大卫和马修斯或者不管我是什么 

2339
01:29:04,830 --> 01:29:09,660
打算输入 ，但如果你想要一个非常 

2340
01:29:07,380 --> 01:29:11,520
不是广义数据结构

2341
01:29:09,660 --> 01:29:14,670
只是 从左到右 的值列表 

2342
01:29:11,520 --> 01:29:16,199
但是， 如果你有元数据或关键字 

2343
01:29:14,670 --> 01:29:18,210
将电子表格视为 列名 

2344
01:29:16,199 --> 01:29:20,460
名为name和名为的列名 

2345
01:29:18,210 --> 01:29:22,710
宿舍各自有你值 只是 

2346
01:29:20,460 --> 01:29:24,810
使用花括号，你把钥匙放进去 

2347
01:29:22,710 --> 01:29:26,370
引号然后冒号 然后 如果 

2348
01:29:24,810 --> 01:29:28,320
你有多个钥匙，你刚刚放了一把 

2349
01:29:26,370 --> 01:29:30,540
逗号所以它 有点神秘 但是这个 

2350
01:29:28,320 --> 01:29:33,660
就像一个哈希表的容器 

2351
01:29:30,540 --> 01:29:36,120
现在包含单词 和值 

2352
01:29:33,660 --> 01:29:38,820
你实施拼写时的pset 

2353
01:29:36,120 --> 01:29:40,620
你实际上 只是说是或否是 

2354
01:29:38,820 --> 01:29:42,300
字典中的字， 但你肯定 

2355
01:29:40,620 --> 01:29:44,010
可以存储更多信息 

2356
01:29:42,300 --> 01:29:47,280
而不仅仅是布尔值 

2357
01:29:44,010 --> 01:29:49,110
往往不需要那么做 

2358
01:29:47,280 --> 01:29:51,179
这对我来说对我来说意味着什么？ 

2359
01:29:49,110 --> 01:29:53,580
这个故事我有一个 对象 ，因为 它是 

2360
01:29:51,179 --> 01:29:55,920
在Python中调用存储这些键 

2361
01:29:53,580 --> 01:29:57,600
这些值如果以后我想要的话 

2362
01:29:55,920 --> 01:30:01,460
迭代他们我可以做到这一点 

2363
01:29:57,600 --> 01:30:04,739
学生哦，你必须追加它 

2364
01:30:01,460 --> 01:30:06,810
学生点添加 学生 让我们添加 

2365
01:30:04,739 --> 01:30:08,160
学生到列表这样对学生 

2366
01:30:06,810 --> 01:30:09,750
在学生中，这就是你 

2367
01:30:08,160 --> 01:30:11,160
迭代过去的每一 件事 

2368
01:30:09,750 --> 01:30:16,110
这个清单让我继续说一个 

2369
01:30:11,160 --> 01:30:19,440
句子就像我想说某某一样

2370
01:30:16,110 --> 01:30:21,300
在这个宿舍里，我该怎么表达呢 

2371
01:30:19,440 --> 01:30:23,280
还有某某我需要 得到访问 

2372
01:30:21,300 --> 01:30:27,780
学生的名字和我能做的方式 

2373
01:30:23,280 --> 01:30:29,730
这是如下 我可以说 让我们走吧 

2374
01:30:27,780 --> 01:30:33,960
前面说大括号学生 

2375
01:30:29,730 --> 01:30:36,690
括号名称 括号然后 

2376
01:30:33,960 --> 01:30:39,420
在这里，我可以继续说 oops 让我 

2377
01:30:36,690 --> 01:30:42,030
把引号放在这里然后在这里我可以 

2378
01:30:39,420 --> 01:30:44,130
说学生支架报价unquote宿舍

2379
01:30:42,030 --> 01:30:45,510
所以这无疑是最神秘的

2380
01:30:44,130 --> 01:30:47,880
我们到目前为止已经完成了一些例子但是让我们做了

2381
01:30:45,510 --> 01:30:50,250
把它分开作为格式字符串，如果 

2382
01:30:47,880 --> 01:30:52,140
我放大这个我在做什么 

2383
01:30:50,250 --> 01:30:53,760
花括号和 歼只是 意味着格式 

2384
01:30:52,140 --> 01:30:55,489
这个字符串， 所以你 可以忽略卷曲 

2385
01:30:53,760 --> 01:30:57,660
括号作为我们之前故事的一部分

2386
01:30:55,489 --> 01:30:58,710
student是 变量 的名称 

2387
01:30:57,660 --> 01:31:00,989
for循环 所以它就是 

2388
01:30:58,710 --> 01:31:03,719
现在的学生 方括号是 

2389
01:31:00,989 --> 01:31:07,170
新的C在 我们唯一使用square的时候 

2390
01:31:03,719 --> 01:31:09,090
括号是在什么上下文数组和

2391
01:31:07,170 --> 01:31:13,170
我们总是把这些广场放在什么地方 

2392
01:31:09,090 --> 01:31:14,310
括号数字 是啊0 1 2你可以 

2393
01:31:13,170 --> 01:31:17,340
索引到一个数组 

2394
01:31:14,310 --> 01:31:19,080
对象或哈希有什么好处 

2395
01:31:17,340 --> 01:31:22,230
我们现在更普遍地表

2396
01:31:19,080 --> 01:31:25,770
定义它是你可以索引到 

2397
01:31:22,230 --> 01:31:27,960
变量不使用数字而是使用单词 

2398
01:31:25,770 --> 01:31:30,090
你可以想到学生就像

2399
01:31:27,960 --> 01:31:31,830
列表或具有两个值 名称的数组

2400
01:31:30,090 --> 01:31:33,750
和宿舍，但 它是很好的 能 

2401
01:31:31,830 --> 01:31:35,910
指那些不是 一个或一个的 0 

2402
01:31:33,750 --> 01:31:39,300
愚蠢的任意数字，而不是 

2403
01:31:35,910 --> 01:31:40,920
键名和宿舍 所以这里的语法 

2404
01:31:39,300 --> 01:31:43,230
虽然含糊不清地说进去了

2405
01:31:40,920 --> 01:31:45,690
学生反对并获得 我的价值 

2406
01:31:43,230 --> 01:31:49,800
名为name的密钥 ，这是 一样的 

2407
01:31:45,690 --> 01:31:52,170
关于宿舍的事情， 所以 Python中 的对象 

2408
01:31:49,800 --> 01:31:54,150
或更一般地，哈希表允许 

2409
01:31:52,170 --> 01:31:56,280
您 将键与值和关联 

2410
01:31:54,150 --> 01:31:57,960
这很简单就是你使用的语法 

2411
01:31:56,280 --> 01:32:00,960
对于 这样让我继续运行 这个 

2412
01:31:57,960 --> 01:32:04,410
struct 0 dot我输入 我的名字 

2413
01:32:00,960 --> 01:32:06,540
让拯救马修斯让我们喜欢 

2414
01:32:04,410 --> 01:32:10,340
Veronica 焊接 

2415
01:32:06,540 --> 01:32:14,940
让Brian Brian住在哪里 

2416
01:32:10,340 --> 01:32:17,160
新生Pennypacker 不是那样的 

2417
01:32:14,940 --> 01:32:18,690
他们特别重要，但现在 

2418
01:32:17,160 --> 01:32:20,489
我们已经表达了所有这些句子 

2419
01:32:18,690 --> 01:32:23,190
所以现在的缺点是我们没有 

2420
01:32:20,489 --> 01:32:24,960
在C中看到这一点，但我们确实看到了 

2421
01:32:23,190 --> 01:32:27,270
我们实施自己的时候暗示了这一点 

2422
01:32:24,960 --> 01:32:30,630
C中的哈希表，以便我们可以实际 

2423
01:32:27,270 --> 01:32:32,850
任意访问键和值 

2424
01:32:30,630 --> 01:32:39,150
让我们做一个杯子掉在这里的任何 

2425
01:32:32,850 --> 01:32:42,030
问题之前， 我们带回 所有 马里奥 

2426
01:32:39,150 --> 01:32:43,770
是的，现在让我们不只是做例子 

2427
01:32:42,030 --> 01:32:46,500
为了示范而倒带 

2428
01:32:43,770 --> 01:32:48,000
我们见过几个 老朋友 

2429
01:32:46,500 --> 01:32:49,890
时间，只看几个不同的 

2430
01:32:48,000 --> 01:32:51,630
超级马里奥兄弟的屏幕

2431
01:32:49,890 --> 01:32:53,040
从左到右跑你可能还记得 

2432
01:32:51,630 --> 01:32:54,630
或者我已经 看到了类似的东西 

2433
01:32:53,040 --> 01:32:55,950
这在天空和 马里奥应该 是 

2434
01:32:54,630 --> 01:32:57,660
在它下面跑， 然后跳起来， 他得到了 

2435
01:32:55,950 --> 01:33:00,000
硬币或其他任何跳跃和 

2436
01:32:57,660 --> 01:33:01,680
打这些问号 就是这样 

2437
01:33:00,000 --> 01:33:02,850
大多是一种非常人为的说法

2438
01:33:01,680 --> 01:33:04,260
假设我们想打印出来 

2439
01:33:02,850 --> 01:33:06,420
屏幕上的问号就像 

2440
01:33:04,260 --> 01:33:07,680
超级马里奥兄弟我们怎么能这样做 

2441
01:33:06,420 --> 01:33:09,570
这会是一点点 黑色和 白色 

2442
01:33:07,680 --> 01:33:11,400
小文字， 但我怎么打印出来 

2443
01:33:09,570 --> 01:33:12,450
对于问号，让我过去 

2444
01:33:11,400 --> 01:33:15,030
这里 

2445
01:33:12,450 --> 01:33:18,420
让我创建一个名为let的文件 

2446
01:33:15,030 --> 01:33:19,920
马里奥0 PI和我该如何做到这一点 

2447
01:33:18,420 --> 01:33:24,570
最简单的方法来打印 

2448
01:33:19,920 --> 01:33:27,060
问号好吧 我听说打印好了 

2449
01:33:24,570 --> 01:33:29,370
对于问号非常 好 ，让我们走吧 

2450
01:33:27,060 --> 01:33:31,830
提前和运行马里奥 零 正确的那个 

2451
01:33:29,370 --> 01:33:33,270
右，所以这 是 不坏它是一个字符串 

2452
01:33:31,830 --> 01:33:35,430
不是一件大事，让我们至少这样做 

2453
01:33:33,270 --> 01:33:37,020
我们经常 做 的循环 

2454
01:33:35,430 --> 01:33:39,540
只是为了提高设计 即使 

2455
01:33:37,020 --> 01:33:41,940
这是一个非常小个小小例子 使 

2456
01:33:39,540 --> 01:33:44,790
马里奥一个馅饼让我们继续 打印 

2457
01:33:41,940 --> 01:33:46,440
这有一个循环，例如 如何 

2458
01:33:44,790 --> 01:33:50,520
我这样做是如何打印问题的 

2459
01:33:46,440 --> 01:33:56,760
我和是的，一次只有一个标记

2460
01:33:50,520 --> 01:33:59,070
打印问号范围保存 

2461
01:33:56,760 --> 01:34:01,010
好吧所以Python马里奥的人想 

2462
01:33:59,070 --> 01:34:03,540
不要大喊大叫

2463
01:34:01,010 --> 01:34:05,370
好的，谢谢，这 很好，为什么呢 

2464
01:34:03,540 --> 01:34:07,320
你不想让我 那样做 因为 

2465
01:34:05,370 --> 01:34:09,060
他们都是垂直的所以我们确实有 一个 

2466
01:34:07,320 --> 01:34:10,590
修复此问题如何告诉print和 

2467
01:34:09,060 --> 01:34:14,370
不要以默认结束你的行 

2468
01:34:10,590 --> 01:34:17,190
newline所以 N等于引用unquote 

2469
01:34:14,370 --> 01:34:19,380
覆盖默认反斜杠n 

2470
01:34:17,190 --> 01:34:21,600
价值所以现在 我可以重新运行这个或它是一个 

2471
01:34:19,380 --> 01:34:23,430
小马车 ， 我 怎么能 解决这个问题呢 

2472
01:34:21,600 --> 01:34:27,030
移动仅在最后一个之后放置一个新行 

2473
01:34:23,430 --> 01:34:28,500
是的， 他们老实说只是打印 

2474
01:34:27,030 --> 01:34:30,210
没有打印，那将有 

2475
01:34:28,500 --> 01:34:31,950
免费 打印新系列的效果 

2476
01:34:30,210 --> 01:34:33,930
让我们这样做 行不行 

2477
01:34:31,950 --> 01:34:35,400
现在我们已经有了一个很好的例子，那里 所有 

2478
01:34:33,930 --> 01:34:37,380
是的，事实证明我们实际上 

2479
01:34:35,400 --> 01:34:40,380
沿途印有一个单独的例子 

2480
01:34:37,380 --> 01:34:42,540
看起来像这样，虽然有四个 

2481
01:34:40,380 --> 01:34:43,860
阻止所以我们不会让我们继续前进 

2482
01:34:42,540 --> 01:34:46,110
这现在垂直没有问题 

2483
01:34:43,860 --> 01:34:47,490
标记，但像砖块一样的哈希，如果 

2484
01:34:46,110 --> 01:34:49,380
我们想打印出这 三个哈希 

2485
01:34:47,490 --> 01:34:53,280
让我吸取一些灵感

2486
01:34:49,380 --> 01:34:55,890
这个，让我们说 在 马里奥 2点PI让 

2487
01:34:53,280 --> 01:35:00,240
我继续前进，只为我说范围 

2488
01:34:55,890 --> 01:35:02,430
三个人继续 打印出 一个 

2489
01:35:00,240 --> 01:35:04,830
阻止和你一直 只是 建议 

2490
01:35:02,430 --> 01:35:07,080
做到这一点， 或者说不是让我们使用 

2491
01:35:04,830 --> 01:35:09,720
默认打印出垂直条 

2492
01:35:07,080 --> 01:35:11,730
三块，所以这是Mario 两点pi 

2493
01:35:09,720 --> 01:35:13,530
现在我们做了一些令人回想起来的事情

2494
01:35:11,730 --> 01:35:15,780
那个但现在事情变得 有点了 

2495
01:35:13,530 --> 01:35:18,330
有趣的是， 如果我们 去地下 

2496
01:35:15,780 --> 01:35:20,130
让我们专注于这个广场这么三个 

2497
01:35:18,330 --> 01:35:22,230
例如，因为我们没有 

2498
01:35:20,130 --> 01:35:24,750
相当看到这样的事情所以在 

2499
01:35:22,230 --> 01:35:26,310
在这里我们的最后一个例子，让我们看看 我们 能 

2500
01:35:24,750 --> 01:35:30,210
也许是一位勇敢的志愿者来 

2501
01:35:26,310 --> 01:35:32,600
起来这些想法中的一些 是 

2502
01:35:30,210 --> 01:35:37,200
是的， 那边的手回来了 

2503
01:35:32,600 --> 01:35:39,630
所以这将是马里奥 3点PI的目标 

2504
01:35:37,200 --> 01:35:42,030
其中的是打印更大的砖块 

2505
01:35:39,630 --> 01:35:43,280
砖头就好像是三点三打招呼 

2506
01:35:42,030 --> 01:35:46,320
再次

2507
01:35:43,280 --> 01:35:47,160
对于观众来说， 安德烈是什么名字

2508
01:35:46,320 --> 01:35:48,720
很高兴 见到你 

2509
01:35:47,160 --> 01:35:52,230
好的，所以手头的目标是

2510
01:35:48,720 --> 01:35:54,080
打印就像一个三乘三 格的 

2511
01:35:52,230 --> 01:36:00,120
哈希让人想起那些砖块

2512
01:35:54,080 --> 01:36:02,420
好吧 ，无论 你 得到什么， 你都 负责 

2513
01:36:00,120 --> 01:36:02,420
完成的工作 

2514
01:36:03,770 --> 01:36:10,040
好吧 四好还好 

2515
01:36:14,570 --> 01:36:18,170
好的有趣 

2516
01:36:22,849 --> 01:36:33,540
好的打印 报价 - 不引用Sprint的 是的 

2517
01:36:25,949 --> 01:36:36,210
好的关键细节一个哈希是好的所有 

2518
01:36:33,540 --> 01:36:37,790
权之前，我们做这个做的过程 

2519
01:36:36,210 --> 01:36:45,630
每个人都希望她运行这个程序

2520
01:36:37,790 --> 01:36:49,070
并且正确地知道为什么有人 

2521
01:36:45,630 --> 01:36:49,070
声称知道 你关心的 是 什么 

2522
01:36:50,360 --> 01:37:03,210
好的， 所以你可以解决其他问题 

2523
01:36:53,340 --> 01:37:04,199
担心是的，它会好起来的 

2524
01:37:03,210 --> 01:37:09,440
好吧，让我们看看你能走 我们 

2525
01:37:04,199 --> 01:37:09,440
通过口头表达我们做到了

2526
01:37:09,739 --> 01:37:34,560
可以带我们完成该 计划 

2527
01:37:11,580 --> 01:37:36,630
当 我们打印新的 时候会发生这种情况

2528
01:37:34,560 --> 01:37:38,059
行， 然后它应该执行 

2529
01:37:36,630 --> 01:37:40,459
三次

2530
01:37:38,059 --> 01:37:43,429
好吧你觉得你怎么样？ 

2531
01:37:40,459 --> 01:37:45,019
鸭子说服了，为什么不这样做 

2532
01:37:43,429 --> 01:37:47,179
你们保存文件让我们试试吧 

2533
01:37:45,019 --> 01:37:50,199
如此正确或错误都没有害处

2534
01:37:47,179 --> 01:37:53,179
让我们看看这被称为马里奥3 PI 和 

2535
01:37:50,199 --> 01:37:56,629
我想如果有的话，我们会有一阵掌声 

2536
01:37:53,179 --> 01:37:58,819
我们可以很好地做到这一点 

2537
01:37:56,629 --> 01:38:00,859
让我们结束 一场不和的斗争 吧 

2538
01:37:58,819 --> 01:38:03,019
看看最后一个例子 来 

2539
01:38:00,859 --> 01:38:04,669
我们从哪里开始的完整圆圈

2540
01:38:03,019 --> 01:38:06,979
当然看着调整大小，让我们打开

2541
01:38:04,669 --> 01:38:09,859
那只是 为了看看我是如何逃脱的 

2542
01:38:06,979 --> 01:38:12,349
写这么少的代码， 实际上 

2543
01:38:09,859 --> 01:38:14,510
在调整大小点时 完成这项工作 

2544
01:38:12,349 --> 01:38:16,189
pi是我们开始注意到的地方 

2545
01:38:14,510 --> 01:38:17,869
有几行希望看起来像 

2546
01:38:16,189 --> 01:38:20,449
现在不太熟悉，但我们没有

2547
01:38:17,869 --> 01:38:22,969
准确介绍所有 这些功能 

2548
01:38:20,449 --> 01:38:25,999
我们自己， 所以它在第1行和第1行 

2549
01:38:22,969 --> 01:38:27,649
第2行我们有一个不熟悉的和一个 

2550
01:38:25,999 --> 01:38:29,059
熟悉的第二行 只是给了我们 

2551
01:38:27,649 --> 01:38:31,099
访问哪些 命令 行参数 

2552
01:38:29,059 --> 01:38:33,439
我们需要调整 位图线的 大小 

2553
01:38:31,099 --> 01:38:34,669
一个是统治者很多权力

2554
01:38:33,439 --> 01:38:37,069
来自它的结果证明有一个 

2555
01:38:34,669 --> 01:38:38,719
图书馆在Python叫 枕 你 

2556
01:38:37,069 --> 01:38:40,309
可以通过键入某个命令来安装 

2557
01:38:38,719 --> 01:38:41,629
在你的终端，它不一定 

2558
01:38:40,309 --> 01:38:42,800
随 你的Mac或 PC一 起来 

2559
01:38:41,629 --> 01:38:44,719
下载并 与 安装 

2560
01:38:42,800 --> 01:38:46,789
命令然后如果你读它的话

2561
01:38:44,719 --> 01:38:49,069
它将从丸中说出来的文件

2562
01:38:46,789 --> 01:38:50,929
枕头导入图像现在不是

2563
01:38:49,069 --> 01:38:53,449
具体的形象 ，是一个名字 

2564
01:38:50,929 --> 01:38:55,339
库称为图像 库 

2565
01:38:53,449 --> 01:38:57,530
附带那个软件的人 

2566
01:38:55,339 --> 01:38:59,119
自由提供， 所以这是公正的 

2567
01:38:57,530 --> 01:39:01,550
说让我 访问图像 

2568
01:38:59,119 --> 01:39:03,469
相关的图书馆， 无疑是有的 

2569
01:39:01,550 --> 01:39:04,849
可能在C中存在类似的东西但是 

2570
01:39:03,469 --> 01:39:07,639
我们当然是 非常亲力亲为的 

2571
01:39:04,849 --> 01:39:09,679
如果艺术的长度，低级别可以 

2572
01:39:07,639 --> 01:39:10,879
V是不是叫喊在 与 用户 

2573
01:39:09,679 --> 01:39:12,499
用法，这就是他们没有

2574
01:39:10,879 --> 01:39:14,989
通过键入他们应该合作 

2575
01:39:12,499 --> 01:39:16,459
现在这个问题有点冗长了 

2576
01:39:14,989 --> 01:39:17,899
因为我们有Python而且 我们有 

2577
01:39:16,459 --> 01:39:19,999
文件扩展名，但我们可以在技术上 

2578
01:39:17,899 --> 01:39:21,889
如果我们真的想要 排队 那就清理一下

2579
01:39:19,999 --> 01:39:23,899
七八 九 没有什么 

2580
01:39:21,889 --> 01:39:26,419
那里真的很新我只是在宣布 

2581
01:39:23,899 --> 01:39:28,280
隐含式输入的三个变量我没有 

2582
01:39:26,419 --> 01:39:30,589
不得不打扰说int或字符串我 

2583
01:39:28,280 --> 01:39:33,919
访问Arg V一两和三 

2584
01:39:30,589 --> 01:39:36,260
是一两二，然后我正在做 

2585
01:39:33,919 --> 01:39:41,079
第七行的一件事是什么线 

2586
01:39:36,260 --> 01:39:43,069
七，这是重要的我是

2587
01:39:41,079 --> 01:39:45,050
改变论点是什么 

2588
01:39:43,069 --> 01:39:46,579
技术上默认是一个字符串， 因为 

2589
01:39:45,050 --> 01:39:48,889
事实上它来自于人类的双手 

2590
01:39:46,579 --> 01:39:50,809
键盘并将 其转换为数字 

2591
01:39:48,889 --> 01:39:51,980
现在作为一个用户没有的旁边

2592
01:39:50,809 --> 01:39:54,470
提供一个号码 

2593
01:39:51,980 --> 01:39:55,700
两个或10个这个代码可能会破坏 

2594
01:39:54,470 --> 01:39:57,440
我确实应该有一些 错误 

2595
01:39:55,700 --> 01:40:00,860
检查以确定用户是否键入了 

2596
01:39:57,440 --> 01:40:02,090
你好，而不是我需要的 两个 或十个 

2597
01:40:00,860 --> 01:40:04,010
抓住那个错误，所以我 有点儿 

2598
01:40:02,090 --> 01:40:07,610
马虎但它真正的意思 

2599
01:40:04,010 --> 01:40:09,110
现在我们有了简洁的代码 

2600
01:40:07,610 --> 01:40:11,150
在文件中一个 al文件来 完全 找到 

2601
01:40:09,110 --> 01:40:12,530
之前，所以我们 只有 三行 离开 

2602
01:40:11,150 --> 01:40:15,100
实际上实现了大部分

2603
01:40:12,530 --> 01:40:15,100
魔术耶 

2604
01:40:22,550 --> 01:40:35,330
再次 保存最后 一部分的方法是 

2605
01:40:26,870 --> 01:40:37,460
嗯 好 观察，所以这 不仅仅是 

2606
01:40:35,330 --> 01:40:39,560
将用户输入转换为 

2607
01:40:37,460 --> 01:40:42,200
等价的ASCII值，因为那是

2608
01:40:39,560 --> 01:40:45,950
不是我们想要的这个中断 你预言者 

2609
01:40:42,200 --> 01:40:47,510
实际上转换它是 通过 a 到 I a 

2610
01:40:45,950 --> 01:40:49,340
您 可能使用过的一对功能 

2611
01:40:47,510 --> 01:40:51,410
周 前，它只是叫一点点 

2612
01:40:49,340 --> 01:40:53,420
更简洁地说， 有一个功能通过 

2613
01:40:51,410 --> 01:40:55,400
你可以转换一个字符 或 

2614
01:40:53,420 --> 01:40:56,870
字符串到它的ASCII等价物但是 

2615
01:40:55,400 --> 01:40:58,610
这不是它 在 这里发生的事情

2616
01:40:56,870 --> 01:41:00,230
更直观的把它变成了一个 

2617
01:40:58,610 --> 01:41:02,090
不使用密码的整数

2618
01:41:00,230 --> 01:41:03,530
命名的功能就像一个给 我让我们 

2619
01:41:02,090 --> 01:41:04,910
向下滚动一点点进一步 

2620
01:41:03,530 --> 01:41:06,500
最后几行，看看是什么 

2621
01:41:04,910 --> 01:41:08,420
继续他们中的 一些 你只会 

2622
01:41:06,500 --> 01:41:10,130
知道如何从已经阅读做

2623
01:41:08,420 --> 01:41:12,140
正如我们所做的那样，文档说明 

2624
01:41:10,130 --> 01:41:13,250
给我 打电话图像变量 可以 

2625
01:41:12,140 --> 01:41:15,260
把它称之为我正在尝试的任何东西 

2626
01:41:13,250 --> 01:41:17,870
在文件中 保持一致 

2627
01:41:15,260 --> 01:41:19,640
使用图像库使用它打开 

2628
01:41:17,870 --> 01:41:21,680
随之而来 所以图像 功能 

2629
01:41:19,640 --> 01:41:22,940
某种结构， 其内部 

2630
01:41:21,680 --> 01:41:24,890
是一些有用的图像相关 

2631
01:41:22,940 --> 01:41:27,230
功能所以调用 它的开放功能 

2632
01:41:24,890 --> 01:41:29,300
该 文件 的名称 ，然后 继续前进 

2633
01:41:27,230 --> 01:41:31,370
并提取其高度和宽度 

2634
01:41:29,300 --> 01:41:31,910
事实证明这是另一对夫妇，如果你 

2635
01:41:31,370 --> 01:41:34,190
将

2636
01:41:31,910 --> 01:41:35,780
元组再次像X逗号Y纬度 

2637
01:41:34,190 --> 01:41:37,580
逗号经度你只会知道它 

2638
01:41:35,780 --> 01:41:39,350
这是文档中的元组

2639
01:41:37,580 --> 01:41:41,480
当我用逗号高度说这是

2640
01:41:39,350 --> 01:41:43,490
从技术上讲是一个数组 a 

2641
01:41:41,480 --> 01:41:45,140
大小二的列表， 我们真的是一个 tupple 

2642
01:41:43,490 --> 01:41:46,550
它只是为我提取的

2643
01:41:45,140 --> 01:41:48,860
宽度和高度，让我挥动我的 

2644
01:41:46,550 --> 01:41:50,360
以其 特定 语法表达 其余部分 

2645
01:41:48,860 --> 01:41:52,940
这只是以下给我一个 

2646
01:41:50,360 --> 01:41:55,160
叫做图像的新变量

2647
01:41:52,940 --> 01:41:56,990
输入图像调整大小功能另一个 

2648
01:41:55,160 --> 01:42:00,230
内置于 其中 的功能 

2649
01:41:56,990 --> 01:42:02,600
就像开放一样，改变它 

2650
01:42:00,230 --> 01:42:04,970
宽度和这个高度原来的小屋 

2651
01:42:02,600 --> 01:42:07,460
宽度乘以原始高度时间 

2652
01:42:04,970 --> 01:42:09,200
没有填充操作就是全部

2653
01:42:07,460 --> 01:42:10,970
其他一些图书馆的责任 

2654
01:42:09,200 --> 01:42:12,860
人类为我们处理了所有这些 

2655
01:42:10,970 --> 01:42:16,220
这最后一行也许并不令人惊讶 

2656
01:42:12,860 --> 01:42:18,440
将输出图像保存到该文件名 

2657
01:42:16,220 --> 01:42:19,760
所以只需要15行代码 和 

2658
01:42:18,440 --> 01:42:21,200
如果我们摆脱 一些，那就少了 

2659
01:42:19,760 --> 01:42:23,150
空格 可以为您实现 

2660
01:42:21,200 --> 01:42:24,740
整个调整大小，但真的很专注

2661
01:42:23,150 --> 01:42:26,330
关于 我想要 的问题的逻辑 

2662
01:42:24,740 --> 01:42:27,890
从我想要的用户那里获取输入

2663
01:42:26,330 --> 01:42:29,060
将它缩小n倍，我想要 

2664
01:42:27,890 --> 01:42:30,710
要保存文件 ，这就是你 

2665
01:42:29,060 --> 01:42:32,990
关心你 不一定在乎 

2666
01:42:30,710 --> 01:42:34,790
关于完全进入杂草 

2667
01:42:32,990 --> 01:42:35,690
你做了什么， 你必须做什么 

2668
01:42:34,790 --> 01:42:38,660
你呢 

2669
01:42:35,690 --> 01:42:41,239
看到这样，让我们在这里做最后一个例子 

2670
01:42:38,660 --> 01:42:42,830
你会从 问题 集四 回忆起 你 

2671
01:42:41,239 --> 01:42:44,960
实施了自己的拼写检查和 

2672
01:42:42,830 --> 01:42:46,430
赔率是你 尝试 或哈希表或 

2673
01:42:44,960 --> 01:42:48,260
事实证明就是这样 

2674
01:42:46,430 --> 01:42:49,730
肯定在C和它是非平凡的 

2675
01:42:48,260 --> 01:42:51,739
肯定是第一次非平凡

2676
01:42:49,730 --> 01:42:54,199
在任何语言， 但让我采取刺 

2677
01:42:51,739 --> 01:42:56,239
现在用Python做这件事让我走了 

2678
01:42:54,199 --> 01:42:58,489
进入源码6，我有一个拼写器 

2679
01:42:56,239 --> 01:43:00,710
示例并注意在此文件夹中 

2680
01:42:58,489 --> 01:43:02,150
今天我带了 一些文件 

2681
01:43:00,710 --> 01:43:04,580
所以我带了一份完整的副本 

2682
01:43:02,150 --> 01:43:06,380
来自pset 4的词典我的副本 

2683
01:43:04,580 --> 01:43:08,180
la-la-land和the文本文件

2684
01:43:06,380 --> 01:43:10,580
喜欢在文本中然后我带了两个

2685
01:43:08,180 --> 01:43:12,650
文件字典pi和speller dot pi 

2686
01:43:10,580 --> 01:43:15,469
后者是一种实施方式 

2687
01:43:12,650 --> 01:43:16,850
speller在Python中看到， 我不是 

2688
01:43:15,469 --> 01:43:18,830
因为 我们要拉那个

2689
01:43:16,850 --> 01:43:21,050
写下那个完全适合你，但让 

2690
01:43:18,830 --> 01:43:23,780
我继续 写下来 

2691
01:43:21,050 --> 01:43:26,900
我自己的字典 所以字典点pi 

2692
01:43:23,780 --> 01:43:29,540
是 拼写或向上的类比 

2693
01:43:26,900 --> 01:43:31,790
字典点C，让我们继续前进 

2694
01:43:29,540 --> 01:43:33,710
设置这个让我 继续 创造 

2695
01:43:31,790 --> 01:43:36,830
此文件 现在 位于单独的文件夹 中 

2696
01:43:33,710 --> 01:43:38,870
所以字典 点pi和那里有几个 

2697
01:43:36,830 --> 01:43:39,710
字典中的 函数 点C我们 

2698
01:43:38,870 --> 01:43:42,610
或许应该得到周围 

2699
01:43:39,710 --> 01:43:45,320
实现这些功能是什么

2700
01:43:42,610 --> 01:43:47,570
负载为一个和负载需要的名字 

2701
01:43:45,320 --> 01:43:49,310
一个文件 或一个 字典让我们这样做 

2702
01:43:47,570 --> 01:43:50,330
而我只会说要回来 

2703
01:43:49,310 --> 01:43:53,660
其他功能是什么

2704
01:43:50,330 --> 01:43:56,510
字典点C检查所以def检查和 

2705
01:43:53,660 --> 01:43:58,219
什么也检查采取 作为输入 一个字 

2706
01:43:56,510 --> 01:43:59,570
是的，所以我们会回到这个而且 只是 

2707
01:43:58,219 --> 01:44:04,219
回到那个做其他事情 

2708
01:43:59,570 --> 01:44:05,900
函数大小是这样的def大小 

2709
01:44:04,219 --> 01:44:07,370
没有接受输入，但它刚刚返回 

2710
01:44:05,900 --> 01:44:10,100
结构的大小，所以我们会来 

2711
01:44:07,370 --> 01:44:11,870
回到那 ，最后还好，所以卸载 

2712
01:44:10,100 --> 01:44:13,400
好吧，这就是 蟒蛇 

2713
01:44:11,870 --> 01:44:15,260
版本的分发代码 

2714
01:44:13,400 --> 01:44:17,660
speller 为你的字典 文件所以 

2715
01:44:15,260 --> 01:44:19,850
也卸不带任何 参数等等 

2716
01:44:17,660 --> 01:44:21,890
这件事情对我们 做的事情-这样 

2717
01:44:19,850 --> 01:44:23,690
咒语的要点是什么？ 

2718
01:44:21,890 --> 01:44:25,520
检查你在装载你的文字 

2719
01:44:23,690 --> 01:44:27,560
从字典文件加载函数和 

2720
01:44:25,520 --> 01:44:29,750
目标是以某种方式加载它们 

2721
01:44:27,560 --> 01:44:31,760
记忆你有一个设计决定

2722
01:44:29,750 --> 01:44:33,620
在C中的 pset 你可以做一个哈希 

2723
01:44:31,760 --> 01:44:35,690
表或 尝试甚至是链表 或 

2724
01:44:33,620 --> 01:44:37,190
即使是一个阵列，但赔率是第一个 

2725
01:44:35,690 --> 01:44:39,620
这两个可能更有效率 

2726
01:44:37,190 --> 01:44:41,480
所以事实证明，在 Python中 你有 

2727
01:44:39,620 --> 01:44:43,400
能够存储漂亮的单词

2728
01:44:41,480 --> 01:44:45,949
容易在任何数量的 数据结构中 

2729
01:44:43,400 --> 01:44:48,050
你不只是在漂浮物 和 

2730
01:44:45,949 --> 01:44:49,230
字符串但你清楚地列出了 

2731
01:44:48,050 --> 01:44:51,900
我们见过

2732
01:44:49,230 --> 01:44:53,910
我们称它们为对象或散列哈希 

2733
01:44:51,900 --> 01:44:56,430
桌子还有其他的东西 

2734
01:44:53,910 --> 01:44:57,930
调用集合，其中集合是公正的 

2735
01:44:56,430 --> 01:45:00,750
这将是一个词汇集 

2736
01:44:57,930 --> 01:45:02,640
非常好的可搜索，所以你知道 

2737
01:45:00,750 --> 01:45:03,989
如果我想 最终加载一些什么

2738
01:45:02,640 --> 01:45:05,940
让我给自己一个全球性的话

2739
01:45:03,989 --> 01:45:08,489
变量叫做 单词而且只是 

2740
01:45:05,940 --> 01:45:10,020
将它初始化为空集， 所以我有 

2741
01:45:08,489 --> 01:45:11,880
一个叫做词 和 词的全局变量

2742
01:45:10,020 --> 01:45:14,489
什么都没有，但它是一套 

2743
01:45:11,880 --> 01:45:15,989
我怎么去加载单词 

2744
01:45:14,489 --> 01:45:17,820
进入那本词典， 让我们继续吧 

2745
01:45:15,989 --> 01:45:19,410
并在这里实施负载，让我走吧 

2746
01:45:17,820 --> 01:45:22,590
提前并声明一个名为file的变量 

2747
01:45:19,410 --> 01:45:25,200
并在阅读 模式下打开此词典 

2748
01:45:22,590 --> 01:45:27,000
就像在C中一样，然后我如何 迭代 

2749
01:45:25,200 --> 01:45:28,560
在我们没见过的文件中

2750
01:45:27,000 --> 01:45:30,660
那可是我不知道怎么 遍历 

2751
01:45:28,560 --> 01:45:32,130
在阵列和串

2752
01:45:30,660 --> 01:45:35,940
在 这 串字符，以便让我走 

2753
01:45:32,130 --> 01:45:37,560
我的本能确实是文件中的行

2754
01:45:35,940 --> 01:45:39,540
这将完全符合您的要求 

2755
01:45:37,560 --> 01:45:40,170
那么让我继续前进并添加到我的 

2756
01:45:39,540 --> 01:45:44,070
话 

2757
01:45:40,170 --> 01:45:47,550
数据结构如下以及 

2758
01:45:44,070 --> 01:45:48,960
然后让我关闭文件，然后让 

2759
01:45:47,550 --> 01:45:51,840
我 只是说回归真实，因为一切都是 

2760
01:45:48,960 --> 01:45:54,030
干得好， 所以我正在削减 一些 

2761
01:45:51,840 --> 01:45:55,950
技术上让我使用它 

2762
01:45:54,030 --> 01:45:58,470
我之前提到过的功能让我走了 

2763
01:45:55,950 --> 01:45:59,760
进取，拨打我们的带材和剥离 

2764
01:45:58,470 --> 01:46:01,140
因为在文件中新行

2765
01:45:59,760 --> 01:46:03,300
从技术上讲，当你在阅读 那些 

2766
01:46:01,140 --> 01:46:04,920
单词每行以 反斜杠 0结尾

2767
01:46:03,300 --> 01:46:06,540
这不是一个未成年人这个词的一部分

2768
01:46:04,920 --> 01:46:08,520
在那里纠正，我正在剥离 

2769
01:46:06,540 --> 01:46:12,110
这条线，但它是负载我如何 

2770
01:46:08,520 --> 01:46:15,770
现在检查给定单词是否在该集合中 

2771
01:46:12,110 --> 01:46:21,870
好吧，我只能用语言说出来 

2772
01:46:15,770 --> 01:46:25,020
return true else返回false 完成 

2773
01:46:21,870 --> 01:46:27,450
检查如何返回此大小 

2774
01:46:25,020 --> 01:46:29,580
数据结构我 刚回来 怎么样 

2775
01:46:27,450 --> 01:46:32,070
这个结构的长度和 

2776
01:46:29,580 --> 01:46:37,650
然后卸下heck pythons 这样做 

2777
01:46:32,070 --> 01:46:39,060
对我来说，让我缩小你和你 

2778
01:46:37,650 --> 01:46:40,739
知道这有点冗长我 

2779
01:46:39,060 --> 01:46:43,380
实际上并不需要，如果其他人我 要 做到这一点 

2780
01:46:40,739 --> 01:46:44,790
可以用文字和那个字回复

2781
01:46:43,380 --> 01:46:46,260
将返回一个布尔值，我和 

2782
01:46:44,790 --> 01:46:47,880
老实说，如果我想小写 它 

2783
01:46:46,260 --> 01:46:49,250
这很容易我可以做到这一点并采取 

2784
01:46:47,880 --> 01:46:56,580
关心这一点，现在它 甚至 更好 

2785
01:46:49,250 --> 01:46:58,590
这是你 为激动的愿望 设定的第5 集 

2786
01:46:56,580 --> 01:47:00,030
我们用C做过这个 ，那是什么呢 

2787
01:46:58,590 --> 01:47:01,650
所有这一切的 全部意义 因为 

2788
01:47:00,030 --> 01:47:02,880
目标不是创造那种 

2789
01:47:01,650 --> 01:47:05,070
好焦虑和

2790
01:47:02,880 --> 01:47:06,600
在现在，但 有重点 

2791
01:47:05,070 --> 01:47:07,500
介绍看过去这几个人 

2792
01:47:06,600 --> 01:47:09,030
几周是一个 

2793
01:47:07,500 --> 01:47:10,950
现在这一切都不是理所当然的 

2794
01:47:09,030 --> 01:47:12,450
我的意思是你可能渴望拥有 

2795
01:47:10,950 --> 01:47:13,920
用 Python实现这个 ，你可能会 

2796
01:47:12,450 --> 01:47:15,930
不得不 阅读一些文件和 

2797
01:47:13,920 --> 01:47:17,940
找出各种语法， 但我的上帝 

2798
01:47:15,930 --> 01:47:20,520
就像我们削减可能采取的措施一样 

2799
01:47:17,940 --> 01:47:21,510
大多数人只需要几秒钟就能完成一次 

2800
01:47:20,520 --> 01:47:23,400
你更舒适的 

2801
01:47:21,510 --> 01:47:24,960
语言也是我们 最早的 

2802
01:47:23,400 --> 01:47:26,610
一旦你有权利，今天就指出

2803
01:47:24,960 --> 01:47:28,950
语言和工作的正确工具 

2804
01:47:26,610 --> 01:47:30,810
现在不是说 这是完美的 

2805
01:47:28,950 --> 01:47:33,480
因为事实上，我们继续 做 

2806
01:47:30,810 --> 01:47:35,130
一些测试让我进入我的 终端 

2807
01:47:33,480 --> 01:47:38,430
窗口在这里，我实际带来了 我的 

2808
01:47:35,130 --> 01:47:41,400
我的C文件夹中有自己的解决方案 

2809
01:47:38,430 --> 01:47:44,310
看我有自己的代码 来 拼写 

2810
01:47:41,400 --> 01:47:45,720
在这里用C实现， 让我 走吧 

2811
01:47:44,310 --> 01:47:48,990
继续运行测试 让我继续前进 ， 

2812
01:47:45,720 --> 01:47:50,490
对莎士比亚的文字说法 

2813
01:47:48,990 --> 01:47:52,470
这是一个非常大的投入让我们继续前进 

2814
01:47:50,490 --> 01:47:53,820
并回车 ，这 是我的咒语 

2815
01:47:52,470 --> 01:47:55,980
检查器运行和所有的话 

2816
01:47:53,820 --> 01:47:58,860
输出总时间运行 

2817
01:47:55,980 --> 01:47:59,760
拼写用C会说0.9秒所以 

2818
01:47:58,860 --> 01:48:02,250
这实际上非常好 

2819
01:47:59,760 --> 01:48:04,200
在第二个窗口让我进入这里 

2820
01:48:02,250 --> 01:48:07,470
另一个终端窗口 ，让我走 

2821
01:48:04,200 --> 01:48:09,360
进入今天的代码并进入拼写器 

2822
01:48:07,470 --> 01:48:11,370
我有Python版本的文件夹

2823
01:48:09,360 --> 01:48:13,880
我将按照拼写点运行 

2824
01:48:11,370 --> 01:48:16,110
pi让我继续前进吧 

2825
01:48:13,880 --> 01:48:17,640
莎士比亚 所以我们没有看过 

2826
01:48:16,110 --> 01:48:19,950
speller dot Pi但它本质上是 

2827
01:48:17,640 --> 01:48:21,360
line for line a port from a translation 

2828
01:48:19,950 --> 01:48:23,520
C到Python，但欢迎你 看 

2829
01:48:21,360 --> 01:48:25,920
在上 线和它的使用我的 

2830
01:48:23,520 --> 01:48:27,690
字典 点pi文件 让我继续 

2831
01:48:25,920 --> 01:48:30,690
并运行 它正在 通过所有 

2832
01:48:27,690 --> 01:48:37,670
top top是 Python底部是C这里 

2833
01:48:30,690 --> 01:48:39,780
我们走在这里，我们去那里 ，我们去 

2834
01:48:37,670 --> 01:48:41,640
现在这有点误导，因为 

2835
01:48:39,780 --> 01:48:44,250
互联网 再次成为 我们的方式 

2836
01:48:41,640 --> 01:48:45,480
使用基于Web的IDE ，这很有趣 

2837
01:48:44,250 --> 01:48:48,000
即出现了这么多次 和 

2838
01:48:45,480 --> 01:48:49,410
你会发现它不是10 秒20秒 

2839
01:48:48,000 --> 01:48:51,030
不过那 很 长的 时间就是那个 

2840
01:48:49,410 --> 01:48:52,590
互联网很慢， 我们都在计划 

2841
01:48:51,030 --> 01:48:54,810
是你在C和Python中的功能 

2842
01:48:52,590 --> 01:49:01,060
但什么是一个 Python之间 带走 

2843
01:48:54,810 --> 01:49:06,230
和C相同的输入 

2844
01:49:01,060 --> 01:49:08,270
你是怎么说的呀呀是的 我会的 

2845
01:49:06,230 --> 01:49:12,350
说简洁， 它更美观 

2846
01:49:08,270 --> 01:49:13,970
更多好甚至 没有 ，我认为 他们是 

2847
01:49:12,350 --> 01:49:15,230
这些都是正确 的 

2848
01:49:13,970 --> 01:49:18,140
像所有 重要的 一样正确 

2849
01:49:15,230 --> 01:49:21,739
顶部的数字是相同的 ，但是 

2850
01:49:18,140 --> 01:49:24,260
虽然它有什么明显的不同 

2851
01:49:21,739 --> 01:49:26,150
更慢，所以python似乎更慢 

2852
01:49:24,260 --> 01:49:27,920
如果我们愿意，它总是需要 

2853
01:49:26,150 --> 01:49:29,540
看两个数字一点五五 

2854
01:49:27,920 --> 01:49:30,920
Python中的秒，如果你忽略了

2855
01:49:29,540 --> 01:49:33,020
互联网速度， 只需看看代码 

2856
01:49:30,920 --> 01:49:37,070
性能与第九点的关系 

2857
01:49:33,020 --> 01:49:39,260
几乎是 C的 两倍， 所以是什么 

2858
01:49:37,070 --> 01:49:41,510
那里的外卖是的，它把我带走了 

2859
01:49:39,260 --> 01:49:43,220
知道10 20 30秒写什么 

2860
01:49:41,510 --> 01:49:45,140
代码， 但它花了我两倍的时间 

2861
01:49:43,220 --> 01:49:46,610
现在 运行它 时， 当然不是什么大不了的事 

2862
01:49:45,140 --> 01:49:48,110
我们在这里谈论几秒钟 ， 

2863
01:49:46,610 --> 01:49:49,730
但是如果这是一个大数据 集 

2864
01:49:48,110 --> 01:49:52,790
你正在分析一些项目 

2865
01:49:49,730 --> 01:49:54,920
或用于工作或任何类型的分析 

2866
01:49:52,790 --> 01:49:56,239
项目和数据比大得多 

2867
01:49:54,920 --> 01:49:57,800
即便如此，尤其 是 医疗方面 

2868
01:49:56,239 --> 01:49:59,600
可能你不想要的领域等 

2869
01:49:57,800 --> 01:50:01,160
确保你可以使用Python 

2870
01:49:59,600 --> 01:50:03,470
代码只需几分钟即可 

2871
01:50:01,160 --> 01:50:05,750
小时但是一旦你跑了它该死 的不是 

2872
01:50:03,470 --> 01:50:07,790
它比使用像C这样的东西慢

2873
01:50:05,750 --> 01:50:09,320
而用C可能需要你更多的时间了 

2874
01:50:07,790 --> 01:50:10,640
前 ，你可能甚至不有 

2875
01:50:09,320 --> 01:50:11,960
再舒适C，所以它会

2876
01:50:10,640 --> 01:50:14,030
因为 你必须把你带走更长的时间 

2877
01:50:11,960 --> 01:50:16,280
重新学习一门语言， 但是当你跑步时 

2878
01:50:14,030 --> 01:50:18,230
它哇哇跑的速度是你的两倍 

2879
01:50:16,280 --> 01:50:19,970
因此可能需要更少的 RAM 

2880
01:50:18,230 --> 01:50:21,590
硬件或更便宜的硬件 

2881
01:50:19,970 --> 01:50:23,239
因为你可以侥幸逃脱 

2882
01:50:21,590 --> 01:50:25,130
我们继续看到这个主题和数据 

2883
01:50:23,239 --> 01:50:27,290
结构和算法是权衡取舍 

2884
01:50:25,130 --> 01:50:29,480
像开发者时间是一种资源而已 

2885
01:50:27,290 --> 01:50:31,100
真是太好 了我，现在你会 

2886
01:50:29,480 --> 01:50:32,900
能够更快地 编写 代码 

2887
01:50:31,100 --> 01:50:35,000
但你 必须在某个地方付出代价 

2888
01:50:32,900 --> 01:50:36,350
这显然是Python的代价 

2889
01:50:35,000 --> 01:50:38,420
并不是因为python很糟糕 

2890
01:50:36,350 --> 01:50:40,489
实施但 基本的是什么 

2891
01:50:38,420 --> 01:50:42,830
的范例之间的差异 

2892
01:50:40,489 --> 01:50:45,350
编程和C相对于在Python 作为 

2893
01:50:42,830 --> 01:50:47,650
我们今天看到它有什么不同 

2894
01:50:45,350 --> 01:50:47,650
是啊 

2895
01:50:53,690 --> 01:51:00,360
MM-HMM确实让我 周围的 翻转 

2896
01:50:58,350 --> 01:51:01,800
因此，使用 C，您将编译为零 

2897
01:51:00,360 --> 01:51:03,120
和那些编译器是超级的 

2898
01:51:01,800 --> 01:51:04,740
聪明 ，它会移动的 东西 

2899
01:51:03,120 --> 01:51:06,870
在记忆中， 它会谈论电脑 

2900
01:51:04,740 --> 01:51:08,640
的零和 Python的母语

2901
01:51:06,870 --> 01:51:10,830
确实是在阅读你的代码 

2902
01:51:08,640 --> 01:51:12,300
按行从上到下线从左到右 

2903
01:51:10,830 --> 01:51:13,980
即使技术上在下面 

2904
01:51:12,300 --> 01:51:15,750
引擎盖有一个编译步骤 

2905
01:51:13,980 --> 01:51:17,250
虽然有一些开销

2906
01:51:15,750 --> 01:51:19,020
涉及到我们不是的 事实 

2907
01:51:17,250 --> 01:51:20,610
更长时间的运行铿锵然后得到 

2908
01:51:19,020 --> 01:51:22,620
零和一个或运行make和 

2909
01:51:20,610 --> 01:51:24,300
得到零和那些很棒的但是 

2910
01:51:22,620 --> 01:51:25,830
我们必须付出代价才能付出代价 

2911
01:51:24,300 --> 01:51:27,660
这将是主题，就像有 

2912
01:51:25,830 --> 01:51:28,890
在 语言或工具中没有圣杯 

2913
01:51:27,660 --> 01:51:30,630
或技术会有 

2914
01:51:28,890 --> 01:51:32,100
在你的安慰之间进行权衡 

2915
01:51:30,630 --> 01:51:33,960
熟悉或回忆 一个 

2916
01:51:32,100 --> 01:51:36,240
语言使用方式有多容易

2917
01:51:33,960 --> 01:51:38,190
简洁地说，你可以输入它然后如何输入 

2918
01:51:36,240 --> 01:51:40,230
有效地你可以实际运行它 

2919
01:51:38,190 --> 01:51:42,720
屏幕和C希望现在我们 

2920
01:51:40,230 --> 01:51:44,730
不会写 了 C代码，你 有 

2921
01:51:42,720 --> 01:51:47,820
如果你的话，在Python中欣赏

2922
01:51:44,730 --> 01:51:49,830
相反或创建一个哈希或列表 

2923
01:51:47,820 --> 01:51:51,660
创建集合或散列表 等 

2924
01:51:49,830 --> 01:51:54,060
您真正可以访问的是 

2925
01:51:51,660 --> 01:51:56,790
别人对pset 4的实现 

2926
01:51:54,060 --> 01:51:58,620
和pset 3和pset 2以及pset 1中的一些 

2927
01:51:56,790 --> 01:52:01,650
形式，但现在暴露给你更多 

2928
01:51:58,620 --> 01:52:02,850
功能强大，更现代的语言 

2929
01:52:01,650 --> 01:52:04,410
让我们今天正式结束

2930
01:52:02,850 --> 01:52:07,490
下周我们会做同样的事情，但 在 

2931
01:52:04,410 --> 01:52:07,490
网络 编程的背景

