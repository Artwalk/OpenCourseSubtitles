1
00:00:00,000 --> 00:00:26,039
[音乐] 

2
00:00:30,050 --> 00:00:43,299
[音乐] 

3
00:00:46,040 --> 00:00:50,030
[掌声] 

4
00:00:47,200 --> 00:00:53,640
[音乐] 

5
00:00:50,030 --> 00:00:55,949
好吧，这是CS50，这 是 

6
00:00:53,640 --> 00:00:57,329
第二周开始，你会 记得那 

7
00:00:55,949 --> 00:00:58,980
过去几周我们一直 都是 

8
00:00:57,329 --> 00:01:00,659
最初从头开始建立 

9
00:00:58,980 --> 00:01:02,909
图形化编程语言 

10
00:01:00,659 --> 00:01:05,580
然后我们就在上周 翻译成了 

11
00:01:02,909 --> 00:01:07,590
C中的等效程序，当然 

12
00:01:05,580 --> 00:01:09,930
现在有更多的语法

13
00:01:07,590 --> 00:01:11,790
完全是文字，但想法回忆起来了

14
00:01:09,930 --> 00:01:13,740
我们 从根本上讲是一样的 

15
00:01:11,790 --> 00:01:17,310
是计算机不明白这一点 

16
00:01:13,740 --> 00:01:19,530
他们只懂什么语言耶 

17
00:01:17,310 --> 00:01:21,810
零和一个是 二进制的，所以有 

18
00:01:19,530 --> 00:01:24,659
为了让我们 得到一个必要的步骤

19
00:01:21,810 --> 00:01:26,610
从这个代码到二进制和什么 

20
00:01:24,659 --> 00:01:29,490
该程序员进程的那一步

21
00:01:26,610 --> 00:01:31,140
叫是的， 所以编译，当然 

22
00:01:29,490 --> 00:01:32,819
回想你现在已经尝试过的

23
00:01:31,140 --> 00:01:35,100
过去一周，这是一个编译 程序 

24
00:01:32,819 --> 00:01:36,240
你可以使用clang for C语言和你 

25
00:01:35,100 --> 00:01:37,770
可以说铿锵然后的名字 

26
00:01:36,240 --> 00:01:39,149
要编译的文件和 

27
00:01:37,770 --> 00:01:42,270
默认输出它是一个漂亮的

28
00:01:39,149 --> 00:01:43,979
奇怪的命名程序只是一个点出来的 

29
00:01:42,270 --> 00:01:46,860
代表汇编输出更多介绍 

30
00:01:43,979 --> 00:01:48,450
在片刻，但 回想起 你 

31
00:01:46,860 --> 00:01:49,649
可以覆盖该默认行为 

32
00:01:48,450 --> 00:01:51,899
实际上你可以说输出 ， 而不是 

33
00:01:49,649 --> 00:01:53,579
程序叫做hello而不仅仅是一个

34
00:01:51,899 --> 00:01:55,799
点点滴滴，但你可以更进一步 

35
00:01:53,579 --> 00:01:57,719
你可以实际使用make和make 

36
00:01:55,799 --> 00:02:00,030
本身它不是 一个编译器，它是一个构建 

37
00:01:57,719 --> 00:02:04,229
实用但通俗地说 哪些 呢 

38
00:02:00,030 --> 00:02:05,969
它为我们做了它编译它和它 

39
00:02:04,229 --> 00:02:08,729
基本上可以找出所有 这些 

40
00:02:05,969 --> 00:02:10,829
其他明智的神秘命令行 

41
00:02:08,729 --> 00:02:12,480
这些论点- 哦，某事等等 

42
00:02:10,829 --> 00:02:14,220
第四， 这样的程序是 刚 建成 

43
00:02:12,480 --> 00:02:15,769
没有 我们必须 的方式我们想要的方式 

44
00:02:14,220 --> 00:02:18,930
记住那些看似神奇的东西 

45
00:02:15,769 --> 00:02:21,120
咒语虽然只有作用 

46
00:02:18,930 --> 00:02:23,310
对于事实上这样简单的程序

47
00:02:21,120 --> 00:02:25,049
你们中的一些人有最近的问题 

48
00:02:23,310 --> 00:02:26,190
set可能遇到过编译 

49
00:02:25,049 --> 00:02:28,109
我们实际上没有的错误

50
00:02:26,190 --> 00:02:30,359
因故而在课堂上遭遇

51
00:02:28,109 --> 00:02:32,609
make 很快就 帮助了我们 

52
00:02:30,359 --> 00:02:35,220
当你实际增强程序时 

53
00:02:32,609 --> 00:02:37,890
使用CS50库通过采取用户输入

54
00:02:35,220 --> 00:02:39,600
包括cs50 dot H你们中的一些人可能会 

55
00:02:37,890 --> 00:02:41,940
我们 突然意识到了 

56
00:02:39,600 --> 00:02:43,829
沙箱和 更普遍的铿锵没有 

57
00:02:41,940 --> 00:02:45,630
知道什么是束缚而且坦率地说

58
00:02:43,829 --> 00:02:47,730
clang甚至可能都不 知道 字符串是什么 

59
00:02:45,630 --> 00:02:50,430
是的，那是因为那两个是

60
00:02:47,730 --> 00:02:52,709
您拥有的cs50 s库的功能

61
00:02:50,430 --> 00:02:55,620
教铿锵但是这还不够

62
00:02:52,709 --> 00:02:57,240
教铛他们的样子 如 

63
00:02:55,620 --> 00:02:59,610
包括cs50点

64
00:02:57,240 --> 00:03:03,090
原来有一个缺少的步骤， 

65
00:02:59,610 --> 00:03:05,160
make帮助我们解决，但你们 两个可以 

66
00:03:03,090 --> 00:03:07,740
如果你愿意 ， 可以手动解决 

67
00:03:05,160 --> 00:03:09,840
我的意思是这不是编译一个 

68
00:03:07,740 --> 00:03:13,380
只有铛招呼程序点见 

69
00:03:09,840 --> 00:03:14,610
当你想使用cs50 的库时 

70
00:03:13,380 --> 00:03:16,140
实际上打算 你 添加这个 

71
00:03:14,610 --> 00:03:17,760
附加的命令行参数 

72
00:03:16,140 --> 00:03:20,130
具体到底不能进去了 

73
00:03:17,760 --> 00:03:22,200
开始 像 - 哦和 -  L代表 

74
00:03:20,130 --> 00:03:24,600
链接，这是一种告诉铿锵的方式

75
00:03:22,200 --> 00:03:27,720
顺便编译我的程序时 

76
00:03:24,600 --> 00:03:29,940
请链接cs50零和那些

77
00:03:27,720 --> 00:03:32,310
几个星期前我们的工作人员写了 

78
00:03:29,940 --> 00:03:33,750
为你安装在沙箱中 

79
00:03:32,310 --> 00:03:35,310
你有零和一个然后 

80
00:03:33,750 --> 00:03:38,370
你有我们的零和一所以 

81
00:03:35,310 --> 00:03:40,140
说- 壳cs50说连接它们 

82
00:03:38,370 --> 00:03:42,030
如果你得到一些，所以一起

83
00:03:40,140 --> 00:03:44,310
一种未定义的引用错误 

84
00:03:42,030 --> 00:03:45,840
你没有能力， 或者你没有 

85
00:03:44,310 --> 00:03:47,670
编译一个 刚刚使用 过的 程序 

86
00:03:45,840 --> 00:03:50,730
来自cs50库的get函数 

87
00:03:47,670 --> 00:03:52,830
赔率是这个简单的 变化 -  L cs50 

88
00:03:50,730 --> 00:03:54,510
会固定但当然这是 

89
00:03:52,830 --> 00:03:56,400
一个有趣的东西要记住让 

90
00:03:54,510 --> 00:03:58,140
单独记住如何使用 - OH作为 

91
00:03:56,400 --> 00:04:00,450
那么命令得到了什么 

92
00:03:58,140 --> 00:04:02,400
打字真的很乏味所以来吧 

93
00:04:00,450 --> 00:04:03,870
make make make自动完成所有这些 

94
00:04:02,400 --> 00:04:05,580
对我们而言，事实上如果你今后 

95
00:04:03,870 --> 00:04:07,500
开始制作 并付出更近的努力 

96
00:04:05,580 --> 00:04:09,210
注意所以相当长的路线

97
00:04:07,500 --> 00:04:11,820
输出它实际输出你 

98
00:04:09,210 --> 00:04:14,070
看到提到 - L cs50你会看到 

99
00:04:11,820 --> 00:04:15,900
L M它代表 -甚至提

100
00:04:14,070 --> 00:04:17,580
数学所以，如果你正在使用圆形

101
00:04:15,900 --> 00:04:19,859
你可能已经发现了这个例子

102
00:04:17,580 --> 00:04:23,100
第二轮也 没有用 

103
00:04:19,859 --> 00:04:26,400
除非 你使用make本身或者这个 

104
00:04:23,100 --> 00:04:28,680
更加细致入微的方法 所以这就是全部 

105
00:04:26,400 --> 00:04:30,390
说编译 有点白 

106
00:04:28,680 --> 00:04:31,500
谎言就像我们一直在 编译和 

107
00:04:30,390 --> 00:04:33,870
你一直从源 代码到 

108
00:04:31,500 --> 00:04:35,250
机器代码，但事实证明 

109
00:04:33,870 --> 00:04:36,600
还有很多 其他步骤 

110
00:04:35,250 --> 00:04:38,520
发生你说我们该怎么刚 

111
00:04:36,600 --> 00:04:39,840
在今天 结束时打了一些标签

112
00:04:38,520 --> 00:04:41,370
我们刚破坏的那一天

113
00:04:39,840 --> 00:04:42,780
抽象如此编译是这样的

114
00:04:41,370 --> 00:04:44,730
从源代码到机器的抽象

115
00:04:42,780 --> 00:04:46,710
代码让我们简单地放大一下 

116
00:04:44,730 --> 00:04:48,300
要欣赏它正在发生的事情 

117
00:04:46,710 --> 00:04:50,550
希望它能成为我们的代码 

118
00:04:48,300 --> 00:04:53,580
编译更容易理解 

119
00:04:50,550 --> 00:04:55,260
所以 ，当涉及到四 步 之一时 

120
00:04:53,580 --> 00:04:57,120
实际上编译程序被调用 

121
00:04:55,260 --> 00:04:58,680
预处理让人想起这个 

122
00:04:57,120 --> 00:05:00,840
我们刚刚看过的程序有一 对 

123
00:04:58,680 --> 00:05:02,520
包含在文件顶部的 这些 

124
00:05:00,840 --> 00:05:03,990
通常称为预处理器 

125
00:05:02,520 --> 00:05:06,270
指令不是特别的

126
00:05:03,990 --> 00:05:08,640
有趣的术语，但他们划定了界限

127
00:05:06,270 --> 00:05:10,330
通过这些行开头的哈希 

128
00:05:08,640 --> 00:05:11,740
这是一个信号 

129
00:05:10,330 --> 00:05:14,080
铿锵这些事应该是 

130
00:05:11,740 --> 00:05:16,569
处理了第一个预处理 过程 

131
00:05:14,080 --> 00:05:18,699
在其他事情之前，事实上 

132
00:05:16,569 --> 00:05:24,030
我们之前在上周讨论过的原因 

133
00:05:18,699 --> 00:05:24,030
cs50.h里面是什么情况 

134
00:05:24,180 --> 00:05:28,360
特别是这个 

135
00:05:26,199 --> 00:05:30,550
getstring的声明所以 有 一些 

136
00:05:28,360 --> 00:05:32,020
代码行如果你原型

137
00:05:30,550 --> 00:05:34,449
回想代码的一个行 

138
00:05:32,020 --> 00:05:36,189
教铿锵什么输入

139
00:05:34,449 --> 00:05:38,289
getstring是什么和输出是什么

140
00:05:36,189 --> 00:05:40,449
返回类型和参数 

141
00:05:38,289 --> 00:05:42,909
说话， 所以当你有包括 

142
00:05:40,449 --> 00:05:44,590
在文件的顶部cs50.h 是什么

143
00:05:42,909 --> 00:05:46,060
当你第一次跑铿锵时发生

144
00:05:44,590 --> 00:05:48,069
在这个所谓的预处理过程中 

145
00:05:46,060 --> 00:05:50,229
步骤是铿锵看起来在硬盘上 

146
00:05:48,069 --> 00:05:53,289
对于文件字面上称为cs50.h 它 

147
00:05:50,229 --> 00:05:55,930
抓住它的内容，基本上找到 

148
00:05:53,289 --> 00:05:58,930
并在这里替换这一行 

149
00:05:55,930 --> 00:06:00,729
在cs50中， H是一条像 这黄色 的线 

150
00:05:58,930 --> 00:06:02,590
这里说得到 了一个 

151
00:06:00,729 --> 00:06:04,060
函数返回一个字符串 ，并将其 

152
00:06:02,590 --> 00:06:07,029
作为输入，这将被称为 

153
00:06:04,060 --> 00:06:08,979
参数一个 将调用prompt 的字符串 

154
00:06:07,029 --> 00:06:11,229
同时包含标准i / o 

155
00:06:08,979 --> 00:06:13,270
什么是 包括什么的重点 

156
00:06:11,229 --> 00:06:17,349
在该文件中 声明 

157
00:06:13,270 --> 00:06:18,400
大概是标准输入和 

158
00:06:17,349 --> 00:06:21,370
输出，更具体地说是什么 

159
00:06:18,400 --> 00:06:22,990
例如，那是什么功能啊 

160
00:06:21,370 --> 00:06:25,930
printf我们继续使用的另一个功能 

161
00:06:22,990 --> 00:06:28,089
所以在标准的 IOH 内部 

162
00:06:25,930 --> 00:06:29,469
沙箱是硬盘驱动器同样是一个 

163
00:06:28,089 --> 00:06:30,940
坦率地看起来有点代码

164
00:06:29,469 --> 00:06:32,620
更加神秘，但我们会回到 这一点 

165
00:06:30,940 --> 00:06:34,659
在路上 说的 那种事情 

166
00:06:32,620 --> 00:06:36,190
print F是一个正在 返回 的函数 

167
00:06:34,659 --> 00:06:39,279
一个int，但更多的是另一个时间 

168
00:06:36,190 --> 00:06:40,990
碰巧 采取char星形格式但是 

169
00:06:39,279 --> 00:06:42,520
更确切地说，这 是 另一次 

170
00:06:40,990 --> 00:06:44,110
我们隐藏这个细节的原因之一 

171
00:06:42,520 --> 00:06:46,120
早期因为有一些语法 

172
00:06:44,110 --> 00:06:47,979
这只是一个分心，但现在 

173
00:06:46,120 --> 00:06:49,870
这就是尖锐的一切 

174
00:06:47,979 --> 00:06:51,879
包括标志只是发现和

175
00:06:49,870 --> 00:06:53,830
替换内容加上 点点 

176
00:06:51,879 --> 00:06:56,710
这些文件中 的一堆其他东西 

177
00:06:53,830 --> 00:06:57,639
也因此，当我们说预处理 我们 

178
00:06:56,710 --> 00:06:59,440
只是意味着这一点 

179
00:06:57,639 --> 00:07:00,759
替换，所以你不必复制 

180
00:06:59,440 --> 00:07:03,639
并手动粘贴这种东西 

181
00:07:00,759 --> 00:07:05,349
自己那么编译一个字 ， 

182
00:07:03,639 --> 00:07:06,819
实际上曾经有一个明确的 意义 

183
00:07:05,349 --> 00:07:08,469
你已经预处理了你的代码 和你 的代码 

184
00:07:06,819 --> 00:07:10,629
代码看起来基本上像这样

185
00:07:08,469 --> 00:07:14,139
你不知道的是真实的 

186
00:07:10,629 --> 00:07:16,949
编译步骤和这里的代码得到 

187
00:07:14,139 --> 00:07:19,060
变成了这里的代码，现在这是 

188
00:07:16,949 --> 00:07:20,919
可怕的 ，这就是那种 

189
00:07:19,060 --> 00:07:22,810
如果 你 参加像61这样的课程的话 

190
00:07:20,919 --> 00:07:24,160
在哈佛或更普遍的系统 

191
00:07:22,810 --> 00:07:25,660
编程，所以说你 

192
00:07:24,160 --> 00:07:29,830
可能会看到这样的事情，这是 

193
00:07:25,660 --> 00:07:31,060
x86 64位汇编指令 和 

194
00:07:29,830 --> 00:07:33,010
这个说法唯一有趣的事情

195
00:07:31,060 --> 00:07:34,570
目前是我很善良的集会 

196
00:07:33,010 --> 00:07:36,430
提到那个早期的汇编程序 

197
00:07:34,570 --> 00:07:37,810
输出一个点实际上是 一个 

198
00:07:36,430 --> 00:07:40,750
这里的关系， 但长话短说 

199
00:07:37,810 --> 00:07:42,970
这些是 较低级别的 说明 

200
00:07:40,750 --> 00:07:45,580
那个只有你 大脑 里面的CPU 

201
00:07:42,970 --> 00:07:46,870
电脑实际上了解你的CPU 

202
00:07:45,580 --> 00:07:49,180
不理解C它没有 

203
00:07:46,870 --> 00:07:50,320
了解Python或C ++或Java 或任何 

204
00:07:49,180 --> 00:07:52,750
您 可能熟悉 它的语言 

205
00:07:50,320 --> 00:07:54,880
它只能理解这种神秘的外观 

206
00:07:52,750 --> 00:07:57,040
事情 但坦率地从它的外观 

207
00:07:54,880 --> 00:07:58,750
你可能会收集 到的可能并非如此 

208
00:07:57,040 --> 00:07:59,770
多的乐趣 在我 的意思是 编程 

209
00:07:58,750 --> 00:08:02,680
可以说它并没有那么有趣 

210
00:07:59,770 --> 00:08:05,800
在 C中 编程， 所以这甚至看起来都很均匀 

211
00:08:02,680 --> 00:08:07,510
更加神秘， 但没关系 C和很多 

212
00:08:05,800 --> 00:08:09,820
语言只是这些抽象 

213
00:08:07,510 --> 00:08:12,070
在较低级别的东西之上 

214
00:08:09,820 --> 00:08:13,780
CPU确实理解我们 

215
00:08:12,070 --> 00:08:15,130
不必担心 它， 但是 

216
00:08:13,780 --> 00:08:17,740
如果我们在这里强调几个 术语你就会 

217
00:08:15,130 --> 00:08:19,360
看到一些熟悉的东西，主要 是 

218
00:08:17,740 --> 00:08:21,220
在这个所谓的集会中提到

219
00:08:19,360 --> 00:08:23,440
代码，你看到提到的getstring 和 

220
00:08:21,220 --> 00:08:25,330
printf 所以我们不会丢失信息 

221
00:08:23,440 --> 00:08:26,140
它只是在真正的呈现 

222
00:08:25,330 --> 00:08:29,140
不同的语言

223
00:08:26,140 --> 00:08:31,000
汇编语言现在你可以收集 

224
00:08:29,140 --> 00:08:33,280
也许是从其中 的一些 名字 

225
00:08:31,000 --> 00:08:35,890
说明这就是 Intel Inside 

226
00:08:33,280 --> 00:08:38,469
意味着英特尔或任何冲刺的 CPU 

227
00:08:35,890 --> 00:08:41,020
理解指示它意味着什么 

228
00:08:38,469 --> 00:08:43,690
喜欢推动， 移动和减去 

229
00:08:41,020 --> 00:08:45,970
并且调用这些都是低级别的 

230
00:08:43,690 --> 00:08:47,890
如果你愿意，那么动词会起作用 

231
00:08:45,970 --> 00:08:50,140
CPU的级别， 但更多 的 是 

232
00:08:47,890 --> 00:08:51,970
你可以参加整个 课程，但只是为了 

233
00:08:50,140 --> 00:08:53,410
今天就把这个 罩子 从这个带上

234
00:08:51,970 --> 00:08:56,020
是我们正在发生的一步 

235
00:08:53,410 --> 00:08:59,320
我们奇迹般地不为人知 

236
00:08:56,020 --> 00:09:00,910
铿锵如此聚集，你已经拥有了 

237
00:08:59,320 --> 00:09:02,290
这个神秘的代码，我们会

238
00:09:00,910 --> 00:09:04,330
我再也见不到 了 

239
00:09:02,290 --> 00:09:05,950
再输出你用它做什么 

240
00:09:04,330 --> 00:09:08,050
你之前说的只是电脑 

241
00:09:05,950 --> 00:09:09,820
了解零和第三个 

242
00:09:08,050 --> 00:09:13,180
步骤实际上是转换这个 

243
00:09:09,820 --> 00:09:14,920
汇编语言到实际的零和 

244
00:09:13,180 --> 00:09:17,140
那些现在看起来像这样 

245
00:09:14,920 --> 00:09:18,520
所以组装步骤正在发生 

246
00:09:17,140 --> 00:09:20,710
你每次跑步都不知道

247
00:09:18,520 --> 00:09:22,390
铿锵或反过来让我们得到了

248
00:09:20,710 --> 00:09:23,590
零和一 出 的汇编代码 

249
00:09:22,390 --> 00:09:27,100
我们正在获取汇编代码 

250
00:09:23,590 --> 00:09:30,550
您的C代码，但这是第三个或 

251
00:09:27,100 --> 00:09:32,800
第四步也是最后一步回忆起我们 

252
00:09:30,550 --> 00:09:34,360
需要链接其他人零和

253
00:09:32,800 --> 00:09:36,130
如果你使用printf 你没有 

254
00:09:34,360 --> 00:09:37,570
写别人创建 的那些 

255
00:09:36,130 --> 00:09:38,290
零和一的模式是， 

256
00:09:37,570 --> 00:09:40,449
电脑了解

257
00:09:38,290 --> 00:09:42,040
你没有创建getstring我们这样做了 

258
00:09:40,449 --> 00:09:44,050
你需要访问那些零和一个 

259
00:09:42,040 --> 00:09:46,389
以便您的程序可以将它们用作 

260
00:09:44,050 --> 00:09:47,560
好吧， 所以链接基本上是这样做的 

261
00:09:46,389 --> 00:09:50,259
你写的实例程序

262
00:09:47,560 --> 00:09:52,420
你好点 C，它碰巧 使用了一个 

263
00:09:50,259 --> 00:09:54,610
几个其他库 文件 

264
00:09:52,420 --> 00:09:57,310
其他人写的有用的代码

265
00:09:54,610 --> 00:10:00,009
你喜欢确实存在的cs50 dot C. 

266
00:09:57,310 --> 00:10:01,509
某处甚至标准的 IO点 C 

267
00:10:00,009 --> 00:10:03,610
哪个确实存在于某个地方或 

268
00:10:01,509 --> 00:10:05,199
技术上标准 IO这么大 

269
00:10:03,610 --> 00:10:07,360
他们实际上把printf放在一个库中

270
00:10:05,199 --> 00:10:09,430
文件专门称为printf dot C 

271
00:10:07,360 --> 00:10:11,290
但在沙箱中的某个地方很难 

272
00:10:09,430 --> 00:10:14,230
如果它们驱动我们所有的Mac和PC 

273
00:10:11,290 --> 00:10:16,180
支持编译我们 的实例文件 

274
00:10:14,230 --> 00:10:18,699
像这些， 但我们必须转换它 

275
00:10:16,180 --> 00:10:21,130
零和一个这个和这个然后 

276
00:10:18,699 --> 00:10:22,569
以某种方式将它们以图形方式组合在一起

277
00:10:21,130 --> 00:10:24,009
看起来有点像这样，这是 

278
00:10:22,569 --> 00:10:25,899
所有这一切都是由clang自动发生的 

279
00:10:24,009 --> 00:10:28,870
hello dot C你写的代码得到了 

280
00:10:25,899 --> 00:10:31,810
编译成汇编然后得到 

281
00:10:28,870 --> 00:10:34,329
组合成零和 所谓的 

282
00:10:31,810 --> 00:10:35,709
机器代码或目标代码cs50 dot C 

283
00:10:34,329 --> 00:10:38,410
我们在学期 前 为 你做了这件事 

284
00:10:35,709 --> 00:10:41,050
在任何之前就开始了printf 

285
00:10:38,410 --> 00:10:43,000
我们几十年前开始看起来像 

286
00:10:41,050 --> 00:10:45,100
这是三个单独的文件 

287
00:10:43,000 --> 00:10:46,990
虽然如此连接步骤字面上 

288
00:10:45,100 --> 00:10:50,380
意味着把所有 这些东西联系在一起 

289
00:10:46,990 --> 00:10:52,839
从 像 结合的零 和 

290
00:10:50,380 --> 00:10:54,220
三个至少是单独的文件而且只是 

291
00:10:52,839 --> 00:10:56,410
以这样的方式将它们组合起来 ，现在的 

292
00:10:54,220 --> 00:10:59,860
CPU 知道如何使用 不仅仅是你的代码 

293
00:10:56,410 --> 00:11:01,810
但是printf 和getstring 等等 

294
00:10:59,860 --> 00:11:03,699
上周我们引入了编译 作为一个 

295
00:11:01,810 --> 00:11:05,380
抽象，如果你愿意，这就是全部 

296
00:11:03,699 --> 00:11:07,690
我们真的是这个意思

297
00:11:05,380 --> 00:11:09,310
但现在我们已经看到了 正在 发生的 事情 

298
00:11:07,690 --> 00:11:11,740
在引擎盖下面，我们 可以规定 

299
00:11:09,310 --> 00:11:13,420
我的 CPU看起来很像 

300
00:11:11,740 --> 00:11:16,029
这笔虽然在笔记本电脑或笔记本电脑中较小

301
00:11:13,420 --> 00:11:19,269
桌面知道如何处理所有 

302
00:11:16,029 --> 00:11:21,430
所以对这四个问题有任何疑问 

303
00:11:19,269 --> 00:11:24,010
步骤预处理 编译 

304
00:11:21,430 --> 00:11:25,870
组装链接，但现在我们一般

305
00:11:24,010 --> 00:11:30,959
可以称他们为最多编译 

306
00:11:25,870 --> 00:11:30,959
人们做任何问题是的

307
00:11:39,610 --> 00:11:43,879
不是在预处理步骤中所以 

308
00:11:42,350 --> 00:11:46,100
问题是计算机是如何知道的 

309
00:11:43,879 --> 00:11:48,740
printf是 唯一的 功能 

310
00:11:46,100 --> 00:11:50,869
基本上当你进行链接时 

311
00:11:48,740 --> 00:11:52,850
只编码必需的零和一个

312
00:11:50,869 --> 00:11:54,439
通常有时会链接到你 

313
00:11:52,850 --> 00:11:57,050
比实际需要的还多 

314
00:11:54,439 --> 00:11:58,550
一个大图书馆， 但那也没关系 

315
00:11:57,050 --> 00:12:01,339
零和一个从未使用过 

316
00:11:58,550 --> 00:12:05,869
CPU 好问题 其他问题 

317
00:12:01,339 --> 00:12:07,819
没关系， 所以现在 我们知道了 

318
00:12:05,869 --> 00:12:09,889
我们可以开始 建立自己的方式 

319
00:12:07,819 --> 00:12:12,259
备份 ，因为每个人都可能在这里 

320
00:12:09,889 --> 00:12:13,939
现在知道 在用C 写的时候 

321
00:12:12,259 --> 00:12:16,309
在概念上 就像这样 

322
00:12:13,939 --> 00:12:17,809
并非没有障碍和问题 

323
00:12:16,309 --> 00:12:19,550
以及错误和错误让我们来介绍一下 

324
00:12:17,809 --> 00:12:20,869
一些技术和工具与 

325
00:12:19,550 --> 00:12:22,429
你可以在本周开始今后

326
00:12:20,869 --> 00:12:24,019
以及尝试解决这些问题 

327
00:12:22,429 --> 00:12:25,610
自己而 不仅仅是问题

328
00:12:24,019 --> 00:12:27,290
试图通读神秘的 

329
00:12:25,610 --> 00:12:28,879
查找错误消息或伸手去拿 

330
00:12:27,290 --> 00:12:31,100
帮助另一个人让我们看看是否 

331
00:12:28,879 --> 00:12:32,749
软件实际上可以回答一些问题 

332
00:12:31,100 --> 00:12:33,920
这些问题对你来说让 我走吧 

333
00:12:32,749 --> 00:12:36,319
前进并做到这一点让我继续前进 

334
00:12:33,920 --> 00:12:38,990
在这里打开一个沙箱 ，我要走了 

335
00:12:36,319 --> 00:12:41,689
提前创建 一个名为 buggy 的新文件 

336
00:12:38,990 --> 00:12:43,819
零点C 这次我将在这里 

337
00:12:41,689 --> 00:12:46,449
故意 介绍一个我要去的bug 

338
00:12:43,819 --> 00:12:48,920
继续 创建我的函数调用 

339
00:12:46,449 --> 00:12:51,050
main再次是默认的

340
00:12:48,920 --> 00:12:52,819
当点击绿旗时我会 

341
00:12:51,050 --> 00:12:57,290
继续说printf引用unquote 

342
00:12:52,819 --> 00:12:58,670
你好世界反斜杠 n 好吧 

343
00:12:57,290 --> 00:13:02,269
很好，我会继续前进 

344
00:12:58,670 --> 00:13:04,129
编译越野车零进入，当然我 

345
00:13:02,269 --> 00:13:06,319
在这里得到一堆 错误消息 

346
00:13:04,129 --> 00:13:07,999
我放大了他们幸运我只 

347
00:13:06,319 --> 00:13:09,829
有两种但要记住，你必须有 

348
00:13:07,999 --> 00:13:11,029
必须始终 向上滚动才能 看到 

349
00:13:09,829 --> 00:13:12,350
第一个因为可能只有一个 

350
00:13:11,029 --> 00:13:13,550
从一个恼人的级联效应

351
00:13:12,350 --> 00:13:16,370
早期的bug到了后来

352
00:13:13,550 --> 00:13:18,589
越野车零点c9五是这个 

353
00:13:16,370 --> 00:13:21,139
意味着角色五，就像五个空格 

354
00:13:18,589 --> 00:13:23,779
隐式声明 库函数 

355
00:13:21,139 --> 00:13:25,220
printf带点圆点，所以你要去

356
00:13:23,779 --> 00:13:26,720
如果你开始经常看到这个 

357
00:13:25,220 --> 00:13:29,149
犯这个特别的错误或 

358
00:13:26,720 --> 00:13:31,040
监督隐含地宣称某事 

359
00:13:29,149 --> 00:13:32,660
意味着你忘了教铿锵 

360
00:13:31,040 --> 00:13:34,519
存在的东西，你可能知道 

361
00:13:32,660 --> 00:13:37,549
从经验 或许现在是什么 

362
00:13:34,519 --> 00:13:39,970
解决方案是我犯的第一个错误

363
00:13:37,549 --> 00:13:39,970
在这里

364
00:13:40,310 --> 00:13:43,999
是的我 没有包含 头文件 

365
00:13:42,470 --> 00:13:47,410
为我缺少的图书馆说话

366
00:13:43,999 --> 00:13:50,449
文件 顶部 包括标准IOH 

367
00:13:47,410 --> 00:13:52,879
其中printf是定义但是让我们 

368
00:13:50,449 --> 00:13:54,410
建议你不太 确定 如何 

369
00:13:52,879 --> 00:13:55,939
达到这一点，我们如何得到 

370
00:13:54,410 --> 00:13:57,350
实际上有一些帮助， 让我 

371
00:13:55,939 --> 00:13:59,149
实际上增加了我的大小

372
00:13:57,350 --> 00:14:01,069
这里终端和回忆 ，只是 一个 

373
00:13:59,149 --> 00:14:03,259
前一刻 我跑了制作 越野车 零 

374
00:14:01,069 --> 00:14:05,360
产生了，我看到了错误事实证明 

375
00:14:03,259 --> 00:14:07,220
安装在 沙箱中的是 一个 

376
00:14:05,360 --> 00:14:09,620
我们工作人员写的命令叫 

377
00:14:07,220 --> 00:14:11,600
帮助50 ，这只是 我们的 一个 程序 

378
00:14:09,620 --> 00:14:13,999
写道，输入任何错误

379
00:14:11,600 --> 00:14:16,100
您的代码或某些程序的消息

380
00:14:13,999 --> 00:14:17,569
输出了我们的样子 

381
00:14:16,100 --> 00:14:19,160
熟悉的单词和短语就像一个 

382
00:14:17,569 --> 00:14:21,290
TF会在办公时间内，如果我们的话 

383
00:14:19,160 --> 00:14:23,420
认识到我们会发现一些错误信息 

384
00:14:21,290 --> 00:14:25,699
尝试提供修辞或修辞 

385
00:14:23,420 --> 00:14:27,559
明确一些关于如何 处理的 建议 

386
00:14:25,699 --> 00:14:29,959
所以，如果我继续 前进， 运行此命令 

387
00:14:27,559 --> 00:14:32,480
现在注意到我的输出有点多了 

388
00:14:29,959 --> 00:14:34,459
看到完全相同的输出 白色和 

389
00:14:32,480 --> 00:14:36,019
绿色和红色如前，但下面 

390
00:14:34,459 --> 00:14:38,089
是一些黄色的具体来说 

391
00:14:36,019 --> 00:14:40,990
从帮助50，如果我继续 和 缩放 

392
00:14:38,089 --> 00:14:44,600
在这个你会看到 的线 

393
00:14:40,990 --> 00:14:46,250
我们认识到的 输出 就是这个 

394
00:14:44,600 --> 00:14:48,620
那个我遇到口头的同一个人

395
00:14:46,250 --> 00:14:50,629
注意 之前有bug 0.05错误 

396
00:14:48,620 --> 00:14:53,600
隐式声明 库函数 

397
00:14:50,629 --> 00:14:54,949
的printf 等等 所以这里不 

398
00:14:53,600 --> 00:14:57,139
背景突出但仍在

399
00:14:54,949 --> 00:14:58,699
黄色是我们的建议或TF的问题 

400
00:14:57,139 --> 00:15:00,649
或者C a可能会在 办公时间 问你 

401
00:14:58,699 --> 00:15:03,889
你忘了包括标准吗？ 

402
00:15:00,649 --> 00:15:07,519
IOH ，其中printf声明在顶部 

403
00:15:03,889 --> 00:15:09,199
你的文件，希望我们的问题 

404
00:15:07,519 --> 00:15:11,089
修辞其他的眼睛是正确的 

405
00:15:09,199 --> 00:15:13,160
这会让你更进一步，所以让我们 

406
00:15:11,089 --> 00:15:16,610
继续前进， 尝试意见，使包括 

407
00:15:13,160 --> 00:15:18,110
标准的IOH 现在让我继续前进 

408
00:15:16,610 --> 00:15:20,029
回到这里如果 你愿意的 话 

409
00:15:18,110 --> 00:15:22,040
不喜欢杂乱，你可以键入清楚或 

410
00:15:20,029 --> 00:15:24,170
点击终端窗口中的ctrl L 

411
00:15:22,040 --> 00:15:26,389
如果你愿意的话 ，像我一样保持清洁

412
00:15:24,170 --> 00:15:30,199
现在继续前进并运行使马车 零 

413
00:15:26,389 --> 00:15:32,360
输入更少的错误， 以便 进步 

414
00:15:30,199 --> 00:15:34,819
并且不一样所以这个也许是一个 

415
00:15:32,360 --> 00:15:39,800
更容易阅读线条什么线 

416
00:15:34,819 --> 00:15:42,139
代码是错误的，所以这 是 

417
00:15:39,800 --> 00:15:43,189
事实证明，现在仍然排在第五位 

418
00:15:42,139 --> 00:15:45,170
出于不同的原因 

419
00:15:43,189 --> 00:15:46,730
我似乎错过了一个分号，但我 

420
00:15:45,170 --> 00:15:48,800
同样可以请求帮助50寻求帮助 

421
00:15:46,730 --> 00:15:50,269
有了它，希望 它能认出我的 

422
00:15:48,800 --> 00:15:51,709
错误，所以这也 应该开始 

423
00:15:50,269 --> 00:15:53,420
如果乍一看你的第一直觉

424
00:15:51,709 --> 00:15:53,750
你 真的不懂什么 

425
00:15:53,420 --> 00:15:55,100
错误

426
00:15:53,750 --> 00:15:56,900
即使你滚动到也只是做

427
00:15:55,100 --> 00:15:58,850
第 一个 就像 字面上问的那样 

428
00:15:56,900 --> 00:16:01,070
这个程序通过重新运行帮助

429
00:15:58,850 --> 00:16:03,620
完全相同的命令你刚刚跑了但是 

430
00:16:01,070 --> 00:16:05,900
用帮助50和空格前缀它

431
00:16:03,620 --> 00:16:09,710
将运行50帮助 你的任何 

432
00:16:05,900 --> 00:16:11,270
关于这个过程的问题好吧 

433
00:16:09,710 --> 00:16:14,150
看看另一个 程序 

434
00:16:11,270 --> 00:16:17,480
这个时间有 不同的例子

435
00:16:14,150 --> 00:16:18,710
错误涉及它 所以如何让 我 

436
00:16:17,480 --> 00:16:22,220
继续前进， 快速进行 程序 

437
00:16:18,710 --> 00:16:24,050
在这里，我将把这个有问题的2点C称为

438
00:16:22,220 --> 00:16:26,240
与我们的一些样品的一致性

439
00:16:24,050 --> 00:16:29,750
以后在这里和你 在线 

440
00:16:26,240 --> 00:16:31,670
例如， 我要继续 写下来 

441
00:16:29,750 --> 00:16:33,380
在第一个标准 IO点H 正确的事情 

442
00:16:31,670 --> 00:16:35,750
然后我会有int main void 

443
00:16:33,380 --> 00:16:37,100
这让我的整个程序开始了 

444
00:16:35,750 --> 00:16:39,380
然后我会有一个循环和 

445
00:16:37,100 --> 00:16:41,090
回想起来，马里奥或其他人 

446
00:16:39,380 --> 00:16:43,250
你可能做过的其他程序

447
00:16:41,090 --> 00:16:45,410
像int这样的东西我得到0我更少 

448
00:16:43,250 --> 00:16:48,440
或者 等于让我们这样做10 次 

449
00:16:45,410 --> 00:16:50,600
然后我加上加上 我想要的一切 

450
00:16:48,440 --> 00:16:54,620
在这个程序中打印出来的那个 

451
00:16:50,600 --> 00:16:56,390
我可以用 百分比 来衡量我的 价值 

452
00:16:54,620 --> 00:17:00,140
我占位符这么简单的程序 

453
00:16:56,390 --> 00:17:02,750
希望它从 0到 10 计数， 所以让我们 

454
00:17:00,140 --> 00:17:04,730
继续前进 ，跑2越野车或者说我 

455
00:17:02,750 --> 00:17:08,240
我想要 

456
00:17:04,730 --> 00:17:11,209
让我们不打印是的 倒带让我们走吧 

457
00:17:08,240 --> 00:17:16,040
提前并打印出一个哈希符号 

458
00:17:11,209 --> 00:17:17,810
而不是这样破坏解决方案 

459
00:17:16,040 --> 00:17:20,150
在这里，我继续打印 出越野车 

460
00:17:17,810 --> 00:17:22,010
我的目标是现在我将规定打印 

461
00:17:20,150 --> 00:17:23,900
每行 只有 10个哈希符号 

462
00:17:22,010 --> 00:17:25,640
这就是我想在这里和 现在 做的事情 

463
00:17:23,900 --> 00:17:29,240
我要继续 进行点斜线 

464
00:17:25,640 --> 00:17:31,760
越野车 2，我希望看到10 

465
00:17:29,240 --> 00:17:33,470
哈希好吧，我有点被宠坏了 

466
00:17:31,760 --> 00:17:39,590
这一点点，但 我该怎么做 

467
00:17:33,470 --> 00:17:41,420
看是的我认为我看到的比我多 

468
00:17:39,590 --> 00:17:47,450
期待，我们可以放大这里 

469
00:17:41,420 --> 00:17:50,750
仔细检查 1 2 3 4 5 6 7 8 9 10 

470
00:17:47,450 --> 00:17:52,730
11 11 现在你的一些眼睛可能会 

471
00:17:50,750 --> 00:17:54,800
已经在努力解决问题了

472
00:17:52,730 --> 00:17:56,210
应该是，但我们只是建议 

473
00:17:54,800 --> 00:17:57,680
它并不明显 ，如果它实际上是 

474
00:17:56,210 --> 00:17:59,450
非显而易见的更好所以如何可能 

475
00:17:57,680 --> 00:18:00,860
你去 诊断这种 

476
00:17:59,450 --> 00:18:02,750
问题不仅仅是伸手而出 

477
00:18:00,860 --> 00:18:04,910
向人寻求帮助这不是一个 

478
00:18:02,750 --> 00:18:06,560
问题， 帮助50 可与帮助 

479
00:18:04,910 --> 00:18:07,730
因为这不是你的错误信息 

480
00:18:06,560 --> 00:18:09,830
程序正在运行

481
00:18:07,730 --> 00:18:11,180
它只是没有输出你想要的东西 

482
00:18:09,830 --> 00:18:13,220
它工作但它 不是一个错误信息 

483
00:18:11,180 --> 00:18:15,140
来自编译器的帮助50可以 

484
00:18:13,220 --> 00:18:17,840
帮助所以你想要 得到眼睛 

485
00:18:15,140 --> 00:18:19,460
进入你的计划正在 做什么 和你 

486
00:18:17,840 --> 00:18:21,470
想知道你为什么打印 

487
00:18:19,460 --> 00:18:23,600
11当你真正 设置它时 

488
00:18:21,470 --> 00:18:25,910
从0到10 井 是最常见的一种 

489
00:18:23,600 --> 00:18:28,310
C语言或任何语言的老练 

490
00:18:25,910 --> 00:18:31,070
就是将printf用于其他目的

491
00:18:28,310 --> 00:18:32,720
诊断目的，例如那里

492
00:18:31,070 --> 00:18:34,250
在这个 计划中没有太多进展但是 

493
00:18:32,720 --> 00:18:36,290
我认为 这会很 有趣 

494
00:18:34,250 --> 00:18:39,050
让 我知道 ，因此 明白 

495
00:18:36,290 --> 00:18:42,770
通过只是我的节目，让我们打印出此 

496
00:18:39,050 --> 00:18:44,690
通过执行每次迭代的I值

497
00:18:42,770 --> 00:18:46,960
的代码行， 我先前做的和 

498
00:18:44,690 --> 00:18:49,280
只是说出 像 我 一样的 东西 

499
00:18:46,960 --> 00:18:50,540
百分之百我喜欢我会 删除它 

500
00:18:49,280 --> 00:18:53,120
最终因为它会让我的 

501
00:18:50,540 --> 00:18:54,680
程序看起来有点傻但是 它 

502
00:18:53,120 --> 00:18:58,120
会帮助我理解发生了什么 

503
00:18:54,680 --> 00:19:02,300
让我继续，重新编译 越野车 2 

504
00:18:58,120 --> 00:19:04,940
dot slash buggy 2这次我看到了 

505
00:19:02,300 --> 00:19:08,450
更多的输出，但如果我现在放大 

506
00:19:04,940 --> 00:19:10,040
现在计算机就是这样的 

507
00:19:08,450 --> 00:19:12,230
基本上帮助我理解是什么 

508
00:19:10,040 --> 00:19:14,810
当我 在这里 是 零时继续前进

509
00:19:12,230 --> 00:19:17,180
当我在这里时，他们是另一个是 2 3 

510
00:19:14,810 --> 00:19:19,130
4 5 6 7 8 9看起来不错但是如果 

511
00:19:17,180 --> 00:19:22,190
我们进一步滚动感觉一个 

512
00:19:19,130 --> 00:19:23,990
小问题 我也能 10 

513
00:19:22,190 --> 00:19:27,680
那么从逻辑上来说这是什么错误

514
00:19:23,990 --> 00:19:29,390
程序是啊我使用不到或等于 

515
00:19:27,680 --> 00:19:31,160
因为 我有点困惑 

516
00:19:29,390 --> 00:19:33,110
范式右像程序员往往 

517
00:19:31,160 --> 00:19:34,610
显然从零开始计数， 但我 

518
00:19:33,110 --> 00:19:36,050
要做到这一点的 10 倍，并 在 

519
00:19:34,610 --> 00:19:37,660
人类 世界，如果我想做点什么 10 

520
00:19:36,050 --> 00:19:40,280
我可能算得上，也包括在内 

521
00:19:37,660 --> 00:19:42,140
10，但你不能两种方式 

522
00:19:40,280 --> 00:19:44,240
如果你不能从0开始到10结束 

523
00:19:42,140 --> 00:19:45,290
我想做 10次 这样的 事情 

524
00:19:44,240 --> 00:19:49,370
哪里有几种可能性 

525
00:19:45,290 --> 00:19:50,540
我们怎么可能解决这个问题， 所以我们 

526
00:19:49,370 --> 00:19:54,200
当然可以将它改为小于 

527
00:19:50,540 --> 00:19:55,850
什么是另一种正确的方法是的 

528
00:19:54,200 --> 00:19:57,590
我们可以把这个留下来，然后 开始 

529
00:19:55,850 --> 00:19:59,180
如果你不是真的，那就算是1 

530
00:19:57,590 --> 00:20:00,800
打印实际值

531
00:19:59,180 --> 00:20:02,720
程序可能是完美的 

532
00:20:00,800 --> 00:20:04,370
合理也是 如此 

533
00:20:02,720 --> 00:20:06,290
常规喜欢舒服 

534
00:20:04,370 --> 00:20:08,120
很快 从零开始 计算 因为 

535
00:20:06,290 --> 00:20:10,730
这就是大多数人所做的 

536
00:20:08,120 --> 00:20:13,160
这些天， 但这里的技术只是 

537
00:20:10,730 --> 00:20:15,770
使用printf时就像怀疑一样 

538
00:20:13,160 --> 00:20:17,060
在这一行的这一行上使用printf 

539
00:20:15,770 --> 00:20:18,650
这条线在某个地方

540
00:20:17,060 --> 00:20:20,120
有趣的可能 会在 你的 

541
00:20:18,650 --> 00:20:21,490
程序只是用 它 打印 出来的 

542
00:20:20,120 --> 00:20:23,320
字符串是 在变量 

543
00:20:21,490 --> 00:20:25,330
打印出我的整数 

544
00:20:23,320 --> 00:20:26,830
你的变量或其他任何东西 

545
00:20:25,330 --> 00:20:30,540
你可以这么说 

546
00:20:26,830 --> 00:20:34,900
程序 内部发生了什么 

547
00:20:30,540 --> 00:20:37,540
printf 好的最后一个工具， 所以它不是 

548
00:20:34,900 --> 00:20:39,490
编写代码时 可能不常见

549
00:20:37,540 --> 00:20:40,480
特别是 在 早期的 时候 有点草率 

550
00:20:39,490 --> 00:20:42,580
你不是很熟悉 

551
00:20:40,480 --> 00:20:45,640
模式，例如，如果我继续前进 

552
00:20:42,580 --> 00:20:46,210
通过删除一大堆 来 做到这一点 

553
00:20:45,640 --> 00:20:48,400
空白 

554
00:20:46,210 --> 00:20:50,650
即使在 通过去 解决 这个错误 之后 

555
00:20:48,400 --> 00:20:54,250
从零 到十是这个程序现在 

556
00:20:50,650 --> 00:20:59,230
如果目标是 打印 10，请更正

557
00:20:54,250 --> 00:21:04,390
哈希是的，为什么它是正确的 

558
00:20:59,230 --> 00:21:06,730
什么意义，是的， 它仍然有效 

559
00:21:04,390 --> 00:21:09,250
它打印出十个哈希值 

560
00:21:06,730 --> 00:21:11,320
行，但它 写在 不良 

561
00:21:09,250 --> 00:21:13,330
风格感如此回忆我们倾向于 

562
00:21:11,320 --> 00:21:14,890
评估和世界倾向于思考 

563
00:21:13,330 --> 00:21:16,570
关于代码至少有三种方式之一

564
00:21:14,890 --> 00:21:17,980
它的正确性是什么呢 

565
00:21:16,570 --> 00:21:19,780
应该像打印 十个哈希和 

566
00:21:17,980 --> 00:21:21,309
是的，因为我所做的只是删除 

567
00:21:19,780 --> 00:21:23,440
空格我实际上没有改变或 

568
00:21:21,309 --> 00:21:25,270
使得该修复程序后，打破代码

569
00:21:23,440 --> 00:21:27,190
设计 怎么样 怎么样 周到 

570
00:21:25,270 --> 00:21:28,420
写得很好是代码，坦率地说 

571
00:21:27,190 --> 00:21:30,100
这也很难写 出来 

572
00:21:28,420 --> 00:21:31,630
很多方法， 因为 它的线条很少 但是 

573
00:21:30,100 --> 00:21:33,370
随着 时间的推移 你会看到 你的节目 

574
00:21:31,630 --> 00:21:34,660
培养教学研究员 和员工可以 

575
00:21:33,370 --> 00:21:36,610
为您 提供有关设计的反馈 

576
00:21:34,660 --> 00:21:38,770
你的 代码，但风格相对 

577
00:21:36,610 --> 00:21:40,630
方便， 我一直 主要 由 教 它 

578
00:21:38,770 --> 00:21:42,760
例如，如果你愿意，因为我

579
00:21:40,630 --> 00:21:44,440
一直非常有条理地缩进我的代码 

580
00:21:42,760 --> 00:21:46,210
并确保一切都看起来 

581
00:21:44,440 --> 00:21:48,400
非常漂亮或至少相当漂亮 

582
00:21:46,210 --> 00:21:50,410
训练有素的眼睛，但这只是 

583
00:21:48,400 --> 00:21:52,630
规定并不像左边那样 

584
00:21:50,410 --> 00:21:54,790
对准一切仍然工作 不 

585
00:21:52,630 --> 00:21:56,620
不正确， 但它的风格很差 

586
00:21:54,790 --> 00:21:58,150
这将是不 争论 

587
00:21:56,620 --> 00:21:59,770
编写这样的代码 而不是 

588
00:21:58,150 --> 00:22:04,590
像我刚才那样 写代码 

589
00:21:59,770 --> 00:22:04,590
虽然修好 了虫子，但是 

590
00:22:13,210 --> 00:22:17,960
让我总结一下这 是允许的 

591
00:22:15,500 --> 00:22:19,909
你可以看到 更直观的 东西 

592
00:22:17,960 --> 00:22:22,039
单个子程序或代码块 

593
00:22:19,909 --> 00:22:23,870
这样做 与每个 相关联 

594
00:22:22,039 --> 00:22:25,789
其他正确的划痕是丰富多彩的 

595
00:22:23,870 --> 00:22:27,470
具有像拥抱形状的形状

596
00:22:25,789 --> 00:22:29,179
许多控制块都会产生 

597
00:22:27,470 --> 00:22:31,340
向程序员直观地表达清楚 

598
00:22:29,179 --> 00:22:33,500
这个区块包含其他人和 

599
00:22:31,340 --> 00:22:35,210
因此， 重复阻止或此 

600
00:22:33,500 --> 00:22:36,980
永远阻止正在做这些 事情 

601
00:22:35,210 --> 00:22:38,630
再，再而这就是 

602
00:22:36,980 --> 00:22:40,730
这些花括号服务的角色

603
00:22:38,630 --> 00:22:43,340
在这个和另一个背景下的缩进

604
00:22:40,730 --> 00:22:45,320
只是帮助它变得更加 明显 

605
00:22:43,340 --> 00:22:47,720
程序员什么是什么和内部

606
00:22:45,320 --> 00:22:50,059
这是怎么回事

607
00:22:47,720 --> 00:22:52,130
写得好， 因为你可以看到 

608
00:22:50,059 --> 00:22:53,720
main中的代码就是一切 

609
00:22:52,130 --> 00:22:55,610
这是在这里缩进 的代码 

610
00:22:53,720 --> 00:22:57,649
for循环 内部 就是一切 

611
00:22:55,610 --> 00:22:59,389
在这里缩进 所以它只适合我们人类 

612
00:22:57,649 --> 00:23:00,830
读者教学 研究员 的情况 

613
00:22:59,389 --> 00:23:02,870
该课程或同事的情况 

614
00:23:00,830 --> 00:23:04,429
现实世界， 但假设 你 

615
00:23:02,870 --> 00:23:07,669
不太看到这些模式 

616
00:23:04,429 --> 00:23:09,260
最初很容易就是 cs50 

617
00:23:07,669 --> 00:23:11,659
在其网站上有我们称之为风格的东西

618
00:23:09,260 --> 00:23:13,580
指导它只是你的总结 

619
00:23:11,659 --> 00:23:15,590
代码应该在使用某些时 看起来像 

620
00:23:13,580 --> 00:23:17,029
C循环条件变量的特征 

621
00:23:15,590 --> 00:23:18,950
功能等等，它是相互关联的 

622
00:23:17,029 --> 00:23:20,870
在课程网站上， 但也有 

623
00:23:18,950 --> 00:23:22,610
写作时可以使用的工具

624
00:23:20,870 --> 00:23:24,500
你的代码 可以帮助你清理它 

625
00:23:22,610 --> 00:23:26,059
并使其一致， 而不仅仅是为了 

626
00:23:24,500 --> 00:23:27,320
制作 与风格一致 的缘故

627
00:23:26,059 --> 00:23:30,080
指导，但只是制作 自己的代码 

628
00:23:27,320 --> 00:23:31,429
可读性更可读，例如 

629
00:23:30,080 --> 00:23:35,480
如果我 继续 并 运行一个 名为 的命令 

630
00:23:31,429 --> 00:23:38,710
这个程序错误的样式50到点C 

631
00:23:35,480 --> 00:23:42,049
然后点击进入我会看到一些 

632
00:23:38,710 --> 00:23:44,600
多彩的输出 我看到自己的 代码 

633
00:23:42,049 --> 00:23:47,630
在白色，然后我看到我的 任何地方 

634
00:23:44,600 --> 00:23:49,490
应该有缩进的 绿色空间 

635
00:23:47,630 --> 00:23:51,230
有点鼓励我放空间 

636
00:23:49,490 --> 00:23:53,090
这里的空间空间放置了空间

637
00:23:51,230 --> 00:23:55,100
这里空间空间放八个空格这里 

638
00:23:53,090 --> 00:23:57,080
这里有四个空格，然后等等 

639
00:23:55,100 --> 00:23:58,730
它提醒我应该添加评论 

640
00:23:57,080 --> 00:24:00,380
这 也是一个简短的程序 

641
00:23:58,730 --> 00:24:02,179
一定需要很多 的 评论的事 

642
00:24:00,380 --> 00:24:04,070
解释发生了什么，但只是一个 

643
00:24:02,179 --> 00:24:05,690
像我们上周看到的那样斜线斜线

644
00:24:04,070 --> 00:24:07,549
解释可能在文件的顶部或 

645
00:24:05,690 --> 00:24:09,679
顶部的 代码 块 将 

646
00:24:07,549 --> 00:24:11,389
风格50也 快乐，所以让我们这样做 

647
00:24:09,679 --> 00:24:14,750
让我继续 并接受它的建议 

648
00:24:11,389 --> 00:24:16,610
实际上用tab将其缩进

649
00:24:14,750 --> 00:24:18,620
选项卡这将选项卡这将选项卡和

650
00:24:16,610 --> 00:24:19,850
这一次，你会发现， 上 

651
00:24:18,620 --> 00:24:22,039
你的键盘， 即使你正在击中 

652
00:24:19,850 --> 00:24:23,840
tab 它实际上是为你转换它 

653
00:24:22,039 --> 00:24:24,710
这对于 空间来说非常普遍 

654
00:24:23,840 --> 00:24:26,659
你不必打 

655
00:24:24,710 --> 00:24:28,399
空格键 四次进入 

656
00:24:26,659 --> 00:24:31,820
使用 标签的习惯， 让我继续 

657
00:24:28,399 --> 00:24:34,159
并在这里写评论 打印十 

658
00:24:31,820 --> 00:24:35,929
哈希这样我的同事我 

659
00:24:34,159 --> 00:24:37,309
教学研究员在一周内 没有 

660
00:24:35,929 --> 00:24:38,539
必须再次阅读我自己的代码 

661
00:24:37,309 --> 00:24:41,720
弄清楚 它能做 什么我能读懂 

662
00:24:38,539 --> 00:24:45,080
单独的评论/ / / 如果我跑 

663
00:24:41,720 --> 00:24:46,460
风格50再次现在看起来好 它在 

664
00:24:45,080 --> 00:24:48,710
按照风格指南 和它的 

665
00:24:46,460 --> 00:24:50,120
只是写得那么漂亮 

666
00:24:48,710 --> 00:24:52,130
印刷将是本领域的一个术语

667
00:24:50,120 --> 00:24:54,710
编程时代码看起来很好 

668
00:24:52,130 --> 00:25:03,350
并且不仅仅是 正确的任何问题 

669
00:24:54,710 --> 00:25:04,610
然后是的，它没有启用

670
00:25:03,350 --> 00:25:07,039
它的第一周就启用了 

671
00:25:04,610 --> 00:25:10,880
截至目前和以后 其他 

672
00:25:07,039 --> 00:25:12,799
问题没事所以 只是回顾一下 

673
00:25:10,880 --> 00:25:14,360
然后有三个工具

674
00:25:12,799 --> 00:25:15,740
众所周知的工具箱现在我们的帮助50 

675
00:25:14,360 --> 00:25:17,179
任何时候你看到一个错误 消息 

676
00:25:15,740 --> 00:25:19,010
你不明白 它是否 与 

677
00:25:17,179 --> 00:25:21,590
制造或铿锵或者别的东西

678
00:25:19,010 --> 00:25:23,299
当你 有一个逻辑程序 时， printf 

679
00:25:21,590 --> 00:25:24,980
你的程序中的一个错误， 它只是没有 

680
00:25:23,299 --> 00:25:26,690
工作， 是很 应该 的方式 或 

681
00:25:24,980 --> 00:25:28,730
问题集的方式告诉你 

682
00:25:26,690 --> 00:25:30,440
应该然后 你想要的 风格 50 

683
00:25:28,730 --> 00:25:32,840
以确保 它确实我的代码 看 

684
00:25:30,440 --> 00:25:34,820
就风格而言， 就是这样 

685
00:25:32,840 --> 00:25:36,080
尽可能可读，老实说你会 

686
00:25:34,820 --> 00:25:37,940
在办公时间等找到我们

687
00:25:36,080 --> 00:25:39,470
以前经常鼓励你嘿，我们 

688
00:25:37,940 --> 00:25:41,270
回答这个问题，请你跑 

689
00:25:39,470 --> 00:25:42,799
您 可以 在代码上使用样式50 

690
00:25:41,270 --> 00:25:44,929
清理你的代码，因为它只是 

691
00:25:42,799 --> 00:25:46,340
我们的生活 对其 他人来说如此之多 

692
00:25:44,929 --> 00:25:47,840
我们可以 更容易 理解什么是 

693
00:25:46,340 --> 00:25:49,669
继续而不必在视觉上 

694
00:25:47,840 --> 00:25:51,950
找出括号和卷曲的内容 

695
00:25:49,669 --> 00:25:53,480
括号排队，所以 去那个 

696
00:25:51,950 --> 00:25:55,399
因为习惯将节省您的时间，从 

697
00:25:53,480 --> 00:26:00,169
不得不浪费时间 解析 一些东西 

698
00:25:55,399 --> 00:26:02,539
视觉上你自己 没事，所以没有 

699
00:26:00,169 --> 00:26:04,070
只是CPU和计算机CPU是 

700
00:26:02,539 --> 00:26:05,720
大脑中央处理单元和 

701
00:26:04,070 --> 00:26:07,159
这 就是我们一直在强调 的 原因 

702
00:26:05,720 --> 00:26:09,080
计算机理解的说明 

703
00:26:07,159 --> 00:26:11,240
这也是我们上次看到的

704
00:26:09,080 --> 00:26:14,960
- 这 是什么类型 的 例子 

705
00:26:11,240 --> 00:26:17,120
硬件RAM或随机存取存储器

706
00:26:14,960 --> 00:26:19,279
这是 笔记本电脑 的 内存 类型 

707
00:26:17,120 --> 00:26:21,710
桌面服务器已使用

708
00:26:19,279 --> 00:26:23,210
当你运行程序或打开 

709
00:26:21,710 --> 00:26:25,340
文件有另一种类型的内存 

710
00:26:23,210 --> 00:26:26,630
称为硬盘驱动器或固态驱动器 

711
00:26:25,340 --> 00:26:28,190
你可能熟悉它 

712
00:26:26,630 --> 00:26:29,870
消费者，这就是你的 

713
00:26:28,190 --> 00:26:31,909
文件永久存储， 你可以 

714
00:26:29,870 --> 00:26:33,559
你的电池可以死你可以拉

715
00:26:31,909 --> 00:26:34,789
从 您的 笔记本电脑或台式机插入任何 

716
00:26:33,559 --> 00:26:37,279
保存在硬盘上的文件是 

717
00:26:34,789 --> 00:26:38,680
坚持不懈他们留在那里因为 

718
00:26:37,279 --> 00:26:42,460
用于实施的技术

719
00:26:38,680 --> 00:26:44,380
那个但是 拉姆是比较短暂的拉姆 

720
00:26:42,460 --> 00:26:46,270
它仅由电力供电

721
00:26:44,380 --> 00:26:48,610
电源打开或电池使用 

722
00:26:46,270 --> 00:26:50,470
是收费的，这是你的文件和 

723
00:26:48,610 --> 00:26:52,570
程序有效地生活在你身边 

724
00:26:50,470 --> 00:26:53,740
双击它们然后打开 它们 

725
00:26:52,570 --> 00:26:55,900
当你双击类似的东西时 

726
00:26:53,740 --> 00:26:58,840
Microsoft Word 它是从您的复制 

727
00:26:55,900 --> 00:27:01,210
硬盘长期 进入这种类型 

728
00:26:58,840 --> 00:27:03,280
内存因为这种类型的内存那些 

729
00:27:01,210 --> 00:27:05,470
容量较小，你没有

730
00:27:03,280 --> 00:27:08,290
很多字节，但它是非常多的 

731
00:27:05,470 --> 00:27:10,090
当你打开时，同样快得多

732
00:27:08,290 --> 00:27:11,740
一个文件或你去一个 网页 

733
00:27:10,090 --> 00:27:14,020
您正在查看的文件的内容

734
00:27:11,740 --> 00:27:15,400
存储在这种类型的硬件中 是因为 

735
00:27:14,020 --> 00:27:17,140
即使你没有 很多 

736
00:27:15,400 --> 00:27:19,720
它的字节非常多 

737
00:27:17,140 --> 00:27:21,430
更快， 所以这将是主题 

738
00:27:19,720 --> 00:27:24,130
在计算机科学和硬件方面你 

739
00:27:21,430 --> 00:27:26,020
有很多便宜的慢东西 

740
00:27:24,130 --> 00:27:28,000
就像硬盘空间相对而言 

741
00:27:26,020 --> 00:27:30,580
你有越少一点 

742
00:27:28,000 --> 00:27:32,680
昂贵但更快的东西，如RAM和 

743
00:27:30,580 --> 00:27:33,850
你只有一个通常的CPU 

744
00:27:32,680 --> 00:27:36,280
真正快速的事情可以做到 

745
00:27:33,850 --> 00:27:38,500
每秒 十亿的 东西 ，但它是谁 

746
00:27:36,280 --> 00:27:40,360
更贵，所以有四个 

747
00:27:38,500 --> 00:27:42,220
如果你愿意的话就可以看到这个东西

748
00:27:40,360 --> 00:27:43,540
我们不会 详细介绍 如何 

749
00:27:42,220 --> 00:27:46,210
这些东西可以工作，但让我们放大一下 

750
00:27:43,540 --> 00:27:48,220
在这一块黑色芯片上，专注于此

751
00:27:46,210 --> 00:27:50,110
它为代表 的一些 

752
00:27:48,220 --> 00:27:52,000
内存量可能是一兆字节 

753
00:27:50,110 --> 00:27:54,850
100万字节也许就是一个 

754
00:27:52,000 --> 00:27:56,350
gigabyte这几天是10亿字节但是 

755
00:27:54,850 --> 00:27:58,210
这就是说这个芯片可以 

756
00:27:56,350 --> 00:28:00,370
想到只是 有一堆 

757
00:27:58,210 --> 00:28:02,440
在这 此 字节 是不按比例 你 

758
00:28:00,370 --> 00:28:03,760
有更多的字节比这些，但让 

759
00:28:02,440 --> 00:28:05,350
我建议你只 想到每一个 

760
00:28:03,760 --> 00:28:07,420
这些正方形 在这里代表 

761
00:28:05,350 --> 00:28:09,700
一个字节，所以第一个字节 

762
00:28:07,420 --> 00:28:11,560
内存我曾访问 这里是下 一个 

763
00:28:09,700 --> 00:28:12,970
在这里等等 ，事实上， 

764
00:28:11,560 --> 00:28:14,860
他们环绕的只是一个 艺术家 

765
00:28:12,970 --> 00:28:16,750
你可以想到这些东西 

766
00:28:14,860 --> 00:28:18,760
实际上几乎是 从左到右 

767
00:28:16,750 --> 00:28:20,800
不是 在任何一种 网格中而是在物理上 

768
00:28:18,760 --> 00:28:23,620
他们看起来像这样，所以当你真的 

769
00:28:20,800 --> 00:28:26,050
在像 C 这样的程序中创建一个变量 

770
00:28:23,620 --> 00:28:28,900
就像你需要一个char往往是char 

771
00:28:26,050 --> 00:28:31,630
一个字节或 八个比特，这 意味着 

772
00:28:28,900 --> 00:28:34,690
当你有一个 char类型 的变量 时 

773
00:28:31,630 --> 00:28:37,030
一个C程序，它实际上是物理上的 

774
00:28:34,690 --> 00:28:38,590
在你的内部的这些盒子之一 

775
00:28:37,030 --> 00:28:40,750
计算机的Ram，例如它可能 

776
00:28:38,590 --> 00:28:43,240
如果，请在左上方占据这么大的空间 

777
00:28:40,750 --> 00:28:44,920
你有更大的数据类型

778
00:28:43,240 --> 00:28:47,230
有一个趋于4的整数

779
00:28:44,920 --> 00:28:48,730
字节或32位您可能需要更多 

780
00:28:47,230 --> 00:28:51,070
计算机可能 不是一个 方格 

781
00:28:48,730 --> 00:28:51,830
让您访问四个方块 

782
00:28:51,070 --> 00:28:54,260
你有 

783
00:28:51,830 --> 00:28:55,970
跨越该内存区域的32位 

784
00:28:54,260 --> 00:28:57,289
但说实话，我选择了这些盒子 

785
00:28:55,970 --> 00:28:59,090
任意地他们可以在任何地方

786
00:28:57,289 --> 00:29:01,070
在任何其它芯片 该 芯片或 

787
00:28:59,090 --> 00:29:02,600
这取决于计算机才能 记住 

788
00:29:01,070 --> 00:29:05,269
他们是你， 你不需要 

789
00:29:02,600 --> 00:29:07,730
记得本身 ，而是如果我们 认为 

790
00:29:05,269 --> 00:29:09,740
关于这个网格，事实证明这是

791
00:29:07,730 --> 00:29:12,169
其实很 宝贵的 ， 我们有 

792
00:29:09,740 --> 00:29:14,570
大块的内存字节，如果你愿意的话 

793
00:29:12,169 --> 00:29:16,490
背靠背背靠背 

794
00:29:14,570 --> 00:29:18,620
其实还有一个词来形容这种技术 

795
00:29:16,490 --> 00:29:20,360
这是 背靠背的 连续 记忆 

796
00:29:18,620 --> 00:29:22,549
以背靠背 一般备份和 

797
00:29:20,360 --> 00:29:23,149
在编程中，这被称为 

798
00:29:22,549 --> 00:29:25,340
排列

799
00:29:23,149 --> 00:29:26,510
如果你使用，你可能会从头开始回忆

800
00:29:25,340 --> 00:29:28,130
这个功能实际上有东西 

801
00:29:26,510 --> 00:29:30,139
叫做列表就是那个 

802
00:29:28,130 --> 00:29:32,720
值列表。列表的单词列表 

803
00:29:30,139 --> 00:29:34,490
数组中的字符串只是一个 连续的 

804
00:29:32,720 --> 00:29:35,659
大块的记忆，你可以存储 

805
00:29:34,490 --> 00:29:37,820
有些东西 会听到 某些东西 

806
00:29:35,659 --> 00:29:40,399
听到一些 听到的声音 ，等等 

807
00:29:37,820 --> 00:29:43,190
所以事实证明这是一个超级阵列 

808
00:29:40,399 --> 00:29:45,950
简单的原始实际上令人难以置信 

809
00:29:43,190 --> 00:29:47,090
强大的只是能够 存储的东西 

810
00:29:45,950 --> 00:29:49,370
在我电脑的记忆里 

811
00:29:47,090 --> 00:29:53,179
背对背，背对背启用 

812
00:29:49,370 --> 00:29:54,710
许多可能性都 设计明智样 

813
00:29:53,179 --> 00:29:57,470
如何我可以写我的代码， 同时也 

814
00:29:54,710 --> 00:30:00,260
我能以多快的速度运行 我的 代码 

815
00:29:57,470 --> 00:30:02,360
我继续， 拿出一个例子 

816
00:30:00,260 --> 00:30:05,419
我去 进取，不断开拓 的实例 

817
00:30:02,360 --> 00:30:07,760
沙盒中的新文件，我们将调用 

818
00:30:05,419 --> 00:30:10,250
这个成绩为零 ，以让 我继续前进 ， 

819
00:30:07,760 --> 00:30:13,760
关闭这个创建一个名为的新文件

820
00:30:10,250 --> 00:30:16,340
得分为零点C，在这个文件中让我们 

821
00:30:13,760 --> 00:30:18,320
继续写一个相对简单的 

822
00:30:16,340 --> 00:30:19,669
程序让我像往常一样 继续前进 

823
00:30:18,320 --> 00:30:22,700
让自己获得一些有用的帮助 

824
00:30:19,669 --> 00:30:24,200
函数cs50.h 和标准 IO 点 H. 

825
00:30:22,700 --> 00:30:26,120
并且无需将所有这些复制下来 

826
00:30:24,200 --> 00:30:27,710
如果你不喜欢一切，请逐字逐句

827
00:30:26,120 --> 00:30:29,929
将有或已经在 课程 

828
00:30:27,710 --> 00:30:32,149
网站 让我像往常一样启动我的程序 

829
00:30:29,929 --> 00:30:34,010
用int main void然后让我写

830
00:30:32,149 --> 00:30:37,639
这个 程序名称暗示的程序 

831
00:30:34,010 --> 00:30:39,740
就像问用户 三个分数一样 

832
00:30:37,639 --> 00:30:41,090
在最近的问题集上测验什么

833
00:30:39,740 --> 00:30:43,220
然后有点创造一个非常简单的 

834
00:30:41,090 --> 00:30:45,049
他们的图表就像条形图一样 善良 

835
00:30:43,220 --> 00:30:47,389
帮助我想象出如何或 如何 

836
00:30:45,049 --> 00:30:50,210
如果我愿意，我做的很糟糕

837
00:30:47,389 --> 00:30:52,190
得到一个整数毫不奇怪，我们可以使用 

838
00:30:50,210 --> 00:30:54,889
get int 函数，我可以 问一下 

839
00:30:52,190 --> 00:30:56,330
用户的第一次得分，但我 

840
00:30:54,889 --> 00:30:58,159
应该对此做点什么 

841
00:30:56,330 --> 00:31:01,940
得分并在此左侧 

842
00:30:58,159 --> 00:31:04,399
我通常会把所谓的确定 

843
00:31:01,940 --> 00:31:05,480
得分一等于此， 然后我的 

844
00:31:04,399 --> 00:31:06,950
分号如此

845
00:31:05,480 --> 00:31:09,110
可能没有多少 次 使用 

846
00:31:06,950 --> 00:31:11,030
兴趣但是 int 在cs50 

847
00:31:09,110 --> 00:31:12,410
库这就是所谓的提示 

848
00:31:11,030 --> 00:31:14,990
人类看到并实际让我 

849
00:31:12,410 --> 00:31:17,330
修复我的空间，因为我想要人类 

850
00:31:14,990 --> 00:31:19,100
看到结肠 后的空间， 但那是 

851
00:31:17,330 --> 00:31:21,200
只是一个美学细节然后当我 

852
00:31:19,100 --> 00:31:23,390
获取 此值但返回值 

853
00:31:21,200 --> 00:31:25,250
就像 亚伦上周送给我的一样 

854
00:31:23,390 --> 00:31:26,540
一张纸 ，所以没有拿到手我 

855
00:31:25,250 --> 00:31:28,010
虚拟纸上有一个数字 

856
00:31:26,540 --> 00:31:30,559
我将存储在一个变量中 

857
00:31:28,010 --> 00:31:32,900
所谓的 得分之一，目前刚 需 

858
00:31:30,559 --> 00:31:36,830
明确有效发生的事情 

859
00:31:32,900 --> 00:31:40,669
这 是 你 创建变量 的那一刻 

860
00:31:36,830 --> 00:31:42,950
类型为int， 字面上是4个字节 

861
00:31:40,669 --> 00:31:45,620
这 是什么铿锵或更普遍的 

862
00:31:42,950 --> 00:31:47,870
电脑为你所做的是int值 

863
00:31:45,620 --> 00:31:50,630
人类输入的字面意思是存储的 

864
00:31:47,870 --> 00:31:52,429
在四个连续的字节中背靠背 

865
00:31:50,630 --> 00:31:54,530
可能 在这里可能在这里， 但 在一起 

866
00:31:52,429 --> 00:31:56,450
所以这 一切是 怎么回事 时， 

867
00:31:54,530 --> 00:31:58,940
你实际上是在使用C所以让我走吧 

868
00:31:56,450 --> 00:32:00,559
回到我的代码这里 ，现在我想 

869
00:31:58,940 --> 00:32:02,450
绘制一个分数并不有趣 

870
00:32:00,559 --> 00:32:06,620
所以让我们继续做另一个int int 

871
00:32:02,450 --> 00:32:09,260
得分以得到int得到int 我会问 

872
00:32:06,620 --> 00:32:11,809
用户获得两分数和分数 

873
00:32:09,260 --> 00:32:12,410
那么让我们得到一个得分 三分 

874
00:32:11,809 --> 00:32:15,770
INT 

875
00:32:12,410 --> 00:32:17,090
叫它得分三分， 好吧 

876
00:32:15,770 --> 00:32:19,100
现在让我继续 前进 ，生成就像一个 

877
00:32:17,090 --> 00:32:21,380
酒吧就像我要去的条形图

878
00:32:19,100 --> 00:32:23,360
使用我们称之为ASCII art ASCII的 

879
00:32:21,380 --> 00:32:24,890
当然只是文字回忆很简单 

880
00:32:23,360 --> 00:32:26,419
计算机中的文字， 你知道我是什么 

881
00:32:24,890 --> 00:32:28,460
可以制作漂亮的条形图

882
00:32:26,419 --> 00:32:30,799
只需打印出来就像一堆 

883
00:32:28,460 --> 00:32:32,510
水平的哈希，所以短杆

884
00:32:30,799 --> 00:32:34,820
将代表一个小 数字和一个长 

885
00:32:32,510 --> 00:32:36,290
酒吧将代表一个大数字所以让 

886
00:32:34,820 --> 00:32:39,290
我继续向所有用户说 

887
00:32:36,290 --> 00:32:42,200
这里是你的分数， 一个 我要去 

888
00:32:39,290 --> 00:32:46,790
然后再告诉我说我得到0我是 

889
00:32:42,200 --> 00:32:48,350
低于1加I加上现在如果 

890
00:32:46,790 --> 00:32:52,030
我向下滚动并给自己一点点 

891
00:32:48,350 --> 00:32:54,830
这里的 房间 让 我继续前进 并实施 

892
00:32:52,030 --> 00:32:56,360
只是一个简单的打印，以便继续前进 ， 

893
00:32:54,830 --> 00:32:59,929
打印出哈希，然后打印出来 

894
00:32:56,360 --> 00:33:02,419
所有与 打印出新行 来完成 

895
00:32:59,929 --> 00:33:04,970
在那个循环 结束时 ， 让我们做 

896
00:33:02,419 --> 00:33:06,950
暂停那里只是为了回顾我已经问过了 

897
00:33:04,970 --> 00:33:08,480
我只做三个分数的人

898
00:33:06,950 --> 00:33:11,600
目前有一个与他们中的一个

899
00:33:08,480 --> 00:33:13,309
所以实际上 就像快速检查让我一样 

900
00:33:11,600 --> 00:33:15,679
删除那些， 所以它 不会超前 

901
00:33:13,309 --> 00:33:18,260
我让我做得分零 交叉 

902
00:33:15,679 --> 00:33:19,190
我的手指 好吧没有错误 现在让我走了 

903
00:33:18,260 --> 00:33:22,010
前进并做点 

904
00:33:19,190 --> 00:33:24,340
得分 为零 ，并 在 你的第一个 得分 

905
00:33:22,010 --> 00:33:27,950
pset 今年提前一百个 

906
00:33:24,340 --> 00:33:29,630
好一百个好工作所以这是一个 

907
00:33:27,950 --> 00:33:31,280
很长吧，如果再算上那些 了 

908
00:33:29,630 --> 00:33:33,230
希望实际上有 一百个 

909
00:33:31,280 --> 00:33:35,660
酒吧，如果我们再次运行并说出来 

910
00:33:33,230 --> 00:33:37,820
我没有那么好，我 得到了五十分 

911
00:33:35,660 --> 00:33:38,420
一半是一个大酒吧，所以看起来像我们 

912
00:33:37,820 --> 00:33:40,250
在我们的路上

913
00:33:38,420 --> 00:33:42,320
正确的，所以现在让我继续吧 

914
00:33:40,250 --> 00:33:44,000
我 得到了其他 得分 

915
00:33:42,320 --> 00:33:46,100
刚才，让我继续 吧 

916
00:33:44,000 --> 00:33:47,930
你知道那种 复制粘贴 

917
00:33:46,100 --> 00:33:49,610
并将此更改为 两个将此更改为 

918
00:33:47,930 --> 00:33:51,710
三个将此改为三个 

919
00:33:49,610 --> 00:33:54,320
三， 我知道如何打印酒吧 

920
00:33:51,710 --> 00:33:56,240
很明显，让我继续这样做 

921
00:33:54,320 --> 00:33:58,250
然后执行此操作然后修复 

922
00:33:56,240 --> 00:33:59,750
缩进我不想说得分 

923
00:33:58,250 --> 00:34:02,150
一个地方， 我 想说得分 

924
00:33:59,750 --> 00:34:04,340
得分二我的意思是你可能正在 

925
00:34:02,150 --> 00:34:06,710
以错误的方式揉搓这 是两者兼而有之 

926
00:34:04,340 --> 00:34:10,129
乏味和草率，为什么我 

927
00:34:06,710 --> 00:34:12,230
现在做得不好设计明智 的副本 

928
00:34:10,129 --> 00:34:14,000
粘贴几乎总是坏的 就在那里 

929
00:34:12,230 --> 00:34:15,649
这里有冗余， 但这很好 

930
00:34:14,000 --> 00:34:17,629
优先至少正确性现在 

931
00:34:15,649 --> 00:34:20,389
所以让我继续前进，将得分归零 

932
00:34:17,629 --> 00:34:23,120
好吧没有错误点斜线 得分 

933
00:34:20,389 --> 00:34:26,060
零和傀儡，让我继续前进 

934
00:34:23,120 --> 00:34:28,550
现在和运行好我们得到了 一个 百 

935
00:34:26,060 --> 00:34:32,540
我们第一次得到五十岁哦 这是一个 

936
00:34:28,550 --> 00:34:34,790
我在那里做了什么，看到这是什么 

937
00:34:32,540 --> 00:34:36,950
发生在你复制粘贴 所以 让我们来解决 

938
00:34:34,790 --> 00:34:39,379
这应该说得分二，所以 ctrl C 

939
00:34:36,950 --> 00:34:42,500
将退出一个程序，得分为零 

940
00:34:39,379 --> 00:34:43,929
重新创建点斜线得分零输入 

941
00:34:42,500 --> 00:34:47,659
好的，我们 走了 

942
00:34:43,929 --> 00:34:49,810
150让我们分开差异 75 

943
00:34:47,659 --> 00:34:52,220
这是一个简单的条形图 

944
00:34:49,810 --> 00:34:54,260
水平绘制 我的三个人 

945
00:34:52,220 --> 00:34:56,960
得分为100这 是 50和 

946
00:34:54,260 --> 00:34:59,540
这是75，但有机会 

947
00:34:56,960 --> 00:35:01,700
在这里改进，所以 它擦了一些 

948
00:34:59,540 --> 00:35:05,780
人们错误的方式就是我们 

949
00:35:01,700 --> 00:35:07,730
真的复制和粘贴代码，以便 

950
00:35:05,780 --> 00:35:11,420
哪里还有需要 改进的一个机会

951
00:35:07,730 --> 00:35:13,160
这里我应该做什么而不是 复制 

952
00:35:11,420 --> 00:35:16,490
并 一次又一次地 粘贴该代码 

953
00:35:13,160 --> 00:35:17,990
你能带什么成分好我们 

954
00:35:16,490 --> 00:35:20,570
可以使用一个循环， 实际上只是做 

955
00:35:17,990 --> 00:35:25,820
同样的事情三次 让我们试试 

956
00:35:20,570 --> 00:35:27,590
让我继续 这样做 

957
00:35:25,820 --> 00:35:30,860
让我们继续 并 删除复制 粘贴 

958
00:35:27,590 --> 00:35:33,050
我做了，让我继续 说 好 

959
00:35:30,860 --> 00:35:36,200
恩为int我得到0 

960
00:35:33,050 --> 00:35:38,720
我不到三 加我再加上让我 

961
00:35:36,200 --> 00:35:40,130
创建一个 我可以突出显示 的括号 

962
00:35:38,720 --> 00:35:41,780
多行和点击标签 ，他们会 

963
00:35:40,130 --> 00:35:49,460
所有缩进对我来说很方便 

964
00:35:41,780 --> 00:35:51,790
我现在可以这样做 ，例如说a 

965
00:35:49,460 --> 00:35:51,790
小信 

966
00:35:54,250 --> 00:35:59,270
是的， 我有点 担心，因为你 

967
00:35:57,260 --> 00:36:02,360
注意到这里我们在这里使用13号线 

968
00:35:59,270 --> 00:36:03,980
相同的变量， 所以它是好的 

969
00:36:02,360 --> 00:36:05,570
本能，但我觉得喜欢的事实 ， 

970
00:36:03,980 --> 00:36:07,460
这个节目不像上周我们现在 

971
00:36:05,570 --> 00:36:10,720
收集多个数据循环 

972
00:36:07,460 --> 00:36:10,720
正在为我们打破是的

973
00:36:16,920 --> 00:36:23,060
好吧好吧 

974
00:36:24,430 --> 00:36:27,609
是的，我们可以实现另一个功能 

975
00:36:26,500 --> 00:36:31,779
这有些因素 

976
00:36:27,609 --> 00:36:33,460
功能和其他想法 没关系 

977
00:36:31,779 --> 00:36:35,049
我们也可以存储我们的分数 

978
00:36:33,460 --> 00:36:36,789
数组，所以让我们按顺序执行这些操作

979
00:36:35,049 --> 00:36:38,109
事实上，当你这么循环是很棒的 

980
00:36:36,789 --> 00:36:39,849
要 一次又一次地 做 一些事情， 

981
00:36:38,109 --> 00:36:42,400
再一次， 但一个目的 

982
00:36:39,849 --> 00:36:44,079
功能从根本上说是要分解出来的 

983
00:36:42,400 --> 00:36:46,329
共同的 功能，可能会 

984
00:36:44,079 --> 00:36:47,890
仍然是解决方案中的循环但是 

985
00:36:46,329 --> 00:36:49,329
我真正的基本问题 

986
00:36:47,890 --> 00:36:51,160
刚做的是我在复制和 

987
00:36:49,329 --> 00:36:53,200
粘贴功能不应该 

988
00:36:51,160 --> 00:36:54,190
这样做，因为 在C n刮擦我们 

989
00:36:53,200 --> 00:36:56,710
有能力做 我们自己的 

990
00:36:54,190 --> 00:36:58,569
函数让我 这样做 让我撤消 

991
00:36:56,710 --> 00:37:00,670
我的循环在这里改变只是为了让我们回来 

992
00:36:58,569 --> 00:37:02,349
到了我们刚才的地方 ，让我 

993
00:37:00,670 --> 00:37:02,770
继续，然后清理它 

994
00:37:02,349 --> 00:37:04,750
点点 

995
00:37:02,770 --> 00:37:07,000
让我继续创造 一个新的 

996
00:37:04,750 --> 00:37:09,160
功能下降 在这里 ，我要打电话 

997
00:37:07,000 --> 00:37:10,809
图说只是为了创建一个图表 

998
00:37:09,160 --> 00:37:12,460
我和它要作为输入 一个 

999
00:37:10,809 --> 00:37:14,680
得分， 但我可以称之为我 

1000
00:37:12,460 --> 00:37:16,240
希望它的返回类型为void 

1001
00:37:14,680 --> 00:37:17,680
因为我不需要它来交给我 

1002
00:37:16,240 --> 00:37:19,119
回来就像我没有得到 一个 

1003
00:37:17,680 --> 00:37:20,950
来自用户的字符串我只是打印 一个 

1004
00:37:19,119 --> 00:37:22,809
图表它是所谓的副作用或 

1005
00:37:20,950 --> 00:37:26,380
现在输出我要继续 

1006
00:37:22,809 --> 00:37:29,049
并在这里 做 我的循环 int我得到0 我是 

1007
00:37:26,380 --> 00:37:30,400
我想要多少哈希

1008
00:37:29,049 --> 00:37:37,059
打印，如果我被传递给用户 

1009
00:37:30,400 --> 00:37:38,890
得分就像这个3这里的用户得分一样 

1010
00:37:37,059 --> 00:37:40,690
如果我被交给一个0到0的数字 

1011
00:37:38,890 --> 00:37:43,779
100这就是我想要遍历什么

1012
00:37:40,690 --> 00:37:46,660
如果我的目标 最终让我完成 

1013
00:37:43,779 --> 00:37:50,980
这个 想法我加上是 2里面 

1014
00:37:46,660 --> 00:37:53,440
这个循环每点打印一个哈希 

1015
00:37:50,980 --> 00:37:54,670
在一个人的总得分， 只是为了保持 

1016
00:37:53,440 --> 00:37:57,099
事情干净我会继续前进并放 

1017
00:37:54,670 --> 00:37:59,140
在这一端的新线， 但我 

1018
00:37:57,099 --> 00:38:00,849
现在想想我已经考虑了很多 

1019
00:37:59,140 --> 00:38:03,010
冗余并不是一切 

1020
00:38:00,849 --> 00:38:05,950
但 我至少现在给自己 一个 

1021
00:38:03,010 --> 00:38:08,440
函数称为图表所以在这里它 

1022
00:38:05,950 --> 00:38:10,599
看起来 我可以删除这个 

1023
00:38:08,440 --> 00:38:12,490
循环这是我考虑到的那个 

1024
00:38:10,599 --> 00:38:14,619
除了变量几乎相同

1025
00:38:12,490 --> 00:38:19,390
名字是硬编码的，我想我可以

1026
00:38:14,619 --> 00:38:21,309
现在做这样的图表 ，然后我也许 

1027
00:38:19,390 --> 00:38:23,500
如果那样的话可以做一点复制粘贴 

1028
00:38:21,309 --> 00:38:27,579
好吧，如果我可以 逃脱 

1029
00:38:23,500 --> 00:38:30,880
只是做 这个，然后说 2然后 

1030
00:38:27,579 --> 00:38:32,890
说3， 然后说3，然后说 那么 2 

1031
00:38:30,880 --> 00:38:34,750
它仍然是复制/粘贴，但它更少 

1032
00:38:32,890 --> 00:38:36,789
它看起来更好，它完全 适合 

1033
00:38:34,750 --> 00:38:38,080
屏幕所以它的进展并不完美 

1034
00:38:36,789 --> 00:38:41,610
但进步更好的设计

1035
00:38:38,080 --> 00:38:53,740
但不完美，所以这会编译 

1036
00:38:41,610 --> 00:38:56,350
我会有错误为什么 没关系， 好吧 

1037
00:38:53,740 --> 00:38:57,790
好让安让我诱导实际 

1038
00:38:56,350 --> 00:38:59,740
错误只是让我们知道我们遇到了什么问题 

1039
00:38:57,790 --> 00:39:01,900
解决让我继续前进 

1040
00:38:59,740 --> 00:39:04,090
无辜地继续编写分数

1041
00:39:01,900 --> 00:39:07,300
零希望一切， 但当然 

1042
00:39:04,090 --> 00:39:07,930
这是因为 一个熟悉的错误 了 不 

1043
00:39:07,300 --> 00:39:10,120
这里

1044
00:39:07,930 --> 00:39:12,940
所以注意隐含声明a 

1045
00:39:10,120 --> 00:39:14,620
功能图是在C99 所以无效

1046
00:39:12,940 --> 00:39:18,010
再次隐含声明功能 

1047
00:39:14,620 --> 00:39:19,690
只是倾向于意味着铿锵不知道 

1048
00:39:18,010 --> 00:39:21,010
你在谈论什么，你可以 

1049
00:39:19,690 --> 00:39:23,200
运行帮助50 ，它可能会 

1050
00:39:21,010 --> 00:39:25,720
为您提供类似的建议但是 

1051
00:39:23,200 --> 00:39:27,790
这个的要点是图表不是 一个看见 

1052
00:39:25,720 --> 00:39:30,040
功能它 没有附带CI写的 

1053
00:39:27,790 --> 00:39:32,590
它我只是写了 一点太晚 所以 

1054
00:39:30,040 --> 00:39:34,540
一个我们 最后没用的解决方案

1055
00:39:32,590 --> 00:39:36,340
如果你 不这样做，那 周也没关系 

1056
00:39:34,540 --> 00:39:39,430
知道什么图表让我 去吧 

1057
00:39:36,340 --> 00:39:42,730
在哪里你会知道它 ，现在运行 

1058
00:39:39,430 --> 00:39:44,950
得分为零好问题解决了 

1059
00:39:42,730 --> 00:39:47,470
修复它，但我们已经 修复了它 

1060
00:39:44,950 --> 00:39:49,150
上周不同的方式，为什么我们可能 

1061
00:39:47,470 --> 00:39:51,040
我想坚持上周的方法 

1062
00:39:49,150 --> 00:39:54,270
而不只是复制粘贴 我的功能和 

1063
00:39:51,040 --> 00:39:54,270
把它放在 顶部而不是底部 

1064
00:39:57,850 --> 00:40:01,640
是的我的意思是这是一个小问题 

1065
00:40:00,350 --> 00:40:03,800
此刻因为这是一个漂亮的 

1066
00:40:01,640 --> 00:40:05,810
短节目，但我正在推动 

1067
00:40:03,800 --> 00:40:08,060
我的程序的主要部分字面上称为 

1068
00:40:05,810 --> 00:40:09,830
缅因州越来越远 而且喜欢 

1069
00:40:08,060 --> 00:40:11,420
阅读 代码的全部意义 在于 

1070
00:40:09,830 --> 00:40:12,980
如果我打开，了解它正在做什么

1071
00:40:11,420 --> 00:40:14,450
这个文件，我必须滚动滚动 

1072
00:40:12,980 --> 00:40:16,010
滚动滚动滚动只是寻找 

1073
00:40:14,450 --> 00:40:17,780
这个主要功能就是那么 糟糕 

1074
00:40:16,010 --> 00:40:19,610
它只是一种很好的样式而且 它是一种 

1075
00:40:17,780 --> 00:40:21,140
良好的人类习俗把主要代码 

1076
00:40:19,610 --> 00:40:24,260
绿旗的主要功能

1077
00:40:21,140 --> 00:40:26,150
在顶部点击等效 C 所以 

1078
00:40:24,260 --> 00:40:27,500
确实为我们提供了解决方案 

1079
00:40:26,150 --> 00:40:29,900
必须提供一点提示 

1080
00:40:27,500 --> 00:40:32,630
让我继续，从这里切断它 

1081
00:40:29,900 --> 00:40:35,590
把它背下来的底部 ，并 在这里 

1082
00:40:32,630 --> 00:40:40,340
然后继续 复制粘贴或 

1083
00:40:35,590 --> 00:40:42,770
只重新键入值的 值 

1084
00:40:40,340 --> 00:40:45,290
那条所谓的第一条线

1085
00:40:42,770 --> 00:40:47,600
原型 给出足够的信息 

1086
00:40:45,290 --> 00:40:48,980
所以它知道什么参数 

1087
00:40:47,600 --> 00:40:50,990
函数采用其返回类型 

1088
00:40:48,980 --> 00:40:53,750
它的名字是分号和 

1089
00:40:50,990 --> 00:40:56,300
这就是所谓的宣言或者 

1090
00:40:53,750 --> 00:40:58,760
然后用花括号实现它

1091
00:40:56,300 --> 00:41:00,830
以及下面的所有逻辑， 让我们走吧 

1092
00:40:58,760 --> 00:41:04,370
如果我向上滚动 ，请 运行此操作 

1093
00:41:00,830 --> 00:41:06,980
在这里，我们将看到我们将看到的鞭子 

1094
00:41:04,370 --> 00:41:11,630
得分 为零 现在好了我们就 应该 

1095
00:41:06,980 --> 00:41:13,220
方式得分零输入得分 一是150 75 

1096
00:41:11,630 --> 00:41:15,110
现在我们似乎有一些好处 

1097
00:41:13,220 --> 00:41:17,360
功能， 但 还有一个 

1098
00:41:15,110 --> 00:41:19,340
机会 我敢说要改进 

1099
00:41:17,360 --> 00:41:21,050
我认为根本 问题是 

1100
00:41:19,340 --> 00:41:22,370
我 还在复制粘贴一点点 

1101
00:41:21,050 --> 00:41:24,830
的东西，但我认为根本 

1102
00:41:22,370 --> 00:41:27,170
问题是， 我没有 

1103
00:41:24,830 --> 00:41:29,840
表达存储多个值 

1104
00:41:27,170 --> 00:41:32,990
除非我 事先作为程序员 

1105
00:41:29,840 --> 00:41:35,030
给他们所有独特的名字，因为如果我 

1106
00:41:32,990 --> 00:41:36,560
对所有事物使用相同的变量 

1107
00:41:35,030 --> 00:41:38,660
我无法收集所有三个变量 

1108
00:41:36,560 --> 00:41:40,610
在 顶部，然后迭代所有 

1109
00:41:38,660 --> 00:41:42,320
如果我只有一个 ，则在 底部 三个 

1110
00:41:40,610 --> 00:41:44,600
变量， 所以我需要 三个变量 

1111
00:41:42,320 --> 00:41:46,190
但这并不能 很好地 扩展 和谁 

1112
00:41:44,600 --> 00:41:48,470
知道我是否想要获得五个分数 

1113
00:41:46,190 --> 00:41:50,930
十分 或更多SCO的分数然后我 

1114
00:41:48,470 --> 00:41:53,270
真的过分复制和粘贴 

1115
00:41:50,930 --> 00:41:55,430
所以事实证明答案 是 肯定 的 

1116
00:41:53,270 --> 00:41:57,830
数组在一天结束时是一个数组

1117
00:41:55,430 --> 00:41:59,420
只是存储东西 的副作用 

1118
00:41:57,830 --> 00:42:01,610
在记忆中背靠背背靠背 

1119
00:41:59,420 --> 00:42:03,620
但这个现实有什么强大之处 

1120
00:42:01,610 --> 00:42:07,490
内存如下 

1121
00:42:03,620 --> 00:42:10,010
我可以在这里继续说新的和 

1122
00:42:07,490 --> 00:42:10,760
此程序的其它改进版做 

1123
00:42:10,010 --> 00:42:12,230
这让我 

1124
00:42:10,760 --> 00:42:15,230
继续打开我写的这个 

1125
00:42:12,230 --> 00:42:17,780
提前打电话给分数看 

1126
00:42:15,230 --> 00:42:20,690
得分两点 看到通知我们有 

1127
00:42:17,780 --> 00:42:22,700
我的 主要功能中的 代码如下

1128
00:42:20,690 --> 00:42:24,620
得到了一个新功能和新功能

1129
00:42:22,700 --> 00:42:27,290
语法这一行 我在 这里 

1130
00:42:24,620 --> 00:42:30,380
突出显示嘿铿锵 给我一个 

1131
00:42:27,290 --> 00:42:33,080
变量称为 整数类型的分数 

1132
00:42:30,380 --> 00:42:34,790
但请给我三个 这样的 

1133
00:42:33,080 --> 00:42:36,110
这里的新语法是方括号和 

1134
00:42:34,790 --> 00:42:38,810
其内部 是多少 

1135
00:42:36,110 --> 00:42:39,950
变量 你想要 的类型 ，你 

1136
00:42:38,810 --> 00:42:41,570
不必给他们一个独特的名字 

1137
00:42:39,950 --> 00:42:43,250
你真的称他们为集体 

1138
00:42:41,570 --> 00:42:45,110
我故意用英语分数和分数

1139
00:42:43,250 --> 00:42:47,870
选择复数来表示 这一点 

1140
00:42:45,110 --> 00:42:50,360
是一个不是单一 的 值数组

1141
00:42:47,870 --> 00:42:53,180
值我能做些什么下一个井，这里是 我 

1142
00:42:50,360 --> 00:42:55,190
for循环for int我得到0 小于3 

1143
00:42:53,180 --> 00:42:56,990
我加上加号现在我已经解决了 

1144
00:42:55,190 --> 00:42:59,570
提出的早期问题 

1145
00:42:56,990 --> 00:43:01,370
现在我可以把它放在循环中因为 

1146
00:42:59,570 --> 00:43:03,530
现在我的变量不叫分数 

1147
00:43:01,370 --> 00:43:05,180
一个得分两得分 3，我字面意思 

1148
00:43:03,530 --> 00:43:07,220
不得不 硬编码只是名称 

1149
00:43:05,180 --> 00:43:08,780
得分，现在他们被称为 

1150
00:43:07,220 --> 00:43:11,420
得分和我有这个方括号

1151
00:43:08,780 --> 00:43:13,580
符号通知我能做什么 我能得到 

1152
00:43:11,420 --> 00:43:16,430
一个int我可以说给我分数

1153
00:43:13,580 --> 00:43:17,930
％I和插件 我加 一个我 

1154
00:43:16,430 --> 00:43:19,880
不想说0因为人类 

1155
00:43:17,930 --> 00:43:22,640
一般来说不要从 0 算起， 所以这是 

1156
00:43:19,880 --> 00:43:26,030
计算从1 2和3 计算 

1157
00:43:22,640 --> 00:43:29,870
这样做是因为分数是变量 

1158
00:43:26,030 --> 00:43:33,680
支架我关闭支架说存放 

1159
00:43:29,870 --> 00:43:35,750
那里的第8个价值所以 我不喜欢 

1160
00:43:33,680 --> 00:43:37,670
英语意思是转到括号0 

1161
00:43:35,750 --> 00:43:39,230
支架1支架2所以这个 

1162
00:43:37,670 --> 00:43:41,180
有效的手段 是第一个 

1163
00:43:39,230 --> 00:43:44,660
当我等于0时，这个循环的迭代 

1164
00:43:41,180 --> 00:43:47,030
当我这时，这看起来很有效 

1165
00:43:44,660 --> 00:43:49,460
然后在下一次迭代中变为1 

1166
00:43:47,030 --> 00:43:51,530
那么当我变成2岁时你就是这么做的 

1167
00:43:49,460 --> 00:43:54,080
在最后一次迭代看起来像 

1168
00:43:51,530 --> 00:43:56,390
当我变成3而3则不是时 

1169
00:43:54,080 --> 00:43:59,300
小于3 ，所以它不执行 

1170
00:43:56,390 --> 00:44:02,320
再次使用我内部的这些 

1171
00:43:59,300 --> 00:44:05,180
括号方括号是 我 

1172
00:44:02,320 --> 00:44:06,860
索引到一个数组索引到 一个 

1173
00:44:05,180 --> 00:44:08,840
数组意味着转到特定位置 

1174
00:44:06,860 --> 00:44:10,910
所谓的冰的位置，但你开始 

1175
00:44:08,840 --> 00:44:12,950
在0处计数只是为了 使这更多 

1176
00:44:10,910 --> 00:44:15,320
真的，如果你回到这张照片 

1177
00:44:12,950 --> 00:44:18,800
这可能是你电脑的记忆 

1178
00:44:15,320 --> 00:44:21,590
因此是支架我支架一个 屋顶 

1179
00:44:18,800 --> 00:44:24,320
支架0支架1支架2支架3 

1180
00:44:21,590 --> 00:44:26,660
支架4回到 50或 任何你 

1181
00:44:24,320 --> 00:44:28,810
现在可以使用方括号得到任何 

1182
00:44:26,660 --> 00:44:33,320
这些内存块存储 

1183
00:44:28,810 --> 00:44:36,080
对你有什么价值的问题 

1184
00:44:33,320 --> 00:44:37,490
我们刚刚做了所有正确的，然后在 

1185
00:44:36,080 --> 00:44:39,710
翻转方面，我们可以做同样的事情 

1186
00:44:37,490 --> 00:44:42,410
现在，当我打印我的分数时， 我可以 

1187
00:44:39,710 --> 00:44:44,870
类似地从 零到三次 迭代 

1188
00:44:42,410 --> 00:44:48,800
然后通过传递打印出分数

1189
00:44:44,870 --> 00:44:50,480
再次绘制IE得分的相同值

1190
00:44:48,800 --> 00:44:52,520
这里唯一的新语法是变量 

1191
00:44:50,480 --> 00:44:54,620
命名方括号，然后是数字 

1192
00:44:52,520 --> 00:44:57,020
像零一两或 像我一样 的变量 

1193
00:44:54,620 --> 00:44:59,330
然后在这里了我的图表功能 

1194
00:44:57,020 --> 00:45:00,980
完全一样，它不 知道 一个数组 

1195
00:44:59,330 --> 00:45:05,480
甚至涉及因为我只是 

1196
00:45:00,980 --> 00:45:07,730
现在一次传递一个分数 

1197
00:45:05,480 --> 00:45:09,800
那还有一个糟糕的设计 

1198
00:45:07,730 --> 00:45:12,140
这个计划的决定还有 

1199
00:45:09,800 --> 00:45:14,840
我保留的一些冗余

1200
00:45:12,140 --> 00:45:21,440
一而再，再而 再输入一次做任何 

1201
00:45:14,840 --> 00:45:23,480
值重复出现在你面前 

1202
00:45:21,440 --> 00:45:26,390
for loop好吧所以我得到了for循环 

1203
00:45:23,480 --> 00:45:29,050
在多个地方肯定和其他什么 

1204
00:45:26,390 --> 00:45:34,820
价值似乎在多个地方 

1205
00:45:29,050 --> 00:45:37,010
这是微妙的总数，是的三个喜欢 

1206
00:45:34,820 --> 00:45:39,440
三个是在几个地方它在这里 

1207
00:45:37,010 --> 00:45:41,750
这是我宣布这个阵列的时候 

1208
00:45:39,440 --> 00:45:44,060
并猜测自己 有 三个分数 

1209
00:45:41,750 --> 00:45:45,860
在这里，当我迭代时， 它在这里 

1210
00:45:44,060 --> 00:45:47,300
我实习 不在这里因为这个 

1211
00:45:45,860 --> 00:45:50,210
是一个不同的迭代，只是为了 

1212
00:45:47,300 --> 00:45:52,340
在伊朗的哈希 所以有三个地方 

1213
00:45:50,210 --> 00:45:53,900
我写了三个，所以这是什么 

1214
00:45:52,340 --> 00:45:55,340
意思是假设明年你服用 

1215
00:45:53,900 --> 00:45:57,440
更多的测试或其他什么，你需要更多 

1216
00:45:55,340 --> 00:46:00,710
分数你打开你的 程序和 

1217
00:45:57,440 --> 00:46:03,350
好吧，现在我有五个分数和500分 

1218
00:46:00,710 --> 00:46:05,450
ops Zia typos已经五个这样 了 

1219
00:46:03,350 --> 00:46:06,920
你输入的那种模式 

1220
00:46:05,450 --> 00:46:09,140
同样的事情一次又一次 ，现在 

1221
00:46:06,920 --> 00:46:11,090
onus是程序员要记住的 

1222
00:46:09,140 --> 00:46:13,490
改变相同的该死的价值 

1223
00:46:11,090 --> 00:46:14,990
多个地方喜欢糟糕的坏设计 

1224
00:46:13,490 --> 00:46:16,250
你会错过其中一个价值观 

1225
00:46:14,990 --> 00:46:17,570
你的程序 会变得更复杂 

1226
00:46:16,250 --> 00:46:19,100
你要在三点离开一点

1227
00:46:17,570 --> 00:46:20,630
将另一个 改为五和喜欢 

1228
00:46:19,100 --> 00:46:22,340
逻辑错误最终会发生

1229
00:46:20,630 --> 00:46:23,840
如果发生的话，我们如何解决这个问题 

1230
00:46:22,340 --> 00:46:25,520
功能不是这里的解决方案因为

1231
00:46:23,840 --> 00:46:27,860
它不是功能，它只是一个价值 

1232
00:46:25,520 --> 00:46:29,840
好吧，我们可以使用变量但是 a 

1233
00:46:27,860 --> 00:46:31,940
某些类型的变量这些数字 

1234
00:46:29,840 --> 00:46:34,250
这里555 或 三三三 

1235
00:46:31,940 --> 00:46:36,080
或人类通常 所说的 

1236
00:46:34,250 --> 00:46:37,130
魔术数字就像他们的数字但是 

1237
00:46:36,080 --> 00:46:38,330
他们有点神奇， 因为你已经 

1238
00:46:37,130 --> 00:46:41,000
只是随心所欲

1239
00:46:38,330 --> 00:46:43,550
在随机的地方， 但更好的约定 

1240
00:46:41,000 --> 00:46:47,030
通常会作为一个全局变量 

1241
00:46:43,550 --> 00:46:50,240
这样做int 让我们称它为count equals 

1242
00:46:47,030 --> 00:46:52,010
三， 所以声明一个int类型的变量 

1243
00:46:50,240 --> 00:46:54,380
这就是 你想要 的东西 数量 

1244
00:46:52,010 --> 00:46:57,410
然后键入该变量名称all 

1245
00:46:54,380 --> 00:46:59,420
整个代码， 以便 以后如果 

1246
00:46:57,410 --> 00:47:01,910
你想要改变 这个程序 吗？ 

1247
00:46:59,420 --> 00:47:04,070
改变它在一个地方 呐喊 你是 谁 

1248
00:47:01,910 --> 00:47:05,330
重新编译程序后完成 

1249
00:47:04,070 --> 00:47:07,310
其实 我应该做的 更好 一点 

1250
00:47:05,330 --> 00:47:08,990
事实证明，如果你知道的话 

1251
00:47:07,310 --> 00:47:10,550
你有你永远不会变

1252
00:47:08,990 --> 00:47:12,140
会 改变， 因为它不是应该的 

1253
00:47:10,550 --> 00:47:14,510
改变它应该 是一个常数 

1254
00:47:12,140 --> 00:47:16,760
值 C 也有一个特殊的关键字 

1255
00:47:14,510 --> 00:47:19,280
在 数据类型 之前调用Const 

1256
00:47:16,760 --> 00:47:21,380
你说Const int 然后是名字和 

1257
00:47:19,280 --> 00:47:23,180
那么编译器的值和这种方式 

1258
00:47:21,380 --> 00:47:24,950
clang会确保你 是人类 

1259
00:47:23,180 --> 00:47:27,590
不要搞砸，不小心尝试

1260
00:47:24,950 --> 00:47:29,120
改变其他任何地方的计数 

1261
00:47:27,590 --> 00:47:30,860
另外一件值得注意的事情我也是 

1262
00:47:29,120 --> 00:47:32,840
对某些人来说，这一切都是有利的 

1263
00:47:30,860 --> 00:47:34,430
任何时候你的人类惯例的原因

1264
00:47:32,840 --> 00:47:36,110
大写一个字母中的所有字母

1265
00:47:34,430 --> 00:47:37,910
变量名称是约定 

1266
00:47:36,110 --> 00:47:40,130
这意味着其全球 ， 这 意味着 它的 

1267
00:47:37,910 --> 00:47:41,540
在顶部定义， 你 可以使用它 

1268
00:47:40,130 --> 00:47:44,780
在任何地方，因为它在外面

1269
00:47:41,540 --> 00:47:46,730
所有的花括号， 但它意味着 暗示 

1270
00:47:44,780 --> 00:47:48,290
并提醒你，这是 特别的 

1271
00:47:46,730 --> 00:47:50,450
不仅仅是一个所谓的局部 变量 

1272
00:47:48,290 --> 00:47:55,090
在函数内部或循环内部 

1273
00:47:50,450 --> 00:48:00,470
或 类似的 任何问题是的 

1274
00:47:55,090 --> 00:48:03,020
哦，为什么我有加 1让我跑 

1275
00:48:00,470 --> 00:48:05,330
这个程序真的很快，为什么我有我

1276
00:48:03,020 --> 00:48:07,610
在这条线在这里玩是 个 问题 

1277
00:48:05,330 --> 00:48:11,270
所以让 我继续 前进并运行得分 

1278
00:48:07,610 --> 00:48:14,840
在我的目录哎呦做出成绩 来 

1279
00:48:11,270 --> 00:48:17,570
点斜线得分进入我想要的 

1280
00:48:14,840 --> 00:48:20,060
人类看得分 1和得分 2和 

1281
00:48:17,570 --> 00:48:22,640
得分3我不想让他或 她看到 

1282
00:48:20,060 --> 00:48:24,290
喜欢得分 0得1分2因为它 

1283
00:48:22,640 --> 00:48:25,610
只是看起来蹩脚的人类 

1284
00:48:24,290 --> 00:48:27,850
电脑需要 考虑的 方面 

1285
00:48:25,610 --> 00:48:30,320
零我的人和我的用户喜欢不 

1286
00:48:27,850 --> 00:48:32,160
所以只是美学上的 其他问题 

1287
00:48:30,320 --> 00:48:39,599
是啊 

1288
00:48:32,160 --> 00:48:40,890
我 真的好问题啊 

1289
00:48:39,599 --> 00:48:43,349
实际上昨晚想到了这个 

1290
00:48:40,890 --> 00:48:45,390
当试图制作这个时 

1291
00:48:43,349 --> 00:48:47,250
例子为什么我不结合这些 

1292
00:48:45,390 --> 00:48:50,280
两个for 循环因为它们很清楚 

1293
00:48:47,250 --> 00:48:52,980
迭代相同 的次数 

1294
00:48:50,280 --> 00:48:57,319
这是一只手还是只是一个伸展没有 

1295
00:48:52,980 --> 00:49:00,210
伸展所以这实际上是故意的 

1296
00:48:57,319 --> 00:49:06,720
如果我结合这 会 是什么 会 是什么 

1297
00:49:00,210 --> 00:49:09,329
在我的计划中逻辑地改变是的，是的 

1298
00:49:06,720 --> 00:49:12,000
所以每次人类输入得分后 我 

1299
00:49:09,329 --> 00:49:13,349
会看到用户绘制 了运行行的 图表 

1300
00:49:12,000 --> 00:49:15,059
哈希然后我会问他们另一个 

1301
00:49:13,349 --> 00:49:16,260
价值他们会看到 图表的 另一个价值 

1302
00:49:15,059 --> 00:49:17,670
他们会看到 图表，那很好 

1303
00:49:16,260 --> 00:49:19,770
就好像这是你想要的设计 

1304
00:49:17,670 --> 00:49:21,059
完全可以接受完全正确 我 

1305
00:49:19,770 --> 00:49:22,200
通缉矿山看 多 一点 

1306
00:49:21,059 --> 00:49:23,730
传统的所有酒吧 

1307
00:49:22,200 --> 00:49:26,220
所以 我有效地不得不这样做 

1308
00:49:23,730 --> 00:49:27,660
推迟打印哈希，那就是 

1309
00:49:26,220 --> 00:49:29,160
我确实有一点点 

1310
00:49:27,660 --> 00:49:30,930
通过获取用户输入来实现冗余

1311
00:49:29,160 --> 00:49:32,609
在这里然后再次迭代到 

1312
00:49:30,930 --> 00:49:34,890
实际上 打印 用户输出为 

1313
00:49:32,609 --> 00:49:38,339
图表所以只是一个设计决定好 

1314
00:49:34,890 --> 00:49:41,130
可以提出其他问题

1315
00:49:38,339 --> 00:49:42,510
这是什么样子其实你 

1316
00:49:41,130 --> 00:49:44,160
知道我可以做些什么 

1317
00:49:42,510 --> 00:49:46,349
更好的是让我打开最后一个 例子 

1318
00:49:44,160 --> 00:49:49,799
涉及分数和这个东西叫 

1319
00:49:46,349 --> 00:49:54,059
这里得分的数组让我 走了 

1320
00:49:49,799 --> 00:49:55,829
现在，我已经改变 了 我的想法 

1321
00:49:54,059 --> 00:49:57,900
图表功能做多一点 

1322
00:49:55,829 --> 00:49:59,640
你可能还记得 第 0 周 和第 1 周 

1323
00:49:57,900 --> 00:50:01,470
我们有COFF功能，我们保留 

1324
00:49:59,640 --> 00:50:02,940
增强它做越来越像 

1325
00:50:01,470 --> 00:50:06,569
将越来越多的逻辑放入 其中 

1326
00:50:02,940 --> 00:50:08,220
注意这个图表功能现在需要一个

1327
00:50:06,569 --> 00:50:09,750
第二个论点是那种 

1328
00:50:08,220 --> 00:50:11,880
有趣的是它需要 一个参数 

1329
00:50:09,750 --> 00:50:14,880
是一个数字，然后是下一个参数 

1330
00:50:11,880 --> 00:50:16,410
这是一个 很长的 故事 

1331
00:50:14,880 --> 00:50:18,510
如果你想要一个 功能，请 简短 

1332
00:50:16,410 --> 00:50:20,099
将您不需要的数组作为输入 

1333
00:50:18,510 --> 00:50:21,869
必须事先知道如何之大， 

1334
00:50:20,099 --> 00:50:23,609
数组是你实际上不应该放一个 

1335
00:50:21,869 --> 00:50:26,220
数字在方括号之间 

1336
00:50:23,609 --> 00:50:28,470
这个背景但你做的事情 

1337
00:50:26,220 --> 00:50:29,819
需要在某一 时刻 知道 多少 

1338
00:50:28,470 --> 00:50:32,190
如果你已经在数组中的项目

1339
00:50:29,819 --> 00:50:33,960
用Java编程只是使用 APC Java 

1340
00:50:32,190 --> 00:50:36,420
如果 你还记得 给你点长 

1341
00:50:33,960 --> 00:50:38,700
对象C的特征没有 

1342
00:50:36,420 --> 00:50:40,950
这个数组没有固有的 

1343
00:50:38,700 --> 00:50:43,410
与之相关联的长度，你必须

1344
00:50:40,950 --> 00:50:45,390
告诉每个使用你阵列的人如何 

1345
00:50:43,410 --> 00:50:47,280
即使你，它也是如此 

1346
00:50:45,390 --> 00:50:49,380
不这样做语法在这里你 

1347
00:50:47,280 --> 00:50:52,080
字面上只是说我期待一个论点 

1348
00:50:49,380 --> 00:50:54,210
称为得分，是每个数组 

1349
00:50:52,080 --> 00:50:56,550
方括号你必须传入 

1350
00:50:54,210 --> 00:50:58,290
几乎总是第二个变量 

1351
00:50:56,550 --> 00:50:59,850
字面上称为你想要的东西但是 

1352
00:50:58,290 --> 00:51:02,040
是该数组中 的事物数量

1353
00:50:59,850 --> 00:51:06,980
因为如果 这个功能 的目标 是 

1354
00:51:02,040 --> 00:51:09,750
只是为了迭代数量 

1355
00:51:06,980 --> 00:51:12,300
传入的分数然后 

1356
00:51:09,750 --> 00:51:14,580
遍历点的数量 

1357
00:51:12,300 --> 00:51:17,430
那个分数 是为了打印 出来的 

1358
00:51:14,580 --> 00:51:18,720
哈希你需要知道这个数量 ，使得 

1359
00:51:17,430 --> 00:51:21,090
这个功能到底是做什么的

1360
00:51:18,720 --> 00:51:22,770
清除此迭代 总 

1361
00:51:21,090 --> 00:51:24,240
从零到计数 的 分数 

1362
00:51:22,770 --> 00:51:27,060
这可能是三 或五或 

1363
00:51:24,240 --> 00:51:29,460
无论这个循环在这里使用J是什么 

1364
00:51:27,060 --> 00:51:32,820
只是一个约定而不是迭代 

1365
00:51:29,460 --> 00:51:35,430
零到任何分数是这样的 

1366
00:51:32,820 --> 00:51:37,260
现在 我已经过去了 很方便 

1367
00:51:35,430 --> 00:51:39,780
数组，我仍然可以 在 

1368
00:51:37,260 --> 00:51:42,660
个人价值只是通过使用我 

1369
00:51:39,780 --> 00:51:44,100
因为我对我的我适合这里关合作使 

1370
00:51:42,660 --> 00:51:45,420
你可能还记得马里奥的这个

1371
00:51:44,100 --> 00:51:47,100
实例或其中的任何其他示例

1372
00:51:45,420 --> 00:51:49,530
你有非常嵌套的循环

1373
00:51:47,100 --> 00:51:51,570
常规使用我在 外面J 

1374
00:51:49,530 --> 00:51:53,670
在内部但又是唯一的一点 

1375
00:51:51,570 --> 00:51:56,790
这是你 确实可以传球 

1376
00:51:53,670 --> 00:52:00,000
数组甚至作为 我们将看到的 参数 

1377
00:51:56,790 --> 00:52:04,410
为什么那之前很有用 

1378
00:52:00,000 --> 00:52:05,790
问题好，所以这很多，但我们 

1379
00:52:04,410 --> 00:52:07,410
使用数组可以做得更多 

1380
00:52:05,790 --> 00:52:09,570
变得越来越酷 

1381
00:52:07,410 --> 00:52:11,520
事实上，我们会稍微看一下如何 

1382
00:52:09,570 --> 00:52:13,320
阵列实际上已经和我们在一起了 

1383
00:52:11,520 --> 00:52:14,790
上周我们还没有意识到 

1384
00:52:13,320 --> 00:52:15,990
它在引擎盖下， 但让我们继续前进 

1385
00:52:14,790 --> 00:52:18,780
休息五分钟，我们会 来 

1386
00:52:15,990 --> 00:52:21,270
背部和跳水 好吧 ，所以我知道， 

1387
00:52:18,780 --> 00:52:23,460
在其他地方 有点悬崖峭壁 

1388
00:52:21,270 --> 00:52:24,720
数组实际上已经是

1389
00:52:23,460 --> 00:52:26,760
当然这就是我们描绘的方式

1390
00:52:24,720 --> 00:52:28,470
我们称之为阵列和它 

1391
00:52:26,760 --> 00:52:31,320
原来上周我们的时候 

1392
00:52:28,470 --> 00:52:33,780
引入了字符串字符串序列 

1393
00:52:31,320 --> 00:52:36,000
字符实际上 只是一个数组 

1394
00:52:33,780 --> 00:52:38,790
用另一个名字作为字符串 和数组 

1395
00:52:36,000 --> 00:52:40,440
字符和字符当然是另一个 

1396
00:52:38,790 --> 00:52:42,240
数据类型现在是什么实际 

1397
00:52:40,440 --> 00:52:44,010
这两者的含义

1398
00:52:42,240 --> 00:52:46,580
代表计算机是怎样的 

1399
00:52:44,010 --> 00:52:48,780
代表信息，然后到 

1400
00:52:46,580 --> 00:52:51,120
从根本上以编程方式可以做什么

1401
00:52:48,780 --> 00:52:53,460
我们知道所有数据都是这样的 

1402
00:52:51,120 --> 00:52:55,710
背对背或近距离 

1403
00:52:53,460 --> 00:52:58,050
彼此很好，事实证明我们 

1404
00:52:55,710 --> 00:52:58,710
可以在几个不同的地方应用这个逻辑 

1405
00:52:58,050 --> 00:53:02,070
方式让我 

1406
00:52:58,710 --> 00:53:05,640
继续开放，例如 它 

1407
00:53:02,070 --> 00:53:08,160
例如这里称为串 零 ，因此在 

1408
00:53:05,640 --> 00:53:09,690
我们今天的代码和我们的源 

1409
00:53:08,160 --> 00:53:12,510
文件夹让我继续开放 

1410
00:53:09,690 --> 00:53:13,080
字符串零，这个例子看起来像 

1411
00:53:12,510 --> 00:53:17,339
这个

1412
00:53:13,080 --> 00:53:19,020
注意我们第一次在第九 行 得到一个 

1413
00:53:17,339 --> 00:53:21,690
来自用户的字符串只是说输入 

1414
00:53:19,020 --> 00:53:23,700
请将该 值 存储 在字符串s中 

1415
00:53:21,690 --> 00:53:25,440
然后我们说这是输出 

1416
00:53:23,700 --> 00:53:29,070
并注意我在做什么

1417
00:53:25,440 --> 00:53:31,260
以下一行我正在迭代我 

1418
00:53:29,070 --> 00:53:33,510
零至 英镑无论是什么和 

1419
00:53:31,260 --> 00:53:35,940
然后排队十三我打印一个 

1420
00:53:33,510 --> 00:53:37,650
字符一次一个，但 注意 

1421
00:53:35,940 --> 00:53:40,619
语法我正在使用我们没有使用的语法 

1422
00:53:37,650 --> 00:53:44,280
上周， 如果你有一个名为s的字符串 

1423
00:53:40,619 --> 00:53:45,750
你可以索引 到一个字符串 就像 

1424
00:53:44,280 --> 00:53:49,050
它是一个数组，因为它确实是 

1425
00:53:45,750 --> 00:53:51,330
在引擎盖下面，所以括号我在哪里

1426
00:53:49,050 --> 00:53:54,080
我从零开始， 上升到 什么 

1427
00:53:51,330 --> 00:53:56,910
这个 值只是一种获取方式 

1428
00:53:54,080 --> 00:53:59,190
字符0， 则字符 1 然后 

1429
00:53:56,910 --> 00:54:00,930
字符2然后字符3等 

1430
00:53:59,190 --> 00:54:03,869
最终的结果实际上是看起来 

1431
00:54:00,930 --> 00:54:07,740
像这样让 我继续做下去 

1432
00:54:03,869 --> 00:54:11,910
带制作绳0 OOPS 不在 

1433
00:54:07,740 --> 00:54:15,830
目录make string string 0 dot slash 

1434
00:54:11,910 --> 00:54:21,150
字符串0输入，我将输入说 

1435
00:54:15,830 --> 00:54:22,800
zamyla 和输出现在是Z am yla 

1436
00:54:21,150 --> 00:54:24,630
因为我没有这是一个有点乱

1437
00:54:22,800 --> 00:54:25,890
这里有一条新线， 所以让我 真的让我们 

1438
00:54:24,630 --> 00:54:28,410
清理它，因为这是 

1439
00:54:25,890 --> 00:54:31,619
不必要地马虎， 所以让我继续吧 

1440
00:54:28,410 --> 00:54:35,609
并打印出一条新线让我 

1441
00:54:31,619 --> 00:54:39,390
使用make string 0 dot whoops重新编译

1442
00:54:35,609 --> 00:54:44,070
点斜线字符串0输入应为simila 

1443
00:54:39,390 --> 00:54:45,630
进入，现在Z am y la 所以为什么呢 

1444
00:54:44,070 --> 00:54:48,900
如果我向下滚动 这个 就好了 

1445
00:54:45,630 --> 00:54:50,280
代码似乎我通过这个printf 

1446
00:54:48,900 --> 00:54:53,339
此行刚开 i将 

1447
00:54:50,280 --> 00:54:55,170
s中的名称字符然后

1448
00:54:53,339 --> 00:54:57,720
每次打印一个字符

1449
00:54:55,170 --> 00:54:59,820
百分比 C，随后新的行 ，以便 

1450
00:54:57,720 --> 00:55:03,930
你可能猜到这是什么功能 

1451
00:54:59,820 --> 00:55:05,280
这里做郎朗略 

1452
00:55:03,930 --> 00:55:08,190
缩写，但你也许可以收集

1453
00:55:05,280 --> 00:55:10,619
这意味着什么，所以它实际上

1454
00:55:08,190 --> 00:55:12,549
字符串长度所以事实证明有一个 

1455
00:55:10,619 --> 00:55:14,439
C调用的函数

1456
00:55:12,549 --> 00:55:16,689
英镑和人类在白天和 

1457
00:55:14,439 --> 00:55:18,759
直到今天都喜欢打字 

1458
00:55:16,689 --> 00:55:21,309
尽可能的角色，如此英镑 

1459
00:55:18,759 --> 00:55:23,410
是 字符串长度 和你使用它的方式 

1460
00:55:21,309 --> 00:55:24,640
你 只 需要一个头文件 吗？ 

1461
00:55:23,410 --> 00:55:26,439
还有另一个所谓的图书馆

1462
00:55:24,640 --> 00:55:28,539
字符串库，为您提供字符串 

1463
00:55:26,439 --> 00:55:30,459
超出cs50 的相关功能

1464
00:55:28,539 --> 00:55:32,650
库提供，所以如果你包括

1465
00:55:30,459 --> 00:55:34,599
字符串点H，可让您访问 

1466
00:55:32,650 --> 00:55:36,880
另一个叫做Ster Lang的函数

1467
00:55:34,599 --> 00:55:39,429
如果你传递一个 包含a 的变量 

1468
00:55:36,880 --> 00:55:41,439
字符串它将作为回报传递给你 

1469
00:55:39,429 --> 00:55:45,249
值中的字符 的总 数目 ，以便 

1470
00:55:41,439 --> 00:55:47,529
我键入 Z am y la ，所以应该 

1471
00:55:45,249 --> 00:55:49,420
因此 回到我身边 6打印 

1472
00:55:47,529 --> 00:55:55,019
列于 本阿马亚的 那些 六个字符 

1473
00:55:49,420 --> 00:55:55,019
是啊嗯嗯 

1474
00:55:56,039 --> 00:55:59,890
信用证中真的很好的问题

1475
00:55:58,269 --> 00:56:02,319
这个问题的问题就是这样说的 

1476
00:55:59,890 --> 00:56:04,029
绝对是有用的 但是 

1477
00:56:02,319 --> 00:56:05,289
回想一下， 在 信用卡中我们 

1478
00:56:04,029 --> 00:56:07,509
鼓励你真正接受 

1479
00:56:05,289 --> 00:56:09,880
数字作为一个长整数值

1480
00:56:07,509 --> 00:56:12,249
因此需要算术 

1481
00:56:09,880 --> 00:56:14,019
但如果您遇到问题，请回答 

1482
00:56:12,249 --> 00:56:16,150
涉及信用卡号码得到了 

1483
00:56:14,019 --> 00:56:18,339
人类作为输入的长字符串

1484
00:56:16,150 --> 00:56:20,349
字符而不是实际数字 

1485
00:56:18,339 --> 00:56:21,339
像一个 int或 long然后是的你可以 

1486
00:56:20,349 --> 00:56:23,019
实际上得到那些个人 

1487
00:56:21,339 --> 00:56:25,900
人物可能会有 

1488
00:56:23,019 --> 00:56:28,709
使事情变得 更容易，但交付 

1489
00:56:25,900 --> 00:56:28,709
是啊 

1490
00:56:30,070 --> 00:56:33,910
如果我们要定义，那真是个好问题 

1491
00:56:32,200 --> 00:56:36,340
string和cs50是我们重新定义的

1492
00:56:33,910 --> 00:56:38,200
字符串即使 它的 名字 也 没有这么字符串 

1493
00:56:36,340 --> 00:56:40,090
字符串H 实际上没有定义 

1494
00:56:38,200 --> 00:56:43,570
它只是一个叫做字符串的东西

1495
00:56:40,090 --> 00:56:49,090
字符串相关的功能不止于此 

1496
00:56:43,570 --> 00:56:52,119
很快你真的很好 问题 

1497
00:56:49,090 --> 00:56:54,340
编辑各个 值 如此之短 

1498
00:56:52,119 --> 00:56:56,770
回答是， 我们绝对可以改变 

1499
00:56:54,340 --> 00:56:59,130
价值观，并很快将在另一个

1500
00:56:56,770 --> 00:57:02,950
背景其他问题 

1501
00:56:59,130 --> 00:57:04,780
好吧原来这是正确的 

1502
00:57:02,950 --> 00:57:06,760
如果我的目标是打印出所有 的 

1503
00:57:04,780 --> 00:57:08,320
zamyla名字中的人物，但事实并非如此 

1504
00:57:06,760 --> 00:57:09,850
最好的设计，这一点 

1505
00:57:08,320 --> 00:57:11,140
微妙但这又是我们的意思 

1506
00:57:09,850 --> 00:57:13,510
设计成想出了一个问题

1507
00:57:11,140 --> 00:57:15,310
在 休息 期间 ，我们期待每个人 

1508
00:57:13,510 --> 00:57:18,190
写好的风格和好的设计 

1509
00:57:15,310 --> 00:57:19,060
上周 一样 知道，直到 今天这个样子 

1510
00:57:18,190 --> 00:57:20,800
我们已经介绍了。的概念

1511
00:57:19,060 --> 00:57:22,000
正确性在两个划痕和用 C 

1512
00:57:20,800 --> 00:57:24,700
上周，但现在我们正在介绍 

1513
00:57:22,000 --> 00:57:27,040
这些 代码 质量 的 其他轴 就像 

1514
00:57:24,700 --> 00:57:28,960
设计它是如何精心设计的 

1515
00:57:27,040 --> 00:57:31,020
它在上下文中看起来多么漂亮

1516
00:57:28,960 --> 00:57:33,040
风格如此期待 在这里 

1517
00:57:31,020 --> 00:57:35,020
意味着要与那些人保持一致 

1518
00:57:33,040 --> 00:57:38,140
特征，但不是过去 

1519
00:57:35,020 --> 00:57:39,850
所以这里有一个轻微的低效率 使 

1520
00:57:38,140 --> 00:57:43,240
在这个循环的第一次迭代我 

1521
00:57:39,850 --> 00:57:44,890
首先将I初始化为 0 ，然后检查 

1522
00:57:43,240 --> 00:57:46,390
如果I 小于 的 长度 

1523
00:57:44,890 --> 00:57:49,000
字符串希望它是如果它的 

1524
00:57:46,390 --> 00:57:50,920
zamyla 比我长0 

1525
00:57:49,000 --> 00:57:53,140
打印第八个字然后 我 

1526
00:57:50,920 --> 00:57:56,020
增量然后我检查这个条件 

1527
00:57:53,140 --> 00:57:58,420
然后我打印它 然后我 

1528
00:57:56,020 --> 00:58:00,130
增量然后我检查这个条件 

1529
00:57:58,420 --> 00:58:01,480
等等我们 最后 循环循环 

1530
00:58:00,130 --> 00:58:05,380
周末 你也许已经习惯了 

1531
00:58:01,480 --> 00:58:07,200
在问题什么问题，我是 AI 

1532
00:58:05,380 --> 00:58:12,940
看似冗长地问

1533
00:58:07,200 --> 00:58:14,740
不必要的我必须检查一个 

1534
00:58:12,940 --> 00:58:16,380
因为我是一次又一次

1535
00:58:14,740 --> 00:58:19,450
越来越多，但还有另一个

1536
00:58:16,380 --> 00:58:23,130
我不需要 保留的其他问题

1537
00:58:19,450 --> 00:58:26,350
再问一次，得到同样的 答案 

1538
00:58:23,130 --> 00:58:29,380
是的，我的这个函数调用 

1539
00:58:26,350 --> 00:58:31,119
英镑S的环这是很好的，这 是 

1540
00:58:29,380 --> 00:58:33,520
正确我正在检查的长度 

1541
00:58:31,119 --> 00:58:35,140
字符串， 但一旦我输入zamyla 她 

1542
00:58:33,520 --> 00:58:37,330
名称长度不改变我 

1543
00:58:35,140 --> 00:58:39,640
递增我所以我在 移动 

1544
00:58:37,330 --> 00:58:43,000
字符串，如果你愿意，但字符串本身 

1545
00:58:39,640 --> 00:58:43,480
我的la 不会改变，为什么我呢 

1546
00:58:43,000 --> 00:58:45,520
问

1547
00:58:43,480 --> 00:58:47,440
电脑一次又一次让我的 

1548
00:58:45,520 --> 00:58:48,850
英镑的s让我获得s的英镑 

1549
00:58:47,440 --> 00:58:50,740
得到我的英镑，所以我可以 

1550
00:58:48,850 --> 00:58:52,330
实际上修复这个 我可以改进 

1551
00:58:50,740 --> 00:58:53,890
设计，因为这必须采取一些 

1552
00:58:52,330 --> 00:58:56,440
时间可能很快，但它是 

1553
00:58:53,890 --> 00:58:57,460
仍然是一个非零的时间，所以你 

1554
00:58:56,440 --> 00:58:59,320
知道我能做什么我能做什么

1555
00:58:57,460 --> 00:59:01,960
这样的东西 int n得到字符串 

1556
00:58:59,320 --> 00:59:04,270
s的长度，现在就这样做吧 

1557
00:59:01,960 --> 00:59:06,160
会是更好的 设计，因为现在我 

1558
00:59:04,270 --> 00:59:08,560
只询问一次的问题

1559
00:59:06,160 --> 00:59:10,150
功能我记得或兑现，如果 

1560
00:59:08,560 --> 00:59:11,859
你会得到答案 然后我就是 

1561
00:59:10,150 --> 00:59:13,720
使用变量只是比较 

1562
00:59:11,859 --> 00:59:15,880
变量比比较快

1563
00:59:13,720 --> 00:59:17,440
针对其具有的功能的可变

1564
00:59:15,880 --> 00:59:19,780
被调用必须返回 一个值 

1565
00:59:17,440 --> 00:59:21,160
然后你就可以 比较，但老实说 

1566
00:59:19,780 --> 00:59:22,390
它不一定是这个冗长的我们 

1567
00:59:21,160 --> 00:59:25,240
实际上可以有点优雅 

1568
00:59:22,390 --> 00:59:26,440
这个 如果你 使用一个秘密循环 

1569
00:59:25,240 --> 00:59:28,690
循环的功能是你可以拥有的

1570
00:59:26,440 --> 00:59:30,580
声明变量 之后的逗号和你 

1571
00:59:28,690 --> 00:59:33,369
实际上可以做到这一点并使其均匀 

1572
00:59:30,580 --> 00:59:35,050
如果你愿意或更多，你会 更 优雅 

1573
00:59:33,369 --> 00:59:37,030
看起来令人困惑， 但取决于 你的 

1574
00:59:35,050 --> 00:59:39,400
透视，但现在这样做 

1575
00:59:37,030 --> 00:59:41,290
但是在循环内部声明了n 

1576
00:59:39,400 --> 00:59:43,030
就像我声明了我，它只是 

1577
00:59:41,290 --> 00:59:51,700
稍微紧一点就少了几行 

1578
00:59:43,030 --> 00:59:53,590
编码任何问题然后好问题 

1579
00:59:51,700 --> 00:59:55,390
我刚刚完成的方式无法重复使用 

1580
00:59:53,590 --> 00:59:58,630
这个外面的花括号 

1581
00:59:55,390 --> 01:00:01,119
I和 N的范围仅存在于此 

1582
00:59:58,630 --> 01:00:03,900
上下文现在另一种方式是我

1583
01:00:01,119 --> 01:00:03,900
可以在其他地方使用它 

1584
01:00:09,900 --> 01:00:12,900
绝对

1585
01:00:17,630 --> 01:00:21,980
如果我想使用s的长度，请更正

1586
01:00:20,210 --> 01:00:24,170
又绝对能 声明 

1587
01:00:21,980 --> 01:00:26,150
变量或正如我前面 以外 做 

1588
01:00:24,170 --> 01:00:29,420
循环，以便重用它 

1589
01:00:26,150 --> 01:00:31,190
完全没问题甚至II存在 

1590
01:00:29,420 --> 01:00:32,870
只有在这个循环内部，所以 如果我有 

1591
01:00:31,190 --> 01:00:35,030
另一个循环， 我可以 重用 我，它是一个 

1592
01:00:32,870 --> 01:00:36,710
不同我因为这些变量 而已 

1593
01:00:35,030 --> 01:00:39,830
内的 存在循环，其中 

1594
01:00:36,710 --> 01:00:44,450
他们被宣布如此，事实证明 

1595
01:00:39,830 --> 01:00:45,890
这些字符没有任何东西

1596
01:00:44,450 --> 01:00:47,750
他们除了字符以后 

1597
01:00:45,890 --> 01:00:49,940
字符和事实上的字符

1598
01:00:47,750 --> 01:00:51,830
让我继续在这里画一幅画 

1599
01:00:49,940 --> 01:00:53,540
实际上在下面发生了什么 

1600
01:00:51,830 --> 01:00:55,520
计算机的引擎盖 在这里，所以当我 

1601
01:00:53,540 --> 01:01:01,430
输入zamyla的名字我当然是 

1602
01:00:55,520 --> 01:01:02,990
做一些像 Z a MYL的 事情 但是 

1603
01:01:01,430 --> 01:01:04,280
我们在哪里实际上进展 顺利 

1604
01:01:02,990 --> 01:01:06,140
现在知道你的电脑里面 是 

1605
01:01:04,280 --> 01:01:08,030
RAM或内存，你可以想到它 

1606
01:01:06,140 --> 01:01:09,530
像一个网格，老实说，我可以想到 

1607
01:01:08,030 --> 01:01:11,540
这整个屏幕 只是在一个被 

1608
01:01:09,530 --> 01:01:14,150
不同的方向 记忆 网格 

1609
01:01:11,540 --> 01:01:17,270
所以我们可以分开它 

1610
01:01:14,150 --> 01:01:20,600
像这样的行和列不是 

1611
01:01:17,270 --> 01:01:22,760
必须要扩展 ，它是更多的行 

1612
01:01:20,600 --> 01:01:25,130
我在这里的屏幕和栏目

1613
01:01:22,760 --> 01:01:27,860
把 事情分成个人 

1614
01:01:25,130 --> 01:01:30,200
字节的内存，我们刚才也看到了 

1615
01:01:27,860 --> 01:01:33,110
所以确实下方的引擎盖 

1616
01:01:30,200 --> 01:01:35,120
电脑就是这种记忆的布局了 

1617
01:01:33,110 --> 01:01:36,410
编译器已经以某种方式弄明白了 

1618
01:01:35,120 --> 01:01:37,910
程序以某种方式弄清楚在哪里 

1619
01:01:36,410 --> 01:01:39,980
把Z和a放在哪里然后是M. 

1620
01:01:37,910 --> 01:01:41,740
和Y和L 和 a但是 

1621
01:01:39,980 --> 01:01:44,060
关键是它们都是连续的 

1622
01:01:41,740 --> 01:01:46,040
背对背， 但抓住是如果 

1623
01:01:44,060 --> 01:01:48,500
我在我的 程序中输入其他单词 

1624
01:01:46,040 --> 01:01:50,030
或分数到我的程序或任何数据 

1625
01:01:48,500 --> 01:01:52,040
进入我的程序， 它 最终会结束 

1626
01:01:50,030 --> 01:01:53,990
在计算机的内存中 ，以便在别处

1627
01:01:52,040 --> 01:01:56,900
你怎么知道zamyla的起点和地点 

1628
01:01:53,990 --> 01:01:59,840
zamyla 在记忆中结束的地方

1629
01:01:56,900 --> 01:02:04,070
好的变量叫做s本质上 

1630
01:01:59,840 --> 01:02:07,190
在这里有一些纪念

1631
01:02:04,070 --> 01:02:10,460
S开始的计算机但是有 

1632
01:02:07,190 --> 01:02:13,520
没有明显的方法知道zamyla结束的地方 

1633
01:02:10,460 --> 01:02:15,860
除非我们自己告诉电脑 

1634
01:02:13,520 --> 01:02:19,130
任何时候电脑都不知道我们 

1635
01:02:15,860 --> 01:02:22,340
存储像Z 上我拉匝串

1636
01:02:19,130 --> 01:02:24,740
因为它没有使用1 2 3 4 5 6 

1637
01:02:22,340 --> 01:02:27,470
它实际上使用的字符7 

1638
01:02:24,740 --> 01:02:30,329
偷偷地，它实际上是一个特殊的 

1639
01:02:27,470 --> 01:02:33,929
所有0的字符 

1640
01:02:30,329 --> 01:02:35,549
在最后一口 

1641
01:02:33,929 --> 01:02:38,279
每一口都是8位，所以它正在 推杆 

1642
01:02:35,549 --> 01:02:39,569
在那里或我们可以秘密地8个 零 

1643
01:02:38,279 --> 01:02:42,239
实际上， 这更常见 

1644
01:02:39,569 --> 01:02:45,029
反斜杠0就是所谓的null 

1645
01:02:42,239 --> 01:02:47,400
字符，它只是意味着 所有零 

1646
01:02:45,029 --> 01:02:49,229
字符串zamyla的长度是6 但是 

1647
01:02:47,400 --> 01:02:51,719
多少 字节 它显然需要 

1648
01:02:49,229 --> 01:02:53,420
只是为了清楚所以 它实际上需要 

1649
01:02:51,719 --> 01:02:55,140
7点， 这是一个秘密 

1650
01:02:53,420 --> 01:02:57,329
我们没有实现的细节 

1651
01:02:55,140 --> 01:02:58,679
真的要关心，但 最终 

1652
01:02:57,329 --> 01:03:00,119
我们会因为我们想要实施 

1653
01:02:58,679 --> 01:03:02,039
我们需要的某些功能 

1654
01:03:00,119 --> 01:03:03,749
知道实际上是怎么回事 

1655
01:03:02,039 --> 01:03:06,089
让 我继续 这样做 吧 

1656
01:03:03,749 --> 01:03:08,130
我继续创建 一个名为的程序 

1657
01:03:06,089 --> 01:03:09,689
斯特林本身所以这 不是 一个 

1658
01:03:08,130 --> 01:03:11,759
函数但是一个 名为string 的 程序 

1659
01:03:09,689 --> 01:03:14,039
长度点C让我继续并包括 

1660
01:03:11,759 --> 01:03:16,529
顶部的cs50 库让我走了 

1661
01:03:14,039 --> 01:03:18,509
提前并 包括标准 IOH 让我走 

1662
01:03:16,529 --> 01:03:20,130
提前并键入int main void 所以 

1663
01:03:18,509 --> 01:03:21,779
这和以往一样 

1664
01:03:20,130 --> 01:03:25,679
然后让我继续前进并提示 

1665
01:03:21,779 --> 01:03:27,869
用户说出他或她的名字就像这样 

1666
01:03:25,679 --> 01:03:28,920
然后你知道是什么让我 实际上这个 

1667
01:03:27,869 --> 01:03:30,390
时间不只是打印他们的 名字 

1668
01:03:28,920 --> 01:03:32,279
因为我们做了 那个令人作呕的广告 

1669
01:03:30,390 --> 01:03:34,469
只计算他的字母 数 

1670
01:03:32,279 --> 01:03:36,900
或她的 名字，所以我们怎么能做得那么好 

1671
01:03:34,469 --> 01:03:41,699
我们可能只是 这样做 INT n 变 

1672
01:03:36,900 --> 01:03:45,809
英镑的s然后说printf了 

1673
01:03:41,699 --> 01:03:48,809
你的名字长度是％ I然后我们 

1674
01:03:45,809 --> 01:03:50,759
可以插入 n，因为这是数字 

1675
01:03:48,809 --> 01:03:52,229
我们存储了长度但使用 

1676
01:03:50,759 --> 01:03:55,170
英镑我必须包括什么标题 

1677
01:03:52,229 --> 01:03:57,630
文件串点H 是新的 

1678
01:03:55,170 --> 01:04:01,380
所以字符串点H ，现在如果我键入它 

1679
01:03:57,630 --> 01:04:05,160
所有正确的使得郎朗制造 

1680
01:04:01,380 --> 01:04:05,339
Lang good slash sterling让我们试试吧 

1681
01:04:05,160 --> 01:04:08,279
它

1682
01:04:05,339 --> 01:04:10,890
zamyla 输入 她名字的长度 

1683
01:04:08,279 --> 01:04:12,749
是 6 但英镑表现还算不错 

1684
01:04:10,890 --> 01:04:13,799
英镑只是我们的抽象

1685
01:04:12,749 --> 01:04:15,449
别人写的就是这个 

1686
01:04:13,799 --> 01:04:17,729
非常方便， 但你知道我们 

1687
01:04:15,449 --> 01:04:20,009
没有严格需要它其实我可以做 

1688
01:04:17,729 --> 01:04:20,880
这一点我自己 ，如果我明白 什么 

1689
01:04:20,009 --> 01:04:23,519
电脑正在做 

1690
01:04:20,880 --> 01:04:24,989
我可以实现 相同的功能 

1691
01:04:23,519 --> 01:04:26,910
我自己如下，我可以宣布一个 

1692
01:04:24,989 --> 01:04:28,679
变量名为n并将其初始化为 0 

1693
01:04:26,910 --> 01:04:34,019
然后 你知道我要去的地方 

1694
01:04:28,679 --> 01:04:37,559
提前做这个， 而s括号n 

1695
01:04:34,019 --> 01:04:39,299
不等于全 零，但你不写 

1696
01:04:37,559 --> 01:04:41,489
你真的这样做的所有零

1697
01:04:39,299 --> 01:04:43,289
这是反斜杠 0 我 

1698
01:04:41,489 --> 01:04:44,310
早先在单引号中提到过

1699
01:04:43,289 --> 01:04:46,680
只是意味着一切

1700
01:04:44,310 --> 01:04:49,560
在咬伤中 ，现在我可以继续前进 

1701
01:04:46,680 --> 01:04:51,060
如果不熟悉 什么，请 加n加 

1702
01:04:49,560 --> 01:04:53,670
这意味着要记住这只是 N. 

1703
01:04:51,060 --> 01:04:56,370
等于n 加1，但 它 只是一点点 

1704
01:04:53,670 --> 01:04:58,170
更加紧凑，说n加上然后 

1705
01:04:56,370 --> 01:05:00,060
我可以打印出 你的 n 的名字 你 

1706
01:04:58,170 --> 01:05:03,390
你的名字和 你 的名字 

1707
01:05:00,060 --> 01:05:05,910
你的名字的长度是 ％i插入 

1708
01:05:03,390 --> 01:05:07,560
在n中，为什么这有效呢？ 

1709
01:05:05,910 --> 01:05:09,210
看起来很时髦， 但这只是 

1710
01:05:07,560 --> 01:05:10,950
展示对什么的理解

1711
01:05:09,210 --> 01:05:13,980
在众所周知的引擎盖下面 

1712
01:05:10,950 --> 01:05:16,020
如果n初始化为0 ，我看s 

1713
01:05:13,980 --> 01:05:18,510
支架n就像看着s一样 

1714
01:05:16,020 --> 01:05:23,370
括号0，如果字符串s 是zamyla 

1715
01:05:18,510 --> 01:05:25,290
什么是s 括号0 Z然后呢 

1716
01:05:23,370 --> 01:05:27,690
不等于反斜杠0它等于Z. 

1717
01:05:25,290 --> 01:05:31,200
显然我们增加n所以现在n是 

1718
01:05:27,690 --> 01:05:34,290
1 ， 现在n是1，所以s括号1 

1719
01:05:31,200 --> 01:05:38,670
在zamyla的名字等等我们 

1720
01:05:34,290 --> 01:05:41,370
到 了我的la然后全部为零 

1721
01:05:38,670 --> 01:05:44,280
所谓的空字符或反斜杠0 

1722
01:05:41,370 --> 01:05:46,110
那当然是等于反斜杠0所以 

1723
01:05:44,280 --> 01:05:48,660
循环停在那里

1724
01:05:46,110 --> 01:05:52,320
它的总数或n值 

1725
01:05:48,660 --> 01:05:54,360
以前是6，所以就是这样 

1726
01:05:52,320 --> 01:05:56,880
就像所有我们所拥有的一样

1727
01:05:54,360 --> 01:05:58,530
就像这个顶部的记忆一样

1728
01:05:56,880 --> 01:05:59,760
从左到右，但是所有的 

1729
01:05:58,530 --> 01:06:02,100
我们一直在使用的功能 

1730
01:05:59,760 --> 01:06:04,440
现在一周，从此以后 只是归结起来 

1731
01:06:02,100 --> 01:06:05,940
一些相对简单的原语和 

1732
01:06:04,440 --> 01:06:08,070
如果你理解那些基元就像 

1733
01:06:05,940 --> 01:06:09,630
你可以用你想做的任何事

1734
01:06:08,070 --> 01:06:12,510
计算机兼具计算机代码 

1735
01:06:09,630 --> 01:06:13,830
我们实际上可以看到 记忆力 

1736
01:06:12,510 --> 01:06:16,080
事实上我们看过的一些东西 

1737
01:06:13,830 --> 01:06:17,550
或两周前如下，让 我走吧 

1738
01:06:16,080 --> 01:06:18,630
进取，不断开拓 被调用 的例子 

1739
01:06:17,550 --> 01:06:20,430
ASCII 零 

1740
01:06:18,630 --> 01:06:22,380
回想一下，ASCII是两者之间的映射

1741
01:06:20,430 --> 01:06:24,210
计算机中的 字母 和数字 

1742
01:06:22,380 --> 01:06:26,670
注意这个程序要做什么 

1743
01:06:24,210 --> 01:06:30,750
让我进入这个文件夹make 

1744
01:06:26,670 --> 01:06:34,590
ASCII 0点斜杠ASCII 0输入 

1745
01:06:30,750 --> 01:06:37,250
字符串应该让zamyla进入

1746
01:06:34,590 --> 01:06:41,250
事实证明，如果你 真的 

1747
01:06:37,250 --> 01:06:45,780
查找zamyla的ASCII码 

1748
01:06:41,250 --> 01:06:47,910
名字Z是90 小写字母a是97 M是109 

1749
01:06:45,780 --> 01:06:49,080
等等有那些人物 

1750
01:06:47,910 --> 01:06:50,730
实际上我们可以玩 同一个游戏 

1751
01:06:49,080 --> 01:06:53,730
如果我 再次 这样做，我们上周 做 了 

1752
01:06:50,730 --> 01:06:55,920
喜欢那里有你的72，那就是你的 

1753
01:06:53,730 --> 01:06:57,840
73 现在这里的情况很好 

1754
01:06:55,920 --> 01:06:59,910
我知道如何 操纵个人 

1755
01:06:57,840 --> 01:07:01,920
注意我能做什么 我可以 得到一个字符串 

1756
01:06:59,910 --> 01:07:03,630
来自用户就像我们一直拥有的那样 

1757
01:07:01,920 --> 01:07:05,760
我可以迭代这个长度 

1758
01:07:03,630 --> 01:07:07,950
字符串尽管使用效率低下 

1759
01:07:05,760 --> 01:07:13,020
英镑在这里，然后注意这个新的 

1760
01:07:07,950 --> 01:07:15,570
今天功能我现在可以转换一个数据 

1761
01:07:13,020 --> 01:07:17,550
键入另一个 因为char a 

1762
01:07:15,570 --> 01:07:20,120
字符只有 八位但是 

1763
01:07:17,550 --> 01:07:22,560
在人物的背景下呈现

1764
01:07:20,120 --> 01:07:24,690
字节也只是你的八位 

1765
01:07:22,560 --> 01:07:26,190
可以当作一个整数 权数 

1766
01:07:24,690 --> 01:07:27,930
如果你这完全是上下文敏感的话 

1767
01:07:26,190 --> 01:07:29,580
如果它是您使用的图形，请使用Photoshop 

1768
01:07:27,930 --> 01:07:32,730
一个文本程序，这是一个消息等等

1769
01:07:29,580 --> 01:07:36,360
所以你可以编码改变 

1770
01:07:32,730 --> 01:07:38,430
上下文所以请注意这里的括号 

1771
01:07:36,360 --> 01:07:41,160
当然是zamyla的 冰 人物 

1772
01:07:38,430 --> 01:07:43,050
这样命名为Z 或a或 M 或其他什么，但我 

1773
01:07:41,160 --> 01:07:45,060
可以将Ice字符转换为

1774
01:07:43,050 --> 01:07:46,830
执行所谓的铸造你的整数

1775
01:07:45,060 --> 01:07:48,990
可以用括号中的字面指定 

1776
01:07:46,830 --> 01:07:51,480
要 转换一个数据的 数据类型 

1777
01:07:48,990 --> 01:07:54,000
键入，然后准确存储它 

1778
01:07:51,480 --> 01:07:56,040
那个数据类型所以括号我转换 它 

1779
01:07:54,000 --> 01:07:58,710
到一个数字然后存储在实际 

1780
01:07:56,040 --> 01:08:01,080
数字变量，所以我可以打印出来 

1781
01:07:58,710 --> 01:08:03,420
价值所以看到这是给我看的 

1782
01:08:01,080 --> 01:08:06,090
字符 显示我的信 ，通过 

1783
01:08:03,420 --> 01:08:08,040
插入角色然后 

1784
01:08:06,090 --> 01:08:09,660
字母和字符的种类 

1785
01:08:08,040 --> 01:08:11,370
我刚把它转换成的数字 

1786
01:08:09,660 --> 01:08:13,730
而你实际上甚至不必 

1787
01:08:11,370 --> 01:08:16,470
显式这称为显式铸造 

1788
01:08:13,730 --> 01:08:19,170
从技术上讲，我们可以隐含地这样做

1789
01:08:16,470 --> 01:08:20,760
看，计算机知道这些数字

1790
01:08:19,170 --> 01:08:22,260
是字符和 字符是 数字 

1791
01:08:20,760 --> 01:08:24,030
你不必那么迂腐 

1792
01:08:22,260 --> 01:08:25,290
甚至做明确的演员 

1793
01:08:24,030 --> 01:08:27,420
圆括号你可以做到 这一点 

1794
01:08:25,290 --> 01:08:28,680
隐含地使用数据类型， 老实说 

1795
01:08:27,420 --> 01:08:31,350
在这 一点上，我 甚至不需要 

1796
01:08:28,680 --> 01:08:33,750
可变我 能摆脱 这种 上下 

1797
01:08:31,350 --> 01:08:37,200
在这里，我可以简单地打印相同的 

1798
01:08:33,750 --> 01:08:39,390
东西两次，但告诉printf打印 

1799
01:08:37,200 --> 01:08:41,339
首先是在一个角色 的背景下 

1800
01:08:39,390 --> 01:08:43,020
和第二在一个 int的上下文中

1801
01:08:41,339 --> 01:08:44,190
只是处理完全相同的位 

1802
01:08:43,020 --> 01:08:47,250
不同 

1803
01:08:44,190 --> 01:08:48,900
那是隐式的铸造而且它只是 

1804
01:08:47,250 --> 01:08:51,240
演示了我们在第零周所做的事情 

1805
01:08:48,900 --> 01:08:53,609
当我们声称字母是数字时 

1806
01:08:51,240 --> 01:08:55,410
和数字 也可以是 颜色和 

1807
01:08:53,609 --> 01:08:58,440
颜色可以是图像 等等 

1808
01:08:55,410 --> 01:09:00,900
这个问题也是肯定的 

1809
01:08:58,440 --> 01:09:04,170
回归信誉 确实是其他的 

1810
01:09:00,900 --> 01:09:06,660
现在问题 还 可以 ， 还有什么 可以 

1811
01:09:04,170 --> 01:09:08,490
我们实际上是这样欣赏的 

1812
01:09:06,660 --> 01:09:10,049
超级简单的功能，我们所有人 

1813
01:09:08,490 --> 01:09:11,460
如果我们做的话，肯定是理所当然的 

1814
01:09:10,049 --> 01:09:13,290
现在使用它了Google Docs 

1815
01:09:11,460 --> 01:09:15,000
微软Word等都可以 

1816
01:09:13,290 --> 01:09:16,349
自动为您 量词 

1817
01:09:15,000 --> 01:09:18,089
这些 天甚至你的手机都可以做到 

1818
01:09:16,349 --> 01:09:19,650
现在只是自动更正你的 

1819
01:09:18,089 --> 01:09:21,900
好消息实际上是怎么回事 

1820
01:09:19,650 --> 01:09:23,309
一旦你知道 一个字符串就 运行 良好 

1821
01:09:21,900 --> 01:09:25,079
只是一堆人物回来 

1822
01:09:23,309 --> 01:09:27,540
背靠背，你知道 这些 

1823
01:09:25,079 --> 01:09:29,909
字符有数字代表

1824
01:09:27,540 --> 01:09:32,819
他们和资本a一样是65岁 

1825
01:09:29,909 --> 01:09:34,409
小写字母a显然是97 

1826
01:09:32,819 --> 01:09:36,359
就像我们可以利用这些 

1827
01:09:34,409 --> 01:09:37,770
如果我继续前进并开放的模式

1828
01:09:36,359 --> 01:09:41,279
这个另一个例子 叫做 

1829
01:09:37,770 --> 01:09:42,900
大写 零 注意这个程序是什么 

1830
01:09:41,279 --> 01:09:46,339
是要去 运行它 为 我 做 第一 

1831
01:09:42,900 --> 01:09:48,839
使大写 零点斜线 

1832
01:09:46,339 --> 01:09:50,880
大写零 让我继续 打字 

1833
01:09:48,839 --> 01:09:52,889
在zamyla的名字就像以前一样， 但现在 

1834
01:09:50,880 --> 01:09:54,119
这都是资本所以这是一点点 

1835
01:09:52,889 --> 01:09:55,800
极端希望你的手机没有 

1836
01:09:54,119 --> 01:09:57,329
善用每一封信，但你可以 

1837
01:09:55,800 --> 01:09:59,489
想象它只是第一个资本化

1838
01:09:57,329 --> 01:10:00,960
如果你想要它，那么它是如何工作的 

1839
01:09:59,489 --> 01:10:05,940
好吧，让我继续开放吧 

1840
01:10:00,960 --> 01:10:07,800
例如这里 还等什么，我们 这样 做 是在这里 

1841
01:10:05,940 --> 01:10:09,630
我从用户得到一个字符串 只是 

1842
01:10:07,800 --> 01:10:11,369
就像我们一直那样，然后我就说了

1843
01:10:09,630 --> 01:10:13,559
只是为了 输出的形式 

1844
01:10:11,369 --> 01:10:16,409
很好，我在 做一个漂亮的循环 

1845
01:10:13,559 --> 01:10:18,540
有效地从我等于零到 

1846
01:10:16,409 --> 01:10:21,059
字符串的长度，现在 注意这一点 

1847
01:10:18,540 --> 01:10:22,980
逻辑的整洁应用它有点 

1848
01:10:21,059 --> 01:10:24,650
乍一看肯定是神秘的但是 

1849
01:10:22,980 --> 01:10:27,270
哎呀， 现在它已经消失了 ，我是什么 

1850
01:10:24,650 --> 01:10:29,340
与这些代码究竟 做 

1851
01:10:27,270 --> 01:10:31,920
以及此循环的每次迭代 

1852
01:10:29,340 --> 01:10:34,020
我问的问题是它 

1853
01:10:31,920 --> 01:10:36,000
s的特征所以当前的性格 

1854
01:10:34,020 --> 01:10:38,760
是大于等于小写 

1855
01:10:36,000 --> 01:10:40,619
一个它是否和小于 或等于 

1856
01:10:38,760 --> 01:10:43,440
小写字母Z换句话说你怎么样 

1857
01:10:40,619 --> 01:10:45,210
比如说英语更通俗 

1858
01:10:43,440 --> 01:10:46,829
字面意思是小写，但这是

1859
01:10:45,210 --> 01:10:49,320
更具程序化的表达方式是

1860
01:10:46,829 --> 01:10:50,969
它是小写好的，如果它 继续 

1861
01:10:49,320 --> 01:10:53,760
现在做到这一点，这 是 一个 有点古怪 

1862
01:10:50,969 --> 01:10:56,880
但具体打印出一个角色 

1863
01:10:53,760 --> 01:10:59,099
它的 性格但减去 

1864
01:10:56,880 --> 01:11:02,969
是小写字母不管 

1865
01:10:59,099 --> 01:11:05,849
差异介于一点点和一点点之间

1866
01:11:02,969 --> 01:11:08,659
现在它来自哪里呢？ 

1867
01:11:05,849 --> 01:11:11,909
结果还可以， 所以资本a是65 

1868
01:11:08,659 --> 01:11:14,040
小写字母a是97所以区别 

1869
01:11:11,909 --> 01:11:17,400
这些之间是32 ，这是真的 

1870
01:11:14,040 --> 01:11:20,250
B 所以资本B是66而小写字母B是 

1871
01:11:17,400 --> 01:11:23,429
98仍然是32 并且它重复整体 

1872
01:11:20,250 --> 01:11:25,650
字母表所以我可以 这样做 

1873
01:11:23,429 --> 01:11:28,380
如果我知道小写字母有 

1874
01:11:25,650 --> 01:11:29,729
更大的数字，如 97 98，我知道 

1875
01:11:28,380 --> 01:11:33,090
小写数字较低 

1876
01:11:29,729 --> 01:11:35,880
字母如65 66 我可以字面意思 

1877
01:11:33,090 --> 01:11:37,050
从我的小写中减去32 

1878
01:11:35,880 --> 01:11:38,459
你指出它是一个字母

1879
01:11:37,050 --> 01:11:42,090
小写字母减去32和那个 

1880
01:11:38,459 --> 01:11:44,249
给我们什么结果资本化 

1881
01:11:42,090 --> 01:11:45,749
版本它为我们提供了一些东西， 但是 

1882
01:11:44,249 --> 01:11:47,610
老实说，这感觉有点hackish 

1883
01:11:45,749 --> 01:11:49,260
那就好，是的，我可以做数学 

1884
01:11:47,610 --> 01:11:50,969
正确，但你知道什么是 更好的 

1885
01:11:49,260 --> 01:11:52,499
一般来说，要把它抽象出去 

1886
01:11:50,969 --> 01:11:53,999
不要陷入计算方式的杂草 

1887
01:11:52,499 --> 01:11:56,099
许多字符 都是 彼此 远离 

1888
01:11:53,999 --> 01:11:57,389
数学在计算机上便宜又容易 

1889
01:11:56,099 --> 01:11:59,749
让它为你做数学 

1890
01:11:57,389 --> 01:12:02,280
减去a的值是什么 

1891
01:11:59,749 --> 01:12:04,679
如果资本a来自的价值

1892
01:12:02,280 --> 01:12:06,360
小写一个我们可以写的东西32 

1893
01:12:04,679 --> 01:12:08,550
否则继续前进， 只打印 

1894
01:12:06,360 --> 01:12:11,489
字符不变， 所以在这种情况下 

1895
01:12:08,550 --> 01:12:14,070
我的LAN zamyla的名字得到了大写 

1896
01:12:11,489 --> 01:12:16,439
Z独自留下的一切 

1897
01:12:14,070 --> 01:12:18,900
只是通过了解正在 发生的事情 

1898
01:12:16,439 --> 01:12:20,459
与 满足 计算机 如何 代表 

1899
01:12:18,900 --> 01:12:22,289
但老实说， 上帝，我 不想留下来 

1900
01:12:20,459 --> 01:12:23,489
像这样 写代码 就像我从来没有 

1901
01:12:22,289 --> 01:12:25,469
这将是编程的新手 

1902
01:12:23,489 --> 01:12:27,420
也许我永远不会得到这种 

1903
01:12:25,469 --> 01:12:29,159
所有神秘C符号的序列

1904
01:12:27,420 --> 01:12:30,630
在一起，这没关系，因为我们可以 

1905
01:12:29,159 --> 01:12:33,300
实际上实现 了同样的程序 a 

1906
01:12:30,630 --> 01:12:34,679
功能 更加轻松 

1907
01:12:33,300 --> 01:12:37,709
和其他人的抽象

1908
01:12:34,679 --> 01:12:40,019
为我们写的所以在这个程序 中转 

1909
01:12:37,709 --> 01:12:41,880
我可以简化我的问题

1910
01:12:40,019 --> 01:12:44,820
通过逐字地调用函数来询问

1911
01:12:41,880 --> 01:12:46,469
这 说的是低，还有另一个 

1912
01:12:44,820 --> 01:12:47,909
一个叫做鞋帮，一个叫做束

1913
01:12:46,469 --> 01:12:50,939
其他 只是字面意思的 人 

1914
01:12:47,909 --> 01:12:53,610
是什么或其他更低的需要 

1915
01:12:50,939 --> 01:12:55,979
一个像s的第8个字符的论点

1916
01:12:53,610 --> 01:12:58,260
它只返回bool true或false 

1917
01:12:55,979 --> 01:12:59,820
如果真的 如何 实施呢？ 

1918
01:12:58,260 --> 01:13:02,939
我们看了一下代码， 别人 

1919
01:12:59,820 --> 01:13:05,309
几十年前写 的是高估的可能性 

1920
01:13:02,939 --> 01:13:08,070
或者他或她写的赔率较低

1921
01:13:05,309 --> 01:13:09,630
代码看起来几乎像这样，但我们 

1922
01:13:08,070 --> 01:13:11,309
不需要 担心这一水平 

1923
01:13:09,630 --> 01:13:13,650
细节，我们可以使用他或她 

1924
01:13:11,309 --> 01:13:15,090
功能， 但我们如何做到这一点 

1925
01:13:13,650 --> 01:13:16,409
这个功能和你只会 

1926
01:13:15,090 --> 01:13:18,209
通过被告知或知道这一点 

1927
01:13:16,409 --> 01:13:21,360
谷歌搜索或阅读参考是在 

1928
01:13:18,209 --> 01:13:23,400
你需要的 库称为 C型点H 

1929
01:13:21,360 --> 01:13:26,280
头文件名为C type dot H in 

1930
01:13:23,400 --> 01:13:27,719
为了使用 它，几乎总是如此 

1931
01:13:26,280 --> 01:13:30,269
指向你的参考和 

1932
01:13:27,719 --> 01:13:32,070
文档向您解释 

1933
01:13:30,269 --> 01:13:33,840
上部是另一个功能目前 只 

1934
01:13:32,070 --> 01:13:34,860
这个数学就像我的上帝，我猜你想要的 

1935
01:13:33,840 --> 01:13:36,909
大写一封我不想要的信 

1936
01:13:34,860 --> 01:13:38,769
真的一直在想着 相隔 多远 

1937
01:13:36,909 --> 01:13:40,389
字母来自小写结果

1938
01:13:38,769 --> 01:13:42,070
在C型库中有 

1939
01:13:40,389 --> 01:13:43,780
另一个函数称为两个上层 

1940
01:13:42,070 --> 01:13:46,150
字面意思完全相同的东西 

1941
01:13:43,780 --> 01:13:49,119
我们之前编写的程序等等 

1942
01:13:46,150 --> 01:13:51,789
那也没关系，但 你知道这 是 什么 

1943
01:13:49,119 --> 01:13:53,679
感觉有点冗长会很好 

1944
01:13:51,789 --> 01:13:56,349
如果我 真的 可以 收紧这个计划 

1945
01:13:53,679 --> 01:13:57,880
那么如何才能更好地工作呢 

1946
01:13:56,349 --> 01:14:00,130
事实证明你们中的一些人可能 很熟悉 

1947
01:13:57,880 --> 01:14:01,719
使用cs50参考在线或基于网络 

1948
01:14:00,130 --> 01:14:04,269
我们有的应用程序可以帮助您导航

1949
01:14:01,719 --> 01:14:05,679
在 C语言函数原来， 

1950
01:14:04,269 --> 01:14:08,709
所有该应用程序 的数据 

1951
01:14:05,679 --> 01:14:10,749
来自较旧的命令行程序 

1952
01:14:08,709 --> 01:14:12,880
它来自Linux并且在 

1953
01:14:10,749 --> 01:14:15,369
沙盒称为man for manual and 

1954
01:14:12,880 --> 01:14:16,809
任何时候你在命令中输入man 

1955
01:14:15,369 --> 01:14:19,119
提示然后是函数的名称 

1956
01:14:16,809 --> 01:14:20,469
如果它存在，你会感兴趣

1957
01:14:19,119 --> 01:14:23,949
会告诉你一些 关于 

1958
01:14:20,469 --> 01:14:27,459
它所以如果我去一个 对上男人上 

1959
01:14:23,949 --> 01:14:30,099
我得到稍微有点隐蔽嗯 文档 

1960
01:14:27,459 --> 01:14:31,780
在这里，但注意上层和其他一些 

1961
01:14:30,099 --> 01:14:34,689
函数转换大写或小写

1962
01:14:31,780 --> 01:14:36,999
那是在中的摘要通知 

1963
01:14:34,689 --> 01:14:39,159
简介可以说是 手册页 

1964
01:14:36,999 --> 01:14:41,349
告诉我我必须使用哪个头文件

1965
01:14:39,159 --> 01:14:43,360
包括通知，根据概要，它是 

1966
01:14:41,349 --> 01:14:45,489
还告诉我签名是什么或 

1967
01:14:43,360 --> 01:14:47,739
原型在其他方面具有功能

1968
01:14:45,489 --> 01:14:49,749
用Linux中的文档说出来 

1969
01:14:47,739 --> 01:14:50,889
程序员手册非常简洁，所以它是 

1970
01:14:49,749 --> 01:14:52,479
不要牵着你的 手 

1971
01:14:50,889 --> 01:14:54,760
黑白格式它只是要 

1972
01:14:52,479 --> 01:14:56,650
为了更好地隐含地传达你 

1973
01:14:54,760 --> 01:14:58,479
把它放在你的文件顶部，顺便说一下 

1974
01:14:56,650 --> 01:15:02,139
这是你如何使用该功能 

1975
01:14:58,479 --> 01:15:07,030
名为 C的参数 返回值 

1976
01:15:02,139 --> 01:15:08,739
输入int为什么它是int让我挥手 

1977
01:15:07,030 --> 01:15:10,929
我的双手 才有效地回归 

1978
01:15:08,739 --> 01:15:11,679
今天和 我们目的的角色 

1979
01:15:10,929 --> 01:15:14,289
如果我们向下滚动

1980
01:15:11,679 --> 01:15:16,829
好的描述我真的不想 

1981
01:15:14,289 --> 01:15:20,019
阅读所有这些， 但好吧，我们去，如果 

1982
01:15:16,829 --> 01:15:22,360
C是返回上限的小写字母

1983
01:15:20,019 --> 01:15:23,530
如果是大写的， 它的 大写等价物 

1984
01:15:22,360 --> 01:15:24,550
表示存在于当前

1985
01:15:23,530 --> 01:15:25,840
区域设置，只是意味着它 

1986
01:15:24,550 --> 01:15:29,139
标点符号它不会 做任何事情 

1987
01:15:25,840 --> 01:15:31,809
否则它会返回C ，那就是那种 

1988
01:15:29,139 --> 01:15:34,570
如果我将它传递给小写的关键细节 

1989
01:15:31,809 --> 01:15:36,820
它会给我 一个 资本 ，但如果我 

1990
01:15:34,570 --> 01:15:39,880
传递资本A它会给予什么 

1991
01:15:36,820 --> 01:15:41,709
我也是资本a返回原始

1992
01:15:39,880 --> 01:15:43,959
字符C这是我唯一的细节 

1993
01:15:41,709 --> 01:15:45,489
像读书一样怀疑 

1994
01:15:43,959 --> 01:15:47,229
手册， 它可能会 有点 

1995
01:15:45,489 --> 01:15:48,880
神秘而且这就是为什么cs50参考 

1996
01:15:47,229 --> 01:15:50,810
需要一些神秘的文档和 

1997
01:15:48,880 --> 01:15:52,400
试图将其简化 为更加 幽默 

1998
01:15:50,810 --> 01:15:53,930
友好的条款， 但在 一天 结束 时 

1999
01:15:52,400 --> 01:15:55,490
这些是权威的答案和 

2000
01:15:53,930 --> 01:15:57,260
如果我或其中一个工作人员不 知道喜欢 

2001
01:15:55,490 --> 01:15:59,150
我们真的拉起了手册页或 

2002
01:15:57,260 --> 01:16:01,160
cs50参考回答这些 

2003
01:15:59,150 --> 01:16:03,020
现在质疑我的含义是什么 

2004
01:16:01,160 --> 01:16:05,630
不需要任何这个 

2005
01:16:03,020 --> 01:16:08,540
我可以从字面上摆脱这种情况 

2006
01:16:05,630 --> 01:16:11,810
并且让上层做所有的 

2007
01:16:08,540 --> 01:16:13,910
腿部工作，现在我的计划是如此 

2008
01:16:11,810 --> 01:16:15,800
比以前的版本更紧凑

2009
01:16:13,910 --> 01:16:17,360
是因为我已经阅读了文档 

2010
01:16:15,800 --> 01:16:19,370
我知道这个功能做了什么，我能做到 

2011
01:16:17,360 --> 01:16:21,800
让你的大写字母或东西 

2012
01:16:19,370 --> 01:16:23,120
只是将它传递给不变的那样 

2013
01:16:21,800 --> 01:16:24,740
更好的设计，因为我们正在写作

2014
01:16:23,120 --> 01:16:28,610
更少的代码 是一样 

2015
01:16:24,740 --> 01:16:31,610
清楚，所以我们现在可以收紧 

2016
01:16:28,610 --> 01:16:34,880
对此有任何疑问 

2017
01:16:31,610 --> 01:16:36,380
特别的方法可以，所以我们 

2018
01:16:34,880 --> 01:16:38,030
现在让我们 做得 很低 

2019
01:16:36,380 --> 01:16:39,440
这些东西更有用，因为 

2020
01:16:38,030 --> 01:16:41,540
显然其他人已经解决了一些 问题 

2021
01:16:39,440 --> 01:16:43,490
这些问题对我们来说就像拥有这些 

2022
01:16:41,540 --> 01:16:45,350
函数和这些C类型库 

2023
01:16:43,490 --> 01:16:47,960
在字符串库中还有更多内容 

2024
01:16:45,350 --> 01:16:51,290
记得每次我们跑铿锵声 

2025
01:16:47,960 --> 01:16:53,000
甚至运行make我们正在输入多个 

2026
01:16:51,290 --> 01:16:55,970
你在命令提示符下的单词

2027
01:16:53,000 --> 01:16:58,790
打字你好或让马里奥成为第二个 

2028
01:16:55,970 --> 01:17:01,430
或者你正在打字 - 哦，你好 

2029
01:16:58,790 --> 01:17:03,260
你好点看到很多单词 

2030
01:17:01,430 --> 01:17:05,360
提示很好，事实证明这一切 

2031
01:17:03,260 --> 01:17:07,460
你正在使用命令行的时间 

2032
01:17:05,360 --> 01:17:09,590
参数但在C中你可以写

2033
01:17:07,460 --> 01:17:11,840
也接受单词和节目的节目 

2034
01:17:09,590 --> 01:17:14,030
用户运行 程序 时的数字

2035
01:17:11,840 --> 01:17:16,130
毕竟 当你跑马里奥时 回想一下 

2036
01:17:14,030 --> 01:17:17,420
你做点斜线马里奥 输入 你 

2037
01:17:16,130 --> 01:17:19,520
无法再输入任何单词

2038
01:17:17,420 --> 01:17:21,680
提示当你做了点数 你做了 点 

2039
01:17:19,520 --> 01:17:23,750
削减信贷的 进入 没有更多的 话 

2040
01:17:21,680 --> 01:17:25,430
提示您使用了getstring或得到了很长时间 

2041
01:17:23,750 --> 01:17:27,320
得到更多的输入， 但不是在 

2042
01:17:25,430 --> 01:17:30,500
命令行 ，事实证明 我们 

2043
01:17:27,320 --> 01:17:32,720
可以相对简单地在C中，但它是一个 

2044
01:17:30,500 --> 01:17:36,500
乍一看 有点神秘 让我走了 

2045
01:17:32,720 --> 01:17:40,360
前进，让我继续前进 ，在这里拉 

2046
01:17:36,500 --> 01:17:43,010
这个签名看起来像 

2047
01:17:40,360 --> 01:17:45,020
这就是我们所有人的功能 

2048
01:17:43,010 --> 01:17:47,000
用现在写 一个主 

2049
01:17:45,020 --> 01:17:49,250
功能，直到现在我们已经说过了 

2050
01:17:47,000 --> 01:17:51,290
void main不接受任何输入和

2051
01:17:49,250 --> 01:17:53,480
事实上，它只是运行，但事实证明

2052
01:17:51,290 --> 01:17:56,240
你改变现有的程序或 

2053
01:17:53,480 --> 01:17:58,910
未来的计划不是说无效而是为了 

2054
01:17:56,240 --> 01:18:00,920
说int Arg C string Arg V它有点 

2055
01:17:58,910 --> 01:18:04,000
乍一看 很神秘， 但是什么的 

2056
01:18:00,920 --> 01:18:06,640
现在可识别的符号

2057
01:18:04,000 --> 01:18:08,620
是的，这里有括号，所以它转了 

2058
01:18:06,640 --> 01:18:10,690
你每次写一个程序都是这样的 

2059
01:18:08,620 --> 01:18:13,180
如果你不只是说你实际上是无效的 

2060
01:18:10,690 --> 01:18:15,310
通过写作 artsy来启用此功能

2061
01:18:13,180 --> 01:18:17,200
字符串Arg V你 实际上 可以 告诉clang 

2062
01:18:15,310 --> 01:18:19,660
你知道我想要这个程序 

2063
01:18:17,200 --> 01:18:21,640
接受一个或多个单词或数字 

2064
01:18:19,660 --> 01:18:23,680
在程序的名称后，我 可以 

2065
01:18:21,640 --> 01:18:23,980
做点斜线你好 David或点斜线 

2066
01:18:23,680 --> 01:18:25,930
你好

2067
01:18:23,980 --> 01:18:28,000
zamyla 我没有等待 

2068
01:18:25,930 --> 01:18:30,520
要运行 以使用get string的程序 

2069
01:18:28,000 --> 01:18:33,690
就像 前面的 例子一样 

2070
01:18:30,520 --> 01:18:36,700
你可以在哪里 绘制 数组 图表 

2071
01:18:33,690 --> 01:18:38,560
main被定义为采用数组 

2072
01:18:36,700 --> 01:18:40,710
因历史 原因称为Arg V. 

2073
01:18:38,560 --> 01:18:42,700
参数矢量矢量意味着数组 

2074
01:18:40,710 --> 01:18:44,770
参数矢量括号关闭括号 

2075
01:18:42,700 --> 01:18:45,460
只是意味着这包含一个或 

2076
01:18:44,770 --> 01:18:48,010
更多的话 

2077
01:18:45,460 --> 01:18:50,020
它的 每 一个都是字符串Arg C 

2078
01:18:48,010 --> 01:18:51,400
参数计数所以这是变量 

2079
01:18:50,020 --> 01:18:53,590
主要访问权限 告诉它 

2080
01:18:51,400 --> 01:18:57,280
多少个字符串有多少个参数 

2081
01:18:53,590 --> 01:18:58,450
实际上在Arg V 中我们 如何 使用它 

2082
01:18:57,280 --> 01:19:00,670
以一种有用的方式

2083
01:18:58,450 --> 01:19:02,770
好吧，让我继续 前进，开放 

2084
01:19:00,670 --> 01:19:05,400
沙盒，让我继续前进 

2085
01:19:02,770 --> 01:19:09,040
创建一个 名为Arg V zero 的新 文件 

2086
01:19:05,400 --> 01:19:11,230
Arg V零点C再次参数向量 

2087
01:19:09,040 --> 01:19:15,070
只是列表或 参数 数组， 让 

2088
01:19:11,230 --> 01:19:19,270
我继续像往常一样 包括cs50.h 

2089
01:19:15,070 --> 01:19:24,240
包括标准的标准IO点H 

2090
01:19:19,270 --> 01:19:28,120
然后int main不是void而是int Arg C. 

2091
01:19:24,240 --> 01:19:30,250
字符串Arg V 是 V开括号关闭 

2092
01:19:28,120 --> 01:19:31,450
支架甚至 不会 来 

2093
01:19:30,250 --> 01:19:34,570
一开始自然会最终 

2094
01:19:31,450 --> 01:19:40,060
如果数量那么我会这样做的 

2095
01:19:34,570 --> 01:19:42,630
传递的参数等于 两个然后我 

2096
01:19:40,060 --> 01:19:46,840
要继续 做这个 printf你好 

2097
01:19:42,630 --> 01:19:48,490
％s逗号 和过去 

2098
01:19:46,840 --> 01:19:50,380
我现在输入了一个变量名称

2099
01:19:48,490 --> 01:19:53,470
实际上可以访问 变量 go 

2100
01:19:50,380 --> 01:19:55,750
前进，做了V支架 其他人 如果 

2101
01:19:53,470 --> 01:19:57,670
用户显然没有输入两个 

2102
01:19:55,750 --> 01:20:00,070
话让我继续前进 ，只是 

2103
01:19:57,670 --> 01:20:00,460
默认我们总是说你好世界 

2104
01:20:00,070 --> 01:20:04,060
有

2105
01:20:00,460 --> 01:20:05,860
现在为什么这是做什么以及 它 是如何做的 

2106
01:20:04,060 --> 01:20:11,110
做得好 让我们快点运行它 

2107
01:20:05,860 --> 01:20:16,210
使whoops 使我们的V 零点 斜线 

2108
01:20:11,110 --> 01:20:17,620
艺术V 零进入你好世界，但 如果 我这样做 

2109
01:20:16,210 --> 01:20:19,750
你好 

2110
01:20:17,620 --> 01:20:20,950
我们的女儿虹膜离开了程序会 

2111
01:20:19,750 --> 01:20:23,920
如果我们称之为 你好，请 更好地命名 

2112
01:20:20,950 --> 01:20:26,140
但是zamyla 进入 

2113
01:20:23,920 --> 01:20:27,940
你好zamyla，如果我现在改为 大卫 

2114
01:20:26,140 --> 01:20:31,090
如果 我是David Malin，我可以访问 David 

2115
01:20:27,940 --> 01:20:33,370
不，它不支持那么是什么 

2116
01:20:31,090 --> 01:20:34,960
如果你改变任何主要的继续 

2117
01:20:33,370 --> 01:20:38,560
计划或 权利采取这两个 

2118
01:20:34,960 --> 01:20:41,140
参数RC一个类型为string int的Arg V. 

2119
01:20:38,560 --> 01:20:42,310
然后是rxc 告诉 的字符串数组 

2120
01:20:41,140 --> 01:20:44,770
你输入了多少单词 

2121
01:20:42,310 --> 01:20:46,720
提示所以，如果人类输入两个字 我 

2122
01:20:44,770 --> 01:20:49,210
假设第一个字的 名字 

2123
01:20:46,720 --> 01:20:51,610
程序点斜杠argv 归零 

2124
01:20:49,210 --> 01:20:52,900
第二个词可能是我的名字，如果 他 

2125
01:20:51,610 --> 01:20:55,030
或者她实际上提供了他们的名字 

2126
01:20:52,900 --> 01:20:57,280
在提示符，所以我打印出 组织V 

2127
01:20:55,030 --> 01:20:59,080
括号1不是0， 因为这 是名称 

2128
01:20:57,280 --> 01:21:01,330
该程序但 RV支架 1其他 

2129
01:20:59,080 --> 01:21:03,550
如果人类 没有提供，请到这里

2130
01:21:01,330 --> 01:21:05,020
只是zamyla 或只是 大卫或只是一个 

2131
01:21:03,550 --> 01:21:08,260
一般来说， 我只是打印出来的 

2132
01:21:05,020 --> 01:21:13,150
默认你好世界， 但什么是整洁的 

2133
01:21:08,260 --> 01:21:19,030
关于这一点现在注意到 RV是一个 

2134
01:21:13,150 --> 01:21:21,280
字符串数组是什么字符串 

2135
01:21:19,030 --> 01:21:23,260
一个字符数组， 所以让我们 

2136
01:21:21,280 --> 01:21:25,300
介绍最后一段语法 

2137
01:21:23,260 --> 01:21:29,560
在 这里 得到一些强大的 让我 走了 

2138
01:21:25,300 --> 01:21:34,390
继续做这让我继续前进， 在 

2139
01:21:29,560 --> 01:21:36,640
这里有一个新文件是V 1 点C让我走 

2140
01:21:34,390 --> 01:21:39,580
提前并粘贴此关闭 

2141
01:21:36,640 --> 01:21:43,080
我继续这样做，而不是做 

2142
01:21:39,580 --> 01:21:49,930
这个逻辑检查让我这样做 

2143
01:21:43,080 --> 01:21:52,690
让我们说int 我得0 我不到 

2144
01:21:49,930 --> 01:21:55,240
argh CI加上让我们继续吧 

2145
01:21:52,690 --> 01:21:57,370
每行一个打印出来的每个 单词 

2146
01:21:55,240 --> 01:21:59,710
人类只是打字加强 

2147
01:21:57,370 --> 01:22:04,420
这 确实是正在发生的事情 

2148
01:21:59,710 --> 01:22:06,880
RV支架0 保存使 RV 0对不起 RV 1 

2149
01:22:04,420 --> 01:22:10,540
进入，现在让我们继续前进吧 

2150
01:22:06,880 --> 01:22:15,250
这个程序点斜线argv 1 大卫 

2151
01:22:10,540 --> 01:22:17,440
malan好的， 如果我们， 你会看到这 三个字 

2152
01:22:15,250 --> 01:22:18,910
将它改为zamyla 我们 只 看到 那些 

2153
01:22:17,440 --> 01:22:21,250
如果我们把它改成zamyla陈，那两个词

2154
01:22:18,910 --> 01:22:22,990
我们 清楚地看到这三个字

2155
01:22:21,250 --> 01:22:24,460
访问所有的 的话 

2156
01:22:22,990 --> 01:22:26,980
数组，但让我们迈出这 一步 

2157
01:22:24,460 --> 01:22:28,690
而不是 仅打印出每一个 

2158
01:22:26,980 --> 01:22:31,150
字符串中的单词让我们继续前进 

2159
01:22:28,690 --> 01:22:35,020
这适用于int J. 

2160
01:22:31,150 --> 01:22:42,219
零n等于的字符串长度 

2161
01:22:35,020 --> 01:22:45,159
这样 Ĵ 当前参数 是以下 

2162
01:22:42,219 --> 01:22:47,320
比n j + +呐喊呐喊呐加j 

2163
01:22:45,159 --> 01:22:49,870
加上现在让我继续 打印 出来 

2164
01:22:47,320 --> 01:22:51,630
不是完整的字符串，但让我做鞭子

2165
01:22:49,870 --> 01:22:55,920
假设让我继续 打印出来 

2166
01:22:51,630 --> 01:23:01,300
这不是一个字符串，但在性格

2167
01:22:55,920 --> 01:23:03,760
托架我括 Ĵ这样 好吗 所以 

2168
01:23:01,300 --> 01:23:06,969
这个外 循环 发生了什么？ 

2169
01:23:03,760 --> 01:23:10,060
让我们评论它迭代字符串 

2170
01:23:06,969 --> 01:23:13,900
argh v这个内循环 遍历 

2171
01:23:10,060 --> 01:23:16,780
在argh v括号中 我的外表 

2172
01:23:13,900 --> 01:23:18,940
循环遍历所有字符串 

2173
01:23:16,780 --> 01:23:20,790
哎呀 v和使用内循环 

2174
01:23:18,940 --> 01:23:23,500
从 0 开始的不同变量

2175
01:23:20,790 --> 01:23:26,830
迭代中的所有字符 

2176
01:23:23,500 --> 01:23:29,080
第八个参数本身就是一个字符串 

2177
01:23:26,830 --> 01:23:31,090
所以我们可以在它上面调用字符串长度 

2178
01:23:29,080 --> 01:23:32,350
然后我们这样做，直到n为 

2179
01:23:31,090 --> 01:23:34,090
该字符串的长度， 然后我们打印 

2180
01:23:32,350 --> 01:23:38,290
出每个角色， 以便清楚 

2181
01:23:34,090 --> 01:23:40,210
当我运行Arg V 1并更正它时 

2182
01:23:38,290 --> 01:23:41,800
乍看之下，这是隐含的 

2183
01:23:40,210 --> 01:23:43,120
声明库函数斯特林 

2184
01:23:41,800 --> 01:23:46,929
什么是无往不利的解决方案时， 

2185
01:23:43,120 --> 01:23:50,020
你做错了是的所以我忘了这个 

2186
01:23:46,929 --> 01:23:51,130
所以包括字符串点H 和帮助 50 

2187
01:23:50,020 --> 01:23:53,710
也会帮助我们 

2188
01:23:51,130 --> 01:23:58,120
重新编译将使我们的节拍1 好 

2189
01:23:53,710 --> 01:24:03,390
当我运行我们的Z 1说zamyla一些 

2190
01:23:58,120 --> 01:24:07,630
nyla Chan我会看到什么 

2191
01:24:03,390 --> 01:24:12,340
是我正确的直觉 

2192
01:24:07,630 --> 01:24:14,050
看到一些鸡眼 陈但一个角色 

2193
01:24:12,340 --> 01:24:15,699
包括程序在内的每一行 

2194
01:24:14,050 --> 01:24:18,040
这个名字实际上让我这样滚动它 

2195
01:24:15,699 --> 01:24:20,620
这是一个更大的 输入 好吧它是一个 

2196
01:24:18,040 --> 01:24:23,409
程序有点愚蠢， 但确实如此 

2197
01:24:20,620 --> 01:24:25,330
我确认使用 数组 

2198
01:24:23,409 --> 01:24:26,860
不仅可以访问单词，还 可以访问 

2199
01:24:25,330 --> 01:24:28,690
有第二个维度和 

2200
01:24:26,860 --> 01:24:31,870
在每个单词中， 我可以得到每个单词

2201
01:24:28,690 --> 01:24:34,540
内在的角色，我们 再次 这样做 

2202
01:24:31,870 --> 01:24:36,460
只是使用不仅仅是单个方块 

2203
01:24:34,540 --> 01:24:38,440
括号但是加倍并且再次突破 

2204
01:24:36,460 --> 01:24:39,880
这归结为第一原则是什么 

2205
01:24:38,440 --> 01:24:41,860
这 是第一个支架， 这 是 第八个 

2206
01:24:39,880 --> 01:24:43,840
参数中的冰串和 

2207
01:24:41,860 --> 01:24:44,910
然后如果你用支架进一步 

2208
01:24:43,840 --> 01:24:48,630
J给你的 

2209
01:24:44,910 --> 01:24:50,520
杰夫人物 里面的这个现在谁 

2210
01:24:48,630 --> 01:24:52,260
关心任何这种 

2211
01:24:50,520 --> 01:24:55,050
功能很好让我回滚 

2212
01:24:52,260 --> 01:24:57,480
并在此提出一个申请 

2213
01:24:55,050 --> 01:24:59,250
回想起CS真的很公正 

2214
01:24:57,480 --> 01:25:00,210
解决问题但 提出问题 

2215
01:24:59,250 --> 01:25:02,400
你要解决的就是 喜欢 

2216
01:25:00,210 --> 01:25:04,410
实际上在课堂上传递一条秘密信息 

2217
01:25:02,400 --> 01:25:06,300
无论如何都要向某人发送秘密 

2218
01:25:04,410 --> 01:25:07,860
很好地说，这个 问题 的输入 是 

2219
01:25:06,300 --> 01:25:09,480
通常称为纯 文本 消息 

2220
01:25:07,860 --> 01:25:11,820
你想发送 给那 个人 

2221
01:25:09,480 --> 01:25:14,520
你理想地希望密文 出现 

2222
01:25:11,820 --> 01:25:16,140
从它的密码扰乱它 

2223
01:25:14,520 --> 01:25:17,880
以某种方式加密信息， 以便 

2224
01:25:16,140 --> 01:25:20,040
房间里的任何人都像老师一样 

2225
01:25:17,880 --> 01:25:21,390
不能只抓住节点并阅读什么 

2226
01:25:20,040 --> 01:25:22,950
你发送给你的 秘密暗恋 它 

2227
01:25:21,390 --> 01:25:25,140
整个房间或其他任何地方 

2228
01:25:22,950 --> 01:25:26,670
上下文也是如此，但问题 在于 

2229
01:25:25,140 --> 01:25:28,620
如果您要发送的消息 是 

2230
01:25:26,670 --> 01:25:29,310
我们的老朋友高兴地感叹道 

2231
01:25:28,620 --> 01:25:31,800
点

2232
01:25:29,310 --> 01:25:35,280
你可以在 某些情况下 编码它 

2233
01:25:31,800 --> 01:25:36,780
因为只有72 73 33而且我敢说最多 

2234
01:25:35,280 --> 01:25:39,300
校园里的课程， 如果你写的 

2235
01:25:36,780 --> 01:25:40,530
一张纸72 73 33通过它 

2236
01:25:39,300 --> 01:25:42,090
通过房间和 任何教授 

2237
01:25:40,530 --> 01:25:43,920
拦截它他们不会 知道 

2238
01:25:42,090 --> 01:25:46,080
不管你怎么说，但是这是

2239
01:25:43,920 --> 01:25:51,150
这不是一个好的系统， 这 不是一个加密 

2240
01:25:46,080 --> 01:25:56,970
系统为什么它不安全你是什么

2241
01:25:51,150 --> 01:25:58,380
想是的，任何人都可以访问这个

2242
01:25:56,970 --> 01:26:01,020
只要 你像周 一样 参加，那就对了 

2243
01:25:58,380 --> 01:26:03,060
一个或 CS50的 零 或者你只是 有 

2244
01:26:01,020 --> 01:26:05,550
有这样一个滑雪 一般熟悉 

2245
01:26:03,060 --> 01:26:07,560
这不是一个 我只是代码的代码 

2246
01:26:05,550 --> 01:26:09,630
滑雪是一个 地图 和 系统 

2247
01:26:07,560 --> 01:26:11,160
写给数字的信和其他任何人 

2248
01:26:09,630 --> 01:26:12,270
知道这段代码显然知道什么 

2249
01:26:11,160 --> 01:26:14,370
你的信息是因为它不是 

2250
01:26:12,270 --> 01:26:16,050
您和收件人的独特秘诀

2251
01:26:14,370 --> 01:26:17,400
所以这 可能不是最好的主意 

2252
01:26:16,050 --> 01:26:19,560
那么你可以 多 一点 

2253
01:26:17,400 --> 01:26:21,570
复杂，这实际上是回来了 

2254
01:26:19,560 --> 01:26:23,130
从二战时期 一个 照片 

2255
01:26:21,570 --> 01:26:25,890
这是 从德国发送 到消息

2256
01:26:23,130 --> 01:26:27,780
墨西哥的编码非常相似 

2257
01:26:25,890 --> 01:26:29,370
方式是没有 使用ASCII数字作为 

2258
01:26:27,780 --> 01:26:31,560
你也许可以从 照片 中 收集到 

2259
01:26:29,370 --> 01:26:33,180
实际上要大得多，但在这个系统中 

2260
01:26:31,560 --> 01:26:35,730
在军国主义的背景下，有一个 

2261
01:26:33,180 --> 01:26:36,900
代码簿 在精神上与ASCII相似 

2262
01:26:35,730 --> 01:26:39,270
你喜欢一列数字的地方 

2263
01:26:36,900 --> 01:26:41,490
和他们的一列信件 

2264
01:26:39,270 --> 01:26:43,830
对应一个更一般的码本

2265
01:26:41,490 --> 01:26:45,630
喜欢数字，然后甚至可能是字母 

2266
01:26:43,830 --> 01:26:47,370
或者他们对应的整个词

2267
01:26:45,630 --> 01:26:50,550
有时成千上万的人喜欢

2268
01:26:47,370 --> 01:26:52,500
字面上是一本非常大的代码和书

2269
01:26:50,550 --> 01:26:54,840
只要只在此范围 内 

2270
01:26:52,500 --> 01:26:57,480
德国人和 墨西哥人的接受者 

2271
01:26:54,840 --> 01:26:59,400
曾获得 同样的书只有 他们 

2272
01:26:57,480 --> 01:27:01,770
可以加密和解密或更确切地说

2273
01:26:59,400 --> 01:27:03,780
当然，编码和解码信息 

2274
01:27:01,770 --> 01:27:05,010
在这个非常具体的背景下和你一起 

2275
01:27:03,780 --> 01:27:07,320
可以在历史中阅读更多相关信息 

2276
01:27:05,010 --> 01:27:09,090
文本这是截获此消息 

2277
01:27:07,320 --> 01:27:10,740
虽然肯定是看似无害的

2278
01:27:09,090 --> 01:27:13,410
所有 这些 都是可疑的 

2279
01:27:10,740 --> 01:27:15,810
因此数量不是无害的 

2280
01:27:13,410 --> 01:27:17,610
它是 英国在这种情况下， 

2281
01:27:15,810 --> 01:27:20,340
实际上拦截了它并感谢 a 

2282
01:27:17,610 --> 01:27:22,440
很多的 努力，加密分析 

2283
01:27:20,340 --> 01:27:24,750
布莱切利公园风格代码 破碎 

2284
01:27:22,440 --> 01:27:25,920
虽然他们能够进一步回来

2285
01:27:24,750 --> 01:27:28,830
找出那些数字 

2286
01:27:25,920 --> 01:27:31,080
用文字表示并实际解码 

2287
01:27:28,830 --> 01:27:32,430
这样的消息，事实上这是一个 

2288
01:27:31,080 --> 01:27:34,470
一些词的照片

2289
01:27:32,430 --> 01:27:37,380
从一个 翻译 成另一个 

2290
01:27:34,470 --> 01:27:39,510
但更多的是 在任何在线或 

2291
01:27:37,380 --> 01:27:41,760
文本参考文献在这里 

2292
01:27:39,510 --> 01:27:43,740
诗也 有 类似的代码权利 

2293
01:27:41,760 --> 01:27:45,750
在波士顿购买的小偷坡 

2294
01:27:43,740 --> 01:27:47,640
在这里你可能还记得这个听我的

2295
01:27:45,750 --> 01:27:50,040
孩子们，你们应该听到了

2296
01:27:47,640 --> 01:27:52,560
保罗·里维尔的午夜乘坐18号 

2297
01:27:50,040 --> 01:27:54,510
在75年4月，现在几乎没有男人活着

2298
01:27:52,560 --> 01:27:56,970
谁记得那个着名的日子和年份 

2299
01:27:54,510 --> 01:27:59,280
他 对英国的 朋友说 

2300
01:27:56,970 --> 01:28:01,590
从镇上陆地或海上游行

2301
01:27:59,280 --> 01:28:04,050
今晚挂灯笼在高处 

2302
01:28:01,590 --> 01:28:04,560
北教堂塔楼为钟楼牌坊

2303
01:28:04,050 --> 01:28:07,620
生病了 

2304
01:28:04,560 --> 01:28:08,100
如果土地 哦 光一和 二如果 

2305
01:28:07,620 --> 01:28:09,900
海

2306
01:28:08,100 --> 01:28:11,250
而我在对岸 会 

2307
01:28:09,900 --> 01:28:12,780
准备好骑行并传播警报

2308
01:28:11,250 --> 01:28:14,790
虽然每个米德尔塞克斯村庄和农场

2309
01:28:12,780 --> 01:28:16,500
为乡村民众提供 两个 

2310
01:28:14,790 --> 01:28:18,240
武装，使其显示出一些 是 

2311
01:28:16,500 --> 01:28:19,910
实际上并不正确，但是 

2312
01:28:18,240 --> 01:28:23,070
一个如果是陆地，两个如果是海上

2313
01:28:19,910 --> 01:28:24,720
代码是一个 例子 

2314
01:28:23,070 --> 01:28:26,330
一次性代码，因为如果 

2315
01:28:24,720 --> 01:28:28,740
革命者和美国人 

2316
01:28:26,330 --> 01:28:30,780
革命有种秘密决定 

2317
01:28:28,740 --> 01:28:32,580
他们之间的字面意思是我们会 

2318
01:28:30,780 --> 01:28:34,680
在 教堂 的 顶部 竖起一盏灯 

2319
01:28:32,580 --> 01:28:36,690
如果 英国人 来购买土地 

2320
01:28:34,680 --> 01:28:38,250
如果是 ，我们将使用两个 

2321
01:28:36,690 --> 01:28:39,960
而英国人则喜欢在海边出现 

2322
01:28:38,250 --> 01:28:41,370
这是一个代码， 你可以写它 

2323
01:28:39,960 --> 01:28:43,350
在书中，因此你有一个 代码 

2324
01:28:41,370 --> 01:28:45,750
书， 但当然一个人 

2325
01:28:43,350 --> 01:28:47,610
弄清楚 这种模式是否妥协 

2326
01:28:45,750 --> 01:28:50,880
所以代码书往往不是 

2327
01:28:47,610 --> 01:28:53,430
最强大的编码机制 

2328
01:28:50,880 --> 01:28:55,320
信息而不是最好使用 

2329
01:28:53,430 --> 01:28:56,850
更多的算法和算法 

2330
01:28:55,320 --> 01:28:59,130
计算机科学就是这样 

2331
01:28:56,850 --> 01:29:02,100
我们一直在说黑匣子的家

2332
01:28:59,130 --> 01:29:04,530
算法和一般加密是 

2333
01:29:02,100 --> 01:29:06,960
输入和输出的问题，但我们 

2334
01:29:04,530 --> 01:29:08,460
只需 输入一个输入就可以了 

2335
01:29:06,960 --> 01:29:11,040
twich一般称为键或a 

2336
01:29:08,460 --> 01:29:13,830
秘密和秘密可能只是一个 

2337
01:29:11,040 --> 01:29:15,210
例如，如果我想要我的话 

2338
01:29:13,830 --> 01:29:16,500
秘密是一个因为我们会保持 

2339
01:29:15,210 --> 01:29:18,300
例如简单但它确实可以 

2340
01:29:16,500 --> 01:29:19,620
任何数字，实际上我们看到了

2341
01:29:18,300 --> 01:29:21,000
刚才德国人用的照片

2342
01:29:19,620 --> 01:29:22,650
比这大得多， 我会把它放进去 

2343
01:29:21,000 --> 01:29:24,690
码的情况下，现在 假设 你 

2344
01:29:22,650 --> 01:29:26,280
想要发送更多私信 

2345
01:29:24,690 --> 01:29:28,650
房间里 有人 和 一个班级 

2346
01:29:26,280 --> 01:29:31,050
我爱你，你怎么去编码 

2347
01:29:28,650 --> 01:29:32,580
这种方式不仅仅是使用 

2348
01:29:31,050 --> 01:29:34,650
ASCII 并不只是 使用一些简单的 

2349
01:29:32,580 --> 01:29:36,870
代码簿，让 我 现在 提出 

2350
01:29:34,650 --> 01:29:38,460
我们理解字符串是怎样的 

2351
01:29:36,870 --> 01:29:42,090
代表我们即将 要做的 

2352
01:29:38,460 --> 01:29:43,970
爱现在真的很蹩脚和 怪异 

2353
01:29:42,090 --> 01:29:46,260
你 知道如何表达字符串 

2354
01:29:43,970 --> 01:29:49,830
计算好，让我们开始吧 

2355
01:29:46,260 --> 01:29:53,370
代表我用ASCII爱你， 所以我73 

2356
01:29:49,830 --> 01:29:55,020
L是76 OVe ey o 你就是ascii 

2357
01:29:53,370 --> 01:29:56,850
不应该这样发送，因为 

2358
01:29:55,020 --> 01:29:58,980
任何知道ascii的人都会 坐下来 

2359
01:29:56,850 --> 01:30:00,810
要知道你在说什么， 但是 什么 

2360
01:29:58,980 --> 01:30:03,120
如果我加密了这个消息我 

2361
01:30:00,810 --> 01:30:04,830
对它及其执行算法

2362
01:30:03,120 --> 01:30:07,140
最简单的发送算法就可以了 

2363
01:30:04,830 --> 01:30:08,910
正如我们所见，数学简单算术 

2364
01:30:07,140 --> 01:30:11,370
你知道让我 用我的秘密 密钥 

2365
01:30:08,910 --> 01:30:14,580
一个，让我确保 我的我的 

2366
01:30:11,370 --> 01:30:16,770
我喜欢知道 我 正在使用一个秘密 

2367
01:30:14,580 --> 01:30:18,420
一个人的价值，所以他或 她也知道 

2368
01:30:16,770 --> 01:30:20,520
期待价值和 

2369
01:30:18,420 --> 01:30:24,270
我发送消息我要加一个 

2370
01:30:20,520 --> 01:30:30,390
到每一个字母， 所以73变成74 76 

2371
01:30:24,270 --> 01:30:32,580
现在变成了77 80 80 77090 8086 

2372
01:30:30,390 --> 01:30:35,010
可以只是明确地发送，然后 

2373
01:30:32,580 --> 01:30:36,570
我实际上可以将它作为文本发送

2374
01:30:35,010 --> 01:30:43,440
消息所以让我们把它转换回来 

2375
01:30:36,570 --> 01:30:45,840
ASCII 74现在是J 77，现在是M 80 

2376
01:30:43,440 --> 01:30:49,200
P，你也许可以看到模式 

2377
01:30:45,840 --> 01:30:53,100
这个消息是我爱你，现在 所有人 

2378
01:30:49,200 --> 01:30:57,450
我想我 的 字母是一个字母 

2379
01:30:53,100 --> 01:30:59,190
成了JL成了M 哦成了 P等 

2380
01:30:57,450 --> 01:31:01,200
所以现在声称是 

2381
01:30:59,190 --> 01:31:03,840
加密 我会发送这个 

2382
01:31:01,200 --> 01:31:05,160
整个房间的消息，现在没有人 

2383
01:31:03,840 --> 01:31:06,480
谁喜欢一个码本就可以了 

2384
01:31:05,160 --> 01:31:08,160
解决这个问题我不能只是偷了 

2385
01:31:06,480 --> 01:31:10,440
预订和解码它， 因为现在的关键 

2386
01:31:08,160 --> 01:31:12,420
就像只在这里这样说而已 

2387
01:31:10,440 --> 01:31:14,190
只是他或 她和我的头号人物 

2388
01:31:12,420 --> 01:31:15,360
必须事先就我们 达成一致意见 

2389
01:31:14,190 --> 01:31:18,420
会用来发送我们的秘密 

2390
01:31:15,360 --> 01:31:20,150
消息所以如果有人捕获了这个消息

2391
01:31:18,420 --> 01:31:22,770
消息老师在房间里或谁 

2392
01:31:20,150 --> 01:31:26,880
他们怎么会 去解码 

2393
01:31:22,770 --> 01:31:30,570
这个或解密它是有的 

2394
01:31:26,880 --> 01:31:32,220
我敢说他们可以使用的技术 

2395
01:31:30,570 --> 01:31:33,020
我们可以为这种爱而消磨 

2396
01:31:32,220 --> 01:31:35,370
注意

2397
01:31:33,020 --> 01:31:36,750
什么是检查，我们可以 

2398
01:31:35,370 --> 01:31:38,730
尝试所有的锅 有那么 一些 

2399
01:31:36,750 --> 01:31:40,860
间距，所以你老实说我们可以做到

2400
01:31:38,730 --> 01:31:43,110
就像 它的一种密码 分析 一样 

2401
01:31:40,860 --> 01:31:44,580
像我想不到的频率攻击 

2402
01:31:43,110 --> 01:31:46,350
英语中 有太多的单词 

2403
01:31:44,580 --> 01:31:49,500
在他们的单个字母 ，所以什么是J 

2404
01:31:46,350 --> 01:31:51,660
可能代表我可能 是一个 

2405
01:31:49,500 --> 01:31:53,670
但可能我和那里并没有 太多 

2406
01:31:51,660 --> 01:31:56,040
其他选择， 所以我们攻击的地方 

2407
01:31:53,670 --> 01:32:00,120
消息的一部分我 已经 看到了 

2408
01:31:56,040 --> 01:32:01,830
共性有两个在这里 2p 

2409
01:32:00,120 --> 01:32:03,930
而且我不一定知道那一点 

2410
01:32:01,830 --> 01:32:06,570
映射到 O，但我知道它是相同的 

2411
01:32:03,930 --> 01:32:08,760
如果我继续这个，那么这个角色

2412
01:32:06,570 --> 01:32:10,770
周到的过程 或这个试验和 

2413
01:32:08,760 --> 01:32:12,600
错误，我弄清楚如果那是一个 

2414
01:32:10,770 --> 01:32:14,100
O 然后那是O然后等一下 

2415
01:32:12,600 --> 01:32:15,510
他们从一个人那里知道了 

2416
01:32:14,100 --> 01:32:16,800
对另一个可能说我爱你 

2417
01:32:15,510 --> 01:32:20,340
就像你 实际上可以与一些 

2418
01:32:16,800 --> 01:32:21,900
概率通过 执行来解密消息

2419
01:32:20,340 --> 01:32:23,160
它就是这样的分析 

2420
01:32:21,900 --> 01:32:24,720
比密码本 更安全 

2421
01:32:23,160 --> 01:32:26,340
因为如果你没有妥协的话

2422
01:32:24,720 --> 01:32:28,770
书本身被盗，你可以改变 

2423
01:32:26,340 --> 01:32:29,940
每 一次 的关键 ， 只要你和 

2424
01:32:28,770 --> 01:32:31,890
收件人实际上同意

2425
01:32:29,940 --> 01:32:34,290
什么， 但 至少我们 

2426
01:32:31,890 --> 01:32:35,880
有这个机制， 所以 

2427
01:32:34,290 --> 01:32:37,950
只是了解 你能做什么 

2428
01:32:35,880 --> 01:32:39,300
用字符串做你真的知道吗 

2429
01:32:37,950 --> 01:32:41,460
非常有趣的域特定 

2430
01:32:39,300 --> 01:32:43,830
他们的 事情 ，事实上回到了 他们身上 

2431
01:32:41,460 --> 01:32:45,360
天凯撒

2432
01:32:43,830 --> 01:32:47,460
回到军国主义时代

2433
01:32:45,360 --> 01:32:49,230
字面上使用了一个非常类似的密码 

2434
01:32:47,460 --> 01:32:51,090
当你 坦白 的第一个 

2435
01:32:49,230 --> 01:32:52,290
使用这些密码，他们实际上是 善良的 

2436
01:32:51,090 --> 01:32:53,940
即使他们是相对的，也是安全的

2437
01:32:52,290 --> 01:32:57,360
简单， 但希望不 只是使用 

2438
01:32:53,940 --> 01:32:59,580
密钥1可能是2或13或25或 

2439
01:32:57,360 --> 01:33:02,970
更大的东西， 但这是一个例子 

2440
01:32:59,580 --> 01:33:04,380
替换密码或旋转 

2441
01:33:02,970 --> 01:33:06,780
加密器我们就像一切的那种 

2442
01:33:04,380 --> 01:33:09,600
旋转a正在变成蜜蜂成为 

2443
01:33:06,780 --> 01:33:12,150
si或你 甚至 可以 旋转它 

2444
01:33:09,600 --> 01:33:15,360
更进一步， 让我们来看看 

2445
01:33:12,150 --> 01:33:17,790
在这里的最后一个例子只有 一个 

2446
01:33:15,360 --> 01:33:19,620
今天一个特征的另一个最终原语

2447
01:33:17,790 --> 01:33:21,900
然后我们 才回到高位 

2448
01:33:19,620 --> 01:33:24,150
事实证明 ， 所有事情都归于一致 

2449
01:33:21,900 --> 01:33:26,190
打印出错误消息不是

2450
01:33:24,150 --> 01:33:29,070
发出信号的唯一方法 

2451
01:33:26,190 --> 01:33:31,410
出了问题， 有一个新的关键词 a 

2452
01:33:29,070 --> 01:33:33,480
在此使用旧关键字 

2453
01:33:31,410 --> 01:33:35,130
这个例子实际上就是惯例 

2454
01:33:33,480 --> 01:33:37,800
信号错误所以这是一个例子 

2455
01:33:35,130 --> 01:33:39,840
它 显然想要 退出点 C 

2456
01:33:37,800 --> 01:33:44,370
如果你从中推断，人类会做什么

2457
01:33:39,840 --> 01:33:47,550
代码是的

2458
01:33:44,370 --> 01:33:49,320
很好的是 什么是不想要的 

2459
01:33:47,550 --> 01:33:50,630
人类在隐含的基础上做

2460
01:33:49,320 --> 01:33:56,000
printf 先知 

2461
01:33:50,630 --> 01:33:56,000
我应该怎么运行这个程序 啊 

2462
01:33:57,239 --> 01:34:02,070
是的，无论出于何种 原因这个节目 

2463
01:33:59,659 --> 01:34:04,440
隐含地要我准确提供 

2464
01:34:02,070 --> 01:34:05,940
提示时有两个字， 因为 如果我 

2465
01:34:04,440 --> 01:34:07,260
不要因为我失踪而大喊大叫 

2466
01:34:05,940 --> 01:34:08,760
命令行参数，然后是它

2467
01:34:07,260 --> 01:34:10,230
无论那是什么，都会回归

2468
01:34:08,760 --> 01:34:12,210
否则它会打招呼 

2469
01:34:10,230 --> 01:34:15,239
如果我实际 运行这个 ， 那么这样的话 

2470
01:34:12,210 --> 01:34:19,019
程序让我回到这里做 

2471
01:34:15,239 --> 01:34:22,710
在我的目录中make exit who 

2472
01:34:19,019 --> 01:34:24,300
退出okay dot slash exit进入 我 

2473
01:34:22,710 --> 01:34:25,590
缺少命令行参数all 

2474
01:34:24,300 --> 01:34:27,989
对，让我说一些ayahs的名字 

2475
01:34:25,590 --> 01:34:29,909
哦，你好zamyla让我放一些其他的 

2476
01:34:27,989 --> 01:34:32,489
陈没有丢失命令行参数吧

2477
01:34:29,909 --> 01:34:35,249
在这种情况下，只想要那个

2478
01:34:32,489 --> 01:34:36,900
但事实证明我在视觉上看到了 

2479
01:34:35,249 --> 01:34:39,719
错误消息， 但结果是 

2480
01:34:36,900 --> 01:34:42,630
电脑也向我发出了什么信号 

2481
01:34:39,719 --> 01:34:44,429
所谓的退出代码是如此长的故事 

2482
01:34:42,630 --> 01:34:45,539
总之，我们已经看到了最后的例子 

2483
01:34:44,429 --> 01:34:47,760
如何拥有一个功能的一周 

2484
01:34:45,539 --> 01:34:49,199
价值回归，我们看到了亚伦 

2485
01:34:47,760 --> 01:34:51,059
走上舞台， 她回到我身边 

2486
01:34:49,199 --> 01:34:52,380
一张纸，上面有一根绳子， 但是 

2487
01:34:51,059 --> 01:34:52,949
事实证明，主要是一点点 

2488
01:34:52,380 --> 01:34:58,079
特别 

2489
01:34:52,949 --> 01:35:00,360
如果main返回一个像1 或0的值你 

2490
01:34:58,079 --> 01:35:04,019
实际上可以看到虽然是一种

2491
01:35:00,360 --> 01:35:06,659
如果我运行退出和我 ，一个非显而易见的方式 

2492
01:35:04,019 --> 01:35:10,139
用zamyla 作为名称正确运行它

2493
01:35:06,659 --> 01:35:12,869
如果我然后输入echo美元符号问题 

2494
01:35:10,139 --> 01:35:15,239
所有事物的标记进入后我会 看到 

2495
01:35:12,869 --> 01:35:17,159
究竟是什么主要归还了哪个 

2496
01:35:15,239 --> 01:35:20,550
这个案子现在是0让我 试试 吧 

2497
01:35:17,159 --> 01:35:23,460
不合作，如果我实际上 只 运行 点 

2498
01:35:20,550 --> 01:35:25,619
斜线退出没有字

2499
01:35:23,460 --> 01:35:27,929
我看到缺少命令行参数但是 

2500
01:35:25,619 --> 01:35:29,880
如果我做同样的神秘命令回声 

2501
01:35:27,929 --> 01:35:31,980
美元符号问号我看到了 

2502
01:35:29,880 --> 01:35:33,599
主要退出一个 现在为什么这样 

2503
01:35:31,980 --> 01:35:36,239
很有用， 因为我们开始写更多 

2504
01:35:33,599 --> 01:35:39,059
使用更复杂的程序 

2505
01:35:36,239 --> 01:35:41,789
成为退出 主要的惯例

2506
01:35:39,059 --> 01:35:43,679
如果有的话，返回非零值 

2507
01:35:41,789 --> 01:35:45,900
出错了0恰好意味着一切 

2508
01:35:43,679 --> 01:35:47,820
事实上，所有的事情都 进展 顺利 

2509
01:35:45,900 --> 01:35:50,429
程序是我们迄今为止写的，如果你 

2510
01:35:47,820 --> 01:35:52,559
不要提回任何主要的东西

2511
01:35:50,429 --> 01:35:55,110
自动和自动自动 

2512
01:35:52,559 --> 01:35:56,400
为你返回0，它已经全部 

2513
01:35:55,110 --> 01:35:57,780
这次它只是一个功能所以你 

2514
01:35:56,400 --> 01:35:59,610
不必费心自己打字 

2515
01:35:57,780 --> 01:36:01,889
但是这个或者什么是好的 

2516
01:35:59,610 --> 01:36:03,599
真实的是，如果你的 Mac或 PC 

2517
01:36:01,889 --> 01:36:05,639
如果你曾经变得 像个烦人的话 

2518
01:36:03,599 --> 01:36:08,489
错误消息，表示 错误消极 

2519
01:36:05,639 --> 01:36:10,019
29你知道发生了系统错误或 

2520
01:36:08,489 --> 01:36:11,160
一些东西冻结但你常常 看到 

2521
01:36:10,019 --> 01:36:13,770
屏幕上的数字

2522
01:36:11,160 --> 01:36:15,780
也许像那些真正的错误代码

2523
01:36:13,770 --> 01:36:17,370
倾向于映射到这些类型的 值 

2524
01:36:15,780 --> 01:36:19,050
当人类正在编写软件时 

2525
01:36:17,370 --> 01:36:21,360
出错了，出错了 

2526
01:36:19,050 --> 01:36:23,490
他们通常会返回一个 值 

2527
01:36:21,360 --> 01:36:25,080
像这样和计算机访问 

2528
01:36:23,490 --> 01:36:26,520
它并没有那么有用 

2529
01:36:25,080 --> 01:36:28,620
人类在运行程序但是作为 

2530
01:36:26,520 --> 01:36:30,750
我们会看到你的程序变得更复杂 

2531
01:36:28,620 --> 01:36:33,180
这 其实 是 一个 非常有用的 

2532
01:36:30,750 --> 01:36:37,050
确实发出信号的方式

2533
01:36:33,180 --> 01:36:41,730
出错了没关系，这是很多 语法 

2534
01:36:37,050 --> 01:36:43,290
包裹在一些爱心方面 的任何 

2535
01:36:41,730 --> 01:36:45,630
在我们看一场 决赛 之前的问题

2536
01:36:43,290 --> 01:36:49,020
域名号 

2537
01:36:45,630 --> 01:36:51,450
好吧，事实证明我们可以 

2538
01:36:49,020 --> 01:36:54,990
回答谁关心的问题呢 

2539
01:36:51,450 --> 01:36:58,080
另一种方式 - 结果让我 走了 

2540
01:36:54,990 --> 01:37:00,750
进取，不断开拓的例子 我们 

2541
01:36:58,080 --> 01:37:02,580
数组可以在这里重新排列数组 

2542
01:37:00,750 --> 01:37:04,320
实际上现在用来解决问题 

2543
01:37:02,580 --> 01:37:05,700
更算法，这是在哪里 

2544
01:37:04,320 --> 01:37:07,440
生活变得像我们一样有趣

2545
01:37:05,700 --> 01:37:08,880
如此令人难以置信的今天的杂草和 

2546
01:37:07,440 --> 01:37:10,290
我们在课堂上 向前迈进 ，我们 不是 

2547
01:37:08,880 --> 01:37:12,090
会花那么多时间 在诸如 

2548
01:37:10,290 --> 01:37:13,410
语法和美元符号和问题 

2549
01:37:12,090 --> 01:37:14,970
商标和方括号 之类 

2550
01:37:13,410 --> 01:37:16,200
这不是有趣的部分 

2551
01:37:14,970 --> 01:37:17,400
有趣的是 我们现在有的时候 

2552
01:37:16,200 --> 01:37:19,800
这些都是基础建设 

2553
01:37:17,400 --> 01:37:22,710
像我们可以使用的数组一样的块

2554
01:37:19,800 --> 01:37:24,810
解决问题 所以事实证明 了 

2555
01:37:22,710 --> 01:37:27,090
你知道你可以 想到的阵列

2556
01:37:24,810 --> 01:37:29,250
它作为一系列储物柜系列 

2557
01:37:27,090 --> 01:37:31,680
内部可能看起来像这样的储物柜

2558
01:37:29,250 --> 01:37:32,760
其中包括值字符串或数字或 

2559
01:37:31,680 --> 01:37:34,140
chars或诸如此类的东西 

2560
01:37:32,760 --> 01:37:36,690
但储物柜是一个恰当的 比喻 

2561
01:37:34,140 --> 01:37:39,030
因为不像我们人类 的计算机 可以 

2562
01:37:36,690 --> 01:37:41,010
它只能看到并做一件事 

2563
01:37:39,030 --> 01:37:42,390
可以打开一个 储物柜 ，看看里面但是 

2564
01:37:41,010 --> 01:37:44,580
它不能像退一步一样 

2565
01:37:42,390 --> 01:37:46,290
我们 人类可以 看到所有 这些 

2566
01:37:44,580 --> 01:37:48,480
储物柜， 即使所有的门都是 

2567
01:37:46,290 --> 01:37:50,460
打开它必须是一个更刻意的行为

2568
01:37:48,480 --> 01:37:53,460
比那 更实际 

2569
01:37:50,460 --> 01:37:55,140
我们所有的这段时间都很有意义 

2570
01:37:53,460 --> 01:37:57,120
第一是电话簿例子 

2571
01:37:55,140 --> 01:37:58,920
周和我们的的效率 

2572
01:37:57,120 --> 01:38:01,320
在这里 找到迈克史密斯的算法

2573
01:37:58,920 --> 01:38:04,980
电话簿都假设了什么功能 

2574
01:38:01,320 --> 01:38:06,930
它订购的这本电话簿 

2575
01:38:04,980 --> 01:38:08,190
按字母顺序排列， 这是一个巨大的优势 

2576
01:38:06,930 --> 01:38:09,600
因为那时我想去 

2577
01:38:08,190 --> 01:38:11,280
中间，我可以去中间 

2578
01:38:09,600 --> 01:38:13,260
中间等等 ，这是一个 

2579
01:38:11,280 --> 01:38:14,520
我们手机上的算法可能性如果

2580
01:38:13,260 --> 01:38:16,110
你拉起你的联系人 

2581
01:38:14,520 --> 01:38:18,150
所有的名字或姓氏列表 

2582
01:38:16,110 --> 01:38:21,000
按字母排序，因为 

2583
01:38:18,150 --> 01:38:22,980
猜猜你的数据结构 或布局 

2584
01:38:21,000 --> 01:38:23,960
手机可能用来存放你的 

2585
01:38:22,980 --> 01:38:26,940
往来

2586
01:38:23,960 --> 01:38:28,380
这是一个正确的数组吧 

2587
01:38:26,940 --> 01:38:30,000
只是一个列表，它可能 会显示 

2588
01:38:28,380 --> 01:38:31,380
垂直而不是水平

2589
01:38:30,000 --> 01:38:32,760
我今天一直在画它，但它只是 

2590
01:38:31,380 --> 01:38:34,740
这又回到价值观背靠背 

2591
01:38:32,760 --> 01:38:36,870
背对背 实际排序 

2592
01:38:34,740 --> 01:38:38,280
但他们是如何实现这一目标的呢？ 

2593
01:38:36,870 --> 01:38:40,320
排序顺序，你是如何实际的 

2594
01:38:38,280 --> 01:38:41,760
找到价值观让我们考虑一下 

2595
01:38:40,320 --> 01:38:44,430
这个 问题 实际上就像是一个 

2596
01:38:41,760 --> 01:38:48,060
电脑如下让 我在这里继续 

2597
01:38:44,430 --> 01:38:50,820
会主动雷 的加盟 在这里 

2598
01:38:48,060 --> 01:38:52,500
也许 可以投入一个自由压力球 

2599
01:38:50,820 --> 01:38:54,350
从后面有人对不起没关系上来吧 

2600
01:38:52,500 --> 01:38:57,420
这里有你的名字 

2601
01:38:54,350 --> 01:39:01,290
Aaron 没事，所以Aaron 会来的 

2602
01:38:57,420 --> 01:39:01,560
起来，我很抱歉 哦，Erik 很高兴认识 

2603
01:39:01,290 --> 01:39:03,360
您

2604
01:39:01,560 --> 01:39:04,620
没事到这儿来如此 埃里克 

2605
01:39:03,360 --> 01:39:06,840
通常我会要求你 找到 

2606
01:39:04,620 --> 01:39:08,190
23号， 但 看到的是一点点 

2607
01:39:06,840 --> 01:39:10,230
您可以轻松前往，找到我们 

2608
01:39:08,190 --> 01:39:12,570
这些门后面的数字50 或 

2609
01:39:10,230 --> 01:39:15,690
真的这些黄色储物柜 八卦 

2610
01:39:12,570 --> 01:39:17,250
42 没有好非常 好的，三个 

2611
01:39:15,690 --> 01:39:18,440
三个七人制你怎么能得到它 

2612
01:39:17,250 --> 01:39:21,270
这么快 

2613
01:39:18,440 --> 01:39:25,100
好的， 所以他的客人 是最好的 

2614
01:39:21,270 --> 01:39:25,100
Eric可以 在这里使用的算法

2615
01:39:25,790 --> 01:39:33,210
好吧，我不知道是不是 

2616
01:39:29,090 --> 01:39:34,740
为什么为什么他没有其他信息 

2617
01:39:33,210 --> 01:39:35,490
所以，是的，这是 你能做 的最好的 

2618
01:39:34,740 --> 01:39:37,770
但让我给你多一点

2619
01:39:35,490 --> 01:39:40,260
您可以 留在这里的信息让我 

2620
01:39:37,770 --> 01:39:42,360
继续 ， 在这里 重新加载 屏幕 

2621
01:39:40,260 --> 01:39:45,450
让我继续前进，拉出一个不同的 

2622
01:39:42,360 --> 01:39:46,800
一套 门 ，现在假设 那么多 

2623
01:39:45,450 --> 01:39:48,810
喜欢这款手机的书， 很像 

2624
01:39:46,800 --> 01:39:53,900
手机现在排序这些门

2625
01:39:48,810 --> 01:39:58,940
排序并找到我们的数字50 好吧 

2626
01:39:53,900 --> 01:39:58,940
你还好那么好吗？ 

2627
01:40:01,490 --> 01:40:06,660
没事 ，所以你跳到 中间 

2628
01:40:04,440 --> 01:40:08,250
你最初跳到了中间 

2629
01:40:06,660 --> 01:40:10,500
然后到右半边然后 

2630
01:40:08,250 --> 01:40:11,640
从技术上讲，我们在技术上是靠近的 

2631
01:40:10,500 --> 01:40:13,500
一个权利， 因为像二进制搜索 

2632
01:40:11,640 --> 01:40:15,750
会进入那个中间 

2633
01:40:13,500 --> 01:40:18,360
好吧，但 埃里克在这里做得 很好 

2634
01:40:15,750 --> 01:40:22,260
我至少强调了这一点 

2635
01:40:18,360 --> 01:40:23,640
球所以非常感谢你做得好 所以用 

2636
01:40:22,260 --> 01:40:25,290
您知道的 其他 信息 

2637
01:40:23,640 --> 01:40:27,570
就像埃里克能够做得更好，因为 

2638
01:40:25,290 --> 01:40:30,210
信息在屏幕上排序 

2639
01:40:27,570 --> 01:40:31,800
但他 对锁柜 只有 一个洞察力 

2640
01:40:30,210 --> 01:40:34,170
在一个时间，因为只有通过揭示 

2641
01:40:31,800 --> 01:40:36,130
里面有什么 你 可以 看到它 ， 

2642
01:40:34,170 --> 01:40:37,210
这似乎 表明， 一个 

2643
01:40:36,130 --> 01:40:39,460
你有这些额外的信息 

2644
01:40:37,210 --> 01:40:42,040
在Eric的手机示例示例中 

2645
01:40:39,460 --> 01:40:44,409
在你打开的电话簿示例中

2646
01:40:42,040 --> 01:40:47,320
更多的可能性

2647
01:40:44,409 --> 01:40:49,510
有效的算法， 但要到达那里 

2648
01:40:47,320 --> 01:40:52,120
我们有点推迟这一切 

2649
01:40:49,510 --> 01:40:54,699
在课堂上你是如何实际排序的 

2650
01:40:52,120 --> 01:40:56,260
这些元素如果你不介意的话 

2651
01:40:54,699 --> 01:40:58,060
这样我们就可以结束了 

2652
01:40:56,260 --> 01:40:59,469
因为我知道，这里更加精力充沛

2653
01:40:58,060 --> 01:41:02,830
我们已经在杂草中待 了一段时间 

2654
01:40:59,469 --> 01:41:05,020
我们可以像八个志愿者一样好吗 

2655
01:41:02,830 --> 01:41:08,260
所以一二三四 

2656
01:41:05,020 --> 01:41:10,510
怎么样五六七八

2657
01:41:08,260 --> 01:41:12,730
下来吧，哦，我很抱歉， 我 没有 

2658
01:41:10,510 --> 01:41:14,739
完全 忽略了前排 好吧 

2659
01:41:12,730 --> 01:41:15,280
没事的下一次下一次加油 

2660
01:41:14,739 --> 01:41:22,840
下 

2661
01:41:15,280 --> 01:41:26,110
哦， 科尔顿 你介意 见过 他们 

2662
01:41:22,840 --> 01:41:27,310
相反， 没事就可以了 

2663
01:41:26,110 --> 01:41:29,980
你叫什么名字 

2664
01:41:27,310 --> 01:41:33,670
叫你大卫就在那边 

2665
01:41:29,980 --> 01:41:35,800
马特·大卫·朱嘿大卫最大不错 

2666
01:41:33,670 --> 01:41:37,360
认识詹姆斯詹姆斯很高兴见到你 

2667
01:41:35,800 --> 01:41:37,630
在这里，我会得到更多的椅子 

2668
01:41:37,360 --> 01:41:40,960
名称

2669
01:41:37,630 --> 01:41:42,520
佩恩顿大卫和其他两个 实际上可以 

2670
01:41:40,960 --> 01:41:43,600
你们其中一个人来到这里 

2671
01:41:42,520 --> 01:41:46,650
你叫什么名字 

2672
01:41:43,600 --> 01:41:49,179
安德烈很高兴见到你和你的名字 

2673
01:41:46,650 --> 01:41:51,570
picot David很高兴 见到你没问题 

2674
01:41:49,179 --> 01:41:55,540
科尔顿为你们每个人都穿上了一件T恤

2675
01:41:51,570 --> 01:41:57,100
非常港口的办公桌 和 这些 

2676
01:41:55,540 --> 01:42:02,080
你将 要 看到的衬衫有 一个 

2677
01:41:57,100 --> 01:42:03,010
它上面的数字和 那个号码我会去的 

2678
01:42:02,080 --> 01:42:08,440
如果你不愿意的话，将它们放在前面

2679
01:42:03,010 --> 01:42:10,270
介意， 好的，非常感谢你，所以我敢 

2680
01:42:08,440 --> 01:42:12,040
说我们安排我们的人类很像 

2681
01:42:10,270 --> 01:42:13,929
像我们一样在数组中的储物柜

2682
01:42:12,040 --> 01:42:16,360
人类背对背，背对背

2683
01:42:13,929 --> 01:42:18,880
但这 实际上既是一种祝福，也是一种祝福 

2684
01:42:16,360 --> 01:42:20,469
约束，因为我们只有八个

2685
01:42:18,880 --> 01:42:22,690
椅子，所以真的没有多少空间

2686
01:42:20,469 --> 01:42:24,219
所以我们只限于此 

2687
01:42:22,690 --> 01:42:26,980
在这里的空间， 我看到我们 有四个 

2688
01:42:24,219 --> 01:42:28,540
五 二三一六七所以这是 

2689
01:42:26,980 --> 01:42:30,429
非常喜欢他们没有被分类

2690
01:42:28,540 --> 01:42:31,719
定义它是非常随机的， 所以 

2691
01:42:30,429 --> 01:42:35,340
非常大，所以我们只是 通过这个 开始 

2692
01:42:31,719 --> 01:42:35,340
请自己从1到8排序

2693
01:42:42,010 --> 01:42:50,030
没关系 ，算法是什么 

2694
01:42:44,720 --> 01:42:52,940
环顾四周想好了

2695
01:42:50,030 --> 01:42:55,100
KITT非常聪明地完成了人类的聪明才智 

2696
01:42:52,940 --> 01:42:57,400
我们可以扭转一种想法 

2697
01:42:55,100 --> 01:43:00,170
经历你的 任何 想法 

2698
01:42:57,400 --> 01:43:02,210
找到椅子找到合适的椅子

2699
01:43:00,170 --> 01:43:04,400
去的地方好，所以像一个

2700
01:43:02,210 --> 01:43:08,150
索引位置右侧数组有索引 

2701
01:43:04,400 --> 01:43:09,470
所以说0 1 2一直 到7 

2702
01:43:08,150 --> 01:43:11,420
即使 我们的衬衫编号 

2703
01:43:09,470 --> 01:43:13,100
从1 到8你可以 用术语思考 

2704
01:43:11,420 --> 01:43:22,310
0到7，所以其他人都很好 

2705
01:43:13,100 --> 01:43:23,630
其他的想法 绝对可以 

2706
01:43:22,310 --> 01:43:25,070
从右到左而不是 

2707
01:43:23,630 --> 01:43:26,600
从左到右但至少我们都同意了 

2708
01:43:25,070 --> 01:43:28,610
在这个约定，所以 在 你的 

2709
01:43:26,600 --> 01:43:29,960
记 好那么好，所以我们得到这个排序 去 

2710
01:43:28,610 --> 01:43:38,210
如果你这么做，那就让自己彻底消亡吧

2711
01:43:29,960 --> 01:43:40,340
可能，这是什么算法

2712
01:43:38,210 --> 01:43:42,680
随机的尴尬 确定，所以很好 

2713
01:43:40,340 --> 01:43:44,750
它看起来很随意 ，它会让我们这样做 

2714
01:43:42,680 --> 01:43:45,950
看看我们现在是否可以减少这个过程 

2715
01:43:44,750 --> 01:43:47,660
排序到更多的东西

2716
01:43:45,950 --> 01:43:49,250
算法，以便我们可以肯定 

2717
01:43:47,660 --> 01:43:50,570
我们是正确的，而不仅仅是得到 

2718
01:43:49,250 --> 01:43:52,820
幸运的是， 每个人都想到了这一点 

2719
01:43:50,570 --> 01:43:54,770
外面没有人被排除在外 

2720
01:43:52,820 --> 01:43:56,780
开始 考虑它的效率 

2721
01:43:54,770 --> 01:43:58,190
是的， 因为如果我们一直在 增加 

2722
01:43:56,780 --> 01:44:00,470
电话簿的 效率很高 

2723
01:43:58,190 --> 01:44:01,760
我们的空气环境就像我们一样 

2724
01:44:00,470 --> 01:44:03,800
真的应该 已经询问了整个 

2725
01:44:01,760 --> 01:44:05,840
确保你用二进制文件节省时间

2726
01:44:03,800 --> 01:44:08,060
搜索 和分裂并征服， 但如何 

2727
01:44:05,840 --> 01:44:10,280
花了多少钱它的成本，你得到一个点 

2728
01:44:08,060 --> 01:44:12,320
你可以在哪里使用二进制搜索和 

2729
01:44:10,280 --> 01:44:13,880
划分和征服cuz排序，如果它 

2730
01:44:12,320 --> 01:44:15,800
超级超级超级昂贵和时间 

2731
01:44:13,880 --> 01:44:17,060
消费也许它是一个净负面和 

2732
01:44:15,800 --> 01:44:19,160
你不妨只搜索 一下 

2733
01:44:17,060 --> 01:44:22,220
列表，而不是以往 的所有 事情排序 

2734
01:44:19,160 --> 01:44:27,050
是的 ，让我们看看这里呃5 6＆5我 

2735
01:44:22,220 --> 01:44:30,140
不喜欢这个应该来的 

2736
01:44:27,050 --> 01:44:32,990
5点以后我们可以解决这个问题

2737
01:44:30,140 --> 01:44:34,940
是的，然后让我们看看确定6和 1 不 

2738
01:44:32,990 --> 01:44:38,810
真的很喜欢这个我们可以解决 

2739
01:44:34,940 --> 01:44:40,910
这个非常好的6 ＆3 好吧你 真的有 

2740
01:44:38,810 --> 01:44:45,830
棍子的短端在 这里6和3 

2741
01:44:40,910 --> 01:44:48,590
我们可以解决这个问题，6是的，确定 6和7 

2742
01:44:45,830 --> 01:44:51,230
好的好，所以 7和8 相当 不错 

2743
01:44:48,590 --> 01:44:54,380
好的8＆4对不起，我们可以 

2744
01:44:51,230 --> 01:44:57,020
切换到这里然后八 和 

2745
01:44:54,380 --> 01:44:58,550
两个没关系，我们可以在这里切换 好吗 

2746
01:44:57,020 --> 01:45:01,010
让我有点夸夸其谈 

2747
01:44:58,550 --> 01:45:03,050
问我还好，我没事 

2748
01:45:01,010 --> 01:45:04,400
显然不是，但 我确实解决了一些 

2749
01:45:03,050 --> 01:45:06,020
问题对我解决了一些问题

2750
01:45:04,400 --> 01:45:07,730
换位数字不在 

2751
01:45:06,020 --> 01:45:08,930
订单，事实上我可以是你的名字 

2752
01:45:07,730 --> 01:45:10,670
再来Comi 

2753
01:45:08,930 --> 01:45:12,770
它有点冒泡通过右边 

2754
01:45:10,670 --> 01:45:14,330
在这里，如果你愿意，你会有点喜欢 

2755
01:45:12,770 --> 01:45:16,790
更远，现在你在这里 

2756
01:45:14,330 --> 01:45:18,890
而 像更小的数字 样 

2757
01:45:16,790 --> 01:45:20,660
是的，像我的上帝一样令人讨厌 

2758
01:45:18,890 --> 01:45:22,250
以这种方式冒泡他的方式就像事情一样 

2759
01:45:20,660 --> 01:45:25,070
在某种意义上是渗透的， 那就是 

2760
01:45:22,250 --> 01:45:27,050
一件好事，所以你 知道让我试试 

2761
01:45:25,070 --> 01:45:28,910
解决一些遗留问题

2762
01:45:27,050 --> 01:45:32,960
五个 好哦，三个和五个可以 

2763
01:45:28,910 --> 01:45:36,100
切换五和六好六和七 

2764
01:45:32,960 --> 01:45:41,510
7四个可切换很好 ，而且 

2765
01:45:36,100 --> 01:45:43,160
七，二你可以切换，现在我 

2766
01:45:41,510 --> 01:45:44,420
不必 再与共匪 说话 

2767
01:45:43,160 --> 01:45:45,920
因为我们知道你是对的 

2768
01:45:44,420 --> 01:45:47,390
所以我实际上没有 必要这样做 

2769
01:45:45,920 --> 01:45:50,330
这次的工作量 相当多 

2770
01:45:47,390 --> 01:45:53,090
有点 好，但我没有明显做到 

2771
01:45:50,330 --> 01:45:54,560
不是，现在的 模式 是什么 样的 

2772
01:45:53,090 --> 01:45:57,110
如果我是什么基本原语

2773
01:45:54,560 --> 01:45:59,270
只比较成对的人和数字

2774
01:45:57,110 --> 01:46:01,310
我 可以稍微改善一下情况 

2775
01:45:59,270 --> 01:46:03,800
每次只是交换他们交换 

2776
01:46:01,310 --> 01:46:05,540
他们每次现在我很抱歉高峰去 

2777
01:46:03,800 --> 01:46:07,370
在我没有的七号位置

2778
01:46:05,540 --> 01:46:08,720
因为他现在已经和他说话了 

2779
01:46:07,370 --> 01:46:10,370
冒泡途中一路 攀升到 

2780
01:46:08,720 --> 01:46:11,930
顶部，所以尽管我也在做同样的事情 

2781
01:46:10,370 --> 01:46:13,970
事情 一次又一次地再次 循环 

2782
01:46:11,930 --> 01:46:15,410
又一次并不总是最好的 东西 ，所以 

2783
01:46:13,970 --> 01:46:17,510
只要你循环越来越少 

2784
01:46:15,410 --> 01:46:18,950
我最终会阻止它 

2785
01:46:17,510 --> 01:46:20,120
似乎因为 6是 要去 最终会 

2786
01:46:18,950 --> 01:46:22,010
在正确的地方， 然后五 和 

2787
01:46:20,120 --> 01:46:24,860
四，等等，如果我们可以 

2788
01:46:22,010 --> 01:46:28,220
完成这个算法好不好 

2789
01:46:24,860 --> 01:46:30,430
好还好 六 两只时却好，如果你 

2790
01:46:28,220 --> 01:46:32,540
可以换掉你的名字再说一遍 

2791
01:46:30,430 --> 01:46:34,520
Peyton Peyton现在位于正确的位置 

2792
01:46:32,540 --> 01:46:36,380
我现在面前 的 工作就更少了 

2793
01:46:34,520 --> 01:46:39,680
如果 它可以继续这个过程1＆ 

2794
01:46:36,380 --> 01:46:42,410
3 3 ＆5 4＆5好，然后2＆5和 

2795
01:46:39,680 --> 01:46:44,090
那么Matt 现在 再次叫你的名字了 

2796
01:46:42,410 --> 01:46:47,120
在正确的地方， 我们的工作更少 

2797
01:46:44,090 --> 01:46:50,060
几乎有1＆3 3＆ 4 2＆4＆ 2你 

2798
01:46:47,120 --> 01:46:53,239
可以交换 好几乎 完成和1 3 3 

2799
01:46:50,060 --> 01:46:55,250
＆2，如果你可以不交换， 所以这 是 

2800
01:46:53,239 --> 01:46:58,130
有趣的 是，你似乎知道 

2801
01:46:55,250 --> 01:47:00,739
首先，我有点比较 7 

2802
01:46:58,130 --> 01:47:02,210
一对人 然后下次我 

2803
01:47:00,739 --> 01:47:04,869
通过我比较了多少对 

2804
01:47:02,210 --> 01:47:06,429
人最大的只是 

2805
01:47:04,869 --> 01:47:07,959
六， 因为我们要离开 Comi 

2806
01:47:06,429 --> 01:47:09,789
然后我们就离开了Pico 

2807
01:47:07,959 --> 01:47:11,469
出来然后画上画等等 

2808
01:47:09,789 --> 01:47:13,449
比较我正在做 的 比较 

2809
01:47:11,469 --> 01:47:15,219
越来越 少， 所以感觉很漂亮 

2810
01:47:13,449 --> 01:47:16,749
好，但你知道我们甚至 

2811
01:47:15,219 --> 01:47:18,280
分析 说你可以随机分组 

2812
01:47:16,749 --> 01:47:19,919
再次，任何人类算法都是

2813
01:47:18,280 --> 01:47:22,929
好吧让我们尝试另一种方法 

2814
01:47:19,919 --> 01:47:25,030
因为这感觉有点 不明显 

2815
01:47:22,929 --> 01:47:26,559
对，我正在修理东西 

2816
01:47:25,030 --> 01:47:27,699
但我不得不再次修理东西

2817
01:47:26,559 --> 01:47:29,050
再次让我尝试采取 更大的 

2818
01:47:27,699 --> 01:47:30,939
咬出这个时间的问题 

2819
01:47:29,050 --> 01:47:33,429
只选择最小的人好吧 

2820
01:47:30,939 --> 01:47:34,539
所以你的名字又是 犹太人哎 二号 

2821
01:47:33,429 --> 01:47:36,099
这是一个非常小的数字， 所以我 

2822
01:47:34,539 --> 01:47:38,409
会记住 那种精神上的 

2823
01:47:36,099 --> 01:47:40,530
变量， 不，你太大 太大了 

2824
01:47:38,409 --> 01:47:43,360
太大太大 哦 

2825
01:47:40,530 --> 01:47:45,159
詹姆斯詹姆斯 是一个 非常好的1 

2826
01:47:43,360 --> 01:47:47,709
让我继续检查我的詹姆斯 

2827
01:47:45,159 --> 01:47:49,360
心理变量是我的最小数字

2828
01:47:47,709 --> 01:47:51,099
知道我一开始就想要他， 所以如果 

2829
01:47:49,360 --> 01:47:52,479
你不会介意跟我一起 走 ， 我 

2830
01:47:51,099 --> 01:47:53,679
对不起，我们再也没有空间 了 

2831
01:47:52,479 --> 01:47:56,919
如果你可以哦，你知道什么可以 

2832
01:47:53,679 --> 01:47:58,510
你们都只是随便洗牌 我不这样做 

2833
01:47:56,919 --> 01:48:00,039
知道我喜欢这样，这是 一个大量 的工作 

2834
01:47:58,510 --> 01:48:02,409
正确地移动 所有这些价值让我们不行 

2835
01:48:00,039 --> 01:48:05,879
那样做， 不要做那个数字2 

2836
01:48:02,409 --> 01:48:08,860
你介意去詹姆斯 这个词 

2837
01:48:05,879 --> 01:48:10,780
好吧 所以我有点问题了 

2838
01:48:08,860 --> 01:48:13,119
更糟糕的是，2号更远 

2839
01:48:10,780 --> 01:48:14,919
远离目标，但我可以 

2840
01:48:13,119 --> 01:48:16,449
得到幸运，也许她是7号 

2841
01:48:14,919 --> 01:48:18,249
或8， 因此我 只想声称 对 

2842
01:48:16,449 --> 01:48:20,320
平均只是 驱逐这个人 

2843
01:48:18,249 --> 01:48:22,539
会有点洗，平均出来 

2844
01:48:20,320 --> 01:48:25,570
但现在詹姆斯已经在正确的位置 完成了 

2845
01:48:22,539 --> 01:48:27,159
现在我有一个 问题，那就是大小7 左右 

2846
01:48:25,570 --> 01:48:29,229
让我选择 下一个最小的人 4 

2847
01:48:27,159 --> 01:48:32,709
是下一个最小的不是8而不是5没有 设置 

2848
01:48:29,229 --> 01:48:34,629
2不是 3 6好，所以 你回到 游戏中 

2849
01:48:32,709 --> 01:48:35,260
没事快点回来，我们可以驱逐 

2850
01:48:34,629 --> 01:48:37,929
4号 

2851
01:48:35,260 --> 01:48:40,929
并且在这个算法上，如果你哦，我只是 

2852
01:48:37,929 --> 01:48:43,030
迭代地选择最小的人 

2853
01:48:40,929 --> 01:48:44,590
我不是在比较 所有人 

2854
01:48:43,030 --> 01:48:46,629
同样的方式 和 他们成对 交换 我 

2855
01:48:44,590 --> 01:48:48,039
这样做更宏观的掉期的儿子 这么 

2856
01:48:46,629 --> 01:48:49,749
现在我要找 下一个最小的 

2857
01:48:48,039 --> 01:48:51,129
如果你不介意 弹出 ，这是3 

2858
01:48:49,749 --> 01:48:52,959
它在这里叫我们必须 

2859
01:48:51,129 --> 01:48:54,610
不幸的是驱逐了你，但是有效 

2860
01:48:52,959 --> 01:48:56,349
出于我们的利益让我来寻找 

2861
01:48:54,610 --> 01:48:58,809
下一个最小的4个确定你 回来了 

2862
01:48:56,349 --> 01:49:01,419
在与 5 交换下来 

2863
01:48:58,809 --> 01:49:04,389
好的，我现在正在寻找5嘿 5 

2864
01:49:01,419 --> 01:49:07,570
好的， 所以去这里 好找 600 

2865
01:49:04,389 --> 01:49:10,629
第六次一点点洗牌 好吧 

2866
01:49:07,570 --> 01:49:12,969
如果你能去这里，现在寻找707 

2867
01:49:10,629 --> 01:49:14,590
但请注意，我不会再回头了 

2868
01:49:12,969 --> 01:49:16,269
像我的步骤一样 重要 

2869
01:49:14,590 --> 01:49:17,169
变得越来越短 

2870
01:49:16,269 --> 01:49:19,120
步骤越来越短 

2871
01:49:17,169 --> 01:49:21,640
而现在我们已经 

2872
01:49:19,120 --> 01:49:23,260
将所有这些人分类为两个 

2873
01:49:21,640 --> 01:49:25,240
根本不同的方式，但他们是 

2874
01:49:23,260 --> 01:49:27,370
两者都具有比较性， 因为 我 

2875
01:49:25,240 --> 01:49:29,650
再次比较这些字符和 

2876
01:49:27,370 --> 01:49:31,420
一次又一次地交换它们，如果 

2877
01:49:29,650 --> 01:49:33,190
他们出了故障， 或者 我很大 

2878
01:49:31,420 --> 01:49:36,670
更高级别的经历和交换 

2879
01:49:33,190 --> 01:49:39,070
他们一次又一次，但如何 

2880
01:49:36,670 --> 01:49:41,110
许多步骤是 ，每次 我 再碰 

2881
01:49:39,070 --> 01:49:43,150
虽然我做得越来越少，而且我 

2882
01:49:41,110 --> 01:49:45,520
我 第一次没有加倍 

2883
01:49:43,150 --> 01:49:47,920
在做像n减1间的比较 和 

2884
01:49:45,520 --> 01:49:50,230
然后我回到这里，泡泡了

2885
01:49:47,920 --> 01:49:52,240
第一种算法我有点停止了 

2886
01:49:50,230 --> 01:49:54,550
在第二算法 我尽量去

2887
01:49:52,240 --> 01:49:55,690
只是没有回去那么多 

2888
01:49:54,550 --> 01:49:57,820
只是一种 不同 的思维方式 

2889
01:49:55,690 --> 01:50:02,590
问题， 但后来我做了类似的事情 

2890
01:49:57,820 --> 01:50:04,900
7比较然后6 然后5然后4 

2891
01:50:02,590 --> 01:50:06,730
3然后 2然后 1它变小了但是 

2892
01:50:04,900 --> 01:50:08,590
有多少比较是总数if 

2893
01:50:06,730 --> 01:50:12,160
我有一个人和一个人 

2894
01:50:08,590 --> 01:50:15,310
数字它并不像我们的因子那么糟糕 

2895
01:50:12,160 --> 01:50:17,230
一整天都在这里，但它很大 

2896
01:50:15,310 --> 01:50:17,980
这是很大的让我们走吧 

2897
01:50:17,230 --> 01:50:19,420
掌声，我们可以为我们的 

2898
01:50:17,980 --> 01:50:21,310
志愿者你可以保留 衬衫 

2899
01:50:19,420 --> 01:50:24,540
你想要纪念品，非常感谢你 

2900
01:50:21,310 --> 01:50:27,400
多少让我看看，如果 我们不能只是一种 

2901
01:50:24,540 --> 01:50:30,010
量化太感谢你 了 ，看看 

2902
01:50:27,400 --> 01:50:34,060
如果我 ，我们如何实现这 一点 

2903
01:50:30,010 --> 01:50:35,590
继续前进， 拉起来不是我们的储物柜，但 

2904
01:50:34,060 --> 01:50:38,590
我们的答案让 我提出 这个 建议 

2905
01:50:35,590 --> 01:50:40,510
我们刚刚 做了两件事 

2906
01:50:38,590 --> 01:50:41,590
算法有一个名字泡泡和我 

2907
01:50:40,510 --> 01:50:43,180
有点故意 

2908
01:50:41,590 --> 01:50:45,280
在那里泡泡的话 

2909
01:50:43,180 --> 01:50:48,340
排序只是比较商店对 

2910
01:50:45,280 --> 01:50:50,410
通过对修复微小的错误但是 

2911
01:50:48,340 --> 01:50:52,390
我们需要一次又一次地做到这一点 

2912
01:50:50,410 --> 01:50:55,210
再这样那些步骤加起来 但是 

2913
01:50:52,390 --> 01:50:56,500
我们可以表达他们作为伪所以在 

2914
01:50:55,210 --> 01:50:57,910
伪代码，你可以写任何 

2915
01:50:56,500 --> 01:50:59,650
我可能会做 多少种方式 

2916
01:50:57,910 --> 01:51:01,960
以下只是继续做以下 

2917
01:50:59,650 --> 01:51:05,170
直到我没有剩余的掉期

2918
01:51:01,960 --> 01:51:07,840
从0到n减2，这只是n 

2919
01:51:05,170 --> 01:51:10,170
人类总数减去 2是 

2920
01:51:07,840 --> 01:51:12,220
从那个人上升到这个人 

2921
01:51:10,170 --> 01:51:13,630
因为我想 比较他或她 

2922
01:51:12,220 --> 01:51:14,890
反对他们旁边的人， 所以我 

2923
01:51:13,630 --> 01:51:16,570
不想意外地这样做 

2924
01:51:14,890 --> 01:51:18,490
这就是为什么它最后是 n 减2 

2925
01:51:16,570 --> 01:51:20,110
在这里， 我想继续前进， 如果 

2926
01:51:18,490 --> 01:51:22,480
冰和冰加上1个元素都出来了

2927
01:51:20,110 --> 01:51:24,190
按 顺序 交换它们，这 就是我 的 原因 

2928
01:51:22,480 --> 01:51:26,320
要求我们的人类志愿者进行交流 

2929
01:51:24,190 --> 01:51:28,060
的地方，然后自顾自地这样做 

2930
01:51:26,320 --> 01:51:29,860
直到没有人离开交换和 

2931
01:51:28,060 --> 01:51:31,720
定义每个人都是有序的 

2932
01:51:29,860 --> 01:51:32,619
同时第二个 算法有一个 

2933
01:51:31,720 --> 01:51:34,510
常规名称

2934
01:51:32,619 --> 01:51:36,900
选择排序选择排序是 

2935
01:51:34,510 --> 01:51:40,330
字面意思就是 你 真正的地方 

2936
01:51:36,900 --> 01:51:41,800
选择最小的人或数 

2937
01:51:40,330 --> 01:51:42,940
再次感兴趣的是你

2938
01:51:41,800 --> 01:51:44,860
再次， 一个数字 不断变大 

2939
01:51:42,940 --> 01:51:46,630
但你开始无视那些人 

2940
01:51:44,860 --> 01:51:48,699
你已经把它放到了这里

2941
01:51:46,630 --> 01:51:50,650
问题同样越来越小

2942
01:51:48,699 --> 01:51:52,510
较小的就像 在冒泡排序 是 

2943
01:51:50,650 --> 01:51:54,010
越来越排序 

2944
01:51:52,510 --> 01:51:57,219
用于选择排序的伪代码可能看起来 

2945
01:51:54,010 --> 01:51:59,800
像这样我从 0到n减 1 所以 

2946
01:51:57,219 --> 01:52:02,830
在数组中为0，这是n减去 

2947
01:51:59,800 --> 01:52:05,110
1 只是继续寻找最小的 

2948
01:52:02,830 --> 01:52:07,840
这 两个椅子和 元件之间 

2949
01:52:05,110 --> 01:52:10,030
然后将那个人拉出来 然后 就这样 

2950
01:52:07,840 --> 01:52:11,770
驱逐谁在那里交换他们但不是 

2951
01:52:10,030 --> 01:52:14,320
到目前为止， 李 必然 相邻 

2952
01:52:11,770 --> 01:52:16,540
在必要的时候离开， 这样我 

2953
01:52:14,320 --> 01:52:19,449
继续背弃我 越来越多 

2954
01:52:16,540 --> 01:52:21,159
人 ，因为他们是 那么到位 ，使 

2955
01:52:19,449 --> 01:52:22,960
两个不同的问题框架 

2956
01:52:21,159 --> 01:52:25,900
但 事实证明他们实际上都是 

2957
01:52:22,960 --> 01:52:27,040
相同数量的 步骤给予或接受 它 

2958
01:52:25,900 --> 01:52:28,060
事实证明他们大致 相同 

2959
01:52:27,040 --> 01:52:29,020
步 数， 即使 它是一个 

2960
01:52:28,060 --> 01:52:31,210
考虑 这个问题 的不同方式 

2961
01:52:29,020 --> 01:52:33,790
因为如果 我想 冒泡排序的 

2962
01:52:31,210 --> 01:52:35,230
第一次迭代，例如正是如此

2963
01:52:33,790 --> 01:52:37,060
实际上我们考虑选择 

2964
01:52:35,230 --> 01:52:39,429
甚至在选择排序中排序 

2965
01:52:37,060 --> 01:52:41,860
我需要做多少次比较 

2966
01:52:39,429 --> 01:52:43,599
一旦好，我发现我的最小的元素 我 

2967
01:52:41,860 --> 01:52:45,610
不得不将它们与每个人进行比较

2968
01:52:43,599 --> 01:52:47,679
否则， 这样 的n减1个 的 比较 

2969
01:52:45,610 --> 01:52:49,900
第一次在板上如此减1 

2970
01:52:47,679 --> 01:52:51,880
然后我可以忽略它们，因为它们是 

2971
01:52:49,900 --> 01:52:53,909
我现在在身后，所以现在我有多少 

2972
01:52:51,880 --> 01:52:56,770
比较遗漏了 n个人 和 

2973
01:52:53,909 --> 01:52:59,080
减去2，因为我减去 1然后 

2974
01:52:56,770 --> 01:53:01,420
再次n减3然后n减4全部 

2975
01:52:59,080 --> 01:53:02,830
一路下跌到 只有一个人 那么 剩余 

2976
01:53:01,420 --> 01:53:04,810
我会 表达那种一般性的 

2977
01:53:02,830 --> 01:53:07,420
在数学上像这样n减1 

2978
01:53:04,810 --> 01:53:10,060
再加上n 减2加上 1 加 1 

2979
01:53:07,420 --> 01:53:12,429
最后的比较无论 是什么 

2980
01:53:10,060 --> 01:53:13,989
事实证明，如果你真的读过 

2981
01:53:12,429 --> 01:53:14,889
回到数学书 或你的物理学 

2982
01:53:13,989 --> 01:53:15,940
他们有那么一点的教科书

2983
01:53:14,889 --> 01:53:19,330
欺骗床单这些是什么 

2984
01:53:15,940 --> 01:53:21,580
结果是n 减1 

2985
01:53:19,330 --> 01:53:23,170
再加上n 减 2加n 减3 等等 

2986
01:53:21,580 --> 01:53:26,500
可以 更简洁地表达出来 

2987
01:53:23,170 --> 01:53:29,199
字面上只有n 倍n减1/2 

2988
01:53:26,500 --> 01:53:31,060
如果你不记得那 没关系我 

2989
01:53:29,199 --> 01:53:32,260
总是看起来这些东西 ， 但是 

2990
01:53:31,060 --> 01:53:34,239
这是事实 

2991
01:53:32,260 --> 01:53:35,800
那么，什么是等于 嗯 ，这是 

2992
01:53:34,239 --> 01:53:37,030
如果你 只是 N平方减去n 

2993
01:53:35,800 --> 01:53:39,040
把它加倍

2994
01:53:37,030 --> 01:53:41,590
然后，如果你将两者分开，那么它就是 

2995
01:53:39,040 --> 01:53:42,820
N平方除以2减去n超过2所以 

2996
01:53:41,590 --> 01:53:43,869
这是我和步骤 的 总数 

2997
01:53:42,820 --> 01:53:46,119
实际上我们可以插入这个

2998
01:53:43,869 --> 01:53:46,360
插上8做数学并得到总数 

2999
01:53:46,119 --> 01:53:48,430
麻木 

3000
01:53:46,360 --> 01:53:52,660
比较 ，我口头上的善意 

3001
01:53:48,430 --> 01:53:54,160
剑拔弩张关闭，因此是一个大不了 

3002
01:53:52,660 --> 01:53:55,930
感觉就像 是 N 的顺序 

3003
01:53:54,160 --> 01:53:57,730
平方而且确实是计算机 科学家 

3004
01:53:55,930 --> 01:53:59,410
在评估一个人的效率时 

3005
01:53:57,730 --> 01:54:01,090
算法往往不太关心 

3006
01:53:59,410 --> 01:54:02,620
关于我们所有的精确值 

3007
01:54:01,090 --> 01:54:04,690
要关心就像是最大的 

3008
01:54:02,620 --> 01:54:06,070
术语什么是公式中的值 

3009
01:54:04,690 --> 01:54:08,170
那 你 只是 想出来的 

3010
01:54:06,070 --> 01:54:09,340
可以说是支配另一个术语 

3011
01:54:08,170 --> 01:54:12,010
具有 最大的影响特别 

3012
01:54:09,340 --> 01:54:14,080
因为n现在越来越 大了 

3013
01:54:12,010 --> 01:54:16,180
为什么这很好，让我们做点什么 

3014
01:54:14,080 --> 01:54:18,880
校对例如，如果你会 ，如果这是 

3015
01:54:16,180 --> 01:54:20,800
技术上的表达， 但 我声称 

3016
01:54:18,880 --> 01:54:23,260
这是它 足够 接近 说 

3017
01:54:20,800 --> 01:54:25,570
N 的大O的顺序 如此平方 

3018
01:54:23,260 --> 01:54:27,280
如果有的话， 让我们用一个例子 

3019
01:54:25,570 --> 01:54:29,290
百万人在舞台上而不仅仅是 

3020
01:54:27,280 --> 01:54:32,080
八，数学算法 就像一个 

3021
01:54:29,290 --> 01:54:34,360
百万平方除以两步 -  a 

3022
01:54:32,080 --> 01:54:35,800
百万除以两个总数那么 

3023
01:54:34,360 --> 01:54:39,640
这 真的很 有效吗？ 

3024
01:54:35,800 --> 01:54:40,870
这是5000亿-  50 万和 

3025
01:54:39,640 --> 01:54:46,120
这样做 有什么用呢

3026
01:54:40,870 --> 01:54:49,600
这是 4,990 亿999 亿500,000 

3027
01:54:46,120 --> 01:54:51,400
感觉非常接近像N. 

3028
01:54:49,600 --> 01:54:54,490
平方我的意思是，这是一个下降 

3029
01:54:51,400 --> 01:54:56,770
从500减去50万桶 

3030
01:54:54,490 --> 01:54:59,530
亿，所以你知道它是什么

3031
01:54:56,770 --> 01:55:01,720
N 平方的顺序不准确但是 

3032
01:54:59,530 --> 01:55:03,520
它是一般的数量级 

3033
01:55:01,720 --> 01:55:05,410
可以这么说， 因此这 本 象征 

3034
01:55:03,520 --> 01:55:07,390
资本o实际上是一个用于的符号

3035
01:55:05,410 --> 01:55:09,040
计算机科学和编程 

3036
01:55:07,390 --> 01:55:10,960
只是用一波的描述来形容

3037
01:55:09,040 --> 01:55:12,880
但是 一些好的直觉和 

3038
01:55:10,960 --> 01:55:14,860
算法你的速度有多快或多慢

3039
01:55:12,880 --> 01:55:16,540
算法是，而事实证明

3040
01:55:14,860 --> 01:55:18,700
不同的方法来 评估算法 

3041
01:55:16,540 --> 01:55:21,160
只有不同的类似公式N. 

3042
01:55:18,700 --> 01:55:23,050
平方恰好是多少时间 

3043
01:55:21,160 --> 01:55:24,700
如果我，冒泡排序和选择排序

3044
01:55:23,050 --> 01:55:26,170
从字面上统计我们的所有工作 

3045
01:55:24,700 --> 01:55:29,410
与 我们的志愿者 一起 在 舞台上 

3046
01:55:26,170 --> 01:55:33,340
它将大致为N平方8平方 

3047
01:55:29,410 --> 01:55:35,200
或64步给予或采取所有

3048
01:55:33,340 --> 01:55:36,880
那些人类，那将是显着的 

3049
01:55:35,200 --> 01:55:38,490
关有四舍五入的 一个良好的金额 

3050
01:55:36,880 --> 01:55:40,990
错误，但如果我们有一 百万 

3051
01:55:38,490 --> 01:55:42,910
在舞台上的志愿者然后四舍五入 

3052
01:55:40,990 --> 01:55:44,110
错误可以 忽略不计，但是 

3053
01:55:42,910 --> 01:55:46,200
我们实际上已经看到了 其他一些 

3054
01:55:44,110 --> 01:55:48,670
以前可以说的数量级 

3055
01:55:46,200 --> 01:55:50,500
例如，当我们计算某人或某人时 

3056
01:55:48,670 --> 01:55:52,750
研究迈克史密斯的一页

3057
01:55:50,500 --> 01:55:54,880
我们称之为线性算法的时间

3058
01:55:52,750 --> 01:55:56,530
这是n的大O所以它在 订单上 

3059
01:55:54,880 --> 01:55:58,450
n步骤 它可能是一千个 

3060
01:55:56,530 --> 01:56:00,219
999无论是n的顺序 

3061
01:55:58,450 --> 01:56:02,920
星期二是专业人士 

3062
01:56:00,219 --> 01:56:04,420
在两个页面 上 回忆两页的速度快了两倍

3063
01:56:02,920 --> 01:56:06,370
时间， 但 你知道那 仍然 是什么 

3064
01:56:04,420 --> 01:56:07,900
线性右一次两页 

3065
01:56:06,370 --> 01:56:09,699
让我等到 明年我的时候 

3066
01:56:07,900 --> 01:56:11,350
CPU 是两次 的Cuz 英特尔和 快 

3067
01:56:09,699 --> 01:56:13,090
公司不断加快 计算机的 速度 

3068
01:56:11,350 --> 01:56:15,130
算法从根本上说是一样的 

3069
01:56:13,090 --> 01:56:17,980
的确，如果你回想起来的话 

3070
01:56:15,130 --> 01:56:20,110
我们绘制 了那些曲线的形状 

3071
01:56:17,980 --> 01:56:21,910
确实与第一种算法相同 

3072
01:56:20,110 --> 01:56:23,739
一次找到迈克一页看

3073
01:56:21,910 --> 01:56:25,420
像第二个算法找到他 

3074
01:56:23,739 --> 01:56:26,760
看起来这只是第三个 

3075
01:56:25,420 --> 01:56:28,660
算法分而治之 

3076
01:56:26,760 --> 01:56:30,580
分裂 电话簿 是 

3077
01:56:28,660 --> 01:56:31,810
根本不同的形状等 

3078
01:56:30,580 --> 01:56:34,660
即使我们没有使用这种幻想 

3079
01:56:31,810 --> 01:56:36,550
措辞几个 星期前 ，这些第一 

3080
01:56:34,660 --> 01:56:39,040
两个算法一次一页两个 

3081
01:56:36,550 --> 01:56:42,400
页面一次是他们的 顺序 

3082
01:56:39,040 --> 01:56:44,140
n技术上 是n和n除以 

3083
01:56:42,400 --> 01:56:46,180
两个， 但我们只关心 

3084
01:56:44,140 --> 01:56:47,890
主导因素变量和 

3085
01:56:46,180 --> 01:56:49,120
我们可以抛弃一切 

3086
01:56:47,890 --> 01:56:50,560
分母，我们可以扔掉 

3087
01:56:49,120 --> 01:56:52,300
一切都小于 

3088
01:56:50,560 --> 01:56:54,900
在这种情况下最大的术语就是 

3089
01:56:52,300 --> 01:56:57,190
我和我 两个星期 前提到过 这个问题 

3090
01:56:54,900 --> 01:56:58,900
对数 好，事实证明 

3091
01:56:57,190 --> 01:57:00,430
任何时候你 再 分开一些东西 

3092
01:56:58,900 --> 01:57:03,489
你一次又一次地利用了

3093
01:57:00,430 --> 01:57:05,500
对数型函数log 基地 

3094
01:57:03,489 --> 01:57:08,440
技术上， 订单的订单上 

3095
01:57:05,500 --> 01:57:11,350
log base n也是常见的 

3096
01:57:08,440 --> 01:57:13,750
这些字面意思是美丽的算法

3097
01:57:11,350 --> 01:57:15,730
一步或技术常数 

3098
01:57:13,750 --> 01:57:19,650
例如，像是什么的 步骤 

3099
01:57:15,730 --> 01:57:19,650
可能是恒定时间的算法

3100
01:57:20,010 --> 01:57:24,699
打开电话簿好吧一步没有 

3101
01:57:23,350 --> 01:57:26,230
真正的问题多少 页有 

3102
01:57:24,699 --> 01:57:27,850
我只是 要打开 电话簿 和 

3103
01:57:26,230 --> 01:57:29,739
不会因 页数 而异 

3104
01:57:27,850 --> 01:57:32,170
这可能是一个恒定时间算法 

3105
01:57:29,739 --> 01:57:33,520
例如，那些是 你 最低的 

3106
01:57:32,170 --> 01:57:36,550
可以去，然后 甚至 在 某个地方 

3107
01:57:33,520 --> 01:57:38,650
在这里之间，我们可能向往 

3108
01:57:36,550 --> 01:57:41,620
实际上还有某些其他算法

3109
01:57:38,650 --> 01:57:44,350
让我们看看是否只是片刻让我们 

3110
01:57:41,620 --> 01:57:46,510
看看 我们是否可以再做 一点 

3111
01:57:44,350 --> 01:57:50,260
简洁地让我们继续 使用 

3112
01:57:46,510 --> 01:57:53,350
使用合并以最后一种方式提升

3113
01:57:50,260 --> 01:57:54,699
排序所以事实证明 我们使用的是数组 

3114
01:57:53,350 --> 01:57:56,920
实际上可以做点漂亮的事 

3115
01:57:54,699 --> 01:57:59,380
只要我们允许自己，我们就会有力

3116
01:57:56,920 --> 01:58:00,430
当我们刚才时，又是几个阵列 

3117
01:57:59,380 --> 01:58:01,960
做了排序与冒泡排序和 

3118
01:58:00,430 --> 01:58:04,390
选择排序我们只有一个数组

3119
01:58:01,960 --> 01:58:05,949
我们每人有八把椅子

3120
01:58:04,390 --> 01:58:07,960
八个人， 但如果我真的 允许 

3121
01:58:05,949 --> 01:58:09,790
我自己喜欢 十六把椅子甚至更多 

3122
01:58:07,960 --> 01:58:11,590
我允许这些人移动一下 

3123
01:58:09,790 --> 01:58:13,420
我实际上可以做得更好 

3124
01:58:11,590 --> 01:58:14,590
比 使用数组的 那样 

3125
01:58:13,420 --> 01:58:16,270
这里的一些随机数的意志 

3126
01:58:14,590 --> 01:58:17,290
只是做视觉上没有任何人和 

3127
01:58:16,270 --> 01:58:18,910
他们在一个阵列中 

3128
01:58:17,290 --> 01:58:21,100
背对背，背对背， 但如果我 

3129
01:58:18,910 --> 01:58:22,719
让我自己成为第二个阵容 

3130
01:58:21,100 --> 01:58:24,219
能够改变这些东西 

3131
01:58:22,719 --> 01:58:25,840
不只是比较它们，因为它是 

3132
01:58:24,219 --> 01:58:27,130
那些比较和我的全部 

3133
01:58:25,840 --> 01:58:29,020
真的，他们面前的脚步声

3134
01:58:27,130 --> 01:58:29,710
开始花很多时间，所以这里 

3135
01:58:29,020 --> 01:58:31,210
我的阵列

3136
01:58:29,710 --> 01:58:32,739
你知道什么就像电话簿 

3137
01:58:31,210 --> 01:58:35,260
电话簿的例子让我们很漂亮 

3138
01:58:32,739 --> 01:58:37,300
远在第一周让我做了一半 

3139
01:58:35,260 --> 01:58:39,310
这个问题在 那么 样的 时间 和 

3140
01:58:37,300 --> 01:58:40,989
结合我的答案所以 这是一个数组 

3141
01:58:39,310 --> 01:58:43,600
四到七五 六八 三一 

3142
01:58:40,989 --> 01:58:45,580
随机排序让我继续 排序 

3143
01:58:43,600 --> 01:58:47,110
只有一半就像我搜索一样 

3144
01:58:45,580 --> 01:58:49,840
麦克最初和 公正的一半 

3145
01:58:47,110 --> 01:58:52,090
电话簿 所以 二十七 不是 

3146
01:58:49,840 --> 01:58:53,560
排序，但你知道是什么让 我这样 

3147
01:58:52,090 --> 01:58:56,320
感觉仍然是一个太大的问题 

3148
01:58:53,560 --> 01:58:58,239
让我排序左半边 

3149
01:58:56,320 --> 01:59:00,489
左半边 好吧现在它更小了 

3150
01:58:58,239 --> 01:59:01,000
问题你知道还有四个和两个 

3151
01:59:00,489 --> 01:59:03,489
不按顺序

3152
01:59:01,000 --> 01:59:06,070
让我 把这个列表 分成两部分 

3153
01:59:03,489 --> 01:59:07,870
两个小型阵列，每个大小一个 

3154
01:59:06,070 --> 01:59:09,460
这是一个小尺寸的迷你阵列然后 

3155
01:59:07,870 --> 01:59:11,530
像尺寸7 另一个 但 

3156
01:59:09,460 --> 01:59:15,540
他们是背靠背所以不管怎样 

3157
01:59:11,530 --> 01:59:15,540
这个大小为 1的 数组 是排序的 

3158
01:59:15,570 --> 01:59:22,840
抱歉没有， 如果这个数组只有一个 

3159
01:59:19,870 --> 01:59:24,880
元素和那个元素是 四个是的 

3160
01:59:22,840 --> 01:59:27,429
它按 定义 排序 

3161
01:59:24,880 --> 01:59:29,350
这样做 现在取得了一些进展 

3162
01:59:27,429 --> 01:59:32,260
让我有点心理倒带让我 

3163
01:59:29,350 --> 01:59:33,969
排序那个L的右半部分 

3164
01:59:32,260 --> 01:59:37,600
数组现在我有另一个数组

3165
01:59:33,969 --> 01:59:39,040
大小一是这个数组排序是的善良 

3166
01:59:37,600 --> 01:59:40,420
愚蠢的我们似乎并不是真的 

3167
01:59:39,040 --> 01:59:43,150
做任何事情， 我们只是在提出要求 

3168
01:59:40,420 --> 01:59:45,699
但是，这是分类但现在这是 

3169
01:59:43,150 --> 01:59:48,130
原来的一半和这一半是 

3170
01:59:45,699 --> 01:59:49,719
排序这一半是如果我现在排序 

3171
01:59:48,130 --> 01:59:53,020
正中下怀 合并这些分类半 

3172
01:59:49,719 --> 01:59:55,420
我有大小两个列表 一个四年 

3173
01:59:53,020 --> 01:59:57,219
两个， 现在如果我有额外的存储空间 

3174
01:59:55,420 --> 01:59:58,630
空间， 如果我有额外的长凳我 

3175
01:59:57,219 --> 02:00:00,250
可以做得更好一点为什么不这样做 

3176
01:59:58,630 --> 02:00:03,160
我继续 将这两个合并为 

3177
02:00:00,250 --> 02:00:05,320
下面两个会去那里四个会去

3178
02:00:03,160 --> 02:00:07,420
那么现在我已经采取了两个排序列表 

3179
02:00:05,320 --> 02:00:09,520
并制作了一个更大的排序列表 

3180
02:00:07,420 --> 02:00:10,870
只是将它们合并在一起 利用 

3181
02:00:09,520 --> 02:00:12,429
一些额外的空间 现在让我 

3182
02:00:10,870 --> 02:00:14,140
精神上倒退我是如何得到四个 

3183
02:00:12,429 --> 02:00:16,420
成 ，而我开始与左半 

3184
02:00:14,140 --> 02:00:18,460
然后左半边的左半边 让 

3185
02:00:16,420 --> 02:00:20,710
我现在做左边的右半边 

3186
02:00:18,460 --> 02:00:22,600
一半，如果你没事，让我分开 

3187
02:00:20,710 --> 02:00:26,770
这又是七个 大小为1的列表 

3188
02:00:22,600 --> 02:00:28,960
按条件排序是 5它是否排序 

3189
02:00:26,770 --> 02:00:30,910
是的七和五让我们继续 前进 

3190
02:00:28,960 --> 02:00:32,680
将它们合并在一起五当然是 

3191
02:00:30,910 --> 02:00:35,800
要去七点当然是 

3192
02:00:32,680 --> 02:00:38,140
要去这里好了 我们 现在 去哪里 

3193
02:00:35,800 --> 02:00:40,600
我们最初排序了左半边的 

3194
02:00:38,140 --> 02:00:42,460
现在就去对峙吧 

3195
02:00:40,600 --> 02:00:45,880
我们有左半部分和右半部分 

3196
02:00:42,460 --> 02:00:47,740
左半部分的排序让我们走了 

3197
02:00:45,880 --> 02:00:51,640
提前并合并这些我们有两个列表 

3198
02:00:47,740 --> 02:00:55,450
现在大小的2 2 4＆5 7 两者均 

3199
02:00:51,640 --> 02:00:56,770
如果我现在合并2 4和5 7，则排序

3200
02:00:55,450 --> 02:01:02,380
哪个元素应该首先出现在 

3201
02:00:56,770 --> 02:01:03,730
新的更长的名单显然是2＆4＆ 5＆7 

3202
02:01:02,380 --> 02:01:05,230
这不是 什么 好事 ， 但没关系 

3203
02:01:03,730 --> 02:01:07,780
我们只是用 多 一点空间 

3204
02:01:05,230 --> 02:01:09,340
我们的阵列现在接下来是什么 

3205
02:01:07,780 --> 02:01:10,450
现在我们再来一次吧 

3206
02:01:09,340 --> 02:01:12,550
通过 采取整个问题开始

3207
02:01:10,450 --> 02:01:13,960
做左半边的左半边 

3208
02:01:12,550 --> 02:01:15,520
左半部分的 左半部分左半 部分 

3209
02:01:13,960 --> 02:01:17,800
左半边，现在我们要去 

3210
02:01:15,520 --> 02:01:18,880
时光倒流 ，如果你让我们鸿沟 

3211
02:01:17,800 --> 02:01:21,670
这分为两半 

3212
02:01:18,880 --> 02:01:24,280
现在左半边分成两半直到6 

3213
02:01:21,670 --> 02:01:27,340
排序8现在排序 我必须 

3214
02:01:24,280 --> 02:01:30,760
合并他们6 8接下来会发生什么 

3215
02:01:27,340 --> 02:01:34,780
右1/2 1/2 和1 左半的井被分类 

3216
02:01:30,760 --> 02:01:36,970
现在 右半排序1和3 的所有 

3217
02:01:34,780 --> 02:01:39,160
我如何合并这些6 8 1/3哪个 

3218
02:01:36,970 --> 02:01:44,170
元素显然应该首先出现1 

3219
02:01:39,160 --> 02:01:46,330
那么3 然后是6 然后是8然后最后我 

3220
02:01:44,170 --> 02:01:47,740
有 两个大小为4的列表让我给 

3221
02:01:46,330 --> 02:01:51,220
我自己再多一点空间 

3222
02:01:47,740 --> 02:01:57,280
数组现在让我继续前进并放1和2 

3223
02:01:51,220 --> 02:01:59,020
＆3＆4＆5＆6＆7＆8恰到好处

3224
02:01:57,280 --> 02:02:00,940
发生的原因是 它 确实发生了 

3225
02:01:59,020 --> 02:02:03,700
即使我们在做，也要快得多

3226
02:02:00,940 --> 02:02:08,580
这一切都口头上注意到了 多少 

3227
02:02:03,700 --> 02:02:08,580
每个号码改变位置的次数 

3228
02:02:09,570 --> 02:02:15,550
字面意思是3对，就像1 2 3 对吧 

3229
02:02:13,870 --> 02:02:17,590
从原始数组移动到 

3230
02:02:15,550 --> 02:02:19,750
二级数组到第三级数组

3231
02:02:17,590 --> 02:02:22,180
第四个数组 记得那个叫做的 

3232
02:02:19,750 --> 02:02:24,820
然后它最终到位了 

3233
02:02:22,180 --> 02:02:29,620
每个号码必须移动1 2 3个点和 

3234
02:02:24,820 --> 02:02:30,940
然后有多少数字是好的

3235
02:02:29,620 --> 02:02:32,260
他们已经在 原数组 

3236
02:02:30,940 --> 02:02:33,480
所以 他们需要移动 多少 次 

3237
02:02:32,260 --> 02:02:35,740
只有1 2 3 

3238
02:02:33,480 --> 02:02:38,950
那么总数是多少呢

3239
02:02:35,740 --> 02:02:40,659
要清楚的是，所以有8次3次 

3240
02:02:38,950 --> 02:02:44,560
让我们来概括这个，如果有n 值 

3241
02:02:40,659 --> 02:02:46,510
每次我们移动木材我们 

3242
02:02:44,560 --> 02:02:48,639
他们中的一半比他们的一半还要多 

3243
02:02:46,510 --> 02:02:53,350
你能分多少次 

3244
02:02:48,639 --> 02:02:55,510
8 乘2 8到4 4到2 2去 

3245
02:02:53,350 --> 02:02:58,239
1 这 就是我们在 1点 触底 的 原因 

3246
02:02:55,510 --> 02:03:00,010
事实证明 ， 大小为1的元素列表

3247
02:02:58,239 --> 02:03:01,570
每当你 把东西 除去一半 

3248
02:03:00,010 --> 02:03:06,940
这个 功能的 一半是 1/2 

3249
02:03:01,570 --> 02:03:07,590
公式不是权力，那是坏的 

3250
02:03:06,940 --> 02:03:10,449
其他方向

3251
02:03:07,590 --> 02:03:11,800
它是一个对数，所以再次对数是 

3252
02:03:10,449 --> 02:03:13,150
只是数学描述

3253
02:03:11,800 --> 02:03:14,739
你继续划分的任何功能 

3254
02:03:13,150 --> 02:03:16,300
一次又一次的事情 

3255
02:03:14,739 --> 02:03:17,889
1/2和1/2 和1/2在 第三和第三 

3256
02:03:16,300 --> 02:03:20,080
无论它是什么，它只是 意味着 

3257
02:03:17,889 --> 02:03:22,840
除以相同的比例 

3258
02:03:20,080 --> 02:03:26,020
金额一次又一次 等等 

3259
02:03:22,840 --> 02:03:29,590
如果我们将数字移动三次或 

3260
02:03:26,020 --> 02:03:31,300
更常见的是n次记录 

3261
02:03:29,590 --> 02:03:32,800
再一次只是意味着你把事情分开了 

3262
02:03:31,300 --> 02:03:36,159
再， 再 而 你 只需要调用 

3263
02:03:32,800 --> 02:03:39,070
记录 N 并且有n个数字，所以n 

3264
02:03:36,159 --> 02:03:41,800
数字移动到记录总数的n倍 

3265
02:03:39,070 --> 02:03:43,870
这里的算术是其中之一 

3266
02:03:41,800 --> 02:03:46,750
我们的小骗子的其他价值观 

3267
02:03:43,870 --> 02:03:48,760
看起来像这样和我们的表 

3268
02:03:46,750 --> 02:03:51,969
其他cheechee回忆说我们有 

3269
02:03:48,760 --> 02:03:55,179
看起来像这样的公式不仅仅是 

3270
02:03:51,969 --> 02:03:58,659
n平方 和 n 并记录N 和1我们有 

3271
02:03:55,179 --> 02:04:00,100
这个中间n次记录n所以 

3272
02:03:58,659 --> 02:04:02,620
我们再一次在这里跳来跳去 

3273
02:04:00,100 --> 02:04:05,409
但是每个数字再次移动了log n个 地方 

3274
02:04:02,620 --> 02:04:08,770
有n个总数， 所以n次记录n 

3275
02:04:05,409 --> 02:04:10,030
只是按定义和记录，但为什么 

3276
02:04:08,770 --> 02:04:12,040
是这个整理这样 

3277
02:04:10,030 --> 02:04:13,600
从第零周开始记录回忆

3278
02:04:12,040 --> 02:04:16,000
电话簿的例子 是绿色 曲线 

3279
02:04:13,600 --> 02:04:17,830
绝对小于nn 

3280
02:04:16,000 --> 02:04:19,900
直线 log n是绿色 

3281
02:04:17,830 --> 02:04:21,850
弯曲的，所以这确实属于

3282
02:04:19,900 --> 02:04:24,190
因为这是n次n 

3283
02:04:21,850 --> 02:04:27,219
是n 这是 n倍小的东西 

3284
02:04:24,190 --> 02:04:28,719
那么 实际意义 是什么呢？ 

3285
02:04:27,219 --> 02:04:31,570
好吧，如果我们要运行这些算法 

3286
02:04:28,719 --> 02:04:35,290
并排并实际比较它们 

3287
02:04:31,570 --> 02:04:39,489
有这样的事情让我继续前进 

3288
02:04:35,290 --> 02:04:42,400
并 使用此 比较这些算法 

3289
02:04:39,489 --> 02:04:44,469
如果我继续玩，请在这里演示

3290
02:04:42,400 --> 02:04:46,600
我们将看到此图表中的条形图 

3291
02:04:44,469 --> 02:04:48,610
实际上是水平的 和小的 

3292
02:04:46,600 --> 02:04:50,500
条形代表小数字大条形

3293
02:04:48,610 --> 02:04:51,699
表示长数，然后表示每个

3294
02:04:50,500 --> 02:04:53,320
这些将会有所不同 

3295
02:04:51,699 --> 02:04:53,920
算法选择排序在 左边 

3296
02:04:53,320 --> 02:04:55,929
气泡 

3297
02:04:53,920 --> 02:04:58,630
现在将在中间mergesort排序

3298
02:04:55,929 --> 02:05:02,340
把它在 右边，这里是多久 

3299
02:04:58,630 --> 02:05:07,000
他们每个人都需要对这些值进行排序 

3300
02:05:02,340 --> 02:05:08,260
完成的泡沫仍在继续选择 

3301
02:05:07,000 --> 02:05:09,790
还在继续， 所以这就是 

3302
02:05:08,260 --> 02:05:11,350
虽然有一个明显的差异

3303
02:05:09,790 --> 02:05:13,600
N平方和平方之间的小演示 

3304
02:05:11,350 --> 02:05:15,340
像log N 这样的东西，我们有什么 

3305
02:05:13,600 --> 02:05:17,560
在这里完成我们真的非常 真实 

3306
02:05:15,340 --> 02:05:18,670
成什么 阵列 的杂草都 

3307
02:05:17,560 --> 02:05:20,110
实际上为我们做了 什么 

3308
02:05:18,670 --> 02:05:21,550
关系是与字符串，因为 

3309
02:05:20,110 --> 02:05:23,140
所有这些都只是减少了事情 

3310
02:05:21,550 --> 02:05:24,610
背靠背 背靠背但是 

3311
02:05:23,140 --> 02:05:26,469
现在我们回来了 ，我们会 

3312
02:05:24,610 --> 02:05:27,850
继续沿着这条轨迹下次 

3313
02:05:26,469 --> 02:05:30,100
珠宝能够说得 更高 

3314
02:05:27,850 --> 02:05:32,590
关于实际发生的事情的水平

3315
02:05:30,100 --> 02:05:34,719
我们现在可以更进一步 

3316
02:05:32,590 --> 02:05:36,070
应用其他某些形式的媒体 

3317
02:05:34,719 --> 02:05:37,510
这些同样的问题， 我们会 

3318
02:05:36,070 --> 02:05:38,980
总结它大约60秒 

3319
02:05:37,510 --> 02:05:40,330
这些条是垂直的而不是

3320
02:05:38,980 --> 02:05:42,190
水平，你会看到 这里是 一个 

3321
02:05:40,330 --> 02:05:43,750
各种分类的可视化

3322
02:05:42,190 --> 02:05:45,460
其中的算法选择排序 

3323
02:05:43,750 --> 02:05:47,230
冒泡排序和合并排序和整体 

3324
02:05:45,460 --> 02:05:49,300
各种各样的其他人 

3325
02:05:47,230 --> 02:05:52,480
因为 它甚至有不同的声音 

3326
02:05:49,300 --> 02:05:54,460
速度和模式中的速度 

3327
02:05:52,480 --> 02:05:56,910
它实际 运作，所以我们采取 

3328
02:05:54,460 --> 02:05:56,910
快速浏览一下 

3329
02:06:07,650 --> 02:06:20,020
更大的元素确实冒出来了 

3330
02:06:10,330 --> 02:06:27,340
顶端 DISA三通或 周期 

3331
02:06:20,020 --> 02:06:29,610
它越来越 少了 

3332
02:06:27,340 --> 02:06:35,170
越来越 少的工作要做 

3333
02:06:29,610 --> 02:06:37,420
直到这几乎是 现在的 选择排序 

3334
02:06:35,170 --> 02:06:39,610
所以它 随机 开始 ，但我们保持 

3335
02:06:37,420 --> 02:06:42,699
选择最小的人 或在 此 

3336
02:06:39,610 --> 02:06:44,530
案件最短的酒吧，你会看到 

3337
02:06:42,699 --> 02:06:47,110
这里的条与频率相关

3338
02:06:44,530 --> 02:06:49,739
显然所以它越来越高 ， 

3339
02:06:47,110 --> 02:06:53,080
更高 ，更高，更高 

3340
02:06:49,739 --> 02:06:55,060
这是合并排序现在召回 

3341
02:06:53,080 --> 02:06:57,940
事情分成两半然后减半 

3342
02:06:55,060 --> 02:07:01,179
半部，然后合并这些两半，从而 

3343
02:06:57,940 --> 02:07:04,389
我们几乎 都做了所有左边的工作 

3344
02:07:01,179 --> 02:07:07,360
正确的工作， 一个是非常的

3345
02:07:04,389 --> 02:07:11,110
令人满意的 是这个 

3346
02:07:07,360 --> 02:07:13,030
gnome排序改善了事情 

3347
02:07:11,110 --> 02:07:14,409
非常完美，但它总是在制作 

3348
02:07:13,030 --> 02:07:18,000
转发进度，然后种 

3349
02:07:14,409 --> 02:07:18,000
翻倍和清理东西 

3350
02:07:25,020 --> 02:07:28,510
那是很多让我们称它为一天

3351
02:07:27,460 --> 02:07:29,430
坚持围绕一对单的问题 

3352
02:07:28,510 --> 02:07:34,049
我们会看到你下一次 

3353
02:07:29,430 --> 02:07:34,049
[掌声] 

