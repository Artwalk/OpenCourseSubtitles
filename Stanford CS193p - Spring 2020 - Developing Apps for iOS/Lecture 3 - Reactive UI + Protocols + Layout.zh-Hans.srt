1
00:00:00,553 --> 00:00:03,053
（轻音乐） 

2
00:00:04,970 --> 00:00:06,670
-[播音员]斯坦福大学。 

3
00:00:08,150 --> 00:00:09,820
-[老师]大家好，欢迎光临， 

4
00:00:09,820 --> 00:00:13,373
斯坦福CS193p 2020年春季。 

5
00:00:13,373 --> 00:00:15,350
这是第三讲。 

6
00:00:15,350 --> 00:00:18,070
我今天将从演示开始， 

7
00:00:18,070 --> 00:00:22,660
我们正在讨论的反应式SwiftUI内容的演示。 

8
00:00:22,660 --> 00:00:25,010
然后我要跳一些幻灯片， 

9
00:00:25,010 --> 00:00:28,320
多说一些Swift类型的系统， 

10
00:00:28,320 --> 00:00:30,570
特别是协议

11
00:00:30,570 --> 00:00:33,660
然后是一个完全不同的话题， 

12
00:00:33,660 --> 00:00:36,520
这是视图的布局系统， 

13
00:00:36,520 --> 00:00:39,900
它们如何在屏幕上布置。 

14
00:00:39,900 --> 00:00:41,160
如果时间允许， 

15
00:00:41,160 --> 00:00:43,400
我实际上将对该布局进行一些演示

16
00:00:43,400 --> 00:00:44,720
在今天结束时。 

17
00:00:44,720 --> 00:00:47,160
如果没有，它将被推迟到下一次。 

18
00:00:47,160 --> 00:00:48,740
下次我们一定要去

19
00:00:48,740 --> 00:00:52,360
在行和列中排列我们的卡片

20
00:00:52,360 --> 00:00:55,920
而不是像现在这样水平排列。 

21
00:00:55,920 --> 00:00:59,980
我们还将开始实际拥有我们的模型

22
00:00:59,980 --> 00:01:03,690
玩游戏并实现我们的一些逻辑。 

23
00:01:03,690 --> 00:01:06,413
但是现在，让我们来做这个反应式Swift演示。 

24
00:01:07,320 --> 00:01:09,730
你们现在真的很熟悉

25
00:01:09,730 --> 00:01:12,020
希望借助MVVM， 

26
00:01:12,020 --> 00:01:13,450
但是在我开始这个演示之前， 

27
00:01:13,450 --> 00:01:15,380
我要花一秒钟

28
00:01:15,380 --> 00:01:16,710
以防万一， 

29
00:01:16,710 --> 00:01:19,940
也许距离您做完作业已经过了几天。 

30
00:01:19,940 --> 00:01:21,870
这是我们的模型， 

31
00:01:21,870 --> 00:01:23,400
它称为MemoryGame。 

32
00:01:23,400 --> 00:01:25,480
它有这个不在乎CardContent 

33
00:01:25,480 --> 00:01:27,000
卡上有什么

34
00:01:27,000 --> 00:01:29,160
作为模型，我们不在乎。 

35
00:01:29,160 --> 00:01:30,650
这取决于用户界面

36
00:01:30,650 --> 00:01:34,220
它想在卡片上显示什么。 

37
00:01:34,220 --> 00:01:35,053
这是我们的卡。 

38
00:01:35,053 --> 00:01:39,390
这是此Card结构的数组。 

39
00:01:39,390 --> 00:01:43,490
这种选择使我们可以玩游戏。 

40
00:01:43,490 --> 00:01:45,350
我们还没有实现

41
00:01:45,350 --> 00:01:46,560
但是当您选择一张卡时， 

42
00:01:46,560 --> 00:01:50,160
那就是匹配发生的时间，诸如此类。 

43
00:01:50,160 --> 00:01:51,980
这是我们初始化的方式

44
00:01:51,980 --> 00:01:54,610
或创建我们的MemoryGame。 

45
00:01:54,610 --> 00:01:56,150
我们显然想指定

46
00:01:56,150 --> 00:01:58,400
我们的游戏中有几副牌， 

47
00:01:58,400 --> 00:02:01,306
我们需要一个cardContentFactory函数

48
00:02:01,306 --> 00:02:03,530
制作卡片上的内容

49
00:02:03,530 --> 00:02:05,600
因为对我们来说，这不在乎。 

50
00:02:05,600 --> 00:02:08,893
因此，需要照顾的人必须为我们做到这一点。 

51
00:02:09,870 --> 00:02:12,239
这是我们的ViewModel。 

52
00:02:12,239 --> 00:02:15,813
我们的ViewModel有一个var就是Model。 

53
00:02:15,813 --> 00:02:18,870
我们的ViewModel可以一次与模型对话。 

54
00:02:18,870 --> 00:02:22,730
它是视图模型的门户或门口

55
00:02:22,730 --> 00:02:25,050
因此它必须能够做到这一点。 

56
00:02:25,050 --> 00:02:29,410
请注意，这里没有指向视图的变量。 

57
00:02:29,410 --> 00:02:32,730
ViewModel从不与它的View对话。 

58
00:02:32,730 --> 00:02:35,784
是与ViewModel对话的View。 

59
00:02:35,784 --> 00:02:38,090
我们将看看

60
00:02:38,090 --> 00:02:41,860
和ViewModel互动，只需片刻

61
00:02:41,860 --> 00:02:43,060
但永远不会

62
00:02:43,060 --> 00:02:46,020
从ViewModel到View的任何连接

63
00:02:46,020 --> 00:02:47,940
因为很多很多不同的观点

64
00:02:47,940 --> 00:02:49,460
将使用此ViewModel， 

65
00:02:49,460 --> 00:02:52,320
这个门户，这个门，进入模型。 

66
00:02:52,320 --> 00:02:54,270
他们将使用它，共享它。 

67
00:02:54,270 --> 00:02:56,740
同样，这就是为什么我们的ViewModel是一个类。 

68
00:02:56,740 --> 00:02:58,750
它是指向堆中某物的指针。 

69
00:02:58,750 --> 00:03:01,920
分享指向的内容很容易。 

70
00:03:01,920 --> 00:03:04,530
所以我们的ViewModel也提供

71
00:03:04,530 --> 00:03:08,750
对模型的公共访问，否则为私有。 

72
00:03:08,750 --> 00:03:11,290
而且访问都在获取信息， 

73
00:03:11,290 --> 00:03:13,910
喜欢拿卡，也让

74
00:03:13,910 --> 00:03:15,820
视图表达其意图， 

75
00:03:15,820 --> 00:03:18,530
在这种情况下，要选择一张卡。 

76
00:03:18,530 --> 00:03:21,680
两者都非常容易通过我们的模型实施

77
00:03:21,680 --> 00:03:24,690
但这就是我们的ViewModels工作。 

78
00:03:24,690 --> 00:03:26,730
最后，我们有自己的观点。 

79
00:03:26,730 --> 00:03:31,730
在MVVM视图意义上，我们的视图中有两个视图。 

80
00:03:32,380 --> 00:03:35,110
一个是代表一张卡片的视图

81
00:03:35,110 --> 00:03:36,080
然后这个视图

82
00:03:36,080 --> 00:03:39,260
这是我们所有卡片的总和。 

83
00:03:39,260 --> 00:03:43,200
根据我从你们中得到的反馈

84
00:03:43,200 --> 00:03:44,930
这周做功课， 

85
00:03:44,930 --> 00:03:47,960
我想澄清一点， 

86
00:03:47,960 --> 00:03:49,810
通过澄清我们的想法

87
00:03:49,810 --> 00:03:53,060
我们用来形容事物的词。 

88
00:03:53,060 --> 00:03:56,280
你们当中有些人在说

89
00:03:56,280 --> 00:04:01,280
哦，我正在使用此功能设置卡的字体。 

90
00:04:03,080 --> 00:04:07,957
虽然我认为这是不正确的， 

91
00:04:09,510 --> 00:04:11,340
真的是一个更好的说法

92
00:04:11,340 --> 00:04:13,520
这个功能在这里

93
00:04:13,520 --> 00:04:17,190
修改我们发送到的视图， 

94
00:04:17,190 --> 00:04:21,270
以便使用此字体进行绘制。 

95
00:04:21,270 --> 00:04:22,940
那有什么区别？ 

96
00:04:22,940 --> 00:04:26,140
嗯，这是声明式编程之间的区别

97
00:04:26,140 --> 00:04:28,160
和命令式编程。 

98
00:04:28,160 --> 00:04:30,740
在声明中，我们只是在声明

99
00:04:30,740 --> 00:04:34,940
这是用于绘制此视图的字体， 

100
00:04:34,940 --> 00:04:38,080
而当务之急是，您在想诸如此类的事情， 

101
00:04:38,080 --> 00:04:39,730
哦，我叫这个功能

102
00:04:39,730 --> 00:04:43,720
在某个时刻设置字体， 

103
00:04:43,720 --> 00:04:44,553
我正在设置。 

104
00:04:44,553 --> 00:04:47,800
并且没有及时使用此声明。 

105
00:04:47,800 --> 00:04:49,500
在任何时候， 

106
00:04:49,500 --> 00:04:53,110
这应该绘制反映模型的视图

107
00:04:53,110 --> 00:04:54,500
它应该能够做到

108
00:04:54,500 --> 00:04:58,220
任何时候要求这个机构。 

109
00:04:58,220 --> 00:05:01,420
景气，应该是反映

110
00:05:01,420 --> 00:05:04,653
模型的状态，本质上是时间不敏感的。 

111
00:05:05,620 --> 00:05:08,750
关于这个身体的另一件事是这个变种， 

112
00:05:08,750 --> 00:05:11,552
您永远不会访问此变量。 

113
00:05:11,552 --> 00:05:15,520
下半身永远不会出现在您的代码中。 

114
00:05:15,520 --> 00:05:18,880
该主体由系统调用。 

115
00:05:18,880 --> 00:05:21,820
每当系统想要绘制时

116
00:05:21,820 --> 00:05:24,670
代表的模型视图， 

117
00:05:24,670 --> 00:05:28,170
它将调用此变量以获取该视图。 

118
00:05:28,170 --> 00:05:29,710
因此，这由系统调用。 

119
00:05:29,710 --> 00:05:34,710
您的工作是通过声明View是什么来实现它， 

120
00:05:35,530 --> 00:05:36,743
给定模型的当前状态

121
00:05:36,743 --> 00:05:40,589
通过该门户ViewModel看到的

122
00:05:40,589 --> 00:05:42,470
我想说的最后一件事

123
00:05:42,470 --> 00:05:46,970
这些ViewBuilder中有一些人， 

124
00:05:46,970 --> 00:05:51,600
例如在ForEach中，甚至在ZStack或HStack中。 

125
00:05:51,600 --> 00:05:54,890
记住这些是ViewBuilders，而ViewBuilders很酷

126
00:05:54,890 --> 00:05:57,840
因为它们是返回View的函数

127
00:05:57,840 --> 00:06:00,360
而且他们确实允许这种限制

128
00:06:00,360 --> 00:06:02,880
他们允许您只列出视图

129
00:06:02,880 --> 00:06:04,627
而不是必须将它们放入数组之类的东西中， 

130
00:06:04,627 --> 00:06:06,200
您可以列出它们。 

131
00:06:06,200 --> 00:06:08,840
人们想在这里放一个变种， 

132
00:06:08,840 --> 00:06:11,350
var x在这里等于某物。 

133
00:06:11,350 --> 00:06:14,840
当然，您不能在ViewBuilder中创建var。 

134
00:06:14,840 --> 00:06:19,310
无法在这些ViewBuilder中创建变量， 

135
00:06:19,310 --> 00:06:21,630
只是不允许创建var。 

136
00:06:21,630 --> 00:06:22,780
你是怎么做到的？ 

137
00:06:22,780 --> 00:06:24,000
有两种方法可以做到这一点。 

138
00:06:24,000 --> 00:06:27,120
第一，您可以将vars放在ViewBuilders之外， 

139
00:06:27,120 --> 00:06:29,360
只是在正常的功能上

140
00:06:29,360 --> 00:06:33,040
然后我可以在这里使用x 

141
00:06:33,040 --> 00:06:35,560
但是，如果我现在这样做的话，我已经创建了这两行， 

142
00:06:35,560 --> 00:06:38,480
我不得不说返回ZStack， 

143
00:06:38,480 --> 00:06:40,690
没关系，我可以做到。 

144
00:06:40,690 --> 00:06:42,970
另一种方法，也许是更常见的方法

145
00:06:42,970 --> 00:06:45,550
是创造另一个， 

146
00:06:45,550 --> 00:06:48,140
假设这想成为一个Int计算属性， 

147
00:06:48,140 --> 00:06:51,260
并只返回您希望x为的任何值

148
00:06:51,260 --> 00:06:52,770
现在您可以在此处使用x 

149
00:06:52,770 --> 00:06:55,560
它只是要使用这个计算属性

150
00:06:55,560 --> 00:06:58,340
计算它想要的x的值。 

151
00:06:58,340 --> 00:07:00,190
这就是我们处理的方式

152
00:07:00,190 --> 00:07:05,190
本质上创建局部变量或变量

153
00:07:05,420 --> 00:07:09,070
我们需要在这里画图。 

154
00:07:09,070 --> 00:07:11,813
这目前称为ContentView， 

155
00:07:11,813 --> 00:07:15,150
顺便说一句，因为那是我们开始的地方

156
00:07:15,150 --> 00:07:17,310
使用Xcode中的模板。 

157
00:07:17,310 --> 00:07:20,650
Xcode当时不知道我们在做一个记忆游戏

158
00:07:20,650 --> 00:07:22,550
因此将其称为ContentView。 

159
00:07:22,550 --> 00:07:23,810
在我们开始之前就想过

160
00:07:23,810 --> 00:07:25,980
我会告诉你如何重命名

161
00:07:25,980 --> 00:07:29,160
成为一个更好的名字。 

162
00:07:29,160 --> 00:07:31,840
现在您可能会想在导航器中执行此操作

163
00:07:31,840 --> 00:07:35,890
使用此处的搜索和替换功能。 

164
00:07:35,890 --> 00:07:38,230
您可以通过替换此处来做到这一点， 

165
00:07:38,230 --> 00:07:39,810
然后您可以搜索例如

166
00:07:39,810 --> 00:07:43,350
对于ContentView，它将发现

167
00:07:43,350 --> 00:07:45,020
它所引用的所有地方， 

168
00:07:45,020 --> 00:07:46,920
那么你可以用一些东西代替它

169
00:07:46,920 --> 00:07:50,939
例如EmojiMemoryGameView或类似的东西。 

170
00:07:50,939 --> 00:07:54,720
但是实际上，这不是我们要做的。 

171
00:07:54,720 --> 00:07:58,540
如果我们要更改var或类型的名称， 

172
00:07:58,540 --> 00:08:00,766
我们将使用重构。 

173
00:08:00,766 --> 00:08:03,360
所以我们要做的就是压低

174
00:08:03,360 --> 00:08:06,890
Command键，Command +单击。 

175
00:08:06,890 --> 00:08:08,130
当我们按下Command +单击时， 

176
00:08:08,130 --> 00:08:09,380
我们在这里得到这个不错的菜单

177
00:08:09,380 --> 00:08:11,930
在这里我们可以跳转到类型的定义

178
00:08:11,930 --> 00:08:14,380
或var之类的东西。 

179
00:08:14,380 --> 00:08:15,990
我们也可以重命名。 

180
00:08:15,990 --> 00:08:17,880
因此，我们执行Command +单击， 

181
00:08:17,880 --> 00:08:19,970
我们将重命名。 

182
00:08:19,970 --> 00:08:22,330
它向我们展示了所有地方

183
00:08:22,330 --> 00:08:23,807
它发现了ContentView， 

184
00:08:23,807 --> 00:08:27,060
本质上与我们在此处进行搜索相同。 

185
00:08:27,060 --> 00:08:28,570
其中一些会改变， 

186
00:08:28,570 --> 00:08:31,350
你可以用这个小勾号告诉

187
00:08:31,350 --> 00:08:32,830
事情将会改变。 

188
00:08:32,830 --> 00:08:35,880
因此，它将更改此文件名， 

189
00:08:35,880 --> 00:08:38,050
因此，它将要更改其名称，这很好。 

190
00:08:38,050 --> 00:08:41,580
这里显示了评论ContentView 

191
00:08:41,580 --> 00:08:42,900
但这不会改变。 

192
00:08:42,900 --> 00:08:44,770
您会看到它不是蓝色，而是灰色。 

193
00:08:44,770 --> 00:08:46,060
只是说，我发现了这个， 

194
00:08:46,060 --> 00:08:47,150
但我不会改变

195
00:08:47,150 --> 00:08:50,100
因为我不确定那真的是指

196
00:08:50,100 --> 00:08:51,800
这种类型，因为它在注释中。 

197
00:08:51,800 --> 00:08:54,260
所以我们必须自己改变它。 

198
00:08:54,260 --> 00:08:57,140
这个var preViews将会在这里改变。 

199
00:08:57,140 --> 00:08:58,210
那实际上就是那个代码

200
00:08:58,210 --> 00:09:02,270
我们在显示的一开始就滚开了

201
00:09:02,270 --> 00:09:05,630
我们的ContentView在此处的灰色预览窗口中， 

202
00:09:05,630 --> 00:09:07,630
因此显然需要进行更改。 

203
00:09:07,630 --> 00:09:10,180
这是场景委托中的代码

204
00:09:10,180 --> 00:09:12,790
我们实际上在创建记忆游戏的地方

205
00:09:12,790 --> 00:09:15,993
然后将其传递到此顶级ContentView中。 

206
00:09:16,890 --> 00:09:20,150
因此，当您执行Command +单击并重命名时， 

207
00:09:20,150 --> 00:09:23,270
它实际上会选择您要执行的命令并单击

208
00:09:23,270 --> 00:09:24,760
您可以输入新内容。 

209
00:09:24,760 --> 00:09:29,380
所以EmojiMemoryGameView，看看

210
00:09:29,380 --> 00:09:32,890
它正在其他所有地方都在改变它，尽管不在这里。 

211
00:09:32,890 --> 00:09:33,723
就是这样。 

212
00:09:33,723 --> 00:09:35,830
所以你就在这里点击这个重命名

213
00:09:35,830 --> 00:09:36,800
它已经重命名了， 

214
00:09:36,800 --> 00:09:40,400
即使是这里的文件名也被很好地重命名。 

215
00:09:40,400 --> 00:09:43,110
我们可以回去修复这些东西

216
00:09:43,110 --> 00:09:44,400
不确定

217
00:09:44,400 --> 00:09:46,240
诸如评论之类的东西， 

218
00:09:46,240 --> 00:09:51,240
例如，这是我们的EmojiMemoryGameView.swift 

219
00:09:51,680 --> 00:09:53,700
是此文件的名称。 

220
00:09:53,700 --> 00:09:56,630
所以这只是重命名的一小部分

221
00:09:56,630 --> 00:09:57,990
因为有时候你会选一个名字

222
00:09:57,990 --> 00:10:00,650
类型或变量，然后您将决定

223
00:10:00,650 --> 00:10:02,390
我真的不喜欢那个名字，不是， 

224
00:10:02,390 --> 00:10:05,240
因为命名真的非常非常重要。 

225
00:10:05,240 --> 00:10:06,960
不能过分强调它的重要性

226
00:10:06,960 --> 00:10:08,900
为事物取好名字。 

227
00:10:08,900 --> 00:10:11,900
因此，当您改变主意后能够重命名， 

228
00:10:11,900 --> 00:10:13,450
非常非常重要

229
00:10:13,450 --> 00:10:17,490
但是，今天我们的话题将是这种反应。 

230
00:10:17,490 --> 00:10:19,730
我告诉你SwiftUI是反应式的。 

231
00:10:19,730 --> 00:10:21,970
反应是什么意思？ 

232
00:10:21,970 --> 00:10:24,170
我的意思是，当模型发生变化时， 

233
00:10:24,170 --> 00:10:28,470
它们将自动显示在“视图”中。 

234
00:10:28,470 --> 00:10:32,300
目前，我们的用户界面还没有反应。 

235
00:10:32,300 --> 00:10:33,810
所以这是一个问题。 

236
00:10:33,810 --> 00:10:37,250
让我们看看如何解决该问题

237
00:10:37,250 --> 00:10:38,840
并使其具有反应性。 

238
00:10:38,840 --> 00:10:42,840
我们不会在这里实现整个记忆游戏

239
00:10:42,840 --> 00:10:44,100
与所有匹配的卡片。 

240
00:10:44,100 --> 00:10:45,930
我们只是要向前迈出一步

241
00:10:45,930 --> 00:10:48,650
这就是我们要使卡片翻转的原因。 

242
00:10:48,650 --> 00:10:51,000
这是我们模型的一部分。 

243
00:10:51,000 --> 00:10:54,310
本质上是我们游戏逻辑的第一步

244
00:10:54,310 --> 00:10:55,810
是要有一张卡， 

245
00:10:55,810 --> 00:10:57,260
当我们选择它时，翻过来。 

246
00:10:57,260 --> 00:10:59,820
所以我已经移到了我的模型代码

247
00:10:59,820 --> 00:11:02,260
目前我们只说选择的卡片

248
00:11:02,260 --> 00:11:03,360
当您触摸卡片时， 

249
00:11:03,360 --> 00:11:04,930
记得从上次开始。 

250
00:11:04,930 --> 00:11:07,930
现在我想开始实际实现我的游戏逻辑

251
00:11:07,930 --> 00:11:09,823
首先将卡翻转过来。 

252
00:11:11,070 --> 00:11:13,160
现在，您将看到这个，然后您会认为， 

253
00:11:13,160 --> 00:11:14,610
哦，这很容易。 

254
00:11:14,610 --> 00:11:19,610
Card.isFaceUp等于不等于card.isFaceUp，对吗？ 

255
00:11:20,840 --> 00:11:22,970
有人通过我们的卡

256
00:11:22,970 --> 00:11:25,050
他们想选择一个参数

257
00:11:25,050 --> 00:11:27,700
我只是要面对它

258
00:11:28,660 --> 00:11:32,750
在这里被切换或翻转到相反的方向。 

259
00:11:32,750 --> 00:11:36,180
这是一个错误， 

260
00:11:36,180 --> 00:11:37,730
无法分配给属性。 

261
00:11:37,730 --> 00:11:39,300
卡是一个让常量。 

262
00:11:39,300 --> 00:11:44,300
函数的所有参数本质上都是允许的。 

263
00:11:44,850 --> 00:11:47,100
您不键入该让，但它们是一个让。 

264
00:11:47,100 --> 00:11:49,260
这是一个问题。 

265
00:11:49,260 --> 00:11:51,800
但这实际上比这糟得多。 

266
00:11:51,800 --> 00:11:54,900
这不只是让它出租。 

267
00:11:54,900 --> 00:11:56,880
这是一张卡。 

268
00:11:56,880 --> 00:11:58,800
卡是一种结构。 

269
00:11:58,800 --> 00:12:03,800
结构是我们上次谈到的值类型。 

270
00:12:04,530 --> 00:12:08,500
记住，每次都会复制一个值类型

271
00:12:08,500 --> 00:12:10,400
它作为参数传递给函数

272
00:12:10,400 --> 00:12:13,440
甚至分配给另一个变量副本，副本，副本。 

273
00:12:13,440 --> 00:12:15,000
它总是被复制。 

274
00:12:15,000 --> 00:12:19,820
所以这里的这张卡是这里一张卡的副本。 

275
00:12:19,820 --> 00:12:24,210
新的ViewModel将其获取或分发给View 

276
00:12:24,210 --> 00:12:26,650
当视图获得时，它就是副本， 

277
00:12:26,650 --> 00:12:28,470
甚至一个副本。 

278
00:12:28,470 --> 00:12:31,850
所以这实际上不是阵列中的Card， 

279
00:12:31,850 --> 00:12:33,840
这是一个副本。 

280
00:12:33,840 --> 00:12:37,870
每次我们传递值类型时，它都会被复制。 

281
00:12:37,870 --> 00:12:39,610
所以即使我们可以做到

282
00:12:39,610 --> 00:12:41,660
我们不能因为那个问题而在这里

283
00:12:41,660 --> 00:12:43,790
本质上是一个让， 

284
00:12:43,790 --> 00:12:45,540
无论如何，这不会做对的事情。 

285
00:12:45,540 --> 00:12:49,360
这只会改变这个家伙的空间

286
00:12:49,360 --> 00:12:53,340
被交换对这里的这个没有影响。 

287
00:12:53,340 --> 00:12:55,860
因此，让我们在这里尝试完全不同的东西。 

288
00:12:55,860 --> 00:12:59,060
让我们尝试找出索引

289
00:12:59,060 --> 00:13:03,570
该卡在此阵列中的哪个卡。 

290
00:13:03,570 --> 00:13:06,760
我要说的是letedIndex， 

291
00:13:06,760 --> 00:13:09,000
这将是Int类型， 

292
00:13:09,000 --> 00:13:10,380
我等于

293
00:13:10,380 --> 00:13:15,370
我要给自己调用一个函数，该卡的索引。 

294
00:13:15,370 --> 00:13:18,041
所以索引我要写一个函数， 

295
00:13:18,041 --> 00:13:21,130
这将是这张卡的功能。 

296
00:13:21,130 --> 00:13:23,030
所以我要找到这张卡

297
00:13:23,030 --> 00:13:25,694
找出它在此数组中的索引。 

298
00:13:25,694 --> 00:13:29,700
因此，您具有的func索引将成为类型Card， 

299
00:13:29,700 --> 00:13:31,970
它会返回一个Int， 

300
00:13:31,970 --> 00:13:35,940
并且此Int将成为此Array的索引。 

301
00:13:35,940 --> 00:13:39,340
现在也许我会说让letedCard， 

302
00:13:39,340 --> 00:13:41,260
这将是类型卡

303
00:13:41,260 --> 00:13:45,413
在那个selectedIndex等于我的牌。 

304
00:13:46,889 --> 00:13:48,020
这听起来不错。 

305
00:13:48,020 --> 00:13:51,322
现在我可以说现在让我们翻转卡片， 

306
00:13:51,322 --> 00:13:56,263
isFaceUp等于未选择Card.isFaceUp。 

307
00:13:59,100 --> 00:14:01,350
所以这似乎是个好主意， 

308
00:14:01,350 --> 00:14:02,970
我们将在一分钟内实现它， 

309
00:14:02,970 --> 00:14:04,900
但这似乎很棒。 

310
00:14:04,900 --> 00:14:08,520
现在，我们从阵列中取出卡

311
00:14:08,520 --> 00:14:10,780
我们将其翻转过来。 

312
00:14:10,780 --> 00:14:15,520
但这也不会出于完全相同的原因而起作用。 

313
00:14:15,520 --> 00:14:20,370
当我们分配一个变种给这个选择的卡片时， 

314
00:14:20,370 --> 00:14:25,000
这等于将其复制到此处。 

315
00:14:25,000 --> 00:14:27,680
它将卡从阵列中复制出来。 

316
00:14:27,680 --> 00:14:30,020
所以即使只是做一个作业

317
00:14:30,020 --> 00:14:34,181
到另一个变量将复制值类型。 

318
00:14:34,181 --> 00:14:35,790
所以现在您可能会喜欢

319
00:14:35,790 --> 00:14:38,620
好吧，我们将如何改变这个东西？ 

320
00:14:38,620 --> 00:14:41,130
好吧，我们必须对其进行更改。 

321
00:14:41,130 --> 00:14:44,650
而不是在这里更改此副本， 

322
00:14:44,650 --> 00:14:46,940
我们将要更改此数组本身， 

323
00:14:46,940 --> 00:14:48,510
这一系列的卡片， 

324
00:14:48,510 --> 00:14:51,050
我们将到达那里并改变任何一个

325
00:14:51,050 --> 00:14:53,857
是适合作为不同FaceUp的卡片。 

326
00:14:55,050 --> 00:14:56,260
所以我们要去做。 

327
00:14:56,260 --> 00:15:00,720
仍然要做self.cards selectedIndex， 

328
00:15:00,720 --> 00:15:02,900
但不是通过var进行这种间接

329
00:15:02,900 --> 00:15:04,030
那会复制它， 

330
00:15:04,030 --> 00:15:06,850
我将直接拥有那个东西

331
00:15:06,850 --> 00:15:11,553
FaceUp等于不是那个东西直接是FaceUp。 

332
00:15:13,242 --> 00:15:14,810
所以我要把卡片翻过来

333
00:15:14,810 --> 00:15:16,900
直接在数组内部。 

334
00:15:16,900 --> 00:15:18,980
这里发生了几件事。 

335
00:15:18,980 --> 00:15:22,220
一，注意我把self。放在前面

336
00:15:22,220 --> 00:15:25,760
对我的变量的每次访问

337
00:15:25,760 --> 00:15:28,880
和功能，我呼吁自己。 

338
00:15:28,880 --> 00:15:33,430
在大多数情况下，此self。是可选的。 

339
00:15:33,430 --> 00:15:36,443
通常我什至会说，不要把它放在那里。 

340
00:15:36,443 --> 00:15:39,450
这只是额外的提示。 

341
00:15:39,450 --> 00:15:43,010
但是，由于这个原因，我上次谈到

342
00:15:43,010 --> 00:15:44,620
他们要去哪里

343
00:15:44,620 --> 00:15:46,110
所以即使在少数情况下

344
00:15:46,110 --> 00:15:47,660
您确实需要自我的地方。 

345
00:15:47,660 --> 00:15:50,210
像这里，self。实际上是必需的

346
00:15:50,210 --> 00:15:53,520
在我们的视图中，当我们进行点击手势时，这个自我。 

347
00:15:53,520 --> 00:15:54,653
如果把这个拿走

348
00:15:54,653 --> 00:15:55,840
会有错误， 

349
00:15:55,840 --> 00:15:59,010
您必须修复它，还记得吗？ 

350
00:15:59,010 --> 00:16:00,650
所以他们要把这个拿走。 

351
00:16:00,650 --> 00:16:02,240
当他们拿走那东西时， 

352
00:16:02,240 --> 00:16:05,020
那么您将需要自我。几乎无处。 

353
00:16:05,020 --> 00:16:06,440
所以在那个时候

354
00:16:06,440 --> 00:16:08,590
我不知道那是两个月后

355
00:16:09,570 --> 00:16:10,460
还不清楚

356
00:16:10,460 --> 00:16:13,140
WWDC是在六月初。 

357
00:16:13,140 --> 00:16:14,180
很多时候他们会出来

358
00:16:14,180 --> 00:16:16,460
使用新软件，测试版软件， 

359
00:16:16,460 --> 00:16:17,900
至少在那时

360
00:16:17,900 --> 00:16:19,460
也许他们会解决的，我不知道。 

361
00:16:19,460 --> 00:16:20,550
我不在苹果公司工作

362
00:16:20,550 --> 00:16:23,040
我不知道他们的计划是什么， 

363
00:16:23,040 --> 00:16:26,080
但我们确实知道它已被公开批准

364
00:16:26,080 --> 00:16:28,050
摆脱自我

365
00:16:28,050 --> 00:16:29,390
所以在这个过程中

366
00:16:29,390 --> 00:16:34,180
仅在本课程剩下的七八周内， 

367
00:16:34,180 --> 00:16:36,070
我有点推荐也许只是把

368
00:16:36,070 --> 00:16:37,630
自我在一切面前

369
00:16:37,630 --> 00:16:39,540
因为它不会伤害任何东西

370
00:16:39,540 --> 00:16:42,140
这样可以避免您遇到此问题

371
00:16:42,140 --> 00:16:43,973
您必须在哪里进行修复。 

372
00:16:44,970 --> 00:16:49,500
您只是在学习这些东西，这将会

373
00:16:49,500 --> 00:16:52,260
带给您经常打字自我的肌肉记忆。 

374
00:16:52,260 --> 00:16:54,640
您必须训练自己

375
00:16:54,640 --> 00:16:59,400
在此公开修复程序发布后的几个月内。 

376
00:16:59,400 --> 00:17:01,710
但这会让您在本季度摆脱困境。 

377
00:17:01,710 --> 00:17:03,560
那是我的建议

378
00:17:03,560 --> 00:17:06,470
但是在您的作业中，我们不会说

379
00:17:06,470 --> 00:17:08,190
哦，那是错误的，你把自己放了。， 

380
00:17:08,190 --> 00:17:09,927
或哦，那是错误的，你没有自我介绍。 

381
00:17:09,927 --> 00:17:11,980
这完全取决于您。 

382
00:17:11,980 --> 00:17:15,380
我只是想为您解决可能的问题。 

383
00:17:15,380 --> 00:17:19,353
因此，自我追求可能是我的建议。 

384
00:17:21,736 --> 00:17:24,415
但是（笑）我们把它放在这里

385
00:17:24,415 --> 00:17:26,980
而且我们确定这会成功。 

386
00:17:26,980 --> 00:17:30,670
我们确定要更改isFaceUp和该数组， 

387
00:17:30,670 --> 00:17:33,415
毫无疑问，selectedIndex的self.cards。 

388
00:17:33,415 --> 00:17:38,415
我们正在更改此数组以使其切换为isFaceUp， 

389
00:17:38,840 --> 00:17:40,970
但是我们这里仍然有一个错误， 

390
00:17:40,970 --> 00:17:45,320
无法分配给属性：自我是不可变的。 

391
00:17:45,320 --> 00:17:48,350
并不是说这张卡是一成不变的

392
00:17:48,350 --> 00:17:50,940
因为卡不是，所以是变种。 

393
00:17:50,940 --> 00:17:53,090
如果放手，那将是一成不变的， 

394
00:17:53,090 --> 00:17:55,150
但这是一个变种，所以是可变的， 

395
00:17:55,150 --> 00:17:59,800
但是它本身就是一成不变的。 

396
00:17:59,800 --> 00:18:02,070
换句话说，我们自己的功能

397
00:18:02,070 --> 00:18:06,513
似乎无法改变我们的自我。 

398
00:18:07,730 --> 00:18:10,760
如果我们做不到，那该怎么办呢？ 

399
00:18:10,760 --> 00:18:13,180
好吧，这是怎么回事

400
00:18:13,180 --> 00:18:16,520
是我告诉你这些值类型

401
00:18:16,520 --> 00:18:19,110
Swift没有做按位复制， 

402
00:18:19,110 --> 00:18:23,030
实际上不是从内存中的一个位置复制它们

403
00:18:23,030 --> 00:18:25,970
当您将它们传递给另一个时。 

404
00:18:25,970 --> 00:18:27,220
这就是语义

405
00:18:27,220 --> 00:18:29,640
那就是你要想象它正在发生的方式， 

406
00:18:29,640 --> 00:18:32,500
但这实际上只是制作这些副本

407
00:18:32,500 --> 00:18:35,430
当您开始更改某些内容时， 

408
00:18:35,430 --> 00:18:36,920
我们正在这里做。 

409
00:18:36,920 --> 00:18:39,240
我们正在改变这个数组

410
00:18:39,240 --> 00:18:42,420
这是我们的实际财产， 

411
00:18:42,420 --> 00:18:43,690
所以我们不复印

412
00:18:43,690 --> 00:18:45,260
实际上是在改变数组， 

413
00:18:45,260 --> 00:18:49,780
但是这种方法改变了我们的自我。 

414
00:18:49,780 --> 00:18:51,060
它改变了我们的自我

415
00:18:51,060 --> 00:18:52,950
因为它改变了我们的牌。 

416
00:18:52,950 --> 00:18:55,560
所以我们必须通过说让Swift知道这一点

417
00:18:55,560 --> 00:18:58,210
这是一个变异函数。 

418
00:18:58,210 --> 00:19:01,660
所以所有修改自我的功能

419
00:19:01,660 --> 00:19:04,630
必须在结构中标记为变异。 

420
00:19:04,630 --> 00:19:06,400
这在课堂上是不正确的。 

421
00:19:06,400 --> 00:19:08,260
类在堆中。 

422
00:19:08,260 --> 00:19:09,430
我们有指向他们的指针。 

423
00:19:09,430 --> 00:19:12,100
我们总是可以更改堆中的内容， 

424
00:19:12,100 --> 00:19:14,910
总是通过指针修改事物， 

425
00:19:14,910 --> 00:19:16,620
正如我之前所说， 

426
00:19:16,620 --> 00:19:19,700
可以和一件好事一样是一件坏事。 

427
00:19:19,700 --> 00:19:21,820
但是对于结构，不，因为它们是值类型

428
00:19:21,820 --> 00:19:25,160
我们必须让Swift知道我们正在对此进行更改。 

429
00:19:25,160 --> 00:19:28,130
现在，索引，我们将在这里写一秒钟， 

430
00:19:28,130 --> 00:19:31,990
它只是获取此阵列中Card的索引。 

431
00:19:31,990 --> 00:19:33,610
它实际上并没有改变任何东西。 

432
00:19:33,610 --> 00:19:34,880
它只是获取索引。 

433
00:19:34,880 --> 00:19:38,280
因此，它不需要或不想在这里进行变异。 

434
00:19:38,280 --> 00:19:41,410
同样或相反， 

435
00:19:41,410 --> 00:19:45,430
我们的初始化器隐式地改变了我们的自我。 

436
00:19:45,430 --> 00:19:46,630
我们正在创造自我。 

437
00:19:46,630 --> 00:19:49,500
我们在这里设置所有变量。 

438
00:19:49,500 --> 00:19:51,360
所以这当然是变异的

439
00:19:51,360 --> 00:19:53,390
所以你不用说变异了。 

440
00:19:53,390 --> 00:19:55,647
所有的初始化都是变异的。 

441
00:19:55,647 --> 00:19:59,670
这都是价值类型很酷的功能的一部分

442
00:19:59,670 --> 00:20:02,010
Swift知道他们何时进行更改。 

443
00:20:02,010 --> 00:20:05,110
而且您会发现它还有其他好处

444
00:20:05,110 --> 00:20:07,210
除了这个副本

445
00:20:07,210 --> 00:20:10,063
当我们复制事物时保持正确的行为。 

446
00:20:11,190 --> 00:20:15,783
卡的索引，我们如何找出该卡的位置

447
00:20:15,783 --> 00:20:18,590
我们得到的索引是在这个数组中？ 

448
00:20:18,590 --> 00:20:22,200
我们想要具有该卡的该数组的索引。 

449
00:20:22,200 --> 00:20:24,820
事实证明，这对我们来说超级容易

450
00:20:24,820 --> 00:20:28,740
因为卡是可识别的。 

451
00:20:28,740 --> 00:20:29,960
由于它是可识别的， 

452
00:20:29,960 --> 00:20:31,960
我们可以看看它的ID 

453
00:20:31,960 --> 00:20:34,860
并唯一地查看它是哪张卡。 

454
00:20:34,860 --> 00:20:37,280
所以我们只需要在这里做一些for循环

455
00:20:37,280 --> 00:20:42,280
如果零点索引的索引少于我们的卡数， 

456
00:20:42,310 --> 00:20:44,340
还是再一次，如果我们正在做自我点， 

457
00:20:44,340 --> 00:20:48,561
self.cards.count，无论哪种方式都很好。 

458
00:20:48,561 --> 00:20:49,730
我只是要经历每一个

459
00:20:49,730 --> 00:20:53,850
我要说的是self.cards在那个索引上

460
00:20:53,850 --> 00:20:58,850
id在这里等于这个东西， 

461
00:20:59,950 --> 00:21:01,670
顺便说一句，两个等于

462
00:21:01,670 --> 00:21:06,070
我想，点号，那么我可以返回

463
00:21:06,070 --> 00:21:07,920
这个索引是因为我找到了它。 

464
00:21:07,920 --> 00:21:09,770
在这里，我正在看我的数组

465
00:21:09,770 --> 00:21:12,730
查看索引，如果卡片在该索引， 

466
00:21:12,730 --> 00:21:16,060
它的ID与您传递的ID相同。 

467
00:21:16,060 --> 00:21:20,853
现在，您已经可以在这里真正看到一个问题了。 

468
00:21:21,710 --> 00:21:24,070
我们将这个变量称为，不。 

469
00:21:24,070 --> 00:21:25,950
我们不想这样称呼。 

470
00:21:25,950 --> 00:21:28,260
Of只是对人们有益的东西

471
00:21:28,260 --> 00:21:31,640
谁叫我们说卡的自我索引。 

472
00:21:31,640 --> 00:21:36,640
这就是为什么我们要使用双重标签

473
00:21:36,830 --> 00:21:39,327
外部名称，内部名称。 

474
00:21:39,327 --> 00:21:43,350
这样我们就可以将此卡号称为ID 

475
00:21:43,350 --> 00:21:47,370
但是呼叫者仍然可以说出卡片索引。 

476
00:21:47,370 --> 00:21:48,910
希望这是一个很好的例子， 

477
00:21:48,910 --> 00:21:51,517
完全明白为什么我们有外部名称

478
00:21:51,517 --> 00:21:54,160
和参数的内部名称。 

479
00:21:54,160 --> 00:21:55,490
我们没有在这里做。 

480
00:21:55,490 --> 00:21:58,630
外部名称和内部名称相同。 

481
00:21:58,630 --> 00:22:00,030
这里有点争论

482
00:22:00,030 --> 00:22:03,210
您可能实际上选择了下栏

483
00:22:03,210 --> 00:22:05,900
因为很明显，我们正在选择一张卡

484
00:22:05,900 --> 00:22:07,670
这就是这种说法的类型

485
00:22:07,670 --> 00:22:09,850
无论如何我们还会选择什么？ 

486
00:22:09,850 --> 00:22:11,270
但我要这样离开

487
00:22:11,270 --> 00:22:12,850
只是这样，我们不必更改其他代码。 

488
00:22:12,850 --> 00:22:15,110
但是如果您阅读指南

489
00:22:15,110 --> 00:22:16,440
作为上周作业的一部分， 

490
00:22:16,440 --> 00:22:17,860
您会看到这是一个

491
00:22:17,860 --> 00:22:20,240
那里可能有一个酒吧

492
00:22:20,240 --> 00:22:22,740
然后人们会选择

493
00:22:22,740 --> 00:22:24,420
并提供Card作为参数， 

494
00:22:24,420 --> 00:22:26,970
呼叫者将没有标签。 

495
00:22:26,970 --> 00:22:29,806
我们已经完成了for循环，我们找到了这个。 

496
00:22:29,806 --> 00:22:31,630
这里还在抱怨什么？ 

497
00:22:31,630 --> 00:22:35,400
函数预期返回Int中缺少返回。 

498
00:22:35,400 --> 00:22:38,810
哦，是的，如果这个for循环一直进行下去

499
00:22:38,810 --> 00:22:41,370
却找不到那个卡？ 

500
00:22:41,370 --> 00:22:44,193
然后我们必须在这里退货。 

501
00:22:45,070 --> 00:22:48,610
所以Swift实际上有一件很棒的事情

502
00:22:48,610 --> 00:22:51,250
发生这种情况时返回这里

503
00:22:51,250 --> 00:22:54,230
就像您去寻找东西一样，您找不到它。 

504
00:22:54,230 --> 00:22:55,180
用其他语言

505
00:22:55,180 --> 00:23:00,180
您可能会在这里退回一件或几件虚假物品。 

506
00:23:01,360 --> 00:23:04,400
我想我会回来，也许你会归零

507
00:23:04,400 --> 00:23:05,830
这是第一个要素

508
00:23:05,830 --> 00:23:07,067
这是完全错误的。 

509
00:23:07,067 --> 00:23:09,340
如果您去找卡，却找不到它， 

510
00:23:09,340 --> 00:23:11,180
你会说，好吧，归还第一张卡

511
00:23:11,180 --> 00:23:13,630
即使您知道那不是卡。 

512
00:23:13,630 --> 00:23:16,640
所以我们现在回到这里并不重要

513
00:23:16,640 --> 00:23:18,370
因为这都是错误的。 

514
00:23:18,370 --> 00:23:19,810
但是我要放一点东西

515
00:23:19,810 --> 00:23:23,900
在这里叫一个TODO，然后说假的。 

516
00:23:23,900 --> 00:23:26,730
TODO是您以后可以回头的东西， 

517
00:23:26,730 --> 00:23:28,080
斜线斜线TODO， 

518
00:23:28,080 --> 00:23:31,720
并提醒自己您需要解决此问题。 

519
00:23:31,720 --> 00:23:34,380
这些出现在顶部

520
00:23:34,380 --> 00:23:35,390
它说索引。 

521
00:23:35,390 --> 00:23:36,460
如果单击

522
00:23:36,460 --> 00:23:38,710
这是我所有的变量和函数的列表， 

523
00:23:38,710 --> 00:23:40,267
看起来虚假出现在那儿。 

524
00:23:40,267 --> 00:23:42,940
如果我单击它，则需要我进行虚假验证。 

525
00:23:42,940 --> 00:23:46,200
当我向您展示这种很酷的方式时，我们会回来的

526
00:23:46,200 --> 00:23:47,670
你可以退还东西

527
00:23:47,670 --> 00:23:49,880
就像我在Swift中找不到它一样。 

528
00:23:49,880 --> 00:23:52,600
我们将在下一次讲座中介绍

529
00:23:52,600 --> 00:23:54,277
我们将修复此问题，我们将修复此问题。 

530
00:23:54,277 --> 00:23:57,510
但是现在，我们要在这里做这个假的事情。 

531
00:23:57,510 --> 00:23:59,300
所以我们有卡索引。 

532
00:23:59,300 --> 00:24:02,050
我们绝对是在这里翻转卡。 

533
00:24:02,050 --> 00:24:05,290
因此，让我们运行，看看它是否有效。 

534
00:24:05,290 --> 00:24:06,910
因为我们知道我们已经有了这个

535
00:24:06,910 --> 00:24:08,750
钩在那里选择卡。 

536
00:24:08,750 --> 00:24:10,920
所以现在应该选择，例如选择卡片

537
00:24:10,920 --> 00:24:13,110
然后将它翻转过来，就可以开始了

538
00:24:13,110 --> 00:24:14,870
准备好了，鬼。 

539
00:24:14,870 --> 00:24:17,610
哦，南瓜。 

540
00:24:17,610 --> 00:24:21,840
好吧，这肯定是在这里访问模型

541
00:24:21,840 --> 00:24:24,280
因为我们正在选择这张卡。 

542
00:24:24,280 --> 00:24:26,900
但是，这些卡为何面朝上呢？ 

543
00:24:26,900 --> 00:24:29,120
这里发生了什么？ 

544
00:24:29,120 --> 00:24:30,380
好吧，这是怎么回事

545
00:24:30,380 --> 00:24:33,670
是我们还没有实施反应性的东西。 

546
00:24:33,670 --> 00:24:35,440
我一开始就告诉你

547
00:24:35,440 --> 00:24:37,100
这就是为什么我们今天在这里， 

548
00:24:37,100 --> 00:24:38,850
是要做这种反应性的事情。 

549
00:24:38,850 --> 00:24:41,310
您会看到为什么我们需要反应堆。 

550
00:24:41,310 --> 00:24:43,140
我们选择了一张卡， 

551
00:24:43,140 --> 00:24:45,310
它去了这里，改变了模型， 

552
00:24:45,310 --> 00:24:47,260
它翻转了一张卡片， 

553
00:24:47,260 --> 00:24:49,800
但是我们在用户界面中什么都没有看到。 

554
00:24:49,800 --> 00:24:53,410
而且在SwiftUI中永远不会是这种情况。 

555
00:24:53,410 --> 00:24:57,300
更改模型时，UI应更新。 

556
00:24:57,300 --> 00:24:59,700
我们如何做到这一点？ 

557
00:24:59,700 --> 00:25:02,560
如果您记得我的MVVM幻灯片， 

558
00:25:02,560 --> 00:25:05,430
我在屏幕上放了一些关键字

559
00:25:05,430 --> 00:25:07,390
我说，哦，这些Swift关键字， 

560
00:25:07,390 --> 00:25:10,070
我们将用那些来做这种反应

561
00:25:10,070 --> 00:25:12,470
而这正是我们现在要做的。 

562
00:25:12,470 --> 00:25:14,800
我们将从ViewModel开始。 

563
00:25:14,800 --> 00:25:17,240
这是我们的ViewModel。 

564
00:25:17,240 --> 00:25:20,650
以及我们使ViewModel参与的方式

565
00:25:20,650 --> 00:25:24,360
在这种反应性的东西中使用约束

566
00:25:24,360 --> 00:25:27,580
并获得称为ObservableObject的东西。 

567
00:25:28,640 --> 00:25:31,500
现在记住限制和收获， 

568
00:25:31,500 --> 00:25:34,000
也被称为协议。 

569
00:25:34,000 --> 00:25:35,620
这些制约和收获， 

570
00:25:35,620 --> 00:25:38,510
我们在这里用过一个，结肠视图， 

571
00:25:38,510 --> 00:25:40,090
那是一个制约和收获。 

572
00:25:40,090 --> 00:25:41,640
我们有点束缚

573
00:25:41,640 --> 00:25:43,570
我们必须实施这个机构

574
00:25:43,570 --> 00:25:46,440
但是我们获得了所有其他功能

575
00:25:46,440 --> 00:25:47,630
我们可以发送给View。 

576
00:25:47,630 --> 00:25:49,970
所以这是一个巨大的收获

577
00:25:49,970 --> 00:25:53,640
因为我们的限制很小，请点击此处查看。 

578
00:25:53,640 --> 00:25:56,350
我们也在模型，卡片中做到了。 

579
00:25:56,350 --> 00:25:59,360
我们做了一些限制，并取得了可识别的收益， 

580
00:25:59,360 --> 00:26:02,720
这要求我们执行此var id Int， 

581
00:26:02,720 --> 00:26:07,150
但是现在我们可以分辨哪张卡了。 

582
00:26:07,150 --> 00:26:09,310
UI将在此处使用

583
00:26:09,310 --> 00:26:13,120
在此ForEach中，以确保我们的卡是否到处移动

584
00:26:13,120 --> 00:26:16,010
或其他方式，我们可以跟踪它们的位置并为其设置动画。 

585
00:26:16,010 --> 00:26:17,840
您将在SwiftUI中看到动画， 

586
00:26:17,840 --> 00:26:20,870
这非常容易，而且很多

587
00:26:20,870 --> 00:26:22,483
因为这种机制。 

588
00:26:23,560 --> 00:26:26,210
所以这就是制约和收获， 

589
00:26:26,210 --> 00:26:28,410
约束几乎没有。 

590
00:26:28,410 --> 00:26:31,400
您无需实现任何var或funcs， 

591
00:26:31,400 --> 00:26:34,330
没有身体或身份证或类似的东西。 

592
00:26:34,330 --> 00:26:36,370
微小的限制

593
00:26:36,370 --> 00:26:40,380
是它仅适用于ObservableObject类。 

594
00:26:40,380 --> 00:26:44,820
如果您是班级，则只能在此处成为ObservableObject， 

595
00:26:44,820 --> 00:26:47,360
所以那是次要的约束。 

596
00:26:47,360 --> 00:26:50,750
现在，通过这样做您获得的收益

597
00:26:50,750 --> 00:26:54,040
您是否获得了一个名为objectWillChange的变量。 

598
00:26:54,950 --> 00:26:55,900
这个变种就在这里， 

599
00:26:55,900 --> 00:26:58,690
您不必像我们对身体那样把它放在这里， 

600
00:26:58,690 --> 00:27:00,470
您可以在后台免费获得它。 

601
00:27:00,470 --> 00:27:02,040
所以这里不会。 

602
00:27:02,040 --> 00:27:04,430
我只是向您展示您所得到的。 

603
00:27:04,430 --> 00:27:08,123
而且这个var不是真正的这种类型， 

604
00:27:08,123 --> 00:27:10,760
ObservableObjectPublisher， 

605
00:27:10,760 --> 00:27:12,320
比这复杂一点。 

606
00:27:12,320 --> 00:27:16,430
我们甚至不知道或不在乎它是什么

607
00:27:16,430 --> 00:27:19,930
但是我们需要了解有关此var的两件事。 

608
00:27:19,930 --> 00:27:22,890
一个是它是发布者， 

609
00:27:22,890 --> 00:27:25,370
意味着它可以发布给全世界， 

610
00:27:25,370 --> 00:27:26,740
对任何有兴趣的人， 

611
00:27:26,740 --> 00:27:29,050
我们的观点将会引起人们的兴趣， 

612
00:27:29,050 --> 00:27:30,870
当某些变化。 

613
00:27:30,870 --> 00:27:35,630
而且这个变数只能传送一个函数

614
00:27:35,630 --> 00:27:37,673
这是发送功能。 

615
00:27:38,570 --> 00:27:43,450
如果您调用该函数在objectWillChange上发送， 

616
00:27:43,450 --> 00:27:45,730
它要发布给全世界

617
00:27:45,730 --> 00:27:48,160
这个物件有些改变

618
00:27:48,160 --> 00:27:51,730
否则很快就会改变

619
00:27:51,730 --> 00:27:54,120
所以准备好然后对它做出反应。 

620
00:27:54,120 --> 00:27:56,770
就是这样，这就是我们要做的，真的， 

621
00:27:56,770 --> 00:27:59,590
让我们的ViewModel参与其中。 

622
00:27:59,590 --> 00:28:02,090
所以每次我们的模型改变时

623
00:28:02,090 --> 00:28:05,740
我们想要做objectWillChange.send。 

624
00:28:05,740 --> 00:28:07,980
例如，这是一个意图。 

625
00:28:07,980 --> 00:28:10,070
显然，我们正在此处更改模型。 

626
00:28:10,070 --> 00:28:11,800
我们知道选择卡

627
00:28:11,800 --> 00:28:15,041
是一个可变的变异函数。 

628
00:28:15,041 --> 00:28:18,000
因此，这当然会改变我们的模型。 

629
00:28:18,000 --> 00:28:21,177
所以在这里我们只说objectWillChange.send。 

630
00:28:24,060 --> 00:28:25,910
实际上，这是唯一的功能

631
00:28:25,910 --> 00:28:27,720
我们永远都在拜访

632
00:28:27,720 --> 00:28:30,220
这个objectWillChange东西就在这里。 

633
00:28:30,220 --> 00:28:32,930
这将要发布到全世界， 

634
00:28:32,930 --> 00:28:37,900
objectWillChange表示此MemoryGame将更改。 

635
00:28:37,900 --> 00:28:41,780
仅此而已，不是说它是如何改变的，而是它的改变。 

636
00:28:41,780 --> 00:28:43,960
这一点很重要

637
00:28:43,960 --> 00:28:46,390
因为如果此ViewModel更改， 

638
00:28:46,390 --> 00:28:48,380
模型上的此门户已更改， 

639
00:28:48,380 --> 00:28:49,860
希望查看的视图

640
00:28:49,860 --> 00:28:52,260
该门户网站需要重绘。 

641
00:28:52,260 --> 00:28:53,860
我们将在短短一秒钟内告诉您

642
00:28:53,860 --> 00:28:56,860
他们如何注册才能做到这一点。 

643
00:28:56,860 --> 00:28:59,170
再说一次，我们不需要把它放在这里， 

644
00:28:59,170 --> 00:29:00,530
我们免费获得它。 

645
00:29:00,530 --> 00:29:02,880
而当我摆脱它时，您将看不到任何错误。 

646
00:29:02,880 --> 00:29:04,600
这完全是合法的。 

647
00:29:04,600 --> 00:29:06,860
您可以随时拨打此电话， 

648
00:29:06,860 --> 00:29:08,630
任何时候改变。 

649
00:29:08,630 --> 00:29:11,120
甚至不必改变您的模型。 

650
00:29:11,120 --> 00:29:13,220
如果您要更改这些表情符号， 

651
00:29:13,220 --> 00:29:16,510
例如，您可以调用objectWillChange， 

652
00:29:16,510 --> 00:29:18,210
完全取决于您。 

653
00:29:18,210 --> 00:29:21,560
但是，在重要的应用中， 

654
00:29:21,560 --> 00:29:25,150
您可能会有很多意图， 

655
00:29:25,150 --> 00:29:27,630
许多可能会改变您的模型的不同事物。 

656
00:29:27,630 --> 00:29:29,350
这有点烦人

657
00:29:29,350 --> 00:29:31,374
不得不说objectWillChange.send， 

658
00:29:31,374 --> 00:29:32,420
objectWillChange.send。 

659
00:29:32,420 --> 00:29:33,920
甚至容易出错。 

660
00:29:33,920 --> 00:29:37,893
如果我哎呀雏菊忘了把它放在那里

661
00:29:37,893 --> 00:29:39,667
然后您选择一张卡片，就像

662
00:29:39,667 --> 00:29:42,210
卡仍然不翻转，为什么？ 

663
00:29:42,210 --> 00:29:44,570
因为我忘了把它放在那里。 

664
00:29:44,570 --> 00:29:49,360
因此，尽管我们可以随时调用objectWillChange.send， 

665
00:29:49,360 --> 00:29:51,430
通常我们处理这个问题的方式

666
00:29:51,430 --> 00:29:56,027
是我们采用此var并使其发布。 

667
00:29:57,760 --> 00:30:01,100
所以这不是Swift关键字， 

668
00:30:01,100 --> 00:30:02,800
你会看到它不是洋红色的

669
00:30:02,800 --> 00:30:05,300
这就是所谓的属性包装器

670
00:30:05,300 --> 00:30:07,460
这是一个财产。 

671
00:30:07,460 --> 00:30:11,400
属性包装器增加了一些功能

672
00:30:11,400 --> 00:30:13,170
周围的财产。 

673
00:30:13,170 --> 00:30:15,610
在这种情况下，这个包装器会做什么

674
00:30:15,610 --> 00:30:17,430
每次都是这个属性， 

675
00:30:17,430 --> 00:30:19,460
这个模型改变了， 

676
00:30:19,460 --> 00:30:22,200
它调用objectWillChange.send。 

677
00:30:22,200 --> 00:30:24,000
这就是它的作用。 

678
00:30:24,000 --> 00:30:28,080
确实如此，要使我们的ObservableObject在此处， 

679
00:30:28,080 --> 00:30:31,530
我们的ViewModel会在每次发生变化时广播， 

680
00:30:31,530 --> 00:30:35,890
我们只需要@Published我们所有的变量

681
00:30:35,890 --> 00:30:38,180
我们关心在这种情况下它们是否会改变

682
00:30:38,180 --> 00:30:39,930
这只是我们的一个Model var。 

683
00:30:39,930 --> 00:30:42,190
也可能是其他事情。 

684
00:30:42,190 --> 00:30:44,680
您可以根据需要拥有多个@Published变量。 

685
00:30:44,680 --> 00:30:46,830
任何时候只要他们改变

686
00:30:46,830 --> 00:30:49,240
这将是objectWillChange.send， 

687
00:30:49,240 --> 00:30:50,403
这就是它的作用。 

688
00:30:51,540 --> 00:30:54,140
这看起来比记住要好得多

689
00:30:54,140 --> 00:30:58,350
将objectWillChange.send放入所有这些函数中。 

690
00:30:58,350 --> 00:31:00,860
您仍然可以选择执行objectWillChange.send 

691
00:31:00,860 --> 00:31:02,900
即使您使用这些， 

692
00:31:02,900 --> 00:31:04,530
但是大多数时候你不会

693
00:31:04,530 --> 00:31:06,947
做objectWillChange.send。 

694
00:31:08,090 --> 00:31:09,480
所以我们快到了。 

695
00:31:09,480 --> 00:31:11,080
现在我们有了ViewModel 

696
00:31:11,080 --> 00:31:15,560
因此每次模型更改时都会发布。 

697
00:31:15,560 --> 00:31:18,510
现在我们只需要在这里修复我们的视图

698
00:31:18,510 --> 00:31:23,510
这样，当看到此ViewModel发布时，它将重新绘制。 

699
00:31:25,530 --> 00:31:28,700
每当看到这个东西时都会重画， 

700
00:31:28,700 --> 00:31:30,000
说出objectWillChange.send。 

701
00:31:31,271 --> 00:31:33,440
这样做的方法是使用另一个属性包装器

702
00:31:33,440 --> 00:31:35,817
在这个称为@ObservedObject的对象上。 

703
00:31:38,040 --> 00:31:42,630
就是说这个var中有一个ObservableObject， 

704
00:31:42,630 --> 00:31:46,130
这样做，EmojiMemoryGame是一个ObservableObject。 

705
00:31:46,130 --> 00:31:50,720
并且每当它说objectWillChange.send时，都要重画。 

706
00:31:50,720 --> 00:31:54,400
当然重画这个会导致这个

707
00:31:54,400 --> 00:31:57,240
也有可能被重画。 

708
00:31:57,240 --> 00:31:58,780
现在，您可能会觉得， 

709
00:31:58,780 --> 00:32:00,660
哇，这可能效率很低， 

710
00:32:00,660 --> 00:32:02,680
如果模型一直在变化，该怎么办？ 

711
00:32:02,680 --> 00:32:05,670
我们是否会每次都重新绘制视图？ 

712
00:32:05,670 --> 00:32:07,810
好，是的，不是。 

713
00:32:07,810 --> 00:32:11,380
是的，我们将对objectWillChange做出反应

714
00:32:11,380 --> 00:32:15,810
和重绘，但是SwiftUI很聪明地看到了

715
00:32:15,810 --> 00:32:17,940
是否确实发生了变化。 

716
00:32:17,940 --> 00:32:19,680
因此，如果我们翻转一张卡， 

717
00:32:19,680 --> 00:32:22,550
不会重提每张卡， 

718
00:32:22,550 --> 00:32:25,210
只是一个改变了，它知道

719
00:32:25,210 --> 00:32:27,720
因为卡是可识别的。 

720
00:32:27,720 --> 00:32:32,085
您开始了解为什么在此卡阵列上此ForEach 

721
00:32:32,085 --> 00:32:34,990
迫使我们对此进行识别。 

722
00:32:34,990 --> 00:32:37,530
有助于理解，哦，这个改变了

723
00:32:37,530 --> 00:32:39,960
所以我实际上需要重画。 

724
00:32:39,960 --> 00:32:42,710
因为实际上是在调用此代码

725
00:32:42,710 --> 00:32:44,700
可能不是很贵。 

726
00:32:44,700 --> 00:32:48,100
实际上是在屏幕上绘图，这非常昂贵。 

727
00:32:48,100 --> 00:32:51,233
因此，SwiftUI会尽一切可能避免这样做。 

728
00:32:52,410 --> 00:32:55,060
但是从概念上讲，这很简单。 

729
00:32:55,060 --> 00:32:57,170
每当我们的模型改变时， 

730
00:32:57,170 --> 00:33:01,090
@Published包装器注意到， 

731
00:33:01,090 --> 00:33:02,660
我们是一个ObservableObject， 

732
00:33:02,660 --> 00:33:06,030
因此我们的视图可以标记为对该发布感兴趣

733
00:33:06,030 --> 00:33:08,310
瞧，这会重绘。 

734
00:33:08,310 --> 00:33:12,040
这就是我们进行反应式编程的方式。 

735
00:33:12,040 --> 00:33:13,410
真的，这就是全部。 

736
00:33:13,410 --> 00:33:15,700
我们将看到一些小的改进

737
00:33:15,700 --> 00:33:17,080
到那边

738
00:33:17,080 --> 00:33:20,150
但这实际上就是它的工作方式。 

739
00:33:20,150 --> 00:33:21,430
因此，让我们看看它是否有效。 

740
00:33:21,430 --> 00:33:23,090
让我们运行我们的应用程序。 

741
00:33:23,090 --> 00:33:25,403
希望当我们点击卡片时， 

742
00:33:25,403 --> 00:33:27,060
我们会说选择了卡

743
00:33:27,060 --> 00:33:28,260
但它们也将翻转过来。 

744
00:33:28,260 --> 00:33:30,496
因此，让我们尝试一下。 

745
00:33:30,496 --> 00:33:34,680
幽灵，我点击它，它正在双向翻转。 

746
00:33:34,680 --> 00:33:37,230
这个家伙和这个家伙还有这个家伙怎么样。 

747
00:33:37,230 --> 00:33:38,630
好吧。 

748
00:33:38,630 --> 00:33:42,323
所以这里发生的是我们点击这些， 

749
00:33:42,323 --> 00:33:44,410
它是在onTapGesture上完成的。 

750
00:33:44,410 --> 00:33:47,800
它在ViewModel中表达了这个Intent。 

751
00:33:47,800 --> 00:33:50,350
然后，ViewModel询问模型

752
00:33:50,350 --> 00:33:51,600
去做吧。 

753
00:33:51,600 --> 00:33:54,470
模型正在做这种变异的事情。 

754
00:33:54,470 --> 00:33:56,530
一旦完成了这种变异的事情， 

755
00:33:56,530 --> 00:33:58,460
这很容易注意到

756
00:33:58,460 --> 00:34:01,020
它已经改变并被发布， 

757
00:34:01,020 --> 00:34:02,830
objectWillChange.send， 

758
00:34:02,830 --> 00:34:05,700
这个家伙观察到那些objectWillChange.send 

759
00:34:05,700 --> 00:34:07,060
并正在重画。 

760
00:34:07,060 --> 00:34:11,230
那是我给你看的幻灯片， 

761
00:34:11,230 --> 00:34:15,023
来回，这就是代码中的样子。 

762
00:34:17,030 --> 00:34:20,987
所以我们现在需要跳回幻灯片

763
00:34:20,987 --> 00:34:23,253
再谈一些协议。 

764
00:34:24,320 --> 00:34:26,430
一个协议会期待你

765
00:34:26,430 --> 00:34:29,980
就像是精简的类或结构， 

766
00:34:29,980 --> 00:34:33,540
剥离下来，因为它具有函数和变量

767
00:34:33,540 --> 00:34:35,500
但没有实施。 

768
00:34:35,500 --> 00:34:38,500
这是我制定的可移动协议。 

769
00:34:38,500 --> 00:34:40,820
它具有一个功能和两个变量。 

770
00:34:40,820 --> 00:34:43,300
var之一仅在hasMoved处读取。 

771
00:34:43,300 --> 00:34:46,170
您可以看到它带有大括号。 

772
00:34:46,170 --> 00:34:48,777
然后distanceFromStart实际上是可读的

773
00:34:48,777 --> 00:34:51,950
和可写的，这就是为什么它必须得到设置。 

774
00:34:51,950 --> 00:34:53,700
但是这里没有实现。 

775
00:34:53,700 --> 00:34:54,920
甚至那里的那些花括号， 

776
00:34:54,920 --> 00:34:56,810
那只是说这些变量是否是只读的

777
00:34:56,810 --> 00:34:58,493
还是没有，仅此而已。 

778
00:34:59,580 --> 00:35:02,010
声明协议后， 

779
00:35:02,010 --> 00:35:05,310
现在任何类型，结构或类

780
00:35:05,310 --> 00:35:06,800
可以说

781
00:35:06,800 --> 00:35:09,640
是的，我要实现这一目标。 

782
00:35:09,640 --> 00:35:12,850
声称要实现该协议。 

783
00:35:12,850 --> 00:35:14,090
所以我这里有一个结构

784
00:35:14,090 --> 00:35:17,340
便携式的东西，它说冒号可移动

785
00:35:17,340 --> 00:35:18,790
在此声明中。 

786
00:35:18,790 --> 00:35:19,920
当它说的时候， 

787
00:35:19,920 --> 00:35:22,930
立即意味着我注册实施

788
00:35:22,930 --> 00:35:25,470
因此，它必须实现每个var 

789
00:35:25,470 --> 00:35:28,140
以及Moveable中的每个功能。 

790
00:35:28,140 --> 00:35:30,810
现在我们已经在View之前看到了

791
00:35:30,810 --> 00:35:33,710
我们有ContentView，冒号视图。 

792
00:35:33,710 --> 00:35:35,610
它签约成为View，这就是为什么

793
00:35:35,610 --> 00:35:36,860
它必须做变体， 

794
00:35:36,860 --> 00:35:40,090
卡是一样的东西，可识别。 

795
00:35:40,090 --> 00:35:41,970
它签署了实施Identifiable的协议。 

796
00:35:41,970 --> 00:35:44,653
它必须实现该var id。 

797
00:35:46,420 --> 00:35:51,010
现在也可以说一个协议

798
00:35:51,010 --> 00:35:52,650
它需要另一个协议。 

799
00:35:52,650 --> 00:35:54,820
这称为协议继承， 

800
00:35:54,820 --> 00:35:57,010
不要与类继承混淆

801
00:35:57,010 --> 00:35:59,130
因为我们在这里只是在谈论协议。 

802
00:35:59,130 --> 00:36:01,260
所以这里我有一个协议载具

803
00:36:01,260 --> 00:36:04,500
它是从Moveable继承的。 

804
00:36:04,500 --> 00:36:07,580
它在那里添加了自己的var，passengerCount。 

805
00:36:07,580 --> 00:36:11,390
因此，如果像汽车这样的课程出现在底部

806
00:36:11,390 --> 00:36:13,880
它说，我签署了您的车辆， 

807
00:36:13,880 --> 00:36:17,170
现在它必须实现Moveable的所有三件事

808
00:36:17,170 --> 00:36:19,563
而且必须从Vehicle实施

809
00:36:20,540 --> 00:36:23,350
如果您是结构或类，也可以

810
00:36:23,350 --> 00:36:25,760
声称实现多种协议。 

811
00:36:25,760 --> 00:36:27,610
所以这里有上课车。 

812
00:36:27,610 --> 00:36:29,740
不只是说这是一辆车

813
00:36:29,740 --> 00:36:32,470
而且它是可移植的

814
00:36:32,470 --> 00:36:34,960
现在汽车必须实现所有功能

815
00:36:34,960 --> 00:36:37,823
在所有这三个协议的vars中。 

816
00:36:38,780 --> 00:36:41,290
现在，协议就是一种类型。 

817
00:36:41,290 --> 00:36:44,350
这意味着可以使用大多数协议

818
00:36:44,350 --> 00:36:46,700
在大多数情况下，您有类型。 

819
00:36:46,700 --> 00:36:51,400
例如，我可以有一个类型为Moveable的变量m。 

820
00:36:51,400 --> 00:36:54,120
那是m的类型，这是Moveable的类型。 

821
00:36:54,120 --> 00:36:55,330
那是什么意思呢？ 

822
00:36:55,330 --> 00:36:57,420
好吧，如果我还有另外两个变量， 

823
00:36:57,420 --> 00:36:58,820
像汽车和便携式

824
00:36:58,820 --> 00:37:02,420
分别是Car类型和PortableThing类型， 

825
00:37:02,420 --> 00:37:06,160
那么我可以说，m等于汽车或m等于便携式。 

826
00:37:06,160 --> 00:37:07,290
我怎么这么说

827
00:37:07,290 --> 00:37:10,490
因为汽车是动车， 

828
00:37:10,490 --> 00:37:12,820
它实现了可移动协议。 

829
00:37:12,820 --> 00:37:14,300
实际上，汽车实现了Vehicle 

830
00:37:14,300 --> 00:37:16,850
车辆继承了可动

831
00:37:16,850 --> 00:37:19,160
因此汽车是可移动的。 

832
00:37:19,160 --> 00:37:22,240
太好了，因为现在有了这个变量m 

833
00:37:22,240 --> 00:37:25,951
我可以开始发送它的功能，例如移动， 

834
00:37:25,951 --> 00:37:29,310
已经移动，因为我知道m是可移动的。 

835
00:37:29,310 --> 00:37:32,050
不管是那里的汽车还是PortableThing， 

836
00:37:32,050 --> 00:37:33,870
我们知道那些变量和函数

837
00:37:33,870 --> 00:37:34,750
将被实施

838
00:37:34,750 --> 00:37:36,570
因为您需要实施它们

839
00:37:36,570 --> 00:37:39,380
如果你说你是其中之一。 

840
00:37:39,380 --> 00:37:41,450
但是要注意一点， 

841
00:37:41,450 --> 00:37:45,600
你不能说便携式等于汽车。 

842
00:37:45,600 --> 00:37:49,300
那里的var便携式设备不是Moveable类型， 

843
00:37:49,300 --> 00:37:52,920
它是PortableThing类型，不同。 

844
00:37:52,920 --> 00:37:56,690
因此，汽车不是PortablePorting。 

845
00:37:56,690 --> 00:37:58,270
它们都是可移动的

846
00:37:58,270 --> 00:38:00,920
但是汽车的类型不同于PortableThing。 

847
00:38:00,920 --> 00:38:01,823
我认为汽车是一门课， 

848
00:38:01,823 --> 00:38:03,870
PortableThing是一个结构。 

849
00:38:03,870 --> 00:38:06,200
因此，甚至没有同样的事情。 

850
00:38:06,200 --> 00:38:08,020
所以你不能这么说。 

851
00:38:08,020 --> 00:38:10,030
我可以说m等于所有这些东西， 

852
00:38:10,030 --> 00:38:11,560
我不能说他们彼此平等

853
00:38:11,560 --> 00:38:14,750
因为Swift正在执行var的类型， 

854
00:38:14,750 --> 00:38:16,340
然后当我说便携式等于

855
00:38:16,340 --> 00:38:18,670
变量的类型是PortableThing， 

856
00:38:18,670 --> 00:38:20,793
不要在此处输入“可移动”。 

857
00:38:22,170 --> 00:38:24,067
一种考虑协议的方式， 

858
00:38:24,067 --> 00:38:27,140
我已经在演示中提到了这一点， 

859
00:38:27,140 --> 00:38:30,570
是制约和收获。 

860
00:38:30,570 --> 00:38:32,720
我用这个是因为它押韵

861
00:38:32,720 --> 00:38:34,870
希望很容易记住， 

862
00:38:34,870 --> 00:38:36,780
它是这样的。 

863
00:38:36,780 --> 00:38:39,390
所以我这里有这个结构

864
00:38:39,390 --> 00:38:41,500
特斯拉，它是一辆汽车， 

865
00:38:41,500 --> 00:38:43,210
因此它实现了所有这些东西。 

866
00:38:43,210 --> 00:38:46,290
实际上，限制所有事情的实现

867
00:38:46,290 --> 00:38:49,640
载具中的所有事物， 

868
00:38:49,640 --> 00:38:53,690
但是受到限制会使其获益， 

869
00:38:53,690 --> 00:38:57,573
世界为车辆提供的所有东西。 

870
00:38:58,410 --> 00:39:01,832
现在，您可能会说，嗯，在这里稍等片刻， 

871
00:39:01,832 --> 00:39:05,300
车辆是协议，没有实现。 

872
00:39:05,300 --> 00:39:08,698
我们怎么可能在这里获得任何收益？ 

873
00:39:08,698 --> 00:39:12,890
似乎我在这里遇到了所有限制，但没有收获。 

874
00:39:12,890 --> 00:39:17,700
好吧，关键在于关键字扩展。 

875
00:39:17,700 --> 00:39:22,700
在Swift中，我们可以扩展协议以实现。 

876
00:39:23,900 --> 00:39:26,950
我们只说扩展名，协议名称， 

877
00:39:26,950 --> 00:39:29,980
然后我们可以将功能和实现放在一起

878
00:39:29,980 --> 00:39:31,780
vars中的函数及其实现。 

879
00:39:31,780 --> 00:39:34,970
现在我们不能在这里存储任何变量了。 

880
00:39:34,970 --> 00:39:35,870
所以有这个限制

881
00:39:35,870 --> 00:39:38,210
它必须是计算变量

882
00:39:38,210 --> 00:39:40,010
就像var body是计算出来的一样

883
00:39:40,010 --> 00:39:41,390
记住，它有花括号， 

884
00:39:41,390 --> 00:39:43,040
必须在这里做同样的事情

885
00:39:43,040 --> 00:39:46,480
但是我们可以添加任意数量的东西。 

886
00:39:46,480 --> 00:39:49,200
随着车辆登记簿的扩展，DMV 

887
00:39:49,200 --> 00:39:51,690
现在是特斯拉和所有其他车辆

888
00:39:51,690 --> 00:39:53,320
可以在DMV中注册。 

889
00:39:53,320 --> 00:39:55,660
换句话说，他们获得了这种能力

890
00:39:55,660 --> 00:39:58,010
忍受他们所受的束缚

891
00:39:58,010 --> 00:40:00,060
实现那些方法和变量

892
00:40:00,060 --> 00:40:01,663
在那些协议中。 

893
00:40:02,780 --> 00:40:05,220
是的，这真的是中心

894
00:40:05,220 --> 00:40:07,920
Swift中的函数式编程。 

895
00:40:07,920 --> 00:40:11,000
协议视图可能是

896
00:40:11,000 --> 00:40:13,410
这样做的发帖者。 

897
00:40:13,410 --> 00:40:15,210
我们将看到更多关于View的信息

898
00:40:15,210 --> 00:40:16,560
在这里有几张幻灯片。 

899
00:40:17,730 --> 00:40:20,250
除了添加功能之外， 

900
00:40:20,250 --> 00:40:23,470
像registerWithDMV一样，您也可以使用扩展名

901
00:40:23,470 --> 00:40:28,470
如果要添加默认实现，请选择协议。 

902
00:40:28,750 --> 00:40:30,380
所以我在这里扩展Moveable 

903
00:40:30,380 --> 00:40:33,100
我实际上提供了一个默认实现

904
00:40:33,100 --> 00:40:34,430
为hasMoved作为hasMoved 

905
00:40:34,430 --> 00:40:37,760
是协议中的变量之一

906
00:40:37,760 --> 00:40:39,850
但是我在这里提供了默认的实现。 

907
00:40:39,850 --> 00:40:42,440
我只是在看我的距离

908
00:40:42,440 --> 00:40:43,840
如果大于零， 

909
00:40:43,840 --> 00:40:45,737
我假设我已经搬家了。 

910
00:40:45,737 --> 00:40:49,590
而我正在通过对Moveable进行扩展。 

911
00:40:49,590 --> 00:40:52,610
因此，这使我有可能拥有一个结构， 

912
00:40:52,610 --> 00:40:55,300
我这里有一个叫ChessPiece的棋子，它是可移动的， 

913
00:40:55,300 --> 00:40:57,120
您可以移动棋子。 

914
00:40:57,120 --> 00:41:00,680
ChessPiece不需要实现hasMoved。 

915
00:41:00,680 --> 00:41:03,943
如果ChessPiece仅实现moveBy和distanceFromStart， 

916
00:41:04,790 --> 00:41:07,390
那么它将成功实现Moveable 

917
00:41:07,390 --> 00:41:10,650
因为它将采用默认实现

918
00:41:10,650 --> 00:41:12,740
从那扩展名那里。 

919
00:41:12,740 --> 00:41:15,930
现在，如果ChessPiece想要自己实现hasMoved， 

920
00:41:15,930 --> 00:41:18,160
可以，但是不必

921
00:41:18,160 --> 00:41:20,290
因为有一个默认的实现

922
00:41:20,290 --> 00:41:22,563
对于该扩展中的hasMoved。 

923
00:41:23,680 --> 00:41:25,720
现在，您当然可以使用扩展程序了， 

924
00:41:25,720 --> 00:41:28,270
还要向结构和类中添加代码， 

925
00:41:28,270 --> 00:41:30,650
不只是协议。 

926
00:41:30,650 --> 00:41:34,320
例如，在这里，我有一个名为Boat的结构

927
00:41:34,320 --> 00:41:36,090
它有自己的方法， 

928
00:41:36,090 --> 00:41:37,430
无论他们是什么。 

929
00:41:37,430 --> 00:41:40,370
在这里，我将扩展添加到Boat中， 

930
00:41:40,370 --> 00:41:42,690
一个功能sailAroundTheWorld。 

931
00:41:42,690 --> 00:41:46,270
您可以看到，该扩展名带有花括号， 

932
00:41:46,270 --> 00:41:47,440
它有一个实现。 

933
00:41:47,440 --> 00:41:50,210
这是sailAroundTheWorld的实际实现

934
00:41:50,210 --> 00:41:52,253
我们已经添加到Boat中

935
00:41:53,460 --> 00:41:58,160
您甚至可以制作类似Boat的产品

936
00:41:58,160 --> 00:42:01,260
完全通过使用您的扩展名来访问协议。 

937
00:42:01,260 --> 00:42:04,660
所以Boat现在不执行任何协议

938
00:42:04,660 --> 00:42:07,160
但我可以使Boat工具可移动

939
00:42:07,160 --> 00:42:11,420
通过扩展到表示结肠可移动的Boat 

940
00:42:11,420 --> 00:42:13,110
然后在那个扩展中， 

941
00:42:13,110 --> 00:42:16,100
实现moveBy和distanceFromStart。 

942
00:42:16,100 --> 00:42:18,640
现在船是可移动的。 

943
00:42:18,640 --> 00:42:20,773
我将其全部添加为扩展名。 

944
00:42:21,808 --> 00:42:23,790
这不是一件罕见的事

945
00:42:23,790 --> 00:42:27,350
采取结构或类别并使其符合标准

946
00:42:27,350 --> 00:42:30,070
纯粹使用扩展的协议

947
00:42:30,070 --> 00:42:31,870
或者您将代码添加到扩展程序中。 

948
00:42:33,880 --> 00:42:37,140
为什么我们要做所有这些协议呢？ 

949
00:42:37,140 --> 00:42:38,810
现在，对于那些即将到来的人

950
00:42:38,810 --> 00:42:41,560
从面向对象的程序设计来看， 

951
00:42:41,560 --> 00:42:42,393
这里发生了什么？ 

952
00:42:42,393 --> 00:42:43,490
我们为什么要做这个？ 

953
00:42:43,490 --> 00:42:45,900
嗯，有一个非常好的概念上的原因

954
00:42:45,900 --> 00:42:47,810
为什么我们要这样做。 

955
00:42:47,810 --> 00:42:51,230
协议是一种用于类型，结构和类的方式， 

956
00:42:51,230 --> 00:42:53,890
其他协议，甚至枚举， 

957
00:42:53,890 --> 00:42:55,490
我们没有谈论过， 

958
00:42:55,490 --> 00:42:58,160
说出他们的能力， 

959
00:42:58,160 --> 00:43:02,530
他们可以做什么功能，他们有什么变量， 

960
00:43:02,530 --> 00:43:04,460
这也是其他代码的一种方式

961
00:43:04,460 --> 00:43:07,840
要求其他物体的某些行为

962
00:43:07,840 --> 00:43:10,560
通过要求他们遵守协议， 

963
00:43:10,560 --> 00:43:12,900
通过具有该类型的变量

964
00:43:12,900 --> 00:43:14,090
他们正在尝试分配

965
00:43:14,090 --> 00:43:16,220
或函数的参数。 

966
00:43:16,220 --> 00:43:18,430
甚至还有其他机制

967
00:43:18,430 --> 00:43:21,360
不久，当我们谈论泛型和协议时

968
00:43:21,360 --> 00:43:24,380
要求您希望该东西是可移动的。 

969
00:43:24,380 --> 00:43:26,170
无论如何，它必须是一辆载具。 

970
00:43:26,170 --> 00:43:29,870
现在，有了此协议，就可以要求它了。 

971
00:43:29,870 --> 00:43:33,370
但在所有这些方面，双方都不必透露

972
00:43:33,370 --> 00:43:35,860
您是哪种结构类。 

973
00:43:35,860 --> 00:43:38,370
您完全可以随心所欲。 

974
00:43:38,370 --> 00:43:40,590
你只是说你实现了Moveable 

975
00:43:40,590 --> 00:43:43,390
现在您可以将其作为可移动设备进行操作， 

976
00:43:43,390 --> 00:43:44,470
但你可以是任何人。 

977
00:43:44,470 --> 00:43:45,303
你可能是汽车

978
00:43:45,303 --> 00:43:46,390
您可能是PortableThing。 

979
00:43:46,390 --> 00:43:48,552
你可能是一条船。 

980
00:43:48,552 --> 00:43:51,390
我们知道什么时候双方都不在乎。 

981
00:43:51,390 --> 00:43:54,020
一方面，您可以做可移动的事情

982
00:43:54,020 --> 00:43:55,740
而所有其他副作用是

983
00:43:55,740 --> 00:43:58,313
实现所有这些可移动的东西。 

984
00:43:59,630 --> 00:44:01,750
这就是函数式编程

985
00:44:01,750 --> 00:44:03,120
或实际上我们可以称之为

986
00:44:03,120 --> 00:44:06,530
面向协议的编程就是这样。 

987
00:44:06,530 --> 00:44:09,250
这是关于规范数据结构的方式

988
00:44:09,250 --> 00:44:13,000
在我们的应用程序功能中，它们的行为方式。 

989
00:44:13,000 --> 00:44:16,210
即使我们在协议的上下文中谈论var， 

990
00:44:16,210 --> 00:44:19,280
我们没有定义它们的存储或计算方式， 

991
00:44:19,280 --> 00:44:21,580
我们甚至不说它们的存储或计算位置， 

992
00:44:21,580 --> 00:44:24,210
我们只是在谈论它们是只读还是读，写。 

993
00:44:24,210 --> 00:44:28,030
通过所有这些，我们专注于功能。 

994
00:44:28,030 --> 00:44:30,230
我们隐藏了实现细节。 

995
00:44:30,230 --> 00:44:33,670
这是封装的最终希望

996
00:44:33,670 --> 00:44:35,300
来自面向对象的编程

997
00:44:35,300 --> 00:44:37,210
但这确实是一个更高的层次

998
00:44:37,210 --> 00:44:39,890
因为它不会无情地混合它

999
00:44:39,890 --> 00:44:41,153
有了数据和所有这些， 

1000
00:44:41,153 --> 00:44:44,563
只是在谈论功能。 

1001
00:44:45,760 --> 00:44:49,100
所有这些都变得更加强大

1002
00:44:49,100 --> 00:44:51,843
当我们将其与泛型结合使用时。 

1003
00:44:52,770 --> 00:44:55,970
协议加上泛型等于

1004
00:44:55,970 --> 00:44:58,750
正如我在这里所说的，超级大国。 

1005
00:44:58,750 --> 00:45:01,350
让我们来看看泛型

1006
00:45:01,350 --> 00:45:03,550
记住那是无关紧要的东西

1007
00:45:03,550 --> 00:45:05,120
我们上次谈到的

1008
00:45:05,120 --> 00:45:08,810
它如何与协议结合以产生超能力。 

1009
00:45:08,810 --> 00:45:09,930
开始了。 

1010
00:45:09,930 --> 00:45:11,430
让我们以示例方式进行操作。 

1011
00:45:11,430 --> 00:45:14,760
假设我有一个名为Greatness的协议， 

1012
00:45:14,760 --> 00:45:16,850
这个协议里面只有一个功能

1013
00:45:16,850 --> 00:45:19,383
就是比其他大。 

1014
00:45:20,410 --> 00:45:23,140
此函数的另一个参数是GreaterThan。 

1015
00:45:23,140 --> 00:45:25,220
顺便说一句，这是一个有趣的功能

1016
00:45:25,220 --> 00:45:30,020
因为其他类型是大写S Self。 

1017
00:45:30,870 --> 00:45:34,360
这是协议中一种特殊的类型名称

1018
00:45:34,360 --> 00:45:36,210
表示实际类型

1019
00:45:36,210 --> 00:45:38,160
正在实施该协议， 

1020
00:45:38,160 --> 00:45:40,270
因为请记住，协议本身

1021
00:45:40,270 --> 00:45:41,340
没有执行， 

1022
00:45:41,340 --> 00:45:43,960
它们通过结构和类实现。 

1023
00:45:43,960 --> 00:45:46,460
因此，Self表示实际的结构类

1024
00:45:46,460 --> 00:45:47,893
实现这一点， 

1025
00:45:47,893 --> 00:45:50,397
当时正在执行它。 

1026
00:45:50,397 --> 00:45:51,680
所以这很酷。 

1027
00:45:51,680 --> 00:45:52,620
我要告诉你它是如何工作的

1028
00:45:52,620 --> 00:45:54,793
只需点击几下。 

1029
00:45:55,820 --> 00:45:59,380
因此，如果我们有此协议，请看我们能做什么。 

1030
00:45:59,380 --> 00:46:03,720
扩展数组，所以我要添加一些东西到数组， 

1031
00:46:03,720 --> 00:46:05,590
元素在哪里

1032
00:46:05,590 --> 00:46:08,790
不在乎数组

1033
00:46:08,790 --> 00:46:12,890
符合伟大，冒号伟大。 

1034
00:46:12,890 --> 00:46:15,000
这样我放在红色的地方

1035
00:46:15,000 --> 00:46:17,260
因为这真的是关键

1036
00:46:17,260 --> 00:46:19,660
泛型和协议的连接。 

1037
00:46:19,660 --> 00:46:22,490
在这里，我实际上要添加一个变量， 

1038
00:46:22,490 --> 00:46:23,790
或者我可以通过功能来做到这一点

1039
00:46:23,790 --> 00:46:26,850
但我要在这里向数组添加一个变量

1040
00:46:26,850 --> 00:46:30,720
这样每个元素不在乎的数组， 

1041
00:46:30,720 --> 00:46:33,173
符合Greatness将会得到此var。 

1042
00:46:34,500 --> 00:46:36,130
让它沉入。 

1043
00:46:36,130 --> 00:46:39,270
现在，此变量将不存在于数组中

1044
00:46:39,270 --> 00:46:42,510
不在乎的地方

1045
00:46:42,510 --> 00:46:43,600
协议伟大。 

1046
00:46:43,600 --> 00:46:45,380
该变量只是不会存在。 

1047
00:46:45,380 --> 00:46:47,130
如果您尝试在代码中键入它， 

1048
00:46:47,130 --> 00:46:47,963
编译器会说， 

1049
00:46:47,963 --> 00:46:51,290
哦，这个Array没有实现最大的。 

1050
00:46:51,290 --> 00:46:52,840
它只会说它实施得最好， 

1051
00:46:52,840 --> 00:46:56,180
只允许您正确输入

1052
00:46:56,180 --> 00:46:58,420
如果它是实现的东西的数组

1053
00:46:58,420 --> 00:46:59,540
协议伟大。 

1054
00:46:59,540 --> 00:47:03,733
现在我喜欢这样称呼，我们有点关心。 

1055
00:47:03,733 --> 00:47:05,040
（笑）对吗？ 

1056
00:47:05,040 --> 00:47:08,010
通常我们称泛型不在乎， 

1057
00:47:08,010 --> 00:47:09,840
元素不在乎， 

1058
00:47:09,840 --> 00:47:12,360
数组不在乎其中的内容。 

1059
00:47:12,360 --> 00:47:14,070
好吧，这有点

1060
00:47:14,070 --> 00:47:17,820
这个对Array的扩展有点关心Element。 

1061
00:47:17,820 --> 00:47:19,450
真的不在乎元素是什么

1062
00:47:19,450 --> 00:47:21,430
可以是任何结构或类， 

1063
00:47:21,430 --> 00:47:24,350
但是我们确实关心它实现了伟大。 

1064
00:47:24,350 --> 00:47:26,250
所以这有点关怀， 

1065
00:47:26,250 --> 00:47:28,110
你想那样想。 

1066
00:47:28,110 --> 00:47:30,170
然后这个无尽的伟大， 

1067
00:47:30,170 --> 00:47:33,150
看看它的类型是Element。 

1068
00:47:33,150 --> 00:47:35,810
这是因为我要遍历数组

1069
00:47:35,810 --> 00:47:38,518
并通过致电找到最伟大的

1070
00:47:38,518 --> 00:47:41,560
在所有事情上都比其他伟大

1071
00:47:41,560 --> 00:47:43,330
在我知道我可以做的数组中

1072
00:47:43,330 --> 00:47:45,110
因为这个对Array的扩展

1073
00:47:45,110 --> 00:47:48,790
只有元素实现伟大的地方。 

1074
00:47:48,790 --> 00:47:50,800
在这里看到一切如何？ 

1075
00:47:50,800 --> 00:47:52,000
因此，您可以轻松想象， 

1076
00:47:52,000 --> 00:47:52,980
我不会在这里显示代码， 

1077
00:47:52,980 --> 00:47:55,470
但您可以轻松想象构建一个for循环

1078
00:47:55,470 --> 00:47:57,070
只是贯穿所有元素， 

1079
00:47:57,070 --> 00:47:58,750
通话比所有通话都好， 

1080
00:47:58,750 --> 00:48:00,870
找出哪一个是最大的

1081
00:48:00,870 --> 00:48:02,120
然后将其返回。 

1082
00:48:04,860 --> 00:48:06,290
你们当中有些人正在看这一切， 

1083
00:48:06,290 --> 00:48:09,603
就像我在这里所说的，我确定您正在发抖。 

1084
00:48:10,670 --> 00:48:12,750
你必须要思考，圣牛， 

1085
00:48:12,750 --> 00:48:15,110
我应该怎么知道

1086
00:48:15,110 --> 00:48:18,640
如何使用这项技术设计代码？ 

1087
00:48:18,640 --> 00:48:20,930
我的意思是，这对我来说是全新的。 

1088
00:48:20,930 --> 00:48:24,800
这确实是一个非常强大的基础

1089
00:48:24,800 --> 00:48:27,360
对于设计事物，非常强大。 

1090
00:48:27,360 --> 00:48:29,420
但是函数式编程确实需要

1091
00:48:29,420 --> 00:48:32,783
一些只有经验才能掌握的技巧。 

1092
00:48:34,200 --> 00:48:36,150
好消息是你可以做

1093
00:48:36,150 --> 00:48:38,870
SwiftUI中的很多东西，大多数事情， 

1094
00:48:38,870 --> 00:48:42,260
无需真正掌握功能编程。 

1095
00:48:42,260 --> 00:48:45,210
但是在这里，您正在斯坦福大学努力接受良好的教育。 

1096
00:48:45,210 --> 00:48:48,260
所以我现在向你解释的原因

1097
00:48:48,260 --> 00:48:51,020
以便您在SwiftUI中使用它的次数增加， 

1098
00:48:51,020 --> 00:48:53,000
您在文档中看到的越多

1099
00:48:53,000 --> 00:48:55,840
在这些商品发生的地方， 

1100
00:48:55,840 --> 00:48:57,470
我们看到像View这样的协议

1101
00:48:57,470 --> 00:48:59,890
并且可以确定的是， 

1102
00:48:59,890 --> 00:49:01,220
你不只是在说， 

1103
00:49:01,220 --> 00:49:02,860
我必须在这里放冒号

1104
00:49:02,860 --> 00:49:04,250
你实际上是在理解

1105
00:49:04,250 --> 00:49:06,310
它是如何设计的。 

1106
00:49:06,310 --> 00:49:08,607
而且您看到的越多，它就会越陷进去， 

1107
00:49:08,607 --> 00:49:11,630
最终您可能会开始变得更有能力

1108
00:49:11,630 --> 00:49:14,483
同时进行功能编程设计。 

1109
00:49:15,480 --> 00:49:17,660
但是现在没有人期望你

1110
00:49:17,660 --> 00:49:19,890
能够设计东西

1111
00:49:19,890 --> 00:49:22,700
在其中使用泛型向协议添加扩展

1112
00:49:22,700 --> 00:49:23,560
等等。 

1113
00:49:23,560 --> 00:49:25,580
但是最终您将能够。 

1114
00:49:25,580 --> 00:49:27,540
同时，您会知道

1115
00:49:27,540 --> 00:49:29,030
SwiftUI中发生了什么。 

1116
00:49:31,365 --> 00:49:34,930
所以我只是把这张幻灯片放在这里，关于枚举， 

1117
00:49:34,930 --> 00:49:39,930
但是再一次，在本讲座中，我们将不再讨论枚举。 

1118
00:49:40,570 --> 00:49:43,203
我们会尽快谈论，不用担心。 

1119
00:49:44,140 --> 00:49:46,300
因此，几乎涵盖

1120
00:49:46,300 --> 00:49:49,180
今天我们要谈论的建筑

1121
00:49:49,180 --> 00:49:52,910
我们几乎涵盖了整个主题。 

1122
00:49:52,910 --> 00:49:54,840
现在我要完全换档

1123
00:49:54,840 --> 00:49:57,400
然后去一个完全不同的话题

1124
00:49:57,400 --> 00:49:59,810
换句话说，就是布局

1125
00:49:59,810 --> 00:50:03,970
我们如何确定所有视图在屏幕上的位置？ 

1126
00:50:03,970 --> 00:50:07,730
SwiftUI做到这一点的方法非常简单。 

1127
00:50:07,730 --> 00:50:11,120
这是所有SwiftUI中最精美的东西之一。 

1128
00:50:11,120 --> 00:50:13,940
确实只有三个步骤。 

1129
00:50:13,940 --> 00:50:17,060
第一个是容器视图， 

1130
00:50:17,060 --> 00:50:20,120
例如HStacks和VStacks之类的东西。 

1131
00:50:20,120 --> 00:50:24,180
它们为其中的视图提供了空间。 

1132
00:50:24,180 --> 00:50:27,840
然后，这些视图自行选择尺寸， 

1133
00:50:27,840 --> 00:50:29,380
他们想要成为什么。 

1134
00:50:29,380 --> 00:50:30,650
根据该报价， 

1135
00:50:30,650 --> 00:50:32,820
他们可以选择与报价相同的尺寸， 

1136
00:50:32,820 --> 00:50:34,050
这是最常见的

1137
00:50:34,050 --> 00:50:36,210
他们可以选择比报价要小的尺寸， 

1138
00:50:36,210 --> 00:50:38,570
他们可以选择比报价更大的尺寸。 

1139
00:50:38,570 --> 00:50:42,450
因此，它们以一种很好的封装方式使用

1140
00:50:42,450 --> 00:50:45,330
视图决定了它们的大小。 

1141
00:50:45,330 --> 00:50:46,900
没有人告诉他们要多大。 

1142
00:50:46,900 --> 00:50:49,520
他们决定，我们只是为他们提供空间。 

1143
00:50:49,520 --> 00:50:53,620
但是之后，容器视图就像堆栈一样， 

1144
00:50:53,620 --> 00:50:57,260
将视图放置在自己的内部是他们的工作。 

1145
00:50:57,260 --> 00:50:59,670
就是这样，这是三个步骤

1146
00:50:59,670 --> 00:51:03,370
以便将所有内容布置在SwiftUI中。 

1147
00:51:03,370 --> 00:51:04,730
因此，让我们深入了解一下。 

1148
00:51:04,730 --> 00:51:07,400
让我们谈谈容器视图。 

1149
00:51:07,400 --> 00:51:09,180
所以最常见的容器视图

1150
00:51:09,180 --> 00:51:12,770
您已经熟悉的是HStack和VStack。 

1151
00:51:12,770 --> 00:51:14,993
当然，还有ZStack 

1152
00:51:14,993 --> 00:51:17,320
这种堆叠在一起

1153
00:51:17,320 --> 00:51:19,770
但是HStack和VStack很有趣

1154
00:51:19,770 --> 00:51:23,130
因为他们将提供给他们的空间分开了

1155
00:51:23,130 --> 00:51:24,890
在所有子视图中

1156
00:51:24,890 --> 00:51:27,050
稍后我们将讨论其工作原理。 

1157
00:51:27,050 --> 00:51:31,720
ForEach是一种不寻常的容器视图。 

1158
00:51:31,720 --> 00:51:35,239
它实际上推迟了定位

1159
00:51:35,239 --> 00:51:38,190
并调整其所在容器的尺寸， 

1160
00:51:38,190 --> 00:51:40,510
这就是为什么我们将我们的CardViews 

1161
00:51:40,510 --> 00:51:42,410
将ForEach放入HStack。 

1162
00:51:42,410 --> 00:51:46,420
因此，他们的ForEach正在推迟让HStack做出决定。 

1163
00:51:46,420 --> 00:51:51,050
布局中隐藏着的一件事是修饰符， 

1164
00:51:51,050 --> 00:51:53,440
例如.padding等。 

1165
00:51:53,440 --> 00:51:57,240
它们本质上包含它们修改的视图， 

1166
00:51:57,240 --> 00:51:58,600
如果你想这样想， 

1167
00:51:58,600 --> 00:52:01,780
其中一些元素（例如填充）进行布局。 

1168
00:52:01,780 --> 00:52:03,150
所以我们再谈一点

1169
00:52:03,150 --> 00:52:05,357
有关HStack和VStack的详细信息， 

1170
00:52:05,357 --> 00:52:07,427
最重要的一项或至少一项

1171
00:52:07,427 --> 00:52:09,860
布局最多。 

1172
00:52:09,860 --> 00:52:12,140
堆栈划分空间的方式

1173
00:52:12,140 --> 00:52:15,490
提供给他们的情况是平均分配的

1174
00:52:15,490 --> 00:52:20,100
然后他们首先将其提供给最不灵活的视图。 

1175
00:52:20,100 --> 00:52:21,820
那么，那是什么意思呢？ 

1176
00:52:21,820 --> 00:52:26,820
因此，非常灵活的视图就是图像。 

1177
00:52:27,470 --> 00:52:29,660
所以我们还没有谈论图像

1178
00:52:29,660 --> 00:52:31,570
但这只是一个显示图像的视图， 

1179
00:52:31,570 --> 00:52:32,610
如您所想。 

1180
00:52:32,610 --> 00:52:35,330
当然，它希望是图像的大小， 

1181
00:52:35,330 --> 00:52:37,490
那种方式很不灵活。 

1182
00:52:37,490 --> 00:52:38,850
所以一般来说图片

1183
00:52:38,850 --> 00:52:41,400
首先要获得他们想要的空间。 

1184
00:52:41,400 --> 00:52:44,270
另一个僵化的View的另一个例子， 

1185
00:52:44,270 --> 00:52:47,450
不像图像是文字那样僵硬。 

1186
00:52:47,450 --> 00:52:49,550
文字总是想自行调整大小

1187
00:52:49,550 --> 00:52:53,000
可以理解其中的文字，这是可以理解的， 

1188
00:52:53,000 --> 00:52:55,520
但是它确实可以缩小一点

1189
00:52:55,520 --> 00:52:57,510
并在文本末尾加点号

1190
00:52:57,510 --> 00:52:59,580
正如我们稍后将在这里讨论的那样。 

1191
00:52:59,580 --> 00:53:03,230
因此，它不像图像那么灵活。 

1192
00:53:03,230 --> 00:53:05,770
而且大多数视图都非常灵活。 

1193
00:53:05,770 --> 00:53:07,270
例如，所有形状

1194
00:53:07,270 --> 00:53:09,710
就像我们看到的RoundedRectangle 

1195
00:53:09,710 --> 00:53:10,990
无论您提供什么尺寸， 

1196
00:53:10,990 --> 00:53:12,370
这几乎可以接受

1197
00:53:12,370 --> 00:53:15,880
并且它将以该大小适当地绘制自身。 

1198
00:53:15,880 --> 00:53:20,070
因此，在其中一种视图选择了自己的尺寸之后

1199
00:53:20,070 --> 00:53:21,670
并采用所需的尺寸， 

1200
00:53:21,670 --> 00:53:25,810
从堆栈的空间中删除了该大小

1201
00:53:25,810 --> 00:53:27,150
试图分配， 

1202
00:53:27,150 --> 00:53:31,060
然后进入下一个最不灵活的视图

1203
00:53:31,060 --> 00:53:33,343
冲洗并重复直到所有空间用完。 

1204
00:53:33,343 --> 00:53:34,760
就是这么简单。 

1205
00:53:34,760 --> 00:53:39,540
这就是HStack和VStack分配其空间的方式。 

1206
00:53:39,540 --> 00:53:40,880
现在，毕竟

1207
00:53:40,880 --> 00:53:42,663
选择了他们的大小然后HStack 

1208
00:53:42,663 --> 00:53:46,790
而VStack的大小可以适应这些视图

1209
00:53:46,790 --> 00:53:49,640
两者之间的间距很小。 

1210
00:53:50,690 --> 00:53:53,640
HStack和VStack可与任何View一起使用， 

1211
00:53:53,640 --> 00:53:54,980
当然，但是有几个

1212
00:53:54,980 --> 00:53:56,940
我要在这里介绍给你

1213
00:53:56,940 --> 00:53:58,890
确实有助于布局。 

1214
00:53:58,890 --> 00:54:01,240
其中之一称为垫片。 

1215
00:54:01,240 --> 00:54:03,660
因此，垫片只是一个视图

1216
00:54:03,660 --> 00:54:06,100
占用了它提供的所有空间。 

1217
00:54:06,100 --> 00:54:09,170
因此，如果您给它空间，它将使用该空间。 

1218
00:54:09,170 --> 00:54:11,310
因此，它用于填充空间。 

1219
00:54:11,310 --> 00:54:13,050
现在它实际上并没有画任何东西， 

1220
00:54:13,050 --> 00:54:15,947
它只是在占用HStack中的空间

1221
00:54:15,947 --> 00:54:18,440
或VStack，这就是为什么它被称为Spacer。 

1222
00:54:18,440 --> 00:54:23,020
它具有最小长度的minLength参数

1223
00:54:23,020 --> 00:54:24,540
它应该朝着方向

1224
00:54:24,540 --> 00:54:26,490
我们是水平或垂直布置

1225
00:54:26,490 --> 00:54:29,040
取决于是HStack还是VStack， 

1226
00:54:29,040 --> 00:54:30,700
尽管我们通常不指定

1227
00:54:30,700 --> 00:54:33,530
因为默认值是正确的金额

1228
00:54:33,530 --> 00:54:35,650
在这个平台上的空间。 

1229
00:54:35,650 --> 00:54:37,090
你要开始的一件事

1230
00:54:37,090 --> 00:54:38,573
习惯了本季度的发展， 

1231
00:54:38,573 --> 00:54:41,740
即使我们专注于iOS， 

1232
00:54:41,740 --> 00:54:45,940
您可以在Apple Watch和Apple TV上使用SwiftUI 

1233
00:54:45,940 --> 00:54:48,350
以及间距和布局

1234
00:54:48,350 --> 00:54:50,460
在这些平台上有点不同。 

1235
00:54:50,460 --> 00:54:54,080
SwiftUI真的很聪明地说： 

1236
00:54:54,080 --> 00:54:57,050
我在Apple Watch上，所以我要用这么多空间

1237
00:54:57,050 --> 00:54:59,000
默认情况下在我的垫片中。 

1238
00:54:59,000 --> 00:55:00,870
这就是为什么我们要尝试

1239
00:55:00,870 --> 00:55:02,240
并使用这些默认值

1240
00:55:02,240 --> 00:55:06,030
并且在使用Spacer时不指定minLength。 

1241
00:55:06,030 --> 00:55:08,510
HStack本身也有间距

1242
00:55:08,510 --> 00:55:10,180
HStack间距，我们不想这样做。 

1243
00:55:10,180 --> 00:55:13,480
即使是填充，通常也可以放置填充

1244
00:55:13,480 --> 00:55:15,570
但是如果你开始把数字放在那里

1245
00:55:15,570 --> 00:55:18,571
并像我们看到的那样指定确切的填充， 

1246
00:55:18,571 --> 00:55:20,340
你在打败一点

1247
00:55:20,340 --> 00:55:22,400
此平台独立性的目的。 

1248
00:55:22,400 --> 00:55:23,820
现在，有时您需要它， 

1249
00:55:23,820 --> 00:55:26,640
您可以，但是我们尝试使用这些默认值

1250
00:55:26,640 --> 00:55:28,440
越多越好。 

1251
00:55:28,440 --> 00:55:29,990
因此，要添加另一个很酷的视图

1252
00:55:29,990 --> 00:55:32,320
HStack或VStack是Divider。 

1253
00:55:32,320 --> 00:55:34,990
所以分频器只是画一条分界线， 

1254
00:55:34,990 --> 00:55:36,380
同样，特定于平台

1255
00:55:36,380 --> 00:55:38,580
这取决于分隔线的外观

1256
00:55:38,580 --> 00:55:40,670
在它的上下文中。 

1257
00:55:40,670 --> 00:55:43,910
当然，分频器不像垫片

1258
00:55:43,910 --> 00:55:45,100
它不会占用所有的空间。 

1259
00:55:45,100 --> 00:55:48,210
它仅使用足够的空间来绘制该线。 

1260
00:55:48,210 --> 00:55:51,080
而且该线显然与方向相反

1261
00:55:51,080 --> 00:55:51,930
我们正在布局。 

1262
00:55:51,930 --> 00:55:53,410
因此，对于HStack， 

1263
00:55:53,410 --> 00:55:55,380
分隔线显然将是一条垂直线， 

1264
00:55:55,380 --> 00:55:58,350
对于VStack，它将是一条水平线。 

1265
00:55:58,350 --> 00:56:01,670
所以您几乎肯定会想要使用一个

1266
00:56:01,670 --> 00:56:04,890
或在下一个作业中同时使用这两种方法。 

1267
00:56:04,890 --> 00:56:08,630
它们对于使用堆栈进行布局真的很有价值。 

1268
00:56:08,630 --> 00:56:09,970
这些HStack和VStack， 

1269
00:56:09,970 --> 00:56:12,510
我告诉过你他们是有选择的

1270
00:56:12,510 --> 00:56:17,510
它的哪些观点为下一个优先领域提供了空间

1271
00:56:18,060 --> 00:56:19,740
用这个最不灵活的东西， 

1272
00:56:19,740 --> 00:56:21,770
但实际上您可以覆盖

1273
00:56:21,770 --> 00:56:24,824
使用此视图修改器layoutPriority。 

1274
00:56:24,824 --> 00:56:27,180
这是一个HStack的例子

1275
00:56:27,180 --> 00:56:29,580
它的文本非常重要。 

1276
00:56:29,580 --> 00:56:33,050
它有一张我们知道非常不灵活的图片， 

1277
00:56:33,050 --> 00:56:35,580
因此通常会引起HStack的关注。 

1278
00:56:35,580 --> 00:56:40,260
然后有另一个不那么重要的文本。 

1279
00:56:40,260 --> 00:56:45,110
所以我添加了View修饰符点layoutPriority 100 

1280
00:56:45,110 --> 00:56:47,230
我可以选择任何我真正想要的号码， 

1281
00:56:47,230 --> 00:56:49,100
没关系，这是一个浮点数。 

1282
00:56:49,100 --> 00:56:52,020
这不仅仅是默认的layoutPriority 

1283
00:56:52,020 --> 00:56:53,000
这是零。 

1284
00:56:53,000 --> 00:56:55,540
因此，当该HStack提供其空间时， 

1285
00:56:55,540 --> 00:56:58,310
它将首先提供此文本空间。 

1286
00:56:58,310 --> 00:56:59,930
那文本会说， 

1287
00:56:59,930 --> 00:57:01,580
好吧，当然，我想变得这么大

1288
00:57:01,580 --> 00:57:04,810
所以我可以很重要地一直使用这个词

1289
00:57:04,810 --> 00:57:06,140
那会说，好吧， 

1290
00:57:06,140 --> 00:57:08,290
好吧，没有其他高优先级的产品了。 

1291
00:57:08,290 --> 00:57:10,480
可能还有其他号码不同的号码。 

1292
00:57:10,480 --> 00:57:12,670
它以最高优先级开始，然后下降。 

1293
00:57:12,670 --> 00:57:14,350
所以现在去做图像

1294
00:57:14,350 --> 00:57:16,630
因为它不如文本灵活， 

1295
00:57:16,630 --> 00:57:19,277
图像得到空间，然后是不重要的文本

1296
00:57:19,277 --> 00:57:22,660
必须适应剩余的空间。 

1297
00:57:22,660 --> 00:57:23,960
正如我们之前提到的

1298
00:57:23,960 --> 00:57:26,240
当文本没有足够的空间时， 

1299
00:57:26,240 --> 00:57:29,980
它会在其中放点

1300
00:57:29,980 --> 00:57:33,330
或缩短文字以适合其实际空间。 

1301
00:57:33,330 --> 00:57:34,740
它一直想成为它的空间。 

1302
00:57:34,740 --> 00:57:38,450
它从不希望超出其文本的大小。 

1303
00:57:38,450 --> 00:57:39,950
它总是想要确切的尺寸

1304
00:57:39,950 --> 00:57:41,670
但是如果被迫变小， 

1305
00:57:41,670 --> 00:57:43,363
它知道如何做点点。 

1306
00:57:44,350 --> 00:57:49,350
HStack和VStack布局的另一个重要部分

1307
00:57:49,370 --> 00:57:51,280
是他们的一致。 

1308
00:57:51,280 --> 00:57:55,060
因此，假设您有一个VStack，即垂直的View堆栈。 

1309
00:57:55,060 --> 00:57:57,660
如果这些视图自行选择大小

1310
00:57:57,660 --> 00:57:59,200
它们的宽度不一样。 

1311
00:57:59,200 --> 00:58:01,530
所以他们不可能都充满

1312
00:58:01,530 --> 00:58:04,210
此垂直堆栈的整个宽度。 

1313
00:58:04,210 --> 00:58:06,500
VStack也会左对齐吗

1314
00:58:06,500 --> 00:58:08,770
或将它们居中或使其对齐？ 

1315
00:58:08,770 --> 00:58:11,510
它怎么知道将它们放在哪里？ 

1316
00:58:11,510 --> 00:58:14,320
好吧，实际上有一个关于VStack和HStack的争论。 

1317
00:58:14,320 --> 00:58:16,360
我们已经知道VStack和HStack 

1318
00:58:16,360 --> 00:58:18,460
具有确定参数的参数间距

1319
00:58:18,460 --> 00:58:20,280
视图之间的间距。 

1320
00:58:20,280 --> 00:58:22,727
它还有另一个论点，对齐。 

1321
00:58:22,727 --> 00:58:26,400
对齐方式以对齐方式为准。 

1322
00:58:26,400 --> 00:58:29,960
例如，其中一个对齐向导处于领先地位。 

1323
00:58:29,960 --> 00:58:33,950
现在，为什么要领导这里而不是离开？ 

1324
00:58:33,950 --> 00:58:35,320
如果我只想要这个Vstack 

1325
00:58:35,320 --> 00:58:37,000
使所有这些保持对齐， 

1326
00:58:37,000 --> 00:58:37,937
我为什么不说左点？ 

1327
00:58:37,937 --> 00:58:41,050
实际上，不存在像点这样的东西。 

1328
00:58:41,050 --> 00:58:44,820
.lead意味着拥有事物

1329
00:58:44,820 --> 00:58:46,360
在VStack阵容中

1330
00:58:46,360 --> 00:58:50,750
这样它们的边缘就从文本的来源开始。 

1331
00:58:50,750 --> 00:58:52,430
有时用不同的语言

1332
00:58:52,430 --> 00:58:54,920
文字从右边移到左边， 

1333
00:58:54,920 --> 00:58:56,550
像希伯来语和阿拉伯语。 

1334
00:58:56,550 --> 00:59:01,180
因此，我们希望我们的VStack一般能够匹配

1335
00:59:01,180 --> 00:59:03,083
文字来自那一边。 

1336
00:59:04,460 --> 00:59:07,160
文本基线也可以排列。 

1337
00:59:07,160 --> 00:59:10,730
因此，HStacks，仅在HStack中才有意义。 

1338
00:59:10,730 --> 00:59:13,140
您可以将其对齐，以使文本的底部， 

1339
00:59:13,140 --> 00:59:14,670
即使它们是不同的字体， 

1340
00:59:14,670 --> 00:59:17,250
将全部排在您的HStack中。 

1341
00:59:17,250 --> 00:59:19,460
您甚至可以定义自己的东西

1342
00:59:19,460 --> 00:59:22,360
对齐对齐指南。 

1343
00:59:22,360 --> 00:59:24,890
这超出了本课程的范围。 

1344
00:59:24,890 --> 00:59:26,620
所以我们只是要使用内置的

1345
00:59:26,620 --> 00:59:29,830
像.center通常是默认对齐方式

1346
00:59:29,830 --> 00:59:31,540
就是把东西放在中间

1347
00:59:31,540 --> 00:59:33,490
VStack或HStack。 

1348
00:59:33,490 --> 00:59:35,500
但也有顶部和底部的尾随

1349
00:59:35,500 --> 00:59:36,820
领导所有这些事情。 

1350
00:59:36,820 --> 00:59:39,647
可以想象，当您开始输入Xcode时， 

1351
00:59:39,647 --> 00:59:42,560
VStack对齐冒号，当然，Xcode将为您提供帮助

1352
00:59:42,560 --> 00:59:45,173
并告诉您所有这些内置功能。 

1353
00:59:47,630 --> 00:59:49,343
堆栈就是这样。 

1354
00:59:49,343 --> 00:59:50,800
堆栈非常重要。 

1355
00:59:50,800 --> 00:59:54,180
但是还有另一件事，修饰符，例如.padding， 

1356
00:59:54,180 --> 00:59:58,840
我说过的行为本质上就像是容器视图。 

1357
00:59:58,840 --> 01:00:00,647
记住这些东西， 

1358
01:00:00,647 --> 01:00:04,050
.padding等，它们返回一个View。 

1359
01:00:04,050 --> 01:00:06,010
您可能以为他们只是返回一个View 

1360
01:00:06,010 --> 01:00:08,300
这样我们就可以再寄给他们

1361
01:00:08,300 --> 01:00:09,667
在它们上调用另一个函数， 

1362
01:00:09,667 --> 01:00:12,740
.foregroundColor然后返回给我们一个View 

1363
01:00:12,740 --> 01:00:14,197
我们称其为.padding。 

1364
01:00:14,197 --> 01:00:17,470
这为我们提供了View并在其上调用.font。 

1365
01:00:17,470 --> 01:00:19,520
因此，不只是给我们一个“视图” 

1366
01:00:19,520 --> 01:00:21,810
因此我们可以在其上调用另一个函数。 

1367
01:00:21,810 --> 01:00:23,630
那些回来的观点

1368
01:00:23,630 --> 01:00:27,260
可能实际上正在参与布局。 

1369
01:00:27,260 --> 01:00:29,220
现在，大多数人不参加， 

1370
01:00:29,220 --> 01:00:30,790
像font和foregroundColor。 

1371
01:00:30,790 --> 01:00:32,810
它们不影响布局

1372
01:00:32,810 --> 01:00:35,860
因此Hstack提供的任何空间

1373
01:00:35,860 --> 01:00:36,700
或其他一些容器， 

1374
01:00:36,700 --> 01:00:40,980
他们只是将其传递给包含的任何视图。 

1375
01:00:40,980 --> 01:00:42,150
在本幻灯片中， 

1376
01:00:42,150 --> 01:00:43,780
我们会想到一个视图

1377
01:00:43,780 --> 01:00:47,930
这些修饰符修改为包含在该视图中

1378
01:00:47,930 --> 01:00:51,120
修饰符返回的是哪种。 

1379
01:00:51,120 --> 01:00:53,790
我们将看看这些View修饰符

1380
01:00:53,790 --> 01:00:57,010
是在下周或下周制作的

1381
01:00:57,010 --> 01:00:58,680
视情况而定。 

1382
01:00:58,680 --> 01:01:00,980
而且您会真正看到这种情况

1383
01:01:00,980 --> 01:01:03,660
它包含要修改的视图。 

1384
01:01:03,660 --> 01:01:07,510
这些实际参与的修饰符呢？ 

1385
01:01:07,510 --> 01:01:09,640
在布局过程中像填充。 

1386
01:01:09,640 --> 01:01:11,500
让我们看一下填充。 

1387
01:01:11,500 --> 01:01:15,240
.padding，此修饰符， 

1388
01:01:15,240 --> 01:01:19,240
它提供了它正在修改空间的视图

1389
01:01:19,240 --> 01:01:22,120
与提供的尺寸相同

1390
01:01:22,120 --> 01:01:24,590
但在这种情况下降低了10分， 

1391
01:01:24,590 --> 01:01:25,500
无论填充是什么。 

1392
01:01:25,500 --> 01:01:27,380
如果那10个不存在， 

1393
01:01:27,380 --> 01:01:30,540
那么它将是任何适合系统的填充。 

1394
01:01:30,540 --> 01:01:32,650
基本上是删除那10个

1395
01:01:32,650 --> 01:01:35,300
因为它知道应该提供10。 

1396
01:01:35,300 --> 01:01:38,190
然后通过填充返回的视图

1397
01:01:38,190 --> 01:01:41,410
选择自己的尺寸为任意尺寸

1398
01:01:41,410 --> 01:01:44,980
它正在修改的东西最终是加10。 

1399
01:01:44,980 --> 01:01:46,330
这就是填充的作用

1400
01:01:46,330 --> 01:01:50,190
它在外面增加了10分

1401
01:01:50,190 --> 01:01:52,650
或您所说的任何优势。 

1402
01:01:52,650 --> 01:01:54,150
另一件事是修改。 

1403
01:01:54,150 --> 01:01:58,100
因此，您将看到.padding修饰符只是一个View 

1404
01:01:58,100 --> 01:02:00,570
参与布局。 

1405
01:02:00,570 --> 01:02:02,120
另一个例子是什么？ 

1406
01:02:02,120 --> 01:02:04,820
您已经在作业中使用了.aspectRatio。 

1407
01:02:06,030 --> 01:02:09,100
.aspectRatio修饰符返回的View， 

1408
01:02:09,100 --> 01:02:11,430
它占用了提供的空间

1409
01:02:11,430 --> 01:02:13,730
并自行选择大小

1410
01:02:13,730 --> 01:02:16,710
小于提供的尺寸

1411
01:02:16,710 --> 01:02:18,430
并具有长宽比， 

1412
01:02:18,430 --> 01:02:21,730
那就是如果我们选择AspectRatio的.fit选项， 

1413
01:02:21,730 --> 01:02:24,950
或者它可能大于所提供的大小， 

1414
01:02:24,950 --> 01:02:29,290
这是使用所有提供的空间的.fill选项。 

1415
01:02:29,290 --> 01:02:31,770
因此，是的，当您使用View时， 

1416
01:02:31,770 --> 01:02:33,250
当您有一定的空间时， 

1417
01:02:33,250 --> 01:02:35,870
您可以选择更大的尺寸。 

1418
01:02:35,870 --> 01:02:37,720
现在很少见了。 

1419
01:02:37,720 --> 01:02:39,380
我们通常不希望Views of 

1420
01:02:39,380 --> 01:02:41,540
互相溢出

1421
01:02:41,540 --> 01:02:43,030
但这很有意义

1422
01:02:43,030 --> 01:02:46,450
像在这方面比率填充，也许这是有道理的。 

1423
01:02:46,450 --> 01:02:49,760
因此，现在调整自身大小的AspectRatio视图

1424
01:02:49,760 --> 01:02:51,760
具有该长宽比， 

1425
01:02:51,760 --> 01:02:53,910
提供选择的空间

1426
01:02:53,910 --> 01:02:57,510
修改它的任何视图，例如CardView。 

1427
01:02:57,510 --> 01:02:59,590
这样我们的CardView就适合自己了

1428
01:02:59,590 --> 01:03:01,733
在那个不错的宽高比空间中。 

1429
01:03:03,210 --> 01:03:07,050
所以让我们看一个完整布局的例子

1430
01:03:07,050 --> 01:03:09,500
在传递的大小之类的东西上。 

1431
01:03:09,500 --> 01:03:12,540
所以这是一个类似于

1432
01:03:12,540 --> 01:03:15,780
我们在记忆游戏中

1433
01:03:15,780 --> 01:03:18,100
不完全相同，但非常非常相似。 

1434
01:03:18,100 --> 01:03:21,980
这个东西的空间如何分配？ 

1435
01:03:21,980 --> 01:03:23,887
好吧，首先要了解的是

1436
01:03:23,887 --> 01:03:26,480
将会提供空间

1437
01:03:26,480 --> 01:03:30,570
这整个绿色的东西就是填充视图。 

1438
01:03:30,570 --> 01:03:31,800
这是最外面的视图。 

1439
01:03:31,800 --> 01:03:36,310
最终，实际上就是视图

1440
01:03:36,310 --> 01:03:38,220
但无论空间多大，都会有提供

1441
01:03:38,220 --> 01:03:41,310
可用于此处的整个绿色结构。 

1442
01:03:41,310 --> 01:03:44,620
现在要做的是减少

1443
01:03:44,620 --> 01:03:48,870
从其边缘取10点并通过该空间

1444
01:03:48,870 --> 01:03:51,150
留给下一个视图

1445
01:03:51,150 --> 01:03:55,310
这是前景色修改器返回的视图。 

1446
01:03:55,310 --> 01:03:58,310
现在，修饰符并没有真正参与布局， 

1447
01:03:58,310 --> 01:03:59,900
真的没有任何作用

1448
01:03:59,900 --> 01:04:01,520
在东西的大小和位置上， 

1449
01:04:01,520 --> 01:04:06,090
因此它只是将其原封不动地传递给HStack。 

1450
01:04:06,090 --> 01:04:07,900
现在，众所周知，HStack 

1451
01:04:07,900 --> 01:04:10,000
是大时间布局视图。 

1452
01:04:10,000 --> 01:04:13,920
它将开始平等地划分其空间

1453
01:04:13,920 --> 01:04:17,630
由于aspectRatio不是像Images这样的东西

1454
01:04:17,630 --> 01:04:19,430
或固定大小的文字， 

1455
01:04:19,430 --> 01:04:22,120
最终将空间平均分配

1456
01:04:22,120 --> 01:04:26,123
在ForEach的所有AspectRatio视图中， 

1457
01:04:26,123 --> 01:04:28,300
因为我们知道ForEach本身

1458
01:04:28,300 --> 01:04:30,660
只是顺应HStack。 

1459
01:04:30,660 --> 01:04:33,070
所以现在是aspectRatio Views 

1460
01:04:33,070 --> 01:04:35,630
正在HStack中进行布局。 

1461
01:04:35,630 --> 01:04:38,650
每个aspectRatio视图将设置其宽度

1462
01:04:38,650 --> 01:04:41,330
占HStack宽度的份额

1463
01:04:41,330 --> 01:04:43,950
然后选择与宽高比匹配的高度， 

1464
01:04:43,950 --> 01:04:45,690
2/3的宽高比， 

1465
01:04:45,690 --> 01:04:48,330
或者如果高度限制在这里， 

1466
01:04:48,330 --> 01:04:49,820
可能是相反的方式

1467
01:04:49,820 --> 01:04:52,080
AspectRatio View需要的位置

1468
01:04:52,080 --> 01:04:53,840
它提供的所有高度

1469
01:04:53,840 --> 01:04:57,230
而是选择不太适合的宽度。 

1470
01:04:57,230 --> 01:04:58,310
因此，它可能以任何一种方式进行。 

1471
01:04:58,310 --> 01:05:01,150
这取决于哪个最适合

1472
01:05:01,150 --> 01:05:03,500
在提供的空间中。 

1473
01:05:03,500 --> 01:05:06,380
然后AspectRatio选择了该大小。 

1474
01:05:06,380 --> 01:05:07,610
它将提供给CardView 

1475
01:05:07,610 --> 01:05:10,350
而CardView将使用所有空间

1476
01:05:10,350 --> 01:05:12,070
因为就像普通的视图一样

1477
01:05:12,070 --> 01:05:15,620
无论您提供多少空间，它几乎都会被使用。 

1478
01:05:15,620 --> 01:05:19,250
在所有这些提供和调整大小之后， 

1479
01:05:19,250 --> 01:05:22,300
整个绿色视图的大小将是多少？ 

1480
01:05:22,300 --> 01:05:23,410
好吧，这将是大小

1481
01:05:23,410 --> 01:05:27,010
任何View.padding 10返回的结果

1482
01:05:27,010 --> 01:05:29,270
HStack大小调整以适应

1483
01:05:29,270 --> 01:05:33,460
所有这些aspectRatio视图在所有方面加10点。 

1484
01:05:33,460 --> 01:05:36,790
那将是整个绿色物体的大小。 

1485
01:05:36,790 --> 01:05:38,240
让我们来谈谈

1486
01:05:38,240 --> 01:05:40,270
提供给他们的所有空间。 

1487
01:05:40,270 --> 01:05:42,080
显然，诸如RoundedRectangle， 

1488
01:05:42,080 --> 01:05:43,490
对他们来说真的很容易。 

1489
01:05:43,490 --> 01:05:45,750
他们只是一直沿着矩形爬行

1490
01:05:45,750 --> 01:05:48,790
提供给他们的优势。 

1491
01:05:48,790 --> 01:05:51,580
但是，像CardView这样的自定义视图呢？ 

1492
01:05:51,580 --> 01:05:53,890
我们使用ZStack构建的CardView 

1493
01:05:53,890 --> 01:05:55,200
与RoundedRectangle，文字， 

1494
01:05:55,200 --> 01:05:56,910
我们正在建造这个东西。 

1495
01:05:56,910 --> 01:05:59,550
它占用了所有提供的空间， 

1496
01:05:59,550 --> 01:06:01,120
而且没有理由不应该

1497
01:06:01,120 --> 01:06:03,760
但它确实应该适应自己

1498
01:06:03,760 --> 01:06:05,630
到提供的任何空间。 

1499
01:06:05,630 --> 01:06:07,850
我们真的拼命地看到了这一点

1500
01:06:07,850 --> 01:06:10,330
带有表情符号的字体大小。 

1501
01:06:10,330 --> 01:06:13,320
在作业中，我要求您提供小卡片

1502
01:06:13,320 --> 01:06:15,120
切换到较小的字体。 

1503
01:06:15,120 --> 01:06:16,560
而且我相信您可能会意识到， 

1504
01:06:16,560 --> 01:06:19,960
哇，这真是解决这个问题的糟糕方法。 

1505
01:06:19,960 --> 01:06:21,210
当然是。 

1506
01:06:21,210 --> 01:06:24,600
确实，在演示中我们需要做的是，我们要做的， 

1507
01:06:24,600 --> 01:06:26,380
选择一个字体大小

1508
01:06:26,380 --> 01:06:30,000
与所提供的尺寸有关。 

1509
01:06:30,000 --> 01:06:32,210
由于我们要接受提供给我们的尺寸， 

1510
01:06:32,210 --> 01:06:35,400
我们应该选择适合的字体大小。 

1511
01:06:35,400 --> 01:06:39,280
那么，视图如何知道为其提供了什么空间

1512
01:06:39,280 --> 01:06:43,100
并可以做出例如字体选择的决定？ 

1513
01:06:43,100 --> 01:06:45,060
好吧，我们使用特殊的视图来实现。 

1514
01:06:45,060 --> 01:06:45,893
这只是一个景观， 

1515
01:06:45,893 --> 01:06:49,800
但这是一种特殊的名称，称为GeometryReader。 

1516
01:06:49,800 --> 01:06:52,360
以及您使用GeometryReader视图做什么

1517
01:06:52,360 --> 01:06:54,700
它包裹着任何东西吗

1518
01:06:54,700 --> 01:06:57,650
您想要适应的大小。 

1519
01:06:57,650 --> 01:07:00,420
因此，这通常会吸收您体内的任何物质

1520
01:07:00,420 --> 01:07:03,910
您只需像这样将GeometryReader包裹起来即可。 

1521
01:07:03,910 --> 01:07:06,090
GeometryReader只是一个视图。 

1522
01:07:06,090 --> 01:07:09,548
我没有在这里向您展示显而易见的东西。 

1523
01:07:09,548 --> 01:07:12,780
GeometryReader，开括号，内容，冒号， 

1524
01:07:12,780 --> 01:07:14,660
所有这一切，就像在HStack中一样

1525
01:07:14,660 --> 01:07:16,640
这仅仅是内容。 

1526
01:07:16,640 --> 01:07:18,410
但是你确实注意到它有

1527
01:07:18,410 --> 01:07:20,580
里面有几何的一点争论， 

1528
01:07:20,580 --> 01:07:22,620
类似于ForEach具有参数的方式

1529
01:07:22,620 --> 01:07:24,420
这就是我们要迭代的事情。 

1530
01:07:24,420 --> 01:07:26,323
这也有一个论点。 

1531
01:07:27,330 --> 01:07:31,590
因此，此参数的类型为GeometryProxy。 

1532
01:07:31,590 --> 01:07:34,250
而这个GeometryProxy只是一个结构

1533
01:07:34,250 --> 01:07:35,737
它里面有一些不错的信息， 

1534
01:07:35,737 --> 01:07:38,300
最重要的是您看到的第一个

1535
01:07:38,300 --> 01:07:42,090
var size，即您所提供的大小。 

1536
01:07:42,090 --> 01:07:45,000
宽度和高度CGSize是宽度和高度

1537
01:07:45,000 --> 01:07:46,100
被提供给你。 

1538
01:07:46,100 --> 01:07:48,217
您可以使用该尺寸（以磅为单位） 

1539
01:07:48,217 --> 01:07:50,080
当然，字体大小以磅为单位。 

1540
01:07:50,080 --> 01:07:52,990
因此，选择字体大小将非常容易

1541
01:07:52,990 --> 01:07:55,340
恰好适合该尺寸。 

1542
01:07:55,340 --> 01:07:57,070
你在这里看到其他一些东西， 

1543
01:07:57,070 --> 01:07:59,440
像框架实际上不仅大小

1544
01:07:59,440 --> 01:08:02,310
但这是我们所在的矩形

1545
01:08:02,310 --> 01:08:05,750
一定的坐标空间，例如我们的父母坐标空间

1546
01:08:05,750 --> 01:08:07,320
或全局坐标空间

1547
01:08:07,320 --> 01:08:10,750
我们甚至可以看一下是否愿意。 

1548
01:08:10,750 --> 01:08:12,377
我要谈谈那里的最后一个， 

1549
01:08:12,377 --> 01:08:14,803
safeAreaInsets，在下一张幻灯片上。 

1550
01:08:16,020 --> 01:08:18,530
关于GeometeryReader要记住的一件事， 

1551
01:08:18,530 --> 01:08:22,620
它只是一个视图，但它始终接受

1552
01:08:22,620 --> 01:08:24,193
提供给它的空间。 

1553
01:08:25,220 --> 01:08:29,220
我强调这是因为它需要一点点沉入

1554
01:08:29,220 --> 01:08:32,550
因为您不想在这里进入递归循环

1555
01:08:32,550 --> 01:08:35,770
GeometryReader正在读取其大小的位置

1556
01:08:35,770 --> 01:08:37,940
然后您尝试实际更改大小

1557
01:08:37,940 --> 01:08:40,530
基于GeometryReader读取的大小。 

1558
01:08:40,530 --> 01:08:41,590
那样行不通。 

1559
01:08:41,590 --> 01:08:44,450
GeometryReader始终接受尺寸， 

1560
01:08:44,450 --> 01:08:45,850
提供给他们的空间

1561
01:08:45,850 --> 01:08:47,170
你必须这样想。 

1562
01:08:47,170 --> 01:08:50,350
因此，GeometryReaders实用程序受到限制

1563
01:08:50,350 --> 01:08:52,880
知道您要提供的尺寸

1564
01:08:52,880 --> 01:08:55,340
并调整您的内在外观， 

1565
01:08:55,340 --> 01:08:56,800
这就是GeometryReader的目的。 

1566
01:08:56,800 --> 01:09:00,550
不要试图将GeometryReader变成不是的东西。 

1567
01:09:00,550 --> 01:09:02,180
只是在读取您的几何图形， 

1568
01:09:02,180 --> 01:09:03,758
它叫做GeometryReader， 

1569
01:09:03,758 --> 01:09:06,237
它会读取几何图形，并且您可以适应它

1570
01:09:06,237 --> 01:09:09,373
因此您可以更改字体等。 

1571
01:09:11,220 --> 01:09:13,190
我们提到的安全区， 

1572
01:09:13,190 --> 01:09:16,800
GeometryReader告诉您的safeAreaInsets。 

1573
01:09:16,800 --> 01:09:20,120
安全区域可视化程度最高

1574
01:09:20,120 --> 01:09:22,840
通过考虑iPhone 10上的缺口

1575
01:09:22,840 --> 01:09:26,530
在大多数情况下，您不想草拟大小

1576
01:09:26,530 --> 01:09:29,070
缺口在那里的位置，但并非总是如此。 

1577
01:09:29,070 --> 01:09:31,780
有时您可能实际上想在那里画画。 

1578
01:09:31,780 --> 01:09:33,570
还有其他安全区域的事情。 

1579
01:09:33,570 --> 01:09:35,970
有时，视图会添加装饰

1580
01:09:35,970 --> 01:09:38,760
或他们在屏幕上绘画的方式

1581
01:09:38,760 --> 01:09:41,360
他们不希望您在某些空间中绘画的地方

1582
01:09:41,360 --> 01:09:44,930
因此他们会创建一个安全区域供您使用。 

1583
01:09:44,930 --> 01:09:48,300
但是，如果您想离开自己的安全区域，则可以， 

1584
01:09:48,300 --> 01:09:51,680
而执行此操作的方法是通过此处的“视图”修改器， 

1585
01:09:51,680 --> 01:09:55,200
edgeIgnoringSafeArea，然后指定哪些边

1586
01:09:55,200 --> 01:09:57,590
您想忽略该安全区域。 

1587
01:09:57,590 --> 01:10:00,357
因此，如果我说edgesIgnoringSafeArea回到顶部， 

1588
01:10:00,357 --> 01:10:02,427
然后是ZStack及其中的所有内容

1589
01:10:02,427 --> 01:10:05,500
会忽略顶部有一个安全区域

1590
01:10:05,500 --> 01:10:09,450
然后就在那刻痕的下方画上去

1591
01:10:09,450 --> 01:10:12,200
因此，它可能是照片查看应用程序之类的东西， 

1592
01:10:12,200 --> 01:10:14,130
也许你想一直到边缘

1593
01:10:14,130 --> 01:10:15,343
所以你可以在这里做。 

1594
01:10:17,500 --> 01:10:21,180
让我们谈谈容器的作用

1595
01:10:21,180 --> 01:10:23,080
这为他们的意见提供了空间

1596
01:10:23,080 --> 01:10:24,530
然后放置它们。 

1597
01:10:24,530 --> 01:10:28,010
它为此修改器框架提供了空间。 

1598
01:10:28,010 --> 01:10:30,970
现在，我在这里不再详细讨论框架。 

1599
01:10:30,970 --> 01:10:33,010
你可以去看看文件架

1600
01:10:33,010 --> 01:10:37,330
有很多参数，理想宽度，最小宽度， 

1601
01:10:37,330 --> 01:10:40,630
所有这些尝试和交流的事物

1602
01:10:40,630 --> 01:10:44,773
到这里的景观就是我为您提供的空间。 

1603
01:10:45,710 --> 01:10:47,090
这就是空间。 

1604
01:10:47,090 --> 01:10:49,830
然后，视图选择了自己的尺寸后， 

1605
01:10:49,830 --> 01:10:53,170
那么我们将使用这个修饰符位置

1606
01:10:53,170 --> 01:10:56,270
容器之前我们坐标空间中的某个位置。 

1607
01:10:56,270 --> 01:10:59,560
因此，他们就是这样做的。 

1608
01:10:59,560 --> 01:11:00,880
非常简单。 

1609
01:11:00,880 --> 01:11:04,490
例如，堆栈将使用其对齐信息

1610
01:11:04,490 --> 01:11:07,300
以及所有的间距

1611
01:11:07,300 --> 01:11:09,630
弄清楚他们的观点应该去哪里， 

1612
01:11:09,630 --> 01:11:11,990
它会设置这个CGPoint 

1613
01:11:11,990 --> 01:11:13,800
这是视图的中心， 

1614
01:11:13,800 --> 01:11:16,490
在CGPoint中的每个视图。 

1615
01:11:16,490 --> 01:11:18,950
顺便说一句，这里有点酷

1616
01:11:18,950 --> 01:11:22,420
称为偏移量，它将偏移视图

1617
01:11:22,420 --> 01:11:24,150
从容器放到哪里。 

1618
01:11:24,150 --> 01:11:26,200
因此，您可以让容器完成其工作， 

1619
01:11:26,200 --> 01:11:28,350
把东西放在某个地方，然后你仍然可以抵消它

1620
01:11:28,350 --> 01:11:30,010
一点点的东西。 

1621
01:11:30,010 --> 01:11:31,090
容器可以做到这一点

1622
01:11:31,090 --> 01:11:32,350
但其他人也可以做到。 

1623
01:11:32,350 --> 01:11:33,213
视图可以做到这一点。 

1624
01:11:33,213 --> 01:11:35,180
我想抵消一点。 

1625
01:11:35,180 --> 01:11:37,210
因此，抵消是一个有趣的小家伙。 

1626
01:11:37,210 --> 01:11:38,271
我们不用太多的偏移量

1627
01:11:38,271 --> 01:11:40,830
但我只想让你知道它的存在。 

1628
01:11:40,830 --> 01:11:42,560
现在，为了记住，我们将使用框架

1629
01:11:42,560 --> 01:11:45,450
和位置来创建我们自己的容器视图

1630
01:11:45,450 --> 01:11:47,080
有点像堆栈。 

1631
01:11:47,080 --> 01:11:51,020
它被称为网格，它是2D，行和列， 

1632
01:11:51,020 --> 01:11:52,940
而不只是水平行

1633
01:11:52,940 --> 01:11:54,800
这是一个看起来很伤心的游戏， 

1634
01:11:54,800 --> 01:11:56,817
如果我现在就这样说的话。 

1635
01:11:56,817 --> 01:11:58,950
我们显然希望它是行和列。 

1636
01:11:58,950 --> 01:12:01,860
我们将通过使用框架和位置来做到这一点

1637
01:12:01,860 --> 01:12:03,260
创建我们自己的容器。 

1638
01:12:05,350 --> 01:12:07,700
所以我们今天要回到演示。 

1639
01:12:07,700 --> 01:12:10,390
我很想有时间去做那个容器， 

1640
01:12:10,390 --> 01:12:13,650
但是我们没有，第三节课结束。 

1641
01:12:13,650 --> 01:12:16,320
我会做一个简短的演示

1642
01:12:16,320 --> 01:12:18,570
只是向您展示GeometryReader的工作原理。 

1643
01:12:18,570 --> 01:12:21,210
而我们要做的就是我一直在谈论的东西， 

1644
01:12:21,210 --> 01:12:24,150
制作我们的字体，表情符号字体， 

1645
01:12:24,150 --> 01:12:27,040
尺寸更适合我们提供的空间

1646
01:12:27,040 --> 01:12:28,660
使用GeometryReader。 

1647
01:12:28,660 --> 01:12:30,370
当我在那里的时候，我可能会做一件小事

1648
01:12:30,370 --> 01:12:32,170
我要告诉你最好的方法

1649
01:12:32,170 --> 01:12:34,600
或我们大家都同意的那种方式

1650
01:12:34,600 --> 01:12:37,810
在我们的代码中收集魔术数字。 

1651
01:12:37,810 --> 01:12:40,280
如果您已经有一个如cornerRadius 10这样的设备， 

1652
01:12:40,280 --> 01:12:41,750
那10是个魔术数字， 

1653
01:12:41,750 --> 01:12:43,720
它确实不应该嵌入我们的代码中。 

1654
01:12:43,720 --> 01:12:46,780
Swift中有一种规范的方法可以将其删除

1655
01:12:46,780 --> 01:12:49,140
并放在自己的小空间

1656
01:12:49,140 --> 01:12:51,163
因此，它有充分的文档记录和类型。 

1657
01:12:52,800 --> 01:12:54,830
现在，我们开始下一个演讲， 

1658
01:12:54,830 --> 01:12:57,310
使用GeometryReader和泛型

1659
01:12:57,310 --> 01:13:00,130
具有协议和功能类型

1660
01:13:00,130 --> 01:13:03,960
使这个美丽的小简单的网格视图

1661
01:13:03,960 --> 01:13:05,543
那就像是一个HStack。 

1662
01:13:05,543 --> 01:13:08,730
我们将仅使用此Grid View来替换HStack 

1663
01:13:08,730 --> 01:13:10,970
并使我们的卡片排列在一个漂亮的网格中。 

1664
01:13:10,970 --> 01:13:12,510
因此，让我们跳入该演示

1665
01:13:12,510 --> 01:13:14,620
然后这将是本讲座的结尾。 

1666
01:13:14,620 --> 01:13:16,150
现在在您的作业中， 

1667
01:13:16,150 --> 01:13:20,030
您被要求在此处调整字体选择

1668
01:13:20,030 --> 01:13:23,440
适合小卡片，因为小卡片， 

1669
01:13:23,440 --> 01:13:26,200
我们选择的字体，大标题太大。 

1670
01:13:26,200 --> 01:13:28,850
这可能已经解决了，仅适用于小卡片

1671
01:13:28,850 --> 01:13:31,400
但是我让你这样做几乎是为了意识到， 

1672
01:13:31,400 --> 01:13:34,450
好吧，这不是一个好的解决方案，尤其是当我们

1673
01:13:34,450 --> 01:13:38,120
在连大标题都太小的风景中。 

1674
01:13:38,120 --> 01:13:41,660
所以我们真正想要的是我们的卡

1675
01:13:41,660 --> 01:13:43,730
选择使用所有空间的字体。 

1676
01:13:43,730 --> 01:13:45,970
那确实是我们想要做的。 

1677
01:13:45,970 --> 01:13:47,960
那么我们该怎么做呢？ 

1678
01:13:47,960 --> 01:13:50,520
好吧，我们将使用特殊的View来做到这一点。 

1679
01:13:50,520 --> 01:13:52,850
这是另一个视图，就像HStack是一个视图

1680
01:13:52,850 --> 01:13:56,540
ForEach是一个视图，ZStack是一个视图，Text是一个视图。 

1681
01:13:56,540 --> 01:13:58,250
这些都是视图。 

1682
01:13:58,250 --> 01:13:59,930
有一个特殊的看法

1683
01:13:59,930 --> 01:14:03,680
这就是所谓的GeometryReader视图。 

1684
01:14:06,200 --> 01:14:08,800
所以GeometryReader有一个参数

1685
01:14:08,800 --> 01:14:11,760
这将是要显示的内容

1686
01:14:11,760 --> 01:14:16,602
本身就是另一个像我们的卡片一样的视图， 

1687
01:14:16,602 --> 01:14:18,780
ZStack可以制作我们的卡， 

1688
01:14:18,780 --> 01:14:22,990
但是这里有一个很好的论点，叫做几何

1689
01:14:22,990 --> 01:14:26,870
就像ForEach是在这里有论点的View 

1690
01:14:26,870 --> 01:14:29,390
但它也有这种内容论点

1691
01:14:29,390 --> 01:14:33,150
它提供了要遍历的Card。 

1692
01:14:33,150 --> 01:14:35,790
同样，GeometryReader，它具有内容， 

1693
01:14:35,790 --> 01:14:39,720
要求一个视图，但它提供了这种特殊的几何形状。 

1694
01:14:39,720 --> 01:14:41,870
我们将看看这个小变量

1695
01:14:41,870 --> 01:14:43,920
在这里给你的

1696
01:14:43,920 --> 01:14:44,840
因为我们可以看一下

1697
01:14:44,840 --> 01:14:47,270
并查看我们的视图的大小。 

1698
01:14:47,270 --> 01:14:49,680
现在注意，当我们放置代码时， 

1699
01:14:49,680 --> 01:14:53,650
我们的ZStack，位于GeometryReader内容中， 

1700
01:14:53,650 --> 01:14:56,800
我们得到了这些需要self.thing。 

1701
01:14:56,800 --> 01:15:00,957
因此，请通过此处并对此进行修复， 

1702
01:15:00,957 --> 01:15:03,313
修理那个，捡起来。 

1703
01:15:04,700 --> 01:15:06,320
那是什么

1704
01:15:06,320 --> 01:15:09,431
让我们看一下GeometryReader的文档。 

1705
01:15:09,431 --> 01:15:12,080
因此，我将执行Option +单击以查看GeometryReader。 

1706
01:15:12,080 --> 01:15:14,920
您可以在此处看到struct GeometryReader。 

1707
01:15:14,920 --> 01:15:17,970
不用管它叫Content 

1708
01:15:17,970 --> 01:15:20,130
该内容是一个视图。 

1709
01:15:20,130 --> 01:15:23,620
所以现在，希望您开始了解

1710
01:15:23,620 --> 01:15:26,650
这意味着“内容是视图”，对吗？ 

1711
01:15:26,650 --> 01:15:29,460
内容不在乎，视图是协议。 

1712
01:15:29,460 --> 01:15:31,463
所以我们已经把无关紧要变成了

1713
01:15:31,463 --> 01:15:33,610
好吧，我们有点在意吧？ 

1714
01:15:33,610 --> 01:15:36,900
我们关心的是GeometryReader的内容是一个View， 

1715
01:15:36,900 --> 01:15:40,120
但是否则它可以是它想要的任何东西。 

1716
01:15:40,120 --> 01:15:43,200
所以我要在文档中打开它

1717
01:15:43,200 --> 01:15:44,750
看看它怎么说。 

1718
01:15:44,750 --> 01:15:46,290
这是初始化。 

1719
01:15:46,290 --> 01:15:49,200
您可以看到它需要这一参数内容

1720
01:15:49,200 --> 01:15:52,620
您实际上应该在这里识别此语法

1721
01:15:52,620 --> 01:15:55,500
因为真的，它需要一个功能

1722
01:15:55,500 --> 01:15:58,210
返回此内容的内容不在乎， 

1723
01:15:58,210 --> 01:16:01,380
我们知道实际上是我们关心的一点内容

1724
01:16:01,380 --> 01:16:02,990
内容冒号视图

1725
01:16:02,990 --> 01:16:05,100
因此我们知道它必须是View。 

1726
01:16:05,100 --> 01:16:08,210
这就是一个带有参数的函数

1727
01:16:08,210 --> 01:16:12,960
GeometryProxy，并返回此无关内容。 

1728
01:16:12,960 --> 01:16:15,720
不用担心@逃到那里。 

1729
01:16:15,720 --> 01:16:18,580
我们将在接下来的几周内谈论这一点。 

1730
01:16:18,580 --> 01:16:23,580
因此，让我们单击此GeometryProxy并查看其装饰。 

1731
01:16:23,900 --> 01:16:25,680
在这里，您可以看到其中包含的东西

1732
01:16:25,680 --> 01:16:27,810
我们在幻灯片中谈到了。 

1733
01:16:27,810 --> 01:16:31,180
现在，我将重点显然放在此处的尺寸上。 

1734
01:16:31,180 --> 01:16:33,560
因此，让我们单击它。 

1735
01:16:33,560 --> 01:16:36,090
您会看到大小只是CGSize， 

1736
01:16:36,090 --> 01:16:37,467
它只有get，它是只读的。 

1737
01:16:37,467 --> 01:16:39,880
只是要告诉我们宽度和高度

1738
01:16:39,880 --> 01:16:42,973
我们已经提供了绘制此视图的方法。 

1739
01:16:44,028 --> 01:16:46,110
这正是我们想要的。 

1740
01:16:46,110 --> 01:16:47,990
我们希望此几何尺寸就在这里。 

1741
01:16:47,990 --> 01:16:52,010
我要做的是拥有CardView 

1742
01:16:52,010 --> 01:16:56,950
在这里设置自己的字体以取得所有权。 

1743
01:16:56,950 --> 01:16:58,550
因此，它将使用字体。 

1744
01:16:58,550 --> 01:17:01,230
因此，我不再在游戏本身中设置字体。 

1745
01:17:01,230 --> 01:17:03,330
我让卡设置自己的字体

1746
01:17:03,330 --> 01:17:05,890
无论如何，这可能是更好的封装。 

1747
01:17:05,890 --> 01:17:07,140
为什么我们在这里， 

1748
01:17:07,140 --> 01:17:10,997
我们不需要像HStack这样的冒号内容

1749
01:17:10,997 --> 01:17:12,040
以及所有其他这些东西。 

1750
01:17:12,040 --> 01:17:14,960
我们可以摆脱它，摆脱它

1751
01:17:14,960 --> 01:17:17,600
所以这看起来很干净。 

1752
01:17:17,600 --> 01:17:20,860
所以我们想在这里做一个字体，所以写一些字体， 

1753
01:17:20,860 --> 01:17:24,320
其尺寸基于该几何尺寸。 

1754
01:17:24,320 --> 01:17:26,033
所以我要创建系统字体， 

1755
01:17:26,033 --> 01:17:28,470
只是在这里制作系统字体的不同方法， 

1756
01:17:28,470 --> 01:17:29,600
样式和大小。 

1757
01:17:29,600 --> 01:17:31,450
所以我只是选择尺寸。 

1758
01:17:31,450 --> 01:17:35,820
我想要一个CGFloat，其大小为磅值。 

1759
01:17:35,820 --> 01:17:37,540
并记住字体的磅值

1760
01:17:37,540 --> 01:17:41,580
与那里的点宽和点高有关。 

1761
01:17:41,580 --> 01:17:44,510
所以我实际上要选择最小的宽度

1762
01:17:44,510 --> 01:17:46,130
因为我不一定要

1763
01:17:46,130 --> 01:17:49,270
取决于知道我的宽高比是多少。 

1764
01:17:49,270 --> 01:17:51,420
所以我只选择这两个中的最小值

1765
01:17:51,420 --> 01:17:53,960
确保我选择合适的字体。 

1766
01:17:53,960 --> 01:17:58,960
所以这是最小几何尺寸宽度

1767
01:17:59,010 --> 01:18:02,240
以及几何尺寸高度。 

1768
01:18:02,240 --> 01:18:04,630
所以我使用的是我们看到的那个大小变量

1769
01:18:04,630 --> 01:18:07,510
就在这里的GeometryProxy中。 

1770
01:18:07,510 --> 01:18:09,520
也许我们可以尝试一下。 

1771
01:18:09,520 --> 01:18:14,110
我们只选择这两种字体中最小的一种

1772
01:18:14,110 --> 01:18:15,600
然后看看它是什么样子。 

1773
01:18:15,600 --> 01:18:16,573
因此，让我们运行它。 

1774
01:18:19,430 --> 01:18:20,310
看那个。 

1775
01:18:20,310 --> 01:18:24,290
这样的尺寸更接近，甚至更小。 

1776
01:18:24,290 --> 01:18:26,570
但这实际上太大了。 

1777
01:18:26,570 --> 01:18:28,730
那里太大了。 

1778
01:18:28,730 --> 01:18:32,600
也许只是因为绘图点大小

1779
01:18:32,600 --> 01:18:35,060
不完全是字体的宽度。 

1780
01:18:35,060 --> 01:18:38,010
它可能与高度有关， 

1781
01:18:38,010 --> 01:18:41,610
但是我们也确实在边缘上做了一些笔触

1782
01:18:41,610 --> 01:18:44,030
也会占用一点空间。 

1783
01:18:44,030 --> 01:18:47,960
所以可能我需要某种常数乘数

1784
01:18:47,960 --> 01:18:52,960
例如大约75％，0.75。 

1785
01:18:55,520 --> 01:18:59,210
而75％的人看起来确实不错。 

1786
01:18:59,210 --> 01:19:02,173
大的时候看起来不错，小的时候看起来不错。 

1787
01:19:03,310 --> 01:19:05,780
在完成第三讲之前， 

1788
01:19:05,780 --> 01:19:07,840
我想在这里花点时间

1789
01:19:07,840 --> 01:19:10,910
谈论编码风格问题。 

1790
01:19:10,910 --> 01:19:14,460
我不太常谈论编码风格， 

1791
01:19:14,460 --> 01:19:17,750
纯粹出于时间限制

1792
01:19:17,750 --> 01:19:20,159
但是这次我要提一下。 

1793
01:19:20,159 --> 01:19:22,060
因为这有点塞古

1794
01:19:22,060 --> 01:19:25,690
我们将如何构建我们的View代码

1795
01:19:25,690 --> 01:19:28,160
使它更具可读性。 

1796
01:19:28,160 --> 01:19:32,050
我担心的问题是这些幻数。 

1797
01:19:32,050 --> 01:19:34,380
我们已经创建了这些蓝色魔术数字

1798
01:19:34,380 --> 01:19:37,250
并开始在整个代码中散布它们。 

1799
01:19:37,250 --> 01:19:39,290
那不是很好的编码风格。 

1800
01:19:39,290 --> 01:19:42,280
SwiftUI是声明性的。 

1801
01:19:42,280 --> 01:19:45,280
我们实质上是在这里直接声明UI。 

1802
01:19:45,280 --> 01:19:48,150
我们不是在调用函数来告诉它自己构建， 

1803
01:19:48,150 --> 01:19:49,970
我们在这里宣布。 

1804
01:19:49,970 --> 01:19:51,280
当我们这样做时

1805
01:19:51,280 --> 01:19:54,660
这些蓝色的数字最终变成了旋钮

1806
01:19:54,660 --> 01:19:58,590
我们可以调整视图的外观

1807
01:19:58,590 --> 01:19:59,890
并使其正确。 

1808
01:19:59,890 --> 01:20:01,860
好吧，现在我们的旋钮刚刚散开

1809
01:20:01,860 --> 01:20:03,530
在这里的所有地方。 

1810
01:20:03,530 --> 01:20:07,250
如果我们能有一个控制面板，那真是太好了。 

1811
01:20:07,250 --> 01:20:10,520
因此，我将创建一个小的控制面板。 

1812
01:20:10,520 --> 01:20:14,310
我要在这里评论以标记它的绘制常数， 

1813
01:20:14,310 --> 01:20:15,610
我要称呼它

1814
01:20:15,610 --> 01:20:18,460
并把我所有的绘图常数放在这里

1815
01:20:18,460 --> 01:20:22,800
就像vars一样，让和在我的结构上起作用。 

1816
01:20:22,800 --> 01:20:26,430
以及放置vars，let和函数的想法

1817
01:20:26,430 --> 01:20:28,630
在你的结构中清理

1818
01:20:28,630 --> 01:20:33,220
或在您的视图中固定魔术数字，这非常重要。 

1819
01:20:33,220 --> 01:20:35,970
您将看到大多数视图具有

1820
01:20:35,970 --> 01:20:39,030
一些变量，让我们在这里进行功能

1821
01:20:39,030 --> 01:20:43,610
使外观看起来尽可能整洁易懂。 

1822
01:20:43,610 --> 01:20:47,640
因此，让我们使用这个想法来获得这些神奇的数字。 

1823
01:20:47,640 --> 01:20:49,420
这些碰巧是常数。 

1824
01:20:49,420 --> 01:20:51,090
所以我要用let。 

1825
01:20:51,090 --> 01:20:53,960
记住，让我们就像var一样

1826
01:20:53,960 --> 01:20:56,120
因为let表示它是一个常数。 

1827
01:20:56,120 --> 01:20:59,940
因此，让我们在此处进行转角半径cornerRadius的设置。 

1828
01:20:59,940 --> 01:21:03,370
您可能会认为您可以说cornerRadius等于10 

1829
01:21:03,370 --> 01:21:06,540
但这是行不通的，我将向您展示为什么。 

1830
01:21:06,540 --> 01:21:10,460
如果按住Option键，请记住并单击， 

1831
01:21:10,460 --> 01:21:12,560
它会告诉你宣言

1832
01:21:12,560 --> 01:21:15,000
您点击的东西

1833
01:21:15,000 --> 01:21:16,569
就我们而言，这是我们的角落

1834
01:21:16,569 --> 01:21:19,500
并且已将其键入为Int。 

1835
01:21:19,500 --> 01:21:22,590
请记住，如果我们说让var等于某物

1836
01:21:22,590 --> 01:21:24,130
我们没有指定它的类型， 

1837
01:21:24,130 --> 01:21:25,577
Swift会推断出来。 

1838
01:21:25,577 --> 01:21:28,242
这里是看这十个参考

1839
01:21:28,242 --> 01:21:30,040
看起来像一个Int。 

1840
01:21:30,040 --> 01:21:31,770
那不是我们想要的。 

1841
01:21:31,770 --> 01:21:36,020
这些蓝色的数字都是CGFloats， 

1842
01:21:36,020 --> 01:21:38,740
我们用来绘制的浮点数。 

1843
01:21:38,740 --> 01:21:41,320
现在，我什至不能只说10.0。 

1844
01:21:41,320 --> 01:21:43,640
如果我这样做，并且按住Option +单击， 

1845
01:21:43,640 --> 01:21:45,020
它认为这是一个Double。 

1846
01:21:45,020 --> 01:21:47,440
这些不是双精度浮点数。 

1847
01:21:47,440 --> 01:21:50,848
此Double结构与CGFloat结构不同。 

1848
01:21:50,848 --> 01:21:54,683
因此，我必须明确键入CGFloat。 

1849
01:21:55,810 --> 01:21:59,960
那并不一定是那么繁重或繁重， 

1850
01:21:59,960 --> 01:22:02,310
提醒自己的方式很好

1851
01:22:02,310 --> 01:22:04,483
这些在这里画出常数。 

1852
01:22:05,550 --> 01:22:06,470
让我们做其他的吧。 

1853
01:22:06,470 --> 01:22:09,115
我们得到了edgeLineWidth。 

1854
01:22:09,115 --> 01:22:10,700
我们还有另一个常数

1855
01:22:10,700 --> 01:22:12,150
第三

1856
01:22:12,150 --> 01:22:14,620
当然我们有0.75 

1857
01:22:14,620 --> 01:22:17,740
这真的像我们字体的缩放比例。 

1858
01:22:17,740 --> 01:22:19,817
我将其命名为fontScaleFactor， 

1859
01:22:21,020 --> 01:22:24,273
这也是CGFloat，0.75。 

1860
01:22:25,130 --> 01:22:27,200
现在我将这些放在这里， 

1861
01:22:27,200 --> 01:22:30,210
我可以用这些替换所有的魔术数字

1862
01:22:30,210 --> 01:22:33,800
这将成为我控制面板上的旋钮。 

1863
01:22:33,800 --> 01:22:34,660
因此，让我们这样做。 

1864
01:22:34,660 --> 01:22:35,743
我们有这个。 

1865
01:22:36,720 --> 01:22:39,963
我要复制并粘贴，使此过程更快一点。 

1866
01:22:41,340 --> 01:22:45,820
在这里，这三个是这里的边缘线

1867
01:22:47,410 --> 01:22:52,373
而我们的fontScaleFactor在这里是0.75。 

1868
01:22:53,780 --> 01:22:54,613
很好

1869
01:22:54,613 --> 01:22:59,140
实际上，这也使这段代码读起来也很不错， 

1870
01:22:59,140 --> 01:23:00,880
非常像英语

1871
01:23:00,880 --> 01:23:02,560
试图了解正在发生的事情。 

1872
01:23:02,560 --> 01:23:04,360
但是，您会注意到它的引入

1873
01:23:04,360 --> 01:23:06,690
这里有很多错误。 

1874
01:23:06,690 --> 01:23:08,640
它们实际上都是相同的错误。 

1875
01:23:08,640 --> 01:23:11,440
这是可怕的显性自我。 

1876
01:23:11,440 --> 01:23:14,280
使捕获语义明确。 

1877
01:23:14,280 --> 01:23:17,030
我们可以解决这个问题，然后单击此处

1878
01:23:17,030 --> 01:23:19,950
然后修复它，然后单击并修复它， 

1879
01:23:19,950 --> 01:23:23,940
但我将向您展示避免这种自我的技巧。事情

1880
01:23:23,940 --> 01:23:27,150
在这种常见的GeometryReader情况下。 

1881
01:23:27,150 --> 01:23:29,260
因此，每当您执行GeometryReader时， 

1882
01:23:29,260 --> 01:23:31,430
里面的东西总会抱怨

1883
01:23:31,430 --> 01:23:32,550
关于这个自我点。 

1884
01:23:32,550 --> 01:23:34,374
顺便说一句，ForEach也是如此。 

1885
01:23:34,374 --> 01:23:37,560
里面的每样东西都会抱怨自我点。 

1886
01:23:37,560 --> 01:23:40,450
并非每个View都这样做，但是那两个

1887
01:23:40,450 --> 01:23:42,620
并且它们是常用的。 

1888
01:23:42,620 --> 01:23:47,620
我要创建一个功能，我称其为本体， 

1889
01:23:48,000 --> 01:23:51,130
CGSize，它将使我的身体恢复原状， 

1890
01:23:51,130 --> 01:23:54,670
就像我可以拥有的那样，这将是一些视图

1891
01:23:54,670 --> 01:23:57,680
一些View是此var的类型， 

1892
01:23:57,680 --> 01:24:01,330
我可以让一些View作为此函子的返回类型。 

1893
01:24:01,330 --> 01:24:03,180
我要把我的身体， 

1894
01:24:03,180 --> 01:24:06,450
从这里剪下来，放在这里， 

1895
01:24:06,450 --> 01:24:09,880
然后在我的GeometryReader中调用此函数， 

1896
01:24:09,880 --> 01:24:14,310
用于几何尺寸的self.body。 

1897
01:24:17,270 --> 01:24:19,550
这段代码实际上清理得很好。 

1898
01:24:19,550 --> 01:24:21,170
这是很合理的。 

1899
01:24:21,170 --> 01:24:24,830
现在该代码不再嵌入

1900
01:24:24,830 --> 01:24:26,860
在这样的GeometryReader中

1901
01:24:26,860 --> 01:24:28,960
因此您不需要这些自我点。 

1902
01:24:28,960 --> 01:24:30,150
所以我可以摆脱那一个

1903
01:24:30,150 --> 01:24:32,250
那一那一那。 

1904
01:24:32,250 --> 01:24:34,220
所有那些自我点都消失了。 

1905
01:24:34,220 --> 01:24:37,330
更重要的是，我没有通过整个几何

1906
01:24:37,330 --> 01:24:41,310
到这个物体，只是尺寸，几何尺寸var。 

1907
01:24:41,310 --> 01:24:45,410
所以在这里，我不需要说geometry.size。 

1908
01:24:45,410 --> 01:24:48,850
现在这个geometry.size就是size， 

1909
01:24:48,850 --> 01:24:51,150
我传入的这个大小。 

1910
01:24:51,150 --> 01:24:53,550
这样使这段代码看起来更好

1911
01:24:53,550 --> 01:24:56,060
我几乎总是建议， 

1912
01:24:56,060 --> 01:24:57,740
至少接下来的几个月

1913
01:24:57,740 --> 01:25:02,260
直到他们把Swift的self.change放在那里

1914
01:25:02,260 --> 01:25:05,240
自我。不再导致此问题。 

1915
01:25:05,240 --> 01:25:08,220
这是拥有此代码的真正干净的方法

1916
01:25:08,220 --> 01:25:09,980
不必担心自我点。 

1917
01:25:09,980 --> 01:25:14,023
您可以在ForEach中为项目做相同的事情

1918
01:25:15,540 --> 01:25:18,980
因为每个人都会导致那个自我。问题。 

1919
01:25:18,980 --> 01:25:20,550
我们可以在这里做另一件事。 

1920
01:25:20,550 --> 01:25:22,240
在这里，我可以有一个功能

1921
01:25:22,240 --> 01:25:25,083
对于称为fontSize的字体大小， 

1922
01:25:26,140 --> 01:25:29,460
它返回的字体大小也是CGFloat， 

1923
01:25:29,460 --> 01:25:34,030
并将这段代码放在这里

1924
01:25:34,030 --> 01:25:37,773
这样就可以读取fontSize的大小。 

1925
01:25:38,740 --> 01:25:41,820
您可能会认为这是一个非常简单的表达， 

1926
01:25:41,820 --> 01:25:45,090
我真的不需要在这里将其变成自己的功能， 

1927
01:25:45,090 --> 01:25:49,090
但是同样，您不能使它变得太简单。 

1928
01:25:49,090 --> 01:25:51,380
您真的想让它尽可能简单。 

1929
01:25:51,380 --> 01:25:53,210
有时您不得不使其变得简单。 

1930
01:25:53,210 --> 01:25:54,910
正如我所解释的， 

1931
01:25:54,910 --> 01:25:57,780
不能是任意复杂的表达式。 

1932
01:25:57,780 --> 01:25:59,480
所以有时候这需要一个函数

1933
01:25:59,480 --> 01:26:00,420
返回一个布尔， 

1934
01:26:00,420 --> 01:26:03,440
不是在这种情况下，因为这是简单的布尔。 

1935
01:26:03,440 --> 01:26:06,970
但是让这些小班轮发挥作用

1936
01:26:06,970 --> 01:26:11,700
使这个身体看起来更干净，很常见。 

1937
01:26:11,700 --> 01:26:15,780
在这里，我们甚至不必拥有这个fontScaleFactor 

1938
01:26:15,780 --> 01:26:18,410
成为自己的独立

1939
01:26:18,410 --> 01:26:20,470
因为您可以考虑字体大小

1940
01:26:20,470 --> 01:26:22,540
作为绘图常量的一部分。 

1941
01:26:22,540 --> 01:26:26,983
这是给定大小的恒定字体大小。 

1942
01:26:28,210 --> 01:26:30,130
这就是第三讲。 

1943
01:26:30,130 --> 01:26:32,930
我们要马上潜回去

1944
01:26:32,930 --> 01:26:35,500
从第四讲开始，并继续进行此演示

1945
01:26:35,500 --> 01:26:39,650
并使我们的HStack成为2D网格。 

1946
01:26:39,650 --> 01:26:41,883
我们将学到很多东西。 

1947
01:26:42,740 --> 01:26:46,213
-[播音员]有关更多信息，请访问stanford.edu。 

