1
00:00:00,541 --> 00:00:03,208
（空气哇声） 

2
00:00:04,930 --> 00:00:06,580
-[旁白]斯坦福大学。 

3
00:00:08,470 --> 00:00:10,300
-[讲师]好的，第五课。 

4
00:00:10,300 --> 00:00:13,713
斯坦福CS193P 2020年春季。 

5
00:00:14,860 --> 00:00:18,220
今天我们将从一个小样开始

6
00:00:18,220 --> 00:00:21,190
记忆中的访问控制。 

7
00:00:21,190 --> 00:00:24,260
您已经了解了访问控制

8
00:00:24,260 --> 00:00:26,080
在阅读作业中

9
00:00:26,080 --> 00:00:29,860
我们实际上使用了访问控制

10
00:00:29,860 --> 00:00:32,580
在“记住”中，但是现在该应用访问控制了

11
00:00:32,580 --> 00:00:35,330
记住并继续使用

12
00:00:35,330 --> 00:00:36,450
而你应该使用它

13
00:00:36,450 --> 00:00:39,823
在您所有的SwiftUI编程中永无止境。 

14
00:00:41,130 --> 00:00:42,797
演示之后，我们要回来

15
00:00:42,797 --> 00:00:45,040
再谈一下ViewBuilder。 

16
00:00:45,040 --> 00:00:48,061
非常重要，非常简单的小概念

17
00:00:48,061 --> 00:00:50,930
我在上一讲中已经提到过几次

18
00:00:50,930 --> 00:00:54,160
但现在我们只想清楚地阐明

19
00:00:54,160 --> 00:00:55,716
ViewBuilder的全部用途。 

20
00:00:55,716 --> 00:00:57,990
然后我们将讨论当天的主要话题， 

21
00:00:57,990 --> 00:00:59,285
这是形状。 

22
00:00:59,285 --> 00:01:01,860
如果我想绘制视图怎么办

23
00:01:01,860 --> 00:01:04,410
而不是从其他视图中删除我的视图？ 

24
00:01:04,410 --> 00:01:06,180
我怎么做？ 

25
00:01:06,180 --> 00:01:08,614
我们将在“记忆”中进行演示，在其中添加形状

26
00:01:08,614 --> 00:01:12,130
表情符号后面的那个小馅饼

27
00:01:12,130 --> 00:01:15,254
您在第一堂课中看到的

28
00:01:15,254 --> 00:01:18,467
然后我们进入动画主题

29
00:01:18,467 --> 00:01:21,340
我们将意识到动画非常重要

30
00:01:21,340 --> 00:01:24,460
在移动应用程序中，而且在Swift中超级简单

31
00:01:24,460 --> 00:01:27,420
在某些方面几乎是免费的， 

32
00:01:27,420 --> 00:01:29,240
但是当我们开始谈论动画时

33
00:01:29,240 --> 00:01:31,030
我们将迅速到达这一点

34
00:01:31,030 --> 00:01:33,250
在这里我们需要谈论另一个概念

35
00:01:33,250 --> 00:01:35,022
称为ViewModifiers。 

36
00:01:35,022 --> 00:01:36,750
ViewModifiers是基础

37
00:01:36,750 --> 00:01:40,120
我们如何构建这些视图

38
00:01:40,120 --> 00:01:41,710
而且您到处都在使用ViewModifiers 

39
00:01:41,710 --> 00:01:44,747
甚至可能根本没有意识到您正在这样做

40
00:01:44,747 --> 00:01:47,950
我们将深入了解正在发生的事情

41
00:01:47,950 --> 00:01:50,283
在您编写的所有SwiftUI代码中。 

42
00:01:52,110 --> 00:01:56,040
顺便说一句，本周不需要遵循

43
00:01:56,040 --> 00:01:57,300
通过作业。 

44
00:01:57,300 --> 00:01:59,010
实际上，这周的功课

45
00:01:59,010 --> 00:02:00,980
甚至不会被记住。 

46
00:02:00,980 --> 00:02:03,490
是时候编写您自己的应用程序了

47
00:02:03,490 --> 00:02:04,500
从头开始。 

48
00:02:04,500 --> 00:02:08,230
但是我现在要做的访问控制功能

49
00:02:08,230 --> 00:02:10,030
是你必须申请的东西

50
00:02:10,030 --> 00:02:11,220
您的所有代码。 

51
00:02:11,220 --> 00:02:13,430
所以跟着记住

52
00:02:13,430 --> 00:02:15,495
可能是一个很好的学习经验。 

53
00:02:15,495 --> 00:02:19,170
在本季度末，我们很有可能会回来

54
00:02:19,170 --> 00:02:21,440
记住做功课

55
00:02:21,440 --> 00:02:23,500
您尚未完成记忆。 

56
00:02:23,500 --> 00:02:26,700
在那种情况下，我会尽力做到这一点

57
00:02:26,700 --> 00:02:30,670
这样我本周要向您展示的代码

58
00:02:30,670 --> 00:02:35,500
将来的作业中不必包括

59
00:02:35,500 --> 00:02:36,333
记住。 

60
00:02:36,333 --> 00:02:37,966
我不能百分百地承诺， 

61
00:02:37,966 --> 00:02:40,710
但我希望情况确实如此。 

62
00:02:40,710 --> 00:02:43,930
话虽如此，很多学生发现

63
00:02:43,930 --> 00:02:46,880
跟随或真正帮助他们学习， 

64
00:02:46,880 --> 00:02:51,120
所以我想我实际上建议您这样做。 

65
00:02:51,120 --> 00:02:54,130
因此，让我们从潜水开始

66
00:02:54,130 --> 00:02:57,823
将整个访问控制更改为“记住”。 

67
00:02:58,920 --> 00:03:03,610
现在，我们已经在记忆中使用过一次作为控件

68
00:03:03,610 --> 00:03:06,960
只有一次，就在这里，私人的。 

69
00:03:06,960 --> 00:03:10,230
访问控制就是控制访问

70
00:03:10,230 --> 00:03:14,220
不同的结构必须具有彼此的变量。 

71
00:03:14,220 --> 00:03:16,925
通过使该模型完全私有

72
00:03:16,925 --> 00:03:19,030
在我们的ViewModel中， 

73
00:03:19,030 --> 00:03:23,460
我们已经迫使ViewModel制作这种无功卡

74
00:03:23,460 --> 00:03:25,118
以便视图可以获取卡片， 

75
00:03:25,118 --> 00:03:28,650
当然我们要有这个意图

76
00:03:28,650 --> 00:03:30,700
这样，如果有人想更改模型， 

77
00:03:30,700 --> 00:03:34,417
他们必须表达自己的意图，如何做到这一点

78
00:03:34,417 --> 00:03:36,870
很好，这使它变得私有。 

79
00:03:36,870 --> 00:03:40,640
但是，我们可以更进一步。 

80
00:03:40,640 --> 00:03:44,170
在我们的模型中，卡片本身

81
00:03:44,170 --> 00:03:47,890
可能想成为私人的。 

82
00:03:47,890 --> 00:03:48,870
这是为什么？ 

83
00:03:48,870 --> 00:03:51,540
好吧，我们不要任何人进来

84
00:03:51,540 --> 00:03:53,000
并把这些卡片弄糟。 

85
00:03:53,000 --> 00:03:54,660
设置为isMatched 

86
00:03:54,660 --> 00:03:57,100
甚至将它们正面朝上或朝下放置。 

87
00:03:57,100 --> 00:04:00,323
卡是否匹配完全在权限范围内

88
00:04:00,323 --> 00:04:02,510
此MemoryGame模型。 

89
00:04:02,510 --> 00:04:05,670
只有它知道卡是否应该匹配

90
00:04:05,670 --> 00:04:08,400
所有逻辑都在选择卡中。 

91
00:04:08,400 --> 00:04:11,950
因此，我们真的想将此私有化。 

92
00:04:11,950 --> 00:04:15,000
但是将其私有化实际上将是一个问题。 

93
00:04:15,000 --> 00:04:17,580
如果我们回到这里，看看这行代码

94
00:04:17,580 --> 00:04:20,490
并与那里的那个人一起编译它， 

95
00:04:20,490 --> 00:04:21,780
您可以看到我们收到错误消息。 

96
00:04:21,780 --> 00:04:23,870
提示无法访问卡

97
00:04:23,870 --> 00:04:26,240
由于私人保护水平。 

98
00:04:26,240 --> 00:04:28,483
实际上，这些卡现在是私人的

99
00:04:28,483 --> 00:04:32,110
因此不再允许使用ViewModel 

100
00:04:32,110 --> 00:04:33,686
访问此变量。 

101
00:04:33,686 --> 00:04:35,847
但是ViewModel确实需要访问

102
00:04:35,847 --> 00:04:38,200
至少要阅读卡片。 

103
00:04:38,200 --> 00:04:41,240
我们还要如何在用户界面中显示卡片？ 

104
00:04:41,240 --> 00:04:44,080
因此，我们不能真正将其私有化， 

105
00:04:44,080 --> 00:04:46,470
但是我们可以使用不同的访问控制级别

106
00:04:46,470 --> 00:04:48,600
设置好了。 

107
00:04:48,600 --> 00:04:53,600
私有集意味着将其设置为私有， 

108
00:04:53,610 --> 00:04:56,392
但不是。 

109
00:04:56,392 --> 00:04:58,670
这正是我们在这种情况下想要的。 

110
00:04:58,670 --> 00:05:00,970
我们希望人们能够看一下我们的卡片

111
00:05:00,970 --> 00:05:04,080
因此他们可以将它们放在用户界面中，进行显示。 

112
00:05:04,080 --> 00:05:07,020
但是，在更换卡片时， 

113
00:05:07,020 --> 00:05:10,090
我们绝对希望为我们自己保留。 

114
00:05:10,090 --> 00:05:14,993
因此，私有集是要设置的真正的通用访问控制。 

115
00:05:16,240 --> 00:05:21,240
现在，访问控制不仅仅是我们在var上设置的功能。 

116
00:05:21,540 --> 00:05:23,860
这也是我们可以在功能上设置的

117
00:05:23,860 --> 00:05:26,910
和我们自己的内部计算机变量。 

118
00:05:26,910 --> 00:05:29,700
例如，indexOfTheOneAndOnlyFaceUpCard 

119
00:05:29,700 --> 00:05:32,440
在我们的模型中，这纯粹是私人的事情。 

120
00:05:32,440 --> 00:05:35,920
这是我们要弄清楚怎么做的私人逻辑

121
00:05:35,920 --> 00:05:37,200
我们的配对游戏。 

122
00:05:37,200 --> 00:05:40,150
这绝对是要私密的。 

123
00:05:40,150 --> 00:05:43,090
我们当然不希望任何人设置此设置， 

124
00:05:43,090 --> 00:05:45,170
可能完全把我们搞砸了

125
00:05:45,170 --> 00:05:47,550
我们真的不希望有人看着它

126
00:05:47,550 --> 00:05:49,830
因为如果他们开始看它

127
00:05:49,830 --> 00:05:50,958
他们可能会依赖它

128
00:05:50,958 --> 00:05:54,950
然后我必须始终使用这种特殊策略

129
00:05:54,950 --> 00:05:56,682
按照我可能不想做的逻辑， 

130
00:05:56,682 --> 00:06:00,090
所以这就是我们要保持此私密性的原因。 

131
00:06:00,090 --> 00:06:02,100
当然选择不能是私有的。 

132
00:06:02,100 --> 00:06:04,540
这是人们玩我们的游戏的方式

133
00:06:04,540 --> 00:06:07,490
而且我们的init不想成为私有的。 

134
00:06:07,490 --> 00:06:09,961
允许您具有私人初始化。 

135
00:06:09,961 --> 00:06:11,810
这是一种罕见的情况

136
00:06:11,810 --> 00:06:14,590
但是你可以让init只在你的结构内部使用

137
00:06:14,590 --> 00:06:18,333
创建也许将要使用的私有实例。 

138
00:06:19,270 --> 00:06:21,720
现在，struct Card在这里很有意思。 

139
00:06:21,720 --> 00:06:25,280
您可能在想，哦，私人场景，私人场景， 

140
00:06:25,280 --> 00:06:26,630
私有集，私有集。 

141
00:06:26,630 --> 00:06:29,270
我们不希望任何人设置这些。 

142
00:06:29,270 --> 00:06:32,770
但是，获取卡的唯一途径

143
00:06:32,770 --> 00:06:36,838
模型之外的对象就是通过此数组。 

144
00:06:36,838 --> 00:06:38,946
并且此数组已经是私有集。 

145
00:06:38,946 --> 00:06:40,810
这是一个值类型。 

146
00:06:40,810 --> 00:06:43,520
实际的卡在此阵列中。 

147
00:06:43,520 --> 00:06:45,861
当有人打电话给这个变种来获得这个， 

148
00:06:45,861 --> 00:06:49,900
他们正在获取副本，并且该副本是只读的

149
00:06:49,900 --> 00:06:51,340
因为私人订位。 

150
00:06:51,340 --> 00:06:54,470
因此，由于任何人都无法获得可写卡， 

151
00:06:54,470 --> 00:06:57,423
对我们来说，以这种方式离开这些变量非常好。 

152
00:06:58,350 --> 00:07:01,610
好吧，那回到我们的ViewModel呢？ 

153
00:07:01,610 --> 00:07:03,600
清楚地访问模型。 

154
00:07:03,600 --> 00:07:06,700
这不必是私有的。 

155
00:07:06,700 --> 00:07:10,440
无论如何它都是只读的，因为它是只读的var。 

156
00:07:10,440 --> 00:07:13,490
绝对意图是非私有的。 

157
00:07:13,490 --> 00:07:16,130
人们还会如何表达自己的意图？ 

158
00:07:16,130 --> 00:07:18,830
但是这个createMemoryGame，这个静态函数

159
00:07:18,830 --> 00:07:21,290
那可能想成为私人的。 

160
00:07:21,290 --> 00:07:25,370
我们可能不想要其他人， 

161
00:07:25,370 --> 00:07:28,600
特别是我们的View，以创建一个MemoryGame。 

162
00:07:28,600 --> 00:07:30,460
创建一个MemoryGame，创建我们的模型， 

163
00:07:30,460 --> 00:07:32,200
那是我们要做的。 

164
00:07:32,200 --> 00:07:34,780
在家庭作业中，您必须具有新的游戏功能。 

165
00:07:34,780 --> 00:07:37,250
您可能会在这里创建一个新的MemoryGame， 

166
00:07:37,250 --> 00:07:39,710
但这将必须在您的ViewModel中发生

167
00:07:39,710 --> 00:07:43,600
因为例如Views绝不可能

168
00:07:43,600 --> 00:07:45,426
可以负责创建模型。 

169
00:07:45,426 --> 00:07:48,823
因此，ViewModel确实希望这是私有函数。 

170
00:07:50,860 --> 00:07:52,270
我们认为呢？ 

171
00:07:52,270 --> 00:07:54,300
所以这是我们对这里的看法。 

172
00:07:54,300 --> 00:07:55,550
现在让我们看一下CardView。 

173
00:07:55,550 --> 00:07:56,710
这很有趣。 

174
00:07:56,710 --> 00:07:58,850
这些绘图常数在这里。 

175
00:07:58,850 --> 00:08:00,460
这些绝对可以是私人的。 

176
00:08:00,460 --> 00:08:03,750
真的没有任何人会的理由，他们是

177
00:08:03,750 --> 00:08:05,422
还是可以，但是没有理由有人

178
00:08:05,422 --> 00:08:08,710
想要在这里访问这些东西， 

179
00:08:08,710 --> 00:08:10,599
因此这绝对可以是私人的。 

180
00:08:10,599 --> 00:08:14,060
此var机构必须是非私有的

181
00:08:14,060 --> 00:08:16,580
因为系统将调用该名称。 

182
00:08:16,580 --> 00:08:18,980
就是这样，它如何为我们的视图赋予主体

183
00:08:18,980 --> 00:08:21,740
它会在需要的任何时间打电话

184
00:08:21,740 --> 00:08:24,263
了解如何绘制此CardView。 

185
00:08:25,180 --> 00:08:27,400
但是这个小助手功能

186
00:08:27,400 --> 00:08:29,015
我们从GeometryReader内部调用的

187
00:08:29,015 --> 00:08:31,600
没有理由公开，好吗？ 

188
00:08:31,600 --> 00:08:33,870
只有我们从自己的代码中调用它

189
00:08:33,870 --> 00:08:35,253
在CardView内部。 

190
00:08:36,380 --> 00:08:37,430
那这个变种呢？ 

191
00:08:37,430 --> 00:08:38,860
这可以是私人的吗？ 

192
00:08:38,860 --> 00:08:42,160
不，因为当我们创建CardView时， 

193
00:08:42,160 --> 00:08:44,617
我们需要给这个东西一个初始值， 

194
00:08:44,617 --> 00:08:47,400
因此我们必须能够在此处访问它。 

195
00:08:47,400 --> 00:08:48,414
如果我们将此设为私人， 

196
00:08:48,414 --> 00:08:50,263
那么我们将无法在创建它时对其进行设置

197
00:08:50,263 --> 00:08:52,110
这将是未初始化的

198
00:08:52,110 --> 00:08:54,303
而这在Swift中是不允许的。 

199
00:08:55,920 --> 00:08:57,580
那这里呢？ 

200
00:08:57,580 --> 00:09:00,839
好吧，同样，var body必须公开

201
00:09:00,839 --> 00:09:04,560
而且这里的ViewModel必须是公开的

202
00:09:04,560 --> 00:09:07,380
因为例如当我们创建预览器时， 

203
00:09:07,380 --> 00:09:08,770
我们指定了ViewModel， 

204
00:09:08,770 --> 00:09:10,810
在我们的小SceneDelegate中， 

205
00:09:10,810 --> 00:09:15,660
当我们创建应用程序窗口的主视图时， 

206
00:09:15,660 --> 00:09:17,070
我们在这里表达它。 

207
00:09:17,070 --> 00:09:19,313
同样，这必须是公开的。 

208
00:09:21,270 --> 00:09:23,225
在Grid中呢？ 

209
00:09:23,225 --> 00:09:26,910
因此在Grid中，这是一个有趣的案例。 

210
00:09:26,910 --> 00:09:29,490
这些var必须公开吗？ 

211
00:09:29,490 --> 00:09:32,940
嗯，不是因为我们有这个公共初始化程序

212
00:09:32,940 --> 00:09:34,510
设置这些变量。 

213
00:09:34,510 --> 00:09:36,861
因此我们可以将这些完全设为私人

214
00:09:36,861 --> 00:09:39,183
那会很好。 

215
00:09:40,430 --> 00:09:42,610
这些var只需要公开

216
00:09:42,610 --> 00:09:46,000
如果您要让人们直接初始化它们。 

217
00:09:46,000 --> 00:09:47,899
但是由于我们有一个初始化器来初始化它们， 

218
00:09:47,899 --> 00:09:49,550
他们不需要公开。 

219
00:09:49,550 --> 00:09:51,550
可能希望它们是私有的。 

220
00:09:52,820 --> 00:09:55,146
当然，Var主体必须是公开的。 

221
00:09:55,146 --> 00:09:57,917
但是，这些小小的身体助手功能， 

222
00:09:57,917 --> 00:10:00,113
他们不需要公开。 

223
00:10:04,390 --> 00:10:06,160
在GridLayout中如何？ 

224
00:10:06,160 --> 00:10:07,400
因此，我们有了GridLayout。 

225
00:10:07,400 --> 00:10:09,270
当然我们需要构造函数

226
00:10:09,270 --> 00:10:10,910
或将初始化程序公开

227
00:10:10,910 --> 00:10:13,450
我们需要itemSize和位置公开， 

228
00:10:13,450 --> 00:10:14,995
否则，人们将如何使用它？ 

229
00:10:14,995 --> 00:10:19,995
但是这些变量对于使这些私有集非常重要。 

230
00:10:20,640 --> 00:10:24,870
为什么将这三个变量设为私有集如此重要？ 

231
00:10:24,870 --> 00:10:27,970
计算这三个变量

232
00:10:31,270 --> 00:10:32,740
从初始化程序， 

233
00:10:32,740 --> 00:10:35,610
初始化程序中通过的值在这里。 

234
00:10:35,610 --> 00:10:37,570
如果我们不将这些私人套装， 

235
00:10:37,570 --> 00:10:41,020
有人可能会认为他们可以重置此大小变量

236
00:10:41,020 --> 00:10:43,460
并且这些将自动重置。 

237
00:10:43,460 --> 00:10:44,503
但这不是事实。 

238
00:10:45,540 --> 00:10:49,170
初始化GridLayout后，它将永久修复。 

239
00:10:49,170 --> 00:10:50,620
所以我们希望人们知道

240
00:10:50,620 --> 00:10:53,020
他们只能从此处读取这些值。 

241
00:10:53,020 --> 00:10:55,870
您无法设置此项，并期望它们会发生变化

242
00:10:55,870 --> 00:10:56,920
或类似的东西。 

243
00:10:58,261 --> 00:11:00,861
这就是访问控制的情况

244
00:11:00,861 --> 00:11:04,063
实际上可以帮助人们了解如何使用此东西。 

245
00:11:05,713 --> 00:11:09,070
好吧，显然是我们的firstIndex，我们想要那个公众。 

246
00:11:09,070 --> 00:11:10,352
我们将其添加到所有数组中。 

247
00:11:10,352 --> 00:11:12,400
与我们的var相同。 

248
00:11:12,400 --> 00:11:13,993
我们正在公开场合。 

249
00:11:16,330 --> 00:11:17,300
就是这样了。 

250
00:11:17,300 --> 00:11:20,666
这就是我们在Memorize中设置访问控制的方式。 

251
00:11:20,666 --> 00:11:22,740
每次我们添加新功能时， 

252
00:11:22,740 --> 00:11:24,054
当您在家庭作业中这样做时， 

253
00:11:24,054 --> 00:11:27,735
你绝对应该把私人

254
00:11:27,735 --> 00:11:30,145
无论什么地方都应该是私人的。 

255
00:11:30,145 --> 00:11:33,140
现在你们中的许多人已经在做家庭作业。 

256
00:11:33,140 --> 00:11:35,100
您尚未执行此操作，我鼓励您继续执行此操作。 

257
00:11:35,100 --> 00:11:36,960
我们不会让您对此负责

258
00:11:36,960 --> 00:11:38,030
在第二个作业中

259
00:11:38,030 --> 00:11:40,920
但是我们肯定会在第三项任务中。 

260
00:11:40,920 --> 00:11:41,753
让我们运行我们的应用程序

261
00:11:41,753 --> 00:11:44,780
并确保将所有这些私有工作

262
00:11:44,780 --> 00:11:45,613
它做到了。 

263
00:11:45,613 --> 00:11:47,800
有时您会运行您的应用程序，并且会意识到， 

264
00:11:47,800 --> 00:11:50,970
哦，我将其设为私有，但实际上这是必需的。 

265
00:11:50,970 --> 00:11:52,070
然后你必须决定， 

266
00:11:52,070 --> 00:11:54,800
真的要我们访问吗？ 

267
00:11:54,800 --> 00:11:57,543
如果是这样，是私有集还是私有集？ 

268
00:11:58,590 --> 00:12:01,302
这就是我们很少进行访问控制的过程。 

269
00:12:01,302 --> 00:12:03,280
让我们回到幻灯片

270
00:12:03,280 --> 00:12:05,634
并详细讨论ViewBuilder。 

271
00:12:05,634 --> 00:12:08,990
因此，ViewBuilder基于通用技术

272
00:12:08,990 --> 00:12:10,860
最近添加到了Swift 

273
00:12:10,860 --> 00:12:14,350
支持面向列表的语法。 

274
00:12:14,350 --> 00:12:17,440
有很多东西被表达为列表， 

275
00:12:17,440 --> 00:12:19,942
例如HTML，它只是一个列表。 

276
00:12:19,942 --> 00:12:22,324
一段然后是一个嵌入的东西

277
00:12:22,324 --> 00:12:25,570
然后是另一个段落，标题或其他内容， 

278
00:12:25,570 --> 00:12:27,820
它们只是在页面上列出。 

279
00:12:27,820 --> 00:12:29,100
所以在Swift中会很好

280
00:12:29,100 --> 00:12:30,318
能够代表这些

281
00:12:30,318 --> 00:12:34,431
某些本机面向列表的语法。 

282
00:12:34,431 --> 00:12:37,990
一旦有了这种机制，您就会迅速意识到， 

283
00:12:37,990 --> 00:12:39,110
哦，有很多地方

284
00:12:39,110 --> 00:12:40,935
我们只需要一个View列表， 

285
00:12:40,935 --> 00:12:42,455
就像我们卡的正面一样。 

286
00:12:42,455 --> 00:12:44,521
我们只想列出两个RoundedRectangles 

287
00:12:44,521 --> 00:12:46,690
还有表情符号

288
00:12:46,690 --> 00:12:50,374
因此，ViewBuilder让开发人员可以做到这一点

289
00:12:50,374 --> 00:12:52,990
@ViewBuilder是关键字。 

290
00:12:52,990 --> 00:12:55,050
再次，它不是语言的一部分。 

291
00:12:55,050 --> 00:12:58,250
@ViewBuilder就像@Published 

292
00:12:58,250 --> 00:12:59,770
或@ObservedObject， 

293
00:12:59,770 --> 00:13:02,398
这是基于其他技术的东西。 

294
00:13:02,398 --> 00:13:06,440
但是@ViewBuilder，可以标记此关键字

295
00:13:06,440 --> 00:13:10,740
到返回某些View的任何函数上。 

296
00:13:10,740 --> 00:13:12,312
所以只要函数返回一些View 

297
00:13:12,312 --> 00:13:16,460
您可以使用@ViewBuilder标记该功能

298
00:13:16,460 --> 00:13:19,380
现在编译器将解释

299
00:13:19,380 --> 00:13:21,560
该函数的花括号中包含什么

300
00:13:21,560 --> 00:13:25,400
成为视图列表，而不仅仅是任意代码， 

301
00:13:25,400 --> 00:13:27,030
视图列表。 

302
00:13:27,030 --> 00:13:29,660
这就是ViewBuilder的工作方式。 

303
00:13:29,660 --> 00:13:31,810
现在，您要标记的功能

304
00:13:31,810 --> 00:13:32,860
使用@ViewBuilder， 

305
00:13:32,860 --> 00:13:36,170
它返回一些视图，它是单个视图。 

306
00:13:36,170 --> 00:13:38,375
所以ViewBuilder，这就是为什么它被称为ViewBuilder， 

307
00:13:38,375 --> 00:13:41,603
它将视图列表构建为一个视图。 

308
00:13:42,470 --> 00:13:44,650
结合起来的那个观点

309
00:13:44,650 --> 00:13:47,410
很多时候将是一个TupleView。 

310
00:13:47,410 --> 00:13:49,647
因此，如果其中有2到10个视图， 

311
00:13:49,647 --> 00:13:51,990
这将是一个TupleView。 

312
00:13:51,990 --> 00:13:55,080
TupleView最多有10个无关项， 

313
00:13:55,080 --> 00:13:57,768
这是其中的10个视图。 

314
00:13:57,768 --> 00:14:00,590
并注意它仅限于10。 

315
00:14:00,590 --> 00:14:02,810
因此，如果您开始拥有11个以上的视图， 

316
00:14:02,810 --> 00:14:05,460
您将不得不将其分成几组， 

317
00:14:05,460 --> 00:14:08,770
TupleViews的TupleViews可在其中获得那么多视图。 

318
00:14:08,770 --> 00:14:12,540
很难想象拥有超过10个视图

319
00:14:12,540 --> 00:14:14,070
刚连续列出。 

320
00:14:14,070 --> 00:14:15,971
你几乎肯定会把它分解

321
00:14:15,971 --> 00:14:19,277
带有CardViews之类的子视图， 

322
00:14:19,277 --> 00:14:22,428
EmojiGameView等的子视图。 

323
00:14:22,428 --> 00:14:26,620
因此，实际上并没有太大的限制，但确实存在。 

324
00:14:26,620 --> 00:14:28,730
另一种观点可能是

325
00:14:28,730 --> 00:14:30,740
作为ConditionalContent视图， 

326
00:14:30,740 --> 00:14:32,970
下栏的ConditionalContent视图， 

327
00:14:32,970 --> 00:14:34,079
这就是视图创建的

328
00:14:34,079 --> 00:14:36,010
当那里有if-else时。 

329
00:14:36,010 --> 00:14:38,150
请记住，ViewBuilder中的if-elses 

330
00:14:38,150 --> 00:14:41,210
只是选择要包含在列表中的视图， 

331
00:14:41,210 --> 00:14:43,500
就像是CardViews的正面一样

332
00:14:43,500 --> 00:14:45,075
或CardView的背面。 

333
00:14:45,075 --> 00:14:48,023
因此，将创建此ConditionalContent视图

334
00:14:48,023 --> 00:14:51,870
只是有谓词可以测试isFaceUp 

335
00:14:51,870 --> 00:14:55,070
然后有两个视图

336
00:14:55,070 --> 00:14:58,170
可能是TupleView或其他视图

337
00:14:58,170 --> 00:14:59,870
它会从中选择。 

338
00:14:59,870 --> 00:15:01,763
甚至可以是允许的EmptyView。 

339
00:15:01,763 --> 00:15:03,730
我不知道你为什么一定要那样

340
00:15:03,730 --> 00:15:04,872
但你可以拥有它。 

341
00:15:04,872 --> 00:15:06,640
但是要记住的最重要的一点是

342
00:15:06,640 --> 00:15:08,970
可以是这些东西的任何组合。 

343
00:15:08,970 --> 00:15:10,130
所以你可以有一个TupleView 

344
00:15:10,130 --> 00:15:11,919
或TupleView中的其中一项是条件视图

345
00:15:11,919 --> 00:15:13,470
在该条件视图内

346
00:15:13,470 --> 00:15:16,030
还有另一个TupleView等。 

347
00:15:16,030 --> 00:15:19,573
这样您就可以构建这种任意复杂的

348
00:15:19,573 --> 00:15:21,710
视图的条件列表

349
00:15:21,710 --> 00:15:23,993
这才是真正的目的。 

350
00:15:23,993 --> 00:15:26,664
现在请注意，其中一些ViewBuilder API 

351
00:15:26,664 --> 00:15:28,370
尚未完全公开。 

352
00:15:28,370 --> 00:15:31,510
就像看到条件栏下的条件， 

353
00:15:31,510 --> 00:15:33,900
显然前面有一个下杠

354
00:15:33,900 --> 00:15:36,930
还没准备好迎接黄金时段，还没有完全公开。 

355
00:15:36,930 --> 00:15:38,710
我敢打赌，如果您在文档中查找

356
00:15:38,710 --> 00:15:40,720
你甚至在那里都找不到任何东西， 

357
00:15:40,720 --> 00:15:44,017
但这没关系，因为我们实际上不在乎

358
00:15:44,017 --> 00:15:46,270
这些是什么样的看法。 

359
00:15:46,270 --> 00:15:48,410
TupleViews，ConditionalContent等

360
00:15:48,410 --> 00:15:50,890
我们所关心的只是它的某些视图，对不对？ 

361
00:15:50,890 --> 00:15:53,691
我们只能标记一个返回一些View的函数

362
00:15:53,691 --> 00:15:55,300
用这个东西。 

363
00:15:55,300 --> 00:15:56,420
这就是我们所关心的。 

364
00:15:56,420 --> 00:15:58,010
所有这些东西都是一些观点

365
00:15:58,010 --> 00:15:59,803
这样对我们来说足够了。 

366
00:16:00,730 --> 00:16:04,370
同样，任何函数，也是只读的计算变量

367
00:16:04,370 --> 00:16:06,460
也可以使用此ViewBuilder进行标记

368
00:16:06,460 --> 00:16:09,840
并在上面标记它，以便该功能

369
00:16:09,840 --> 00:16:11,800
被解释为ViewBuilder。 

370
00:16:11,800 --> 00:16:14,140
这是我们的记忆样本。 

371
00:16:14,140 --> 00:16:17,860
假设我想排除卡片的正面， 

372
00:16:17,860 --> 00:16:20,920
这两个RoundedRectangles和您在此处看到的文本

373
00:16:20,920 --> 00:16:23,020
变成自己的小功能。 

374
00:16:23,020 --> 00:16:25,560
好吧，我可以使用func，卡片正面

375
00:16:25,560 --> 00:16:27,580
它返回一些视图

376
00:16:27,580 --> 00:16:31,990
在这里，我通常必须将其放在一个组中

377
00:16:31,990 --> 00:16:33,270
或类似的东西， 

378
00:16:33,270 --> 00:16:36,280
但是相反，我可以将其标记为@ViewBuilder 

379
00:16:36,280 --> 00:16:38,660
现在里面的花括号

380
00:16:38,660 --> 00:16:40,990
将被解释为视图列表。 

381
00:16:40,990 --> 00:16:43,788
我可以在这里放一些东西

382
00:16:43,788 --> 00:16:47,080
如果我想在这里做整个卡，我可以

383
00:16:47,080 --> 00:16:49,280
并拥有if isFaceUp， 

384
00:16:49,280 --> 00:16:50,770
所有这些东西完全允许。 

385
00:16:50,770 --> 00:16:53,339
这只是带有这些if-thens的View列表

386
00:16:53,339 --> 00:16:54,733
允许在那里。 

387
00:16:55,958 --> 00:16:59,421
此特定的绿色代码将返回TupleView 

388
00:16:59,421 --> 00:17:01,869
三个不在乎

389
00:17:01,869 --> 00:17:04,600
是RoundedRectangle，RoundedRectangle，Text。 

390
00:17:04,600 --> 00:17:08,150
当然，有两个TupleViews与八个无关项

391
00:17:08,150 --> 00:17:10,653
九个，否则将是三个。 

392
00:17:11,560 --> 00:17:14,540
同样，我们不在乎它在那儿执行TupleView。 

393
00:17:14,540 --> 00:17:15,650
绝对不在乎。 

394
00:17:15,650 --> 00:17:17,453
我们只关心这一些视图。 

395
00:17:19,470 --> 00:17:21,970
现在您也可以使用此@ViewBuilder 

396
00:17:21,970 --> 00:17:25,470
标记功能参数

397
00:17:25,470 --> 00:17:28,840
本身就是返回某些View的函数。 

398
00:17:28,840 --> 00:17:33,450
例如，我们的Grid的viewForItem参数，对不对？ 

399
00:17:33,450 --> 00:17:35,030
那是一个带物品的功能

400
00:17:35,030 --> 00:17:38,920
并返回了一个视图，那将是合格的

401
00:17:38,920 --> 00:17:42,240
用@ViewBuilder标记。 

402
00:17:42,240 --> 00:17:43,610
现在我们不在网格中执行此操作

403
00:17:43,610 --> 00:17:45,700
我将在稍后讨论，为什么我们没有， 

404
00:17:45,700 --> 00:17:48,187
但做到这一点的人是GeometryReader 

405
00:17:48,187 --> 00:17:51,960
HStack，VStack和ForEach都这样做， 

406
00:17:51,960 --> 00:17:53,858
但让我们看看声明

407
00:17:53,858 --> 00:17:58,200
GeometryReader的初始值设定项可能看起来像。 

408
00:17:58,200 --> 00:17:59,860
您已经有了GeometryReader，对吗？ 

409
00:17:59,860 --> 00:18:01,549
这是无关紧要的内容， 

410
00:18:01,549 --> 00:18:04,240
被限制为一个视图。 

411
00:18:04,240 --> 00:18:07,300
因此，GeometryReader的初始化程序

412
00:18:07,300 --> 00:18:10,160
我们知道需要满足，这花括号的东西， 

413
00:18:10,160 --> 00:18:12,340
给您GeometryProxy， 

414
00:18:12,340 --> 00:18:14,330
我们得到大小的东西， 

415
00:18:14,330 --> 00:18:17,320
它返回的内容就是一些View。 

416
00:18:17,320 --> 00:18:19,810
所以既然这个内容争论

417
00:18:19,810 --> 00:18:22,060
是一个返回一些View的函数， 

418
00:18:22,060 --> 00:18:23,910
可以将其标记为@ViewBuilder 

419
00:18:23,910 --> 00:18:25,550
GeometryReader的功能。 

420
00:18:25,550 --> 00:18:27,230
它将其标记为@ViewBuilder。 

421
00:18:27,230 --> 00:18:29,223
这意味着您的GeometryReader里面是什么， 

422
00:18:29,223 --> 00:18:31,850
小花括号是“视图”列表， 

423
00:18:31,850 --> 00:18:35,340
将被解释为视图列表。 

424
00:18:35,340 --> 00:18:36,490
就这么简单。 

425
00:18:37,340 --> 00:18:40,393
通常取决于GeometryReader之类的东西， 

426
00:18:40,393 --> 00:18:41,970
Hstack，VStack， 

427
00:18:41,970 --> 00:18:44,923
决定您是否通过了争论

428
00:18:44,923 --> 00:18:46,980
成为视图列表很有意义。 

429
00:18:46,980 --> 00:18:49,563
对于那些家伙，这就是他们的决定。 

430
00:18:51,870 --> 00:18:55,590
现在，您可能会问，为什么我们不在Grid中执行此操作？ 

431
00:18:55,590 --> 00:19:00,590
网格要求您提供特定项目的视图

432
00:19:01,170 --> 00:19:02,830
然后我们传递一个函数

433
00:19:02,830 --> 00:19:04,620
我们为什么不说@ViewBuilder 

434
00:19:04,620 --> 00:19:07,200
在网格中查看项目参数？ 

435
00:19:07,200 --> 00:19:10,110
那么答案与这件事有关

436
00:19:10,110 --> 00:19:12,900
ViewBuilder仍然是私有的。 

437
00:19:12,900 --> 00:19:14,930
例如它的实现

438
00:19:14,930 --> 00:19:17,834
无法提取视图

439
00:19:17,834 --> 00:19:19,684
从TupleView，ConditionalContent， 

440
00:19:20,573 --> 00:19:23,160
只是你不能让他们离开那里。 

441
00:19:23,160 --> 00:19:26,258
因此，Grid不可能知道它们的全部。 

442
00:19:26,258 --> 00:19:30,600
在当前的@ViewBuilder中不公开。 

443
00:19:30,600 --> 00:19:32,020
我确定这将是公开的

444
00:19:32,020 --> 00:19:33,040
最终你可以做到

445
00:19:33,040 --> 00:19:36,080
然后也许有Grid的论点是有意义的， 

446
00:19:36,080 --> 00:19:38,840
但即使到那时Grid还是二维数组。 

447
00:19:38,840 --> 00:19:40,567
通常，这将是相当数量的View。 

448
00:19:40,567 --> 00:19:43,017
您不太可能会列出他们， 

449
00:19:43,017 --> 00:19:46,219
特别是如果您要拥有10个或更少

450
00:19:46,219 --> 00:19:48,330
可能，但不太可能。 

451
00:19:48,330 --> 00:19:50,870
因此，Grid与ForEach息息相关

452
00:19:50,870 --> 00:19:52,980
并以ForEach相同的方式表示

453
00:19:52,980 --> 00:19:54,663
可能还不错。 

454
00:19:56,780 --> 00:19:58,080
就在我们离开ViewBuilder之前， 

455
00:19:58,080 --> 00:19:59,570
我只想重申一下。 

456
00:19:59,570 --> 00:20:01,063
这张幻灯片不是新内容。 

457
00:20:01,063 --> 00:20:04,590
标记为ViewBuilder的内容只是视图列表。 

458
00:20:04,590 --> 00:20:06,680
是的，里面有条件

459
00:20:06,680 --> 00:20:09,060
看看您是否在列表中包含“视图”， 

460
00:20:09,060 --> 00:20:10,280
但是只有一个视图列表。 

461
00:20:10,280 --> 00:20:12,677
因此无法在其中声明var， 

462
00:20:12,677 --> 00:20:14,910
您不能有任意代码。 

463
00:20:14,910 --> 00:20:16,710
只要您拥有ViewBuilder， 

464
00:20:16,710 --> 00:20:18,965
这只是其中包含if-thens的Views列表

465
00:20:18,965 --> 00:20:20,613
选择哪个视图。 

466
00:20:22,550 --> 00:20:24,570
当天的主要话题，形状。 

467
00:20:24,570 --> 00:20:26,526
形状是一种协议。 

468
00:20:26,526 --> 00:20:30,650
它继承自View，因此所有Shapes都是View。 

469
00:20:30,650 --> 00:20:33,290
因此，您始终可以将Shape放在ZStack或其他任何对象中

470
00:20:33,290 --> 00:20:34,123
如我们所见

471
00:20:34,123 --> 00:20:36,494
RoundedRectangle，我们把它扔在那里，没问题。 

472
00:20:36,494 --> 00:20:38,791
当然有常见的形状

473
00:20:38,791 --> 00:20:40,572
像RoundedRectangle，Circle， 

474
00:20:40,572 --> 00:20:44,440
胶囊是一种椭圆形的东西

475
00:20:44,440 --> 00:20:45,993
和那里的其他人。 

476
00:20:47,450 --> 00:20:49,888
现在，形状默认会自动绘制

477
00:20:49,888 --> 00:20:53,720
通过使用当前的前景色填充自己。 

478
00:20:53,720 --> 00:20:56,510
我们在卡片背面看到了这一点。 

479
00:20:56,510 --> 00:21:00,380
他们采用RoundedRectangle，默认情况下会填充它。 

480
00:21:00,380 --> 00:21:03,470
但是我们也了解到我们可以调用笔划或填充

481
00:21:03,470 --> 00:21:08,090
带有更改Shape外观方式的参数。 

482
00:21:08,090 --> 00:21:11,107
现在我想谈谈填充和描边

483
00:21:11,107 --> 00:21:14,271
以及可以传递给它的参数。 

484
00:21:14,271 --> 00:21:17,900
看起来，当我们完成记忆代码时， 

485
00:21:17,900 --> 00:21:21,470
传递给fill的参数实际上是Color 

486
00:21:21,470 --> 00:21:24,370
因为您会记得第二个RoundedRectangle 

487
00:21:24,370 --> 00:21:26,519
从后面，实际上不， 

488
00:21:26,519 --> 00:21:28,550
背面的矩形一直是白色。 

489
00:21:28,550 --> 00:21:30,590
然后，将描边的一个放在上面。 

490
00:21:30,590 --> 00:21:33,210
因此，我们说的那个白色填充Color.white。 

491
00:21:33,210 --> 00:21:35,660
这样看来，哦，填充需要一种颜色。 

492
00:21:35,660 --> 00:21:38,239
但实际上填充参数不是颜色

493
00:21:38,239 --> 00:21:40,837
我会借此机会充实和中风

494
00:21:40,837 --> 00:21:43,610
谈论Swift中的另一个功能

495
00:21:43,610 --> 00:21:46,530
称为通用函数。 

496
00:21:46,530 --> 00:21:48,040
您已经了解通用类型

497
00:21:48,040 --> 00:21:49,990
像是Array和我们的MemoryGame， 

498
00:21:49,990 --> 00:21:52,400
它的CardContent无关紧要。 

499
00:21:52,400 --> 00:21:54,720
好吧，函数也可以不在乎。 

500
00:21:54,720 --> 00:21:55,914
它们也可以是通用的。 

501
00:21:55,914 --> 00:21:59,250
并且他们执行类似的语法。 

502
00:21:59,250 --> 00:22:03,620
您可以看到填充不关心S， 

503
00:22:03,620 --> 00:22:05,753
用S型填充什么， 

504
00:22:05,753 --> 00:22:07,980
看到这是一种S， 

505
00:22:07,980 --> 00:22:09,780
并限制了它

506
00:22:09,780 --> 00:22:11,200
所以它不是完整的不在乎

507
00:22:11,200 --> 00:22:13,340
有点像在乎

508
00:22:13,340 --> 00:22:17,530
S必须在其中实现ShapeStyle协议。 

509
00:22:17,530 --> 00:22:19,884
所以这个ShapeStyle协议，我们不再谈论它， 

510
00:22:19,884 --> 00:22:22,640
但是如果您实现此ShapeStyle协议， 

511
00:22:22,640 --> 00:22:27,520
那么您就可以用来填充或描画形状。 

512
00:22:27,520 --> 00:22:29,700
什么样的东西实现ShapeStyle？ 

513
00:22:29,700 --> 00:22:30,909
好吧，颜色，显然我们知道

514
00:22:30,909 --> 00:22:33,380
因为我们称填充为颜色， 

515
00:22:33,380 --> 00:22:36,450
还有ImagePaint，可以拍摄JPEG图像

516
00:22:36,450 --> 00:22:38,380
并在那里铺上油漆

517
00:22:38,380 --> 00:22:41,230
好像它只是该图像的画笔一样。 

518
00:22:41,230 --> 00:22:44,060
也有渐变，角度和线性渐变

519
00:22:44,060 --> 00:22:46,897
会显示出一系列颜色或其他颜色。 

520
00:22:46,897 --> 00:22:48,630
所以这些都是完全不同的

521
00:22:48,630 --> 00:22:53,470
颜色，渐变，图像绘制，非常不同的东西， 

522
00:22:53,470 --> 00:22:55,620
真正的填充并不关心它们是什么。 

523
00:22:55,620 --> 00:22:57,330
这就是为什么S是无关紧要的原因。 

524
00:22:57,330 --> 00:22:59,480
但这确实很在乎，因为它们都实现了ShapeStyle 

525
00:22:59,480 --> 00:23:00,932
因为如果他们没有实现ShapeStyle 

526
00:23:00,932 --> 00:23:04,410
那么Shape并不真正知道如何使用它们

527
00:23:04,410 --> 00:23:06,370
做填充和描边。 

528
00:23:06,370 --> 00:23:08,290
再说一次，我主要是向你展示， 

529
00:23:08,290 --> 00:23:11,320
是的，这样您就可以知道可以填充图像

530
00:23:11,320 --> 00:23:12,840
或渐变或颜色， 

531
00:23:12,840 --> 00:23:14,050
而且所以你应该意识到

532
00:23:14,050 --> 00:23:16,190
有这些通用功能， 

533
00:23:16,190 --> 00:23:18,283
无关功能

534
00:23:18,283 --> 00:23:20,673
作为他们某些论点的类型。 

535
00:23:21,950 --> 00:23:24,060
如果您想创建自己的形状该怎么办？ 

536
00:23:24,060 --> 00:23:26,218
您不想使用RoundedRectangle，Circle， 

537
00:23:26,218 --> 00:23:28,500
无论如何，您想要自己的形状。 

538
00:23:28,500 --> 00:23:31,620
好吧，Shape协议使用了扩展

539
00:23:31,620 --> 00:23:34,296
为您实现View的body var，对吗？ 

540
00:23:34,296 --> 00:23:38,022
因为Shape继承自View，所以Shape是View。 

541
00:23:38,022 --> 00:23:39,876
因此，它必须实现body var。 

542
00:23:39,876 --> 00:23:41,640
所有视图都必须实现该主体变量。 

543
00:23:41,640 --> 00:23:42,970
但是Shape为您实现了这一点。 

544
00:23:42,970 --> 00:23:45,110
协议及其扩展

545
00:23:45,110 --> 00:23:46,290
为您实现。 

546
00:23:46,290 --> 00:23:48,739
但是，Shape引入了新的功能

547
00:23:48,739 --> 00:23:51,770
您需要实施。 

548
00:23:51,770 --> 00:23:54,390
在rect中称为路径。 

549
00:23:54,390 --> 00:23:58,830
所以rect中的此函数路径将仅返回

550
00:23:58,830 --> 00:24:00,960
称为路径的东西。 

551
00:24:00,960 --> 00:24:03,560
现在，路径上有很多功能， 

552
00:24:03,560 --> 00:24:08,249
像线到和弧线以及贝塞尔曲线。 

553
00:24:08,249 --> 00:24:11,330
所有这些让您从本质上画画

554
00:24:11,330 --> 00:24:13,700
就像您用笔绘图一样。 

555
00:24:13,700 --> 00:24:17,110
因此，您将建立一些路径

556
00:24:17,110 --> 00:24:20,690
用这支笔绘图，然后将其返回此处。 

557
00:24:20,690 --> 00:24:23,670
现在，一旦您将其退回，Shape就拥有了所有需要知道的信息

558
00:24:23,670 --> 00:24:24,810
去做它做的事， 

559
00:24:24,810 --> 00:24:28,333
它提供了可以抚摸和填充的Shape。 

560
00:24:29,730 --> 00:24:33,710
现在最好通过演示展示它的工作原理。 

561
00:24:33,710 --> 00:24:36,310
所以我们要回到记忆

562
00:24:36,310 --> 00:24:38,240
并实施那个小馅饼。 

563
00:24:38,240 --> 00:24:40,894
如果您还记得我们的第一堂课

564
00:24:40,894 --> 00:24:43,820
有那个小馅饼，它充满生气

565
00:24:43,820 --> 00:24:46,010
有点倒计时

566
00:24:46,010 --> 00:24:47,630
这样，如果您足够快地匹配卡片， 

567
00:24:47,630 --> 00:24:49,210
你有加分。 

568
00:24:49,210 --> 00:24:52,280
因此，我们将在我们的记忆游戏中画图。 

569
00:24:52,280 --> 00:24:53,371
我们还没有动画。 

570
00:24:53,371 --> 00:24:55,410
动画是我们的下一个主题。 

571
00:24:55,410 --> 00:24:56,840
我们将回到这一点。 

572
00:24:56,840 --> 00:25:00,300
所以今天我们只是在学习如何创建自己的形状

573
00:25:00,300 --> 00:25:01,713
通过建立那个馅饼。 

574
00:25:04,720 --> 00:25:09,720
我已经将游戏中的视频截图了

575
00:25:09,720 --> 00:25:12,615
这样我们就可以知道我们要拍摄什么。 

576
00:25:12,615 --> 00:25:16,673
我们正在尝试构建这个小饼图

577
00:25:16,673 --> 00:25:20,890
看起来像吃豆人之类的东西

578
00:25:20,890 --> 00:25:22,540
在我们的幽灵后面。 

579
00:25:22,540 --> 00:25:26,230
而且SwiftUI中没有内置这样的Shape， 

580
00:25:26,230 --> 00:25:27,600
这种吃豆人形状

581
00:25:27,600 --> 00:25:30,100
所以我们必须自己构建。 

582
00:25:30,100 --> 00:25:32,221
但是在我们开始构建自定义形状之前， 

583
00:25:32,221 --> 00:25:34,510
让我们试一试

584
00:25:34,510 --> 00:25:37,650
在这个鬼魂后面。 

585
00:25:37,650 --> 00:25:39,887
“因为我们知道有一个内置的Circle， 

586
00:25:39,887 --> 00:25:42,703
就像这里有一个RoundedRectangle内置的大对象一样。 

587
00:25:43,890 --> 00:25:45,500
因此，这样做非常简单。 

588
00:25:45,500 --> 00:25:48,124
这是我们的视图，这是我们的CardView。 

589
00:25:48,124 --> 00:25:52,930
就在这里，这里是，这是背景。 

590
00:25:52,930 --> 00:25:54,660
这是我们的表情符号所在的位置

591
00:25:54,660 --> 00:25:57,380
而这个圈子只是想生活

592
00:25:57,380 --> 00:25:58,970
就在这之间

593
00:25:58,970 --> 00:26:01,400
就在背景和表情符号之间

594
00:26:01,400 --> 00:26:02,320
让我们来看看。 

595
00:26:02,320 --> 00:26:03,153
这样就行了。 

596
00:26:03,153 --> 00:26:05,841
也许这就是我们开始所需要的。 

597
00:26:05,841 --> 00:26:06,910
好吧，让我们单击。 

598
00:26:06,910 --> 00:26:10,160
哦，实际上到了那里。 

599
00:26:10,160 --> 00:26:10,993
看一看。 

600
00:26:10,993 --> 00:26:12,890
哦，差不多了。 

601
00:26:12,890 --> 00:26:15,167
现在不太正确。 

602
00:26:15,167 --> 00:26:17,890
距离那里的边缘太近了， 

603
00:26:17,890 --> 00:26:19,650
应该有一点差距， 

604
00:26:19,650 --> 00:26:23,510
而且这种颜色有点太橙色了

605
00:26:23,510 --> 00:26:25,640
但它在球场上。 

606
00:26:25,640 --> 00:26:28,980
现在我们可以回到这里尝试解决此问题

607
00:26:28,980 --> 00:26:31,450
然后再次运行，然后再修复一些

608
00:26:31,450 --> 00:26:33,630
然后再次运行并对其进行一些调整。 

609
00:26:33,630 --> 00:26:35,170
但这有点乏味

610
00:26:35,170 --> 00:26:38,060
当然，我们有一个更好的工具， 

611
00:26:38,060 --> 00:26:41,037
这是我们这里的画布

612
00:26:41,037 --> 00:26:45,283
我们可以恢复并看到我们的样子

613
00:26:45,283 --> 00:26:47,315
看起来像... 

614
00:26:47,315 --> 00:26:51,010
哦，不，所有卡都朝下。 

615
00:26:51,010 --> 00:26:54,452
哪种才有意义，因为那是游戏开始的方式， 

616
00:26:54,452 --> 00:26:56,400
但这对我来说毫无用处

617
00:26:56,400 --> 00:26:58,020
使所有这些卡面朝下。 

618
00:26:58,020 --> 00:27:00,770
我真的希望至少其中一张卡面朝上

619
00:27:00,770 --> 00:27:02,519
所以我可以做这个。 

620
00:27:02,519 --> 00:27:04,920
我们该怎么做？ 

621
00:27:04,920 --> 00:27:07,160
原来，这段代码在底部

622
00:27:07,160 --> 00:27:08,690
我推开了

623
00:27:08,690 --> 00:27:11,810
不像我说的那样可怕

624
00:27:11,810 --> 00:27:13,690
通过将其推开。 

625
00:27:13,690 --> 00:27:18,430
这实际上只是一个静态var，其类型为

626
00:27:18,430 --> 00:27:23,430
返回整个视图以预览我们的

627
00:27:25,070 --> 00:27:26,670
EmojiMemoryGameView。 

628
00:27:26,670 --> 00:27:28,600
现在我们正在创建一个

629
00:27:28,600 --> 00:27:29,790
EmojiMemoryGameView。 

630
00:27:29,790 --> 00:27:31,720
我们给它这个ViewModel 

631
00:27:31,720 --> 00:27:33,950
我们刚刚创建的。 

632
00:27:33,950 --> 00:27:34,950
但是没有理由

633
00:27:34,950 --> 00:27:36,980
我们不能只是从这里带走这个， 

634
00:27:36,980 --> 00:27:39,650
把它放在一个变量中，我称之为游戏， 

635
00:27:39,650 --> 00:27:42,340
要求该游戏选择其中一张纸牌， 

636
00:27:42,340 --> 00:27:45,497
如何选择游戏中的第一张牌， 

637
00:27:45,497 --> 00:27:47,150
这样的事情

638
00:27:47,150 --> 00:27:49,040
然后在这里使用该游戏

639
00:27:49,040 --> 00:27:51,219
作为我们要预览的东西。 

640
00:27:51,219 --> 00:27:52,630
当然要回去了

641
00:27:52,630 --> 00:27:54,290
由于我们没有单行功能， 

642
00:27:54,290 --> 00:27:57,584
瞧，我们马上就看到面朝上的卡片

643
00:27:57,584 --> 00:28:02,110
我可能会选择第三张卡

644
00:28:02,110 --> 00:28:03,990
现在向我展示了第三张卡片。 

645
00:28:03,990 --> 00:28:05,732
所以我可以让它挑选几张卡片。 

646
00:28:05,732 --> 00:28:08,220
当然如果我选三张卡

647
00:28:08,220 --> 00:28:10,553
然后就可以玩游戏并进行比赛了。 

648
00:28:11,510 --> 00:28:13,460
但是，这非常适合我们的需求。 

649
00:28:13,460 --> 00:28:15,900
我们可以回到这里开始在这个圈子上工作

650
00:28:15,900 --> 00:28:20,440
并尝试使其看起来更像我们打算在这里进行。 

651
00:28:20,440 --> 00:28:22,670
让我们开始尝试从边缘入手

652
00:28:22,670 --> 00:28:25,150
一点，所以它不会粉碎到边缘。 

653
00:28:25,150 --> 00:28:26,520
我们知道该怎么做。 

654
00:28:26,520 --> 00:28:29,501
只需在此Circle周围放置一些填充物即可。 

655
00:28:29,501 --> 00:28:33,563
好吧，现在，这并不是我们想要的。 

656
00:28:33,563 --> 00:28:34,640
填充太多。 

657
00:28:34,640 --> 00:28:36,140
如果我们不知道怎么办， 

658
00:28:36,140 --> 00:28:38,240
在那儿放些填料？ 

659
00:28:38,240 --> 00:28:40,381
是的，我对此很满意。 

660
00:28:40,381 --> 00:28:43,892
虽然我的幽灵有点大， 

661
00:28:43,892 --> 00:28:47,170
我认为我不想猛冲到那里的边缘。 

662
00:28:47,170 --> 00:28:50,340
所以也许我会在这里进入常量控制面板

663
00:28:50,340 --> 00:28:52,600
并将其更改为0.7， 

664
00:28:52,600 --> 00:28:57,300
也许0.65不，70％看起来不错。 

665
00:28:57,300 --> 00:28:58,570
我不想这太小。 

666
00:28:58,570 --> 00:29:01,210
这是该卡的目的，实际上是为了证明这一点。 

667
00:29:01,210 --> 00:29:03,611
所以我不想在那儿过小。 

668
00:29:03,611 --> 00:29:08,140
那么这种真正的鲜艳橙色呢？ 

669
00:29:08,140 --> 00:29:10,460
好吧，事实证明我们可以做一个橙色

670
00:29:10,460 --> 00:29:14,300
在这里有点通透或透视

671
00:29:14,300 --> 00:29:17,002
通过使其半透明。 

672
00:29:17,002 --> 00:29:21,320
而且View有一个很棒的修改器，不透明度

673
00:29:21,320 --> 00:29:24,330
叫做零之间的两倍

674
00:29:24,330 --> 00:29:26,970
这意味着完全透明

675
00:29:26,970 --> 00:29:29,300
一到完全不透明。 

676
00:29:29,300 --> 00:29:33,210
现在我们可以进入中间，大概是70％ 

677
00:29:33,210 --> 00:29:36,107
也许10％哦，太轻了。 

678
00:29:36,107 --> 00:29:39,570
30％，40％，我有点喜欢40％。 

679
00:29:39,570 --> 00:29:42,240
我认为这就是我在这里结束的事情。 

680
00:29:42,240 --> 00:29:44,053
差不多了。 

681
00:29:45,170 --> 00:29:48,450
您可以看到我们确实拥有我们想要的外观

682
00:29:48,450 --> 00:29:52,420
除了这是一个圆形而不是我们的饼图。 

683
00:29:52,420 --> 00:29:54,410
做我们的吃豆人派

684
00:29:54,410 --> 00:29:57,000
我们只需要在这里替换Circle 

685
00:29:57,000 --> 00:29:59,365
与我们自己的自定义形状。 

686
00:29:59,365 --> 00:30:01,080
因此，让我们创建它。 

687
00:30:01,080 --> 00:30:02,120
我要去File，New 

688
00:30:02,120 --> 00:30:04,782
因为我们在这里创建新事物。 

689
00:30:04,782 --> 00:30:08,158
这将是一个SwiftUI视图，因为形状是视图， 

690
00:30:08,158 --> 00:30:11,500
但是如果我们选择此模板，我们将获得该var body 

691
00:30:11,500 --> 00:30:14,090
Shape协议为我们提供了这一点。 

692
00:30:14,090 --> 00:30:16,549
所以我们要在这里选择Swift文件

693
00:30:16,549 --> 00:30:18,260
确保我们将其放在正确的位置。 

694
00:30:18,260 --> 00:30:22,057
我将其命名为Pie，这是我自定义Shape的名称。 

695
00:30:22,057 --> 00:30:25,010
让我们来创建它。 

696
00:30:25,010 --> 00:30:25,843
开始了。 

697
00:30:25,843 --> 00:30:28,370
当然，现在Shape很大程度上是UI的事情， 

698
00:30:28,370 --> 00:30:32,050
所以我们要导入SwiftUI，而不是那里的Foundation。 

699
00:30:32,050 --> 00:30:35,410
并创建一个Shape，如此简单，构造Pie。 

700
00:30:35,410 --> 00:30:38,010
符合Shape协议

701
00:30:38,010 --> 00:30:40,900
限制和收获

702
00:30:40,900 --> 00:30:43,070
它会得到一个事实，那就是视图

703
00:30:43,070 --> 00:30:45,930
它可以被充满和抚摸，各种收获， 

704
00:30:45,930 --> 00:30:49,330
而这里唯一真正的约束是这个功能， 

705
00:30:49,330 --> 00:30:51,960
在rect中称为路径

706
00:30:53,605 --> 00:30:57,520
它返回我们必须创建的路径， 

707
00:30:57,520 --> 00:31:00,860
而这条路径将成为边缘

708
00:31:00,860 --> 00:31:01,770
我们正在画的东西。 

709
00:31:01,770 --> 00:31:04,394
所以对我们来说，它将从中间开始，然后上升， 

710
00:31:04,394 --> 00:31:07,600
在这里，回到中间。 

711
00:31:07,600 --> 00:31:09,630
那就是我们要建立的道路。 

712
00:31:09,630 --> 00:31:11,970
我们将使用Path中的函数进行构建

713
00:31:11,970 --> 00:31:14,943
就像在此处画一条线并在此处画一条弧。 

714
00:31:14,943 --> 00:31:16,960
我们将把所有这些结合起来

715
00:31:16,960 --> 00:31:18,490
做这条路。 

716
00:31:18,490 --> 00:31:21,010
一旦完成，Shape便会处理所有其余的工作。 

717
00:31:21,010 --> 00:31:22,050
能够填补这一切

718
00:31:22,050 --> 00:31:25,350
都会照顾我们的。 

719
00:31:25,350 --> 00:31:28,110
我们如何返回这个路径的东西？ 

720
00:31:28,110 --> 00:31:31,960
我要创建一个空的，我将其命名为p Path。 

721
00:31:31,960 --> 00:31:34,800
那是一条空的路径，我要归还它。 

722
00:31:34,800 --> 00:31:38,450
在这之间，我只需要调用Path中的函数

723
00:31:38,450 --> 00:31:42,050
移动，画出我想画的线。 

724
00:31:42,050 --> 00:31:45,110
现在传递给我们的是什么？ 

725
00:31:45,110 --> 00:31:49,020
那就是我们应该适合我们的形状的矩形。 

726
00:31:49,020 --> 00:31:51,650
现在几乎所有的形状

727
00:31:51,650 --> 00:31:54,880
通常使用给他们的直肠中的所有空间

728
00:31:54,880 --> 00:31:58,800
是的，您猜对了，因为Shape是一个View， 

729
00:31:58,800 --> 00:32:00,098
直肠会给你在这里

730
00:32:00,098 --> 00:32:03,920
是为其提供的空间。 

731
00:32:03,920 --> 00:32:05,990
提供的空间。 

732
00:32:05,990 --> 00:32:08,290
我们有这条路，有这条路， 

733
00:32:08,290 --> 00:32:09,640
我们该怎么做？ 

734
00:32:09,640 --> 00:32:13,120
让我们从矩形的中心开始。 

735
00:32:13,120 --> 00:32:15,600
因此，我们将获得此矩形以进行绘制。 

736
00:32:15,600 --> 00:32:18,420
让我们直接到它的中心开始， 

737
00:32:18,420 --> 00:32:19,730
就在这里，然后我们要往上走。 

738
00:32:19,730 --> 00:32:21,400
因此，让我们从中间开始。 

739
00:32:21,400 --> 00:32:24,030
因此，获得中间位置非常容易。 

740
00:32:24,030 --> 00:32:27,530
我只是说p路径走到中间， 

741
00:32:27,530 --> 00:32:32,530
这就是路径，点移到中心。 

742
00:32:32,790 --> 00:32:35,390
而中心将是一个变种。 

743
00:32:35,390 --> 00:32:36,841
让中心相等。 

744
00:32:36,841 --> 00:32:39,480
为了获得中心，我将创建一个CGPoint。 

745
00:32:39,480 --> 00:32:41,910
现在注意所有这些绘图内容， 

746
00:32:41,910 --> 00:32:45,330
不仅是CGFloat，还包括CGRect，CGPoint，CGSize 

747
00:32:45,330 --> 00:32:48,180
我们在GeometryReader上看到的，它们都是从CG开始的。 

748
00:32:48,180 --> 00:32:50,680
此CG代表核心图形。 

749
00:32:50,680 --> 00:32:52,560
那就是底层的图形系统

750
00:32:52,560 --> 00:32:55,348
所有这些都是建立在

751
00:32:55,348 --> 00:32:58,670
因此，找到该矩形的中心真的很容易。 

752
00:32:58,670 --> 00:33:01,033
X的位置就是正中

753
00:33:02,108 --> 00:33:04,858
Y是矩形midY。 

754
00:33:06,536 --> 00:33:07,369
就是这样了。 

755
00:33:07,369 --> 00:33:10,160
我们有了中心，我们已经在这里开始了， 

756
00:33:10,160 --> 00:33:11,550
但是我们还没有画任何东西。 

757
00:33:11,550 --> 00:33:13,850
我们实际上还没有画线或任何东西。 

758
00:33:13,850 --> 00:33:15,630
所以接下来我们要做

759
00:33:16,790 --> 00:33:20,123
从中心到此处画一条线。 

760
00:33:21,330 --> 00:33:23,400
现在我要去做，以便我的馅饼， 

761
00:33:23,400 --> 00:33:26,730
这个开始角度和这个结束角度， 

762
00:33:26,730 --> 00:33:27,727
可以是您想要的任何东西。 

763
00:33:27,727 --> 00:33:31,060
所以你可以把你的派做成一小块

764
00:33:31,060 --> 00:33:33,240
或指向任何方向的大馅饼。 

765
00:33:33,240 --> 00:33:34,710
所以我需要几个变量

766
00:33:34,710 --> 00:33:36,630
一个是我的出发点

767
00:33:36,630 --> 00:33:38,940
一个是我的结束角度。 

768
00:33:38,940 --> 00:33:41,000
因此，让我们将这些变量放入Shape中。 

769
00:33:41,000 --> 00:33:41,930
这只是一个结构。 

770
00:33:41,930 --> 00:33:44,700
这样他就可以让vars startAngle， 

771
00:33:44,700 --> 00:33:46,150
但是角度是什么类型？ 

772
00:33:46,150 --> 00:33:49,330
好吧，您可以将其设置为CGFloat或类似的东西， 

773
00:33:49,330 --> 00:33:52,580
但是Swift中有一个很棒的东西叫做Angle 

774
00:33:52,580 --> 00:33:53,890
我会告诉你的

775
00:33:53,890 --> 00:33:58,370
因此，我们将使这些起始角度和终止角度成为角度。 

776
00:33:58,370 --> 00:33:59,550
什么是角度？ 

777
00:33:59,550 --> 00:34:03,203
让我们继续阅读文档中的内容。 

778
00:34:04,180 --> 00:34:05,975
这是struct Angle，它只是一个struct 

779
00:34:05,975 --> 00:34:09,880
它使您可以使用度数或弧度创建角度。 

780
00:34:09,880 --> 00:34:12,580
希望每个人都记得三角学课

781
00:34:12,580 --> 00:34:15,950
什么是弧度，对吗？零度到360度

782
00:34:15,950 --> 00:34:16,880
绕圈， 

783
00:34:16,880 --> 00:34:20,810
弧度为零到2π。 

784
00:34:20,810 --> 00:34:23,984
2πr是圆的周长。 

785
00:34:23,984 --> 00:34:28,120
因此，弧度在圆周围为零到2π。 

786
00:34:28,120 --> 00:34:29,990
并注意该角度的动画效果。 

787
00:34:29,990 --> 00:34:32,670
以后对我们会很好。 

788
00:34:32,670 --> 00:34:33,930
也可以散列， 

789
00:34:33,930 --> 00:34:36,170
这意味着可以将其放入字典或哈希表中。 

790
00:34:36,170 --> 00:34:38,773
我们不需要这样做，但是这个角度非常好

791
00:34:38,773 --> 00:34:41,520
我们的小类型。 

792
00:34:41,520 --> 00:34:44,327
我需要以某种方式计算起始位置

793
00:34:44,327 --> 00:34:48,030
在这里的顶部，这个小位置， 

794
00:34:48,030 --> 00:34:50,210
这样我才能从这里画一条线。 

795
00:34:50,210 --> 00:34:51,718
所以我要说的是

796
00:34:51,718 --> 00:34:56,718
addLine到顶部的开头。 

797
00:34:56,834 --> 00:34:58,023
所以我需要开始。 

798
00:34:58,023 --> 00:35:02,843
起点也等于点，CGPoint也是如此。 

799
00:35:02,843 --> 00:35:06,410
让我们继续将它放在多行上

800
00:35:06,410 --> 00:35:11,130
并将X放在一行上，将Y放在另一行上。 

801
00:35:11,130 --> 00:35:13,580
所以X位置，水平位置

802
00:35:13,580 --> 00:35:18,580
是中心的X加上圆的半径， 

803
00:35:19,130 --> 00:35:20,325
我们将不得不弄清楚， 

804
00:35:20,325 --> 00:35:22,941
一次又一次，我希望你能记住

805
00:35:22,941 --> 00:35:27,630
八年级或九年级的三角函数

806
00:35:27,630 --> 00:35:29,918
或这些天教授三角学的时候

807
00:35:29,918 --> 00:35:34,420
我想做那个起始角度的余弦， 

808
00:35:34,420 --> 00:35:36,260
我必须用弧度来做

809
00:35:36,260 --> 00:35:39,921
因为Swift中的余弦函数会产生弧度， 

810
00:35:39,921 --> 00:35:43,670
我也想在CGFloat世界中做到这一点， 

811
00:35:43,670 --> 00:35:46,240
不是Double的。 

812
00:35:46,240 --> 00:35:48,560
同样，Y只是中心点Y 

813
00:35:48,560 --> 00:35:52,820
加上半径乘以CGFloat的正弦

814
00:35:52,820 --> 00:35:55,990
startAngle点弧度。 

815
00:35:55,990 --> 00:35:57,390
因此，我需要半径。 

816
00:35:57,390 --> 00:36:02,390
我的圆半径将是多少？ 

817
00:36:02,555 --> 00:36:07,160
好吧，我可以把它的宽度

818
00:36:07,160 --> 00:36:09,210
或者我可以把它做成高度。 

819
00:36:09,210 --> 00:36:11,560
我真的希望它是两者中的较小者。 

820
00:36:11,560 --> 00:36:14,730
所以在这种情况下，我绝对不想拥有自己的半径

821
00:36:14,730 --> 00:36:18,310
等于这个空间的一半

822
00:36:18,310 --> 00:36:20,520
因为那样的话太大了。 

823
00:36:20,520 --> 00:36:22,780
所以我要选择宽度或高度中较小的一个

824
00:36:22,780 --> 00:36:24,540
并将其除以二，以得出半径

825
00:36:24,540 --> 00:36:26,020
而不是直径。 

826
00:36:26,020 --> 00:36:29,827
因此，让我们使半径等于最小值

827
00:36:29,827 --> 00:36:34,348
矩形的宽度和矩形的高度

828
00:36:34,348 --> 00:36:35,714
我们除以二。 

829
00:36:36,984 --> 00:36:38,890
所以我认为这就是我们要做的

830
00:36:38,890 --> 00:36:42,370
起床到这里的顶部。 

831
00:36:42,370 --> 00:36:45,500
现在我们需要大步向前。 

832
00:36:45,500 --> 00:36:46,720
好吧，转弯。 

833
00:36:46,720 --> 00:36:51,240
幸运的是Path也具有起弧功能。 

834
00:36:51,240 --> 00:36:55,780
它称为addArc，您可以用不同的方法来做。 

835
00:36:55,780 --> 00:36:58,060
我要在这里选择最简单的一个

836
00:36:58,060 --> 00:36:59,330
让您创建弧线

837
00:36:59,330 --> 00:37:03,320
通过指定圆弧的中心，圆弧的半径， 

838
00:37:03,320 --> 00:37:05,400
起始角度和终止角度

839
00:37:05,400 --> 00:37:08,121
以及您是否要顺时针旋转

840
00:37:08,121 --> 00:37:10,420
还是逆时针，对不对？ 

841
00:37:10,420 --> 00:37:12,912
所以我们是否要像这样逆时针走

842
00:37:12,912 --> 00:37:15,423
或者我们是否要像这样顺时针旋转。 

843
00:37:16,620 --> 00:37:17,930
因此，让我们给这个中心。 

844
00:37:17,930 --> 00:37:20,330
我们知道中心就是那个中心半径。 

845
00:37:20,330 --> 00:37:21,921
是的，我们也知道。 

846
00:37:21,921 --> 00:37:23,223
起始角度？ 

847
00:37:23,223 --> 00:37:25,490
是的，我们知道起始角度。 

848
00:37:25,490 --> 00:37:26,720
结束角？ 

849
00:37:26,720 --> 00:37:28,520
是的，这就是这里的变量。 

850
00:37:28,520 --> 00:37:29,530
这真的很容易。 

851
00:37:29,530 --> 00:37:31,750
那顺时针呢？ 

852
00:37:31,750 --> 00:37:33,376
这是一个布尔值，无论我们是否顺时针旋转， 

853
00:37:33,376 --> 00:37:36,720
让我们也允许人们使用我们来告诉我们。 

854
00:37:36,720 --> 00:37:38,480
所以我们说顺时针是一个布尔， 

855
00:37:39,530 --> 00:37:40,983
顺时针放在这里。 

856
00:37:41,958 --> 00:37:44,960
而且，我们不要让他们这么说。 

857
00:37:44,960 --> 00:37:49,070
我们将使用默认值，我们将使用顺时针false。 

858
00:37:49,070 --> 00:37:51,341
那恰好是我们想要的方式，对吗？ 

859
00:37:51,341 --> 00:37:54,560
逆时针旋转，所以我们将顺时针旋转为false 

860
00:37:54,560 --> 00:37:56,130
为我们的派工作。 

861
00:37:56,130 --> 00:37:58,260
但这只是默认设置，我们不得不选择其中之一， 

862
00:37:58,260 --> 00:37:59,810
我们不妨选择这个。 

863
00:38:01,010 --> 00:38:02,190
那是弧线。 

864
00:38:02,190 --> 00:38:05,060
我们在这里的小路径几乎完成了。 

865
00:38:05,060 --> 00:38:07,890
它绕了过去，现在需要回到中间。 

866
00:38:07,890 --> 00:38:10,780
所以我们需要一条线回到那里的中心。 

867
00:38:10,780 --> 00:38:14,823
这就是p点addLine到中心。 

868
00:38:15,658 --> 00:38:16,960
就是这样。 

869
00:38:16,960 --> 00:38:18,640
我们在这里完成了自定义形状。 

870
00:38:18,640 --> 00:38:21,974
我们要做的就是定义此Path并返回它， 

871
00:38:21,974 --> 00:38:23,780
我们有一个自定义的形状

872
00:38:23,780 --> 00:38:25,520
形状会照顾其他一切， 

873
00:38:25,520 --> 00:38:27,477
填满它，抚摸它，所有这些东西

874
00:38:27,477 --> 00:38:28,773
它知道该怎么做。 

875
00:38:29,930 --> 00:38:31,120
让我们回到我们的观点

876
00:38:31,120 --> 00:38:33,980
还有我们在这里使用Circle的地方

877
00:38:33,980 --> 00:38:36,540
我们将改用Pie。 

878
00:38:36,540 --> 00:38:37,963
所以，让我们做派。 

879
00:38:39,770 --> 00:38:42,480
糟糕，抱歉，在那里退出Xcode。 

880
00:38:42,480 --> 00:38:45,270
让我们回到这里。 

881
00:38:45,270 --> 00:38:46,243
对于那个很抱歉。 

882
00:38:47,130 --> 00:38:49,470
我们知道Pie有一些变种。 

883
00:38:49,470 --> 00:38:52,090
我要初始化起始角度和终止角度。 

884
00:38:52,090 --> 00:38:54,870
请注意，顺时针方向是可选的。 

885
00:38:54,870 --> 00:38:56,580
我们不必指定。 

886
00:38:56,580 --> 00:38:58,950
因此，我们选择在此处进行起始和终止角度。 

887
00:38:58,950 --> 00:39:01,163
现在我们要从什么角度开始？ 

888
00:39:01,163 --> 00:39:04,716
好吧，我们想从这里开始

889
00:39:04,716 --> 00:39:08,170
然后逆时针转到此处。 

890
00:39:08,170 --> 00:39:12,840
所以直线向上可能是角度点度为零， 

891
00:39:14,570 --> 00:39:17,023
然后是结束角，我们在哪里结束？ 

892
00:39:17,960 --> 00:39:20,070
我们在这里结束。 

893
00:39:20,070 --> 00:39:23,460
好吧，如果这是零，那将是90 

894
00:39:23,460 --> 00:39:26,540
所以就像110度

895
00:39:26,540 --> 00:39:28,150
这样的东西。 

896
00:39:28,150 --> 00:39:31,357
让我们尝试角度角度为110。 

897
00:39:33,950 --> 00:39:36,560
哦，那还不行。 

898
00:39:36,560 --> 00:39:37,990
这里发生了什么？ 

899
00:39:37,990 --> 00:39:41,870
这看起来并不像这样。 

900
00:39:41,870 --> 00:39:43,313
那么为什么这是一个问题呢？ 

901
00:39:44,200 --> 00:39:46,301
好吧，首先要了解的是iOS 

902
00:39:46,301 --> 00:39:51,260
是零角度，零度不向上， 

903
00:39:51,260 --> 00:39:53,640
它在右边。 

904
00:39:53,640 --> 00:39:55,200
零角度在右边。 

905
00:39:55,200 --> 00:39:58,110
所以如果我们希望这种程度

906
00:39:58,110 --> 00:39:59,620
零直线上升

907
00:39:59,620 --> 00:40:02,396
我们要减去90度

908
00:40:02,396 --> 00:40:04,110
从所有这些角度来看。 

909
00:40:04,110 --> 00:40:06,100
所以那个角度偏离90度

910
00:40:06,100 --> 00:40:08,366
与那个角度成90度角

911
00:40:08,366 --> 00:40:10,420
但这也不是很有效。 

912
00:40:10,420 --> 00:40:13,042
那仍然不是我们在这里寻找的东西。 

913
00:40:13,042 --> 00:40:15,540
好像是从零开始的

914
00:40:15,540 --> 00:40:20,025
但它是顺时针而不是逆时针。 

915
00:40:20,025 --> 00:40:24,100
我可以肯定在这里我说的是顺时针错误。 

916
00:40:24,100 --> 00:40:25,120
是的，逆时针旋转。 

917
00:40:25,120 --> 00:40:26,453
这是怎么回事？ 

918
00:40:27,710 --> 00:40:30,644
那是不可能的，那不可能发生。 

919
00:40:30,644 --> 00:40:33,683
嗯，这是因为在iOS中， 

920
00:40:37,130 --> 00:40:40,230
您要在其中绘制的绘图坐标系

921
00:40:40,230 --> 00:40:41,063
就在这儿， 

922
00:40:41,063 --> 00:40:46,063
在左上角有（0，0），并且上下颠倒。 

923
00:40:46,170 --> 00:40:47,800
因此，这将增加Y。 

924
00:40:47,800 --> 00:40:49,210
从（0，0）开始

925
00:40:49,210 --> 00:40:51,130
随着我们来到这里，Y越来越大。 

926
00:40:51,130 --> 00:40:53,976
您习惯的不是笛卡尔坐标

927
00:40:53,976 --> 00:40:56,150
从您的三角学课。 

928
00:40:56,150 --> 00:40:59,700
这不是（0，0），这里是（0，0）。 

929
00:40:59,700 --> 00:41:01,584
因此，由于整个过程都是颠倒的， 

930
00:41:01,584 --> 00:41:03,440
顺时针和逆时针

931
00:41:03,440 --> 00:41:05,720
也正朝着相反的方向发展。 

932
00:41:05,720 --> 00:41:09,190
所以我们实际上需要这个起始角度，终止角度

933
00:41:09,190 --> 00:41:14,190
而且我们也希望顺时针为真。 

934
00:41:14,240 --> 00:41:17,173
因此，即使我们确实走了相反的方向， 

935
00:41:17,173 --> 00:41:19,423
我们不得不说顺时针是真的。 

936
00:41:20,600 --> 00:41:24,130
可以肯定的是，这正是我们想要的。 

937
00:41:26,320 --> 00:41:29,920
现在，在下一个讲座中，我们将开始对此进行动画处理。 

938
00:41:29,920 --> 00:41:32,350
举例来说，我们仍然让它从零开始， 

939
00:41:32,350 --> 00:41:34,320
但是随着时间的流逝， 

940
00:41:34,320 --> 00:41:37,313
从110、150开始， 

941
00:41:38,280 --> 00:41:39,733
200， 

942
00:41:40,680 --> 00:41:41,890
300， 

943
00:41:41,890 --> 00:41:44,710
滴答作响350 

944
00:41:44,710 --> 00:41:47,980
几乎提高了360倍。 

945
00:41:47,980 --> 00:41:50,990
所以我们要为这个角度做动画

946
00:41:50,990 --> 00:41:53,133
下降到零。 

947
00:41:54,570 --> 00:41:55,800
这将在下一次演讲中

948
00:41:55,800 --> 00:41:57,420
当我们谈论动画时。 

949
00:41:57,420 --> 00:41:59,080
我们要在动画中谈论的第一件事

950
00:41:59,080 --> 00:42:00,680
给Views设置动画。 

951
00:42:00,680 --> 00:42:02,390
意见来来去去， 

952
00:42:02,390 --> 00:42:04,090
他们越来越大。 

953
00:42:04,090 --> 00:42:05,330
有时候他们在做特别的事情

954
00:42:05,330 --> 00:42:07,677
就像CardView可能会翻转一样。 

955
00:42:07,677 --> 00:42:11,966
好的，可以做3D旋转来翻转。 

956
00:42:11,966 --> 00:42:14,913
现在，查看动画的方式不同。 

957
00:42:14,913 --> 00:42:18,032
形状是动画的，它们直接为自己设置动画。 

958
00:42:18,032 --> 00:42:21,647
视图通过其修改器进行动画处理。 

959
00:42:21,647 --> 00:42:24,654
因此，要了解如何为视图设置动画， 

960
00:42:24,654 --> 00:42:26,635
我们将不得不花一点时间来动画

961
00:42:26,635 --> 00:42:30,498
并讨论什么是ViewModifier。 

962
00:42:30,498 --> 00:42:32,009
现在，您一直在使用ViewModifiers 

963
00:42:32,009 --> 00:42:34,760
到目前为止，在记忆的整个地方， 

964
00:42:34,760 --> 00:42:38,167
AspectRatio，填充，字体，前景颜色。 

965
00:42:38,167 --> 00:42:41,310
所有这些都是ViewModifiers。 

966
00:42:41,310 --> 00:42:44,490
他们修改一个视图并返回一个新的视图

967
00:42:44,490 --> 00:42:47,290
那是您调用它们的View的修改版本。 

968
00:42:47,290 --> 00:42:50,190
这就是ViewModifiers所做的。 

969
00:42:50,190 --> 00:42:53,340
现在，大多数修饰符，不是全部，而是大多数， 

970
00:42:53,340 --> 00:42:55,829
可能只是通过转过来实现

971
00:42:55,829 --> 00:43:00,103
并在View协议中调用一个非常重要的功能， 

972
00:43:00,103 --> 00:43:03,830
通过扩展名添加到View协议

973
00:43:03,830 --> 00:43:05,953
称为修饰符。 

974
00:43:05,953 --> 00:43:08,270
View中的此功能修饰符， 

975
00:43:08,270 --> 00:43:10,200
需要一个论点

976
00:43:10,200 --> 00:43:12,514
这本质上是实现

977
00:43:12,514 --> 00:43:15,090
ViewModifier协议。 

978
00:43:15,090 --> 00:43:16,240
所以这里aspectRatio 2/3 

979
00:43:17,719 --> 00:43:20,240
由于空间原因，我放弃了合适的人选， 

980
00:43:20,240 --> 00:43:21,792
但是aspectRatio 2/3 

981
00:43:21,792 --> 00:43:25,600
可能会执行类似调用View的操作， 

982
00:43:25,600 --> 00:43:28,090
在您将AspectRatio发送到的同一视图上， 

983
00:43:28,090 --> 00:43:29,224
就是说点修饰符， 

984
00:43:29,224 --> 00:43:32,803
AspectModifier是2/3的某种结构。 

985
00:43:33,800 --> 00:43:37,400
因此，让我们谈谈ViewModifier协议是什么。 

986
00:43:37,400 --> 00:43:39,324
顾名思义，您几乎可以猜到。 

987
00:43:39,324 --> 00:43:41,720
它只有一个功能

988
00:43:41,720 --> 00:43:43,979
而唯一起作用的就是拿点东西

989
00:43:43,979 --> 00:43:46,220
并对其进行修改以生成一个View。 

990
00:43:46,220 --> 00:43:49,730
例如，您可以调整空间

991
00:43:49,730 --> 00:43:52,770
提供aspectRatio 2/3， 

992
00:43:52,770 --> 00:43:55,820
或ViewModifier可以在外部添加一些填充。 

993
00:43:55,820 --> 00:43:59,440
这就是我确定的填充ViewModifier。 

994
00:43:59,440 --> 00:44:01,270
那么该代码对于协议来说是什么样的呢？ 

995
00:44:01,270 --> 00:44:03,811
这就是协议ViewModifier。 

996
00:44:03,811 --> 00:44:07,030
第一行关联类型Content。 

997
00:44:07,030 --> 00:44:10,940
再次，你们阅读了阅读作业，我希望

998
00:44:10,940 --> 00:44:13,175
并且您了解什么是关联类型内容

999
00:44:13,175 --> 00:44:16,740
是不在乎协议。 

1000
00:44:16,740 --> 00:44:19,610
协议，就像功能和类型一样

1001
00:44:19,610 --> 00:44:21,660
他们也不在乎， 

1002
00:44:21,660 --> 00:44:25,070
但它们的语法是关联类型Content， 

1003
00:44:25,070 --> 00:44:28,230
而不是您在struct上看到的尖括号。 

1004
00:44:28,230 --> 00:44:30,450
因此，ViewModifier协议不必关心

1005
00:44:30,450 --> 00:44:31,700
称为内容。 

1006
00:44:31,700 --> 00:44:34,957
真的不在乎Content是什么类型。 

1007
00:44:34,957 --> 00:44:36,610
好吧，现在，一旦您了解了， 

1008
00:44:36,610 --> 00:44:38,950
我们可以看一下ViewModifier中的唯一函数， 

1009
00:44:38,950 --> 00:44:40,480
这是身体。 

1010
00:44:40,480 --> 00:44:43,160
身体接受了无关紧要的内容， 

1011
00:44:43,160 --> 00:44:44,298
我们真的不在乎那是什么， 

1012
00:44:44,298 --> 00:44:47,843
它返回非常重要的一些视图。 

1013
00:44:48,810 --> 00:44:51,930
在那个身体里面，只需吸收内容

1014
00:44:51,930 --> 00:44:52,763
那是给它的

1015
00:44:52,763 --> 00:44:56,450
然后以某种方式组成一个View并将其返回。 

1016
00:44:56,450 --> 00:45:00,900
现在，当您在View上调用点修饰符时， 

1017
00:45:00,900 --> 00:45:02,395
通过的内容

1018
00:45:02,395 --> 00:45:06,680
是将“发送点的视图”修饰符发送到的视图，对吗？ 

1019
00:45:06,680 --> 00:45:08,830
您调用的点修饰符所在的视图， 

1020
00:45:08,830 --> 00:45:10,215
这就是内容。 

1021
00:45:10,215 --> 00:45:12,605
这样就可以使任何ViewModifier 

1022
00:45:12,605 --> 00:45:16,290
用点修饰符调用

1023
00:45:16,290 --> 00:45:19,560
将获得作为内容调用的视图。 

1024
00:45:19,560 --> 00:45:22,790
这就是为什么我们说它修改了该视图。 

1025
00:45:22,790 --> 00:45:23,972
它将创建一个新的视图

1026
00:45:23,972 --> 00:45:27,763
使用该视图，您会将其作为内容发送到。 

1027
00:45:29,000 --> 00:45:32,350
是的，让我们来看一个例子

1028
00:45:32,350 --> 00:45:35,150
使这一切更加具体。 

1029
00:45:35,150 --> 00:45:38,130
假设我想拥有一个ViewModifier 

1030
00:45:38,130 --> 00:45:41,420
像我们的文字幽灵一样使用任何视图

1031
00:45:41,420 --> 00:45:43,950
或任何查看图像的任何内容， 

1032
00:45:43,950 --> 00:45:47,240
并对其进行了修改，使其看起来像卡。 

1033
00:45:47,240 --> 00:45:50,695
基本上将其卡住。 

1034
00:45:50,695 --> 00:45:52,274
这就是我们想要构建的。 

1035
00:45:52,274 --> 00:45:55,800
现在听起来这是一个非常复杂的修饰符。 

1036
00:45:55,800 --> 00:45:58,450
这比仅在其周围填充填充更加复杂

1037
00:45:58,450 --> 00:46:00,300
或类似的东西。 

1038
00:46:00,300 --> 00:46:02,184
它实际上是一个非常简单的修饰符， 

1039
00:46:02,184 --> 00:46:04,260
但从概念上讲，这是有道理的。 

1040
00:46:04,260 --> 00:46:07,160
现在在我们的应用中，我们甚至不一定需要修饰符

1041
00:46:07,160 --> 00:46:10,460
之所以这样，是因为我们只有一种视图

1042
00:46:10,460 --> 00:46:12,134
曾经被证伪， 

1043
00:46:12,134 --> 00:46:14,980
但您可以想象一个应用中有一些卡片

1044
00:46:14,980 --> 00:46:17,300
上面有图片，有一些表情符号， 

1045
00:46:17,300 --> 00:46:19,328
有些只是文字或其他内容，其他抽认卡， 

1046
00:46:19,328 --> 00:46:21,610
但他们都有相同的卡。 

1047
00:46:21,610 --> 00:46:24,423
能够对任何视图进行梳理可能很有意义。 

1048
00:46:25,300 --> 00:46:26,491
这是代码的样子。 

1049
00:46:26,491 --> 00:46:28,360
第一行实际上是

1050
00:46:28,360 --> 00:46:30,690
我们如何称呼修饰符。 

1051
00:46:30,690 --> 00:46:32,202
例如，如果我们想进行卡片化

1052
00:46:32,202 --> 00:46:36,750
我们的幽灵文本，我们会说点修饰符， 

1053
00:46:36,750 --> 00:46:38,470
那个非常重要的View功能

1054
00:46:38,470 --> 00:46:40,810
参数是ViewModifier。 

1055
00:46:40,810 --> 00:46:42,660
现在我要叫我的ViewModifier， 

1056
00:46:42,660 --> 00:46:45,920
您可以在下一行看到struct Cardify结构。 

1057
00:46:45,920 --> 00:46:48,500
我将其称为Cardify，它实际上需要一个参数。 

1058
00:46:48,500 --> 00:46:49,800
我们将讨论这一点。 

1059
00:46:49,800 --> 00:46:52,706
但是尽管如此，我最终还是想说

1060
00:46:52,706 --> 00:46:55,860
文字点成Cardify， 

1061
00:46:55,860 --> 00:46:58,890
就像我说的是点前景颜色，点填充

1062
00:46:58,890 --> 00:47:00,330
我想说点Cardify。 

1063
00:47:00,330 --> 00:47:02,470
我不想说点修饰符Cardify。 

1064
00:47:02,470 --> 00:47:03,303
所以在下一张幻灯片上

1065
00:47:03,303 --> 00:47:06,320
我们将展示如何从点修饰符Cardify得到

1066
00:47:06,320 --> 00:47:08,360
点Cardify。 

1067
00:47:08,360 --> 00:47:09,408
但现在，让我们专注于

1068
00:47:09,408 --> 00:47:12,770
我们将如何实现Cardify ViewModifier 

1069
00:47:12,770 --> 00:47:16,840
因为这一定要带上文字幽灵

1070
00:47:16,840 --> 00:47:19,470
并对其进行修改，将其转换为新的视图

1071
00:47:19,470 --> 00:47:20,490
看起来像卡。 

1072
00:47:20,490 --> 00:47:22,190
这就是这件事要做的。 

1073
00:47:23,040 --> 00:47:26,220
我想看的第一件事是Content参数

1074
00:47:26,220 --> 00:47:28,753
在ViewModifier中添加到该主体函数。 

1075
00:47:28,753 --> 00:47:32,503
我把它出现的所有地方都变黄了， 

1076
00:47:32,503 --> 00:47:34,216
这是身体的论点。 

1077
00:47:34,216 --> 00:47:38,950
您可以在顶部看到Text鬼魂是那个Content是什么

1078
00:47:38,950 --> 00:47:41,650
然后也往下看ZStack 

1079
00:47:41,650 --> 00:47:45,010
我嵌入该内容，它是一个视图

1080
00:47:45,010 --> 00:47:47,520
并将其嵌入到我的ZStack中

1081
00:47:47,520 --> 00:47:51,070
在同一地方，我会将其放回旧代码中。 

1082
00:47:51,070 --> 00:47:54,320
所以现在要获取任何视图并将其嵌入到此处

1083
00:47:54,320 --> 00:47:58,330
在我的ZStack卡上。 

1084
00:47:58,330 --> 00:48:02,010
那么您是否知道这将如何修改视图

1085
00:48:02,010 --> 00:48:04,653
您将其发送到看起来像卡片。 

1086
00:48:05,780 --> 00:48:07,392
现在，这里要注意的一件事是

1087
00:48:07,392 --> 00:48:10,350
该ViewModifier需要一些信息， 

1088
00:48:10,350 --> 00:48:12,677
需要知道卡是面朝上还是面朝下。 

1089
00:48:12,677 --> 00:48:17,040
这是一个结构，所以我只添加一个var isFaceUp 

1090
00:48:17,040 --> 00:48:20,210
我们知道，如果您有一个var且未初始化， 

1091
00:48:20,210 --> 00:48:21,899
然后谁创建这个结构， 

1092
00:48:21,899 --> 00:48:24,390
在最上面

1093
00:48:24,390 --> 00:48:27,060
它需要指定它的值。 

1094
00:48:27,060 --> 00:48:29,720
所以希望这是您熟悉的样子

1095
00:48:29,720 --> 00:48:30,553
当您执行这些修饰符时， 

1096
00:48:30,553 --> 00:48:33,160
显然很多人都在争论

1097
00:48:33,160 --> 00:48:34,990
前景色采用一种颜色

1098
00:48:34,990 --> 00:48:38,411
填充可能会占用顶部或底部

1099
00:48:38,411 --> 00:48:42,000
以及要填充的点数和所有其他这些参数。 

1100
00:48:42,000 --> 00:48:45,230
这些只是要放在ViewModifier中进行填充， 

1101
00:48:45,230 --> 00:48:46,123
例如。 

1102
00:48:47,850 --> 00:48:51,413
所以点修饰符，那个函数，它返回一个View， 

1103
00:48:51,413 --> 00:48:53,663
返回符合View的内容

1104
00:48:53,663 --> 00:48:58,663
这将在这里使用身体的紫色内容

1105
00:48:59,035 --> 00:49:01,283
绘制视图。 

1106
00:49:02,280 --> 00:49:06,240
现在修饰符不会直接返回此紫色代码

1107
00:49:06,240 --> 00:49:08,437
返回另一个也是View的东西， 

1108
00:49:08,437 --> 00:49:09,270
但是那是另外一回事

1109
00:49:09,270 --> 00:49:12,193
将使用此紫色代码绘制所绘制的内容。 

1110
00:49:13,310 --> 00:49:14,274
如此简单。 

1111
00:49:14,274 --> 00:49:18,070
点修饰符将仅用于使用ViewModifier， 

1112
00:49:18,070 --> 00:49:21,753
将其发送给身体的视图

1113
00:49:21,753 --> 00:49:25,371
它会得到任何必要的内置

1114
00:49:25,371 --> 00:49:27,690
并作为要使用的新视图返回。 

1115
00:49:27,690 --> 00:49:29,730
然后当然，因为那是一个视图， 

1116
00:49:29,730 --> 00:49:31,470
我们可以给它发送另一个修饰符

1117
00:49:31,470 --> 00:49:34,190
以及其他修饰符，等等

1118
00:49:34,190 --> 00:49:36,540
斯威夫特在跟踪方面非常聪明

1119
00:49:36,540 --> 00:49:38,766
修改，修改，修改时

1120
00:49:38,766 --> 00:49:41,583
这样它就可以做动画之类的事情

1121
00:49:43,420 --> 00:49:47,120
那么我们如何从这种文本点修饰符语法中获得

1122
00:49:47,120 --> 00:49:48,564
点上Cardify， 

1123
00:49:48,564 --> 00:49:51,050
因为这就是我们想要点Cardify的原因。 

1124
00:49:51,050 --> 00:49:52,760
真的很容易，您实际上知道如何执行此操作。 

1125
00:49:52,760 --> 00:49:55,408
我将创建View协议的扩展， 

1126
00:49:55,408 --> 00:49:57,529
添加功能cardify 

1127
00:49:57,529 --> 00:50:00,400
显然，cardify返回了一些视图

1128
00:50:00,400 --> 00:50:03,190
它只会返回自我点修饰符

1129
00:50:03,190 --> 00:50:04,023
的Cardify。 

1130
00:50:04,023 --> 00:50:05,170
请记住，这是View的扩展， 

1131
00:50:05,170 --> 00:50:06,535
所以自我就是观点。 

1132
00:50:06,535 --> 00:50:09,349
所以我当然可以在自身上调用点修饰符

1133
00:50:09,349 --> 00:50:11,930
并将其传递给正确的ViewModifier， 

1134
00:50:11,930 --> 00:50:13,230
在这种情况下，我们的Cardify。 

1135
00:50:15,980 --> 00:50:18,149
好吧，让我们去实现这个

1136
00:50:18,149 --> 00:50:21,043
在我们的记忆应用程序中。 

1137
00:50:22,300 --> 00:50:26,560
在此演示中，我们的目标是使所有View， 

1138
00:50:26,560 --> 00:50:31,260
包括我们的幽灵和吃豆人都可以被证成

1139
00:50:31,260 --> 00:50:35,020
这意味着当它面朝上时将其周围环绕

1140
00:50:35,020 --> 00:50:38,183
或者只是在面朝下时将其拉回。 

1141
00:50:39,190 --> 00:50:41,490
让我们通过想象开始这个演示

1142
00:50:41,490 --> 00:50:45,360
如果有这个修饰符，我们的代码将是什么样子。 

1143
00:50:45,360 --> 00:50:48,710
让我们在此处留出一些空间，以便我们了解发生了什么。 

1144
00:50:48,710 --> 00:50:53,460
我现在要把我们的卡的一部分

1145
00:50:53,460 --> 00:50:54,730
会被气化的

1146
00:50:54,730 --> 00:50:56,759
就是馅饼和文字。 

1147
00:50:56,759 --> 00:50:59,300
我们将把它们与代码分开

1148
00:50:59,300 --> 00:51:01,870
这实际上是在做卡片化。 

1149
00:51:01,870 --> 00:51:04,760
然后我们要拿这个ZStack 

1150
00:51:04,760 --> 00:51:07,230
里面有我们想要的东西， 

1151
00:51:07,230 --> 00:51:09,520
然后我要说点Cardify来进行卡片化。 

1152
00:51:09,520 --> 00:51:12,131
当然，持牌人需要知道

1153
00:51:12,131 --> 00:51:14,292
这个东西是否正视。 

1154
00:51:14,292 --> 00:51:17,980
所以我要过去那面朝上

1155
00:51:17,980 --> 00:51:21,180
我们将看到如何指定

1156
00:51:21,180 --> 00:51:22,301
一点点。 

1157
00:51:22,301 --> 00:51:24,490
现在这段代码就是这样

1158
00:51:24,490 --> 00:51:26,354
实际上是进行卡片化对吧？ 

1159
00:51:26,354 --> 00:51:28,903
将RoundedRectangles放在后面或前面。 

1160
00:51:28,903 --> 00:51:30,297
只是要把它剪下来

1161
00:51:30,297 --> 00:51:34,990
然后将其放入Cardify ViewModifier中。 

1162
00:51:34,990 --> 00:51:35,823
在我去那之前

1163
00:51:35,823 --> 00:51:38,570
我最终确实希望这样说， 

1164
00:51:38,570 --> 00:51:40,718
但是我们知道ViewModifiers 

1165
00:51:40,718 --> 00:51:44,680
正在调用称为修饰符的此View函数

1166
00:51:44,680 --> 00:51:48,240
那么您只需指定所需的ViewModifier。 

1167
00:51:48,240 --> 00:51:50,360
因此，我们将创建ViewModifier来做到这一点， 

1168
00:51:50,360 --> 00:51:51,530
我将其称为Cardify 

1169
00:51:51,530 --> 00:51:55,770
而且当然必须要把脸朝上

1170
00:51:55,770 --> 00:51:57,813
作为争论。 

1171
00:51:57,813 --> 00:52:01,733
这就是这个问题的解决者真正要做的

1172
00:52:01,733 --> 00:52:04,800
这最终将成为我们要创建的功能

1173
00:52:04,800 --> 00:52:07,610
只是这一行而已。 

1174
00:52:07,610 --> 00:52:10,640
所以我们将其注释掉并将其放回去

1175
00:52:10,640 --> 00:52:13,470
一旦我们添加了一个称为衬套的衬套。 

1176
00:52:13,470 --> 00:52:15,181
但这就是要做的

1177
00:52:15,181 --> 00:52:18,698
当然，它说未解析的标识符Cardify， 

1178
00:52:18,698 --> 00:52:23,579
我们必须编写执行此ViewModifier的代码。 

1179
00:52:23,579 --> 00:52:24,990
因此，让我们跳过去。 

1180
00:52:24,990 --> 00:52:26,393
文件，新文件。 

1181
00:52:27,690 --> 00:52:32,380
这不是SwiftUI视图，而是ViewModifier。 

1182
00:52:32,380 --> 00:52:34,725
因此，我们将点击此处，我​​们将转到此处， 

1183
00:52:34,725 --> 00:52:37,140
我将其称为Cardify 

1184
00:52:37,140 --> 00:52:39,190
那是我的新修饰符的名称。 

1185
00:52:39,190 --> 00:52:41,500
注意它没有放在正确的位置。 

1186
00:52:41,500 --> 00:52:43,160
这是一个很好的例子。 

1187
00:52:43,160 --> 00:52:45,480
我不想在顶部的这个蓝色的东西。 

1188
00:52:45,480 --> 00:52:48,240
我要在这里，这个黄色的文件夹

1189
00:52:48,240 --> 00:52:49,734
我希望这是同一个地方

1190
00:52:49,734 --> 00:52:53,310
这个黄色的文件夹在这里。 

1191
00:52:53,310 --> 00:52:55,050
所以希望大家都记得这样做

1192
00:52:55,050 --> 00:52:57,610
这样您就不会到处都是文件

1193
00:52:57,610 --> 00:52:58,443
他们不应该。 

1194
00:52:58,443 --> 00:53:00,030
因此，创建Cardify。 

1195
00:53:00,030 --> 00:53:01,088
这是Cardify。 

1196
00:53:01,088 --> 00:53:05,960
现在，当然，ViewModifiers非常是UI方面的东西， 

1197
00:53:05,960 --> 00:53:08,470
所以我们不说在那儿导入Foundation， 

1198
00:53:08,470 --> 00:53:11,011
并创建一个ViewModifier，非常简单。 

1199
00:53:11,011 --> 00:53:15,333
结构Cardify，这是一个ViewModifier 

1200
00:53:16,320 --> 00:53:18,920
当我们这样做时，我们将立即得到一个错误

1201
00:53:18,920 --> 00:53:22,974
表示Cardify不符合协议ViewModifier。 

1202
00:53:22,974 --> 00:53:26,350
该协议仅具有一个功能， 

1203
00:53:26,350 --> 00:53:30,275
它称为主体，它以内容为参数。 

1204
00:53:30,275 --> 00:53:34,430
此处的此内容是无关紧要的

1205
00:53:34,430 --> 00:53:37,110
从这个协议。 

1206
00:53:37,110 --> 00:53:39,230
因此协议也可以不在乎。 

1207
00:53:39,230 --> 00:53:43,010
他们使用该associatedtype语法指定它们

1208
00:53:43,010 --> 00:53:45,810
在阅读作业中读到的

1209
00:53:45,810 --> 00:53:47,370
所以这可以是任何东西。 

1210
00:53:47,370 --> 00:53:49,080
这不在乎。 

1211
00:53:49,080 --> 00:53:51,280
我们将在短短一秒钟内讨论一下。 

1212
00:53:51,280 --> 00:53:52,491
那当然是一个ViewModifier 

1213
00:53:52,491 --> 00:53:56,870
它正在修改一个视图，然后返回一些新的视图

1214
00:53:56,870 --> 00:54:00,070
那是它的修改版本。 

1215
00:54:00,070 --> 00:54:01,117
所以这个论点在这里， 

1216
00:54:01,117 --> 00:54:03,324
只是从幻灯片上提醒您

1217
00:54:03,324 --> 00:54:07,420
当我们在这里回叫修改器Cardify时， 

1218
00:54:07,420 --> 00:54:10,880
要求我们修改的内容

1219
00:54:10,880 --> 00:54:15,610
将成为我们称之为修改器的任何视图。 

1220
00:54:15,610 --> 00:54:18,120
因此，我们将在ZStack上调用修饰符。 

1221
00:54:18,120 --> 00:54:20,290
因此，在这种情况下，我们的梳理机内部

1222
00:54:20,290 --> 00:54:22,580
内容将是ZStack。 

1223
00:54:22,580 --> 00:54:27,027
这始终是您在其上调用点修饰符的视图。 

1224
00:54:27,027 --> 00:54:28,790
那么，这里发生了什么？ 

1225
00:54:28,790 --> 00:54:31,890
在这里，我们只需要创建修改后的视图， 

1226
00:54:31,890 --> 00:54:33,440
换句话说，一个卡片化视图。 

1227
00:54:33,440 --> 00:54:37,710
所以我只是要粘贴我们以前拥有的东西

1228
00:54:37,710 --> 00:54:40,850
当然，这仍然必须在ZStack中

1229
00:54:40,850 --> 00:54:44,290
因为我们仍然有这些RoundedRectangles 

1230
00:54:44,290 --> 00:54:45,670
彼此堆叠。 

1231
00:54:45,670 --> 00:54:47,960
因此，让我们继续进行。 

1232
00:54:47,960 --> 00:54:51,370
我们这里有一些未定义的东西， 

1233
00:54:51,370 --> 00:54:53,800
如cornerRadius和edgeLineWidth。 

1234
00:54:53,800 --> 00:54:55,970
那些都在这里，那就是绘制常量。 

1235
00:54:55,970 --> 00:54:57,680
我们不再需要它们了

1236
00:54:57,680 --> 00:55:00,630
因为我们使用卡片化来制作卡片。 

1237
00:55:00,630 --> 00:55:03,379
因此，我们将其弹出此处。 

1238
00:55:03,379 --> 00:55:05,840
这解决了我们的大多数问题。 

1239
00:55:05,840 --> 00:55:09,324
我们确实知道我们必须通过这是空间

1240
00:55:09,324 --> 00:55:11,450
作为这里的一个论点

1241
00:55:11,450 --> 00:55:14,013
Cardify需要知道它是否面朝上

1242
00:55:14,013 --> 00:55:17,822
所以会有一个var isFaceUp这是一个布尔值

1243
00:55:17,822 --> 00:55:20,169
我不会把它设置为等于

1244
00:55:20,169 --> 00:55:23,260
因此，只要有人在这里创建Cardify， 

1245
00:55:23,260 --> 00:55:27,090
他们必须告诉我isFaceUp的价值是什么

1246
00:55:27,090 --> 00:55:29,833
然后我要在里面使用这个isFaceUp 

1247
00:55:29,833 --> 00:55:33,380
任何时候我想检查一下我是否正对面。 

1248
00:55:33,380 --> 00:55:35,123
现在，这是匹配的东西。 

1249
00:55:35,123 --> 00:55:39,810
isMatched确实不属于Cardify。 

1250
00:55:39,810 --> 00:55:42,300
匹配与我们的纸牌游戏有关。 

1251
00:55:42,300 --> 00:55:45,070
此Cardify可以Cardify任何视图， 

1252
00:55:45,070 --> 00:55:47,450
不只是我们的纸牌游戏中的“观看次数”。 

1253
00:55:47,450 --> 00:55:51,250
这可以使卡面朝上，面朝下在任何视图上。 

1254
00:55:51,250 --> 00:55:53,290
所以我们想保持通用。 

1255
00:55:53,290 --> 00:55:56,840
我们不希望它与应用程序的其余部分绑定在一起。 

1256
00:55:56,840 --> 00:55:58,460
这是一件很好的可重用的事情

1257
00:55:58,460 --> 00:55:59,910
我们实际上可以使用其他游戏- 

1258
00:55:59,910 --> 00:56:02,030
假设我们写了其他游戏

1259
00:56:02,030 --> 00:56:05,298
卡片上有一些文字，卡片上有图像

1260
00:56:05,298 --> 00:56:08,430
卡上的表情符号和表情符号都混在同一个应用中。 

1261
00:56:08,430 --> 00:56:11,570
好吧，我们可以使用Cardify对所有这些东西进行Cardify。 

1262
00:56:11,570 --> 00:56:13,230
但是我们真的无法找到匹配项

1263
00:56:13,230 --> 00:56:17,183
因为匹配特定于此应用，所以请记住。 

1264
00:56:18,409 --> 00:56:19,860
然后我们要在这里做的最后一件事

1265
00:56:19,860 --> 00:56:23,023
显然，此内容需要在此处的某个位置。 

1266
00:56:23,023 --> 00:56:25,930
好吧，我要把它准确地放在以前的位置。 

1267
00:56:25,930 --> 00:56:26,819
只是为了内容。 

1268
00:56:26,819 --> 00:56:30,710
内容就是视图，ZStack 

1269
00:56:30,710 --> 00:56:33,318
该修饰符将被发送到此处。 

1270
00:56:33,318 --> 00:56:34,410
所以我要拿这个

1271
00:56:34,410 --> 00:56:37,350
它会在这里弹出。 

1272
00:56:37,350 --> 00:56:38,344
现在我完成了。 

1273
00:56:38,344 --> 00:56:41,520
这是一个使用此内容的ViewModifier， 

1274
00:56:41,520 --> 00:56:43,979
点修饰符发送到此处的任何视图

1275
00:56:43,979 --> 00:56:47,461
并将其与RoundedRectangles放在ZStack中

1276
00:56:47,461 --> 00:56:50,260
或者，如果它面朝上，就这样做，等等。 

1277
00:56:50,260 --> 00:56:55,013
这是使该内容有意义的东西。 

1278
00:56:56,700 --> 00:56:58,380
做了什么，让我们回到这里。 

1279
00:56:58,380 --> 00:57:01,963
让我们继续运行，看看是否可行。 

1280
00:57:05,018 --> 00:57:07,130
似乎卡的背面正在工作。 

1281
00:57:07,130 --> 00:57:09,370
让我们尝试一下。 

1282
00:57:09,370 --> 00:57:12,157
哦，这很好。 

1283
00:57:12,157 --> 00:57:14,975
现在这里有一个问题

1284
00:57:14,975 --> 00:57:16,902
如果我有比赛

1285
00:57:16,902 --> 00:57:20,476
然后我点击另一张卡片，哦，这些卡片不会消失。 

1286
00:57:20,476 --> 00:57:24,033
那是因为我从那里拿走了匹配的东西。 

1287
00:57:25,080 --> 00:57:26,880
因此，我们必须解决此问题。 

1288
00:57:26,880 --> 00:57:28,300
我们要解决的另一件事是

1289
00:57:28,300 --> 00:57:31,270
我们想要更好的语法点cardify。 

1290
00:57:31,270 --> 00:57:33,160
因此，让我们先修复更好的语法

1291
00:57:33,160 --> 00:57:35,750
然后我们将解决匹配卡的问题

1292
00:57:35,750 --> 00:57:37,610
仍被包括在这里

1293
00:57:37,610 --> 00:57:39,450
什么时候应该把它们拿走。 

1294
00:57:39,450 --> 00:57:41,610
可以证卡的功能

1295
00:57:41,610 --> 00:57:45,010
这只是我们将要添加的扩展名。 

1296
00:57:45,010 --> 00:57:46,690
这显然最有意义

1297
00:57:46,690 --> 00:57:48,400
把它放在这个文件中

1298
00:57:48,400 --> 00:57:51,198
因为这是Cardify ViewModifier所在的位置。 

1299
00:57:51,198 --> 00:57:54,800
所以这是我们想要扩展View的地方

1300
00:57:54,800 --> 00:57:57,210
具有func cardify的功能。 

1301
00:57:57,210 --> 00:57:59,388
现在cardify也将必须采取

1302
00:57:59,388 --> 00:58:01,350
是否面对面作为争论

1303
00:58:01,350 --> 00:58:04,990
只是要归还该卡片化视图

1304
00:58:04,990 --> 00:58:06,413
真的很容易实现。 

1305
00:58:06,413 --> 00:58:07,810
只会自称

1306
00:58:07,810 --> 00:58:10,061
self是一个View，我们是View的扩展， 

1307
00:58:10,061 --> 00:58:13,528
修饰符，我们要给它一个Cardify 

1308
00:58:13,528 --> 00:58:18,528
isFaceUp是传递给我们的isFaceUp。 

1309
00:58:18,817 --> 00:58:20,200
就是这样。 

1310
00:58:20,200 --> 00:58:21,463
简单如馅饼。 

1311
00:58:22,320 --> 00:58:23,650
无双关语。 

1312
00:58:23,650 --> 00:58:27,420
我们在这里将cardify变成了一个不错的小功能

1313
00:58:27,420 --> 00:58:30,807
我们可以像这样调用任何视图。 

1314
00:58:30,807 --> 00:58:35,200
您不需要这种稍微笨重的方式

1315
00:58:35,200 --> 00:58:37,947
这对您来说应该像字体

1316
00:58:37,947 --> 00:58:42,543
一些点largeTitle，前景色颜色。 

1317
00:58:43,430 --> 00:58:47,260
匹配的卡片没有消失的事实又如何呢？ 

1318
00:58:47,260 --> 00:58:51,350
我只要做这张整张卡片

1319
00:58:51,350 --> 00:58:56,350
如果卡面朝上或尚未匹配。 

1320
00:58:58,120 --> 00:59:00,460
该卡面朝上，或者我尚未匹配， 

1321
00:59:00,460 --> 00:59:02,920
然后繁荣，我要把那张卡片放在那里。 

1322
00:59:02,920 --> 00:59:05,970
不然我只想要空格

1323
00:59:05,970 --> 00:59:08,120
这正是我们以前所拥有的。 

1324
00:59:08,120 --> 00:59:09,773
现在这给了一个错误，说

1325
00:59:09,773 --> 00:59:13,910
函数声明了不透明的返回类型，是的，某些视图， 

1326
00:59:13,910 --> 00:59:15,990
但没有return return语句。 

1327
00:59:15,990 --> 00:59:16,850
哦是的

1328
00:59:16,850 --> 00:59:19,060
这里没有return语句。 

1329
00:59:19,060 --> 00:59:22,830
我想我可以说归还可以解决这个问题， 

1330
00:59:22,830 --> 00:59:25,220
但是在其他情况下呢？ 

1331
00:59:25,220 --> 00:59:27,170
如果没有，我们有这个

1332
00:59:27,170 --> 00:59:29,210
在这种情况下，我们不返回任何东西。 

1333
00:59:29,210 --> 00:59:32,810
所以那不好，我要解决这个问题

1334
00:59:32,810 --> 00:59:35,640
以一种新颖有趣的方式， 

1335
00:59:35,640 --> 00:59:38,863
我就是要把它变成一个ViewBuilder。 

1336
00:59:39,860 --> 00:59:41,900
如果我将此功能转换为ViewBuilder， 

1337
00:59:41,900 --> 00:59:46,640
那么现在它被解释为视图列表。 

1338
00:59:46,640 --> 00:59:49,807
是的，如果要确定某些视图是进入还是退出， 

1339
00:59:49,807 --> 00:59:52,630
但这是视图列表。 

1340
00:59:52,630 --> 00:59:55,290
要么成为ZStack，要么成为View， 

1341
00:59:55,290 --> 00:59:58,750
否则将为EmptyView。 

1342
00:59:58,750 --> 01:00:00,910
看起来没有错误，就这么简单。 

1343
01:00:00,910 --> 01:00:03,525
我们有ViewBuilder。 

1344
01:00:03,525 --> 01:00:04,821
在这里运行它，让我们尝试看看。 

1345
01:00:04,821 --> 01:00:06,380
可以了

1346
01:00:06,380 --> 01:00:09,870
让我们比赛，哦，拿走了他们

1347
01:00:09,870 --> 01:00:12,303
因为这不是真的，他们就走了。 

1348
01:00:13,760 --> 01:00:15,027
现在我们可以做的另一件事

1349
01:00:15,027 --> 01:00:18,052
并确保我们的cardify确实有效， 

1350
01:00:18,052 --> 01:00:21,810
让我们尝试其他一些视图，而不是使用ZStack。 

1351
01:00:21,810 --> 01:00:23,450
像个圆圈怎么样

1352
01:00:24,380 --> 01:00:27,490
让我们继续将画布带回此处。 

1353
01:00:27,490 --> 01:00:29,253
我们可以看到这一点。 

1354
01:00:33,330 --> 01:00:34,163
是的，看那个。 

1355
01:00:34,163 --> 01:00:35,690
这是放在卡片上的圆。 

1356
01:00:35,690 --> 01:00:36,820
我们甚至可以做圆

1357
01:00:36,820 --> 01:00:39,930
上面有一点填充，对吗？ 

1358
01:00:39,930 --> 01:00:42,640
或者，也许我们将在这里放入一个胶囊。 

1359
01:00:42,640 --> 01:00:44,550
那是另一个内置的Shape Capsule。 

1360
01:00:44,550 --> 01:00:47,580
如果您想知道的话，那就是胶囊形状。 

1361
01:00:47,580 --> 01:00:51,643
我们可以放一些类似Text的东西。 

1362
01:00:52,500 --> 01:00:57,500
世界，您好，看得出来。 

1363
01:00:57,750 --> 01:01:01,570
所以cardify是通用的修饰符ViewModifier 

1364
01:01:01,570 --> 01:01:04,093
我们构建的可以修改任何View的视图。 

1365
01:01:05,620 --> 01:01:07,480
好吧，这很好

1366
01:01:07,480 --> 01:01:10,630
我们已经完成了所有ViewModifier的工作

1367
01:01:10,630 --> 01:01:13,993
因为下一场我们要讲的动画

1368
01:01:13,993 --> 01:01:16,660
当涉及到动画视图时， 

1369
01:01:16,660 --> 01:01:20,520
不是像这个Pie那样的形状，而是为Views本身设置动画， 

1370
01:01:20,520 --> 01:01:22,443
都是关于ViewModifiers的。 

1371
01:01:22,443 --> 01:01:25,490
他们真的只是在给ViewModifiers动画， 

1372
01:01:25,490 --> 01:01:28,460
我们实际上并未为View本身设置动画。 

1373
01:01:28,460 --> 01:01:30,690
我们将在下一个讲座中研究

1374
01:01:30,690 --> 01:01:32,980
并了解如何为这张卡制作动画。 

1375
01:01:32,980 --> 01:01:35,440
卡上有很多他们想要的动画。 

1376
01:01:35,440 --> 01:01:37,560
例如，他们想翻身。 

1377
01:01:37,560 --> 01:01:39,890
那是一张卡片想要的好动画， 

1378
01:01:39,890 --> 01:01:42,297
因此，我们将这张卡片说明

1379
01:01:42,297 --> 01:01:46,130
到ViewModifier，以便我们下次对其进行动画处理。 

1380
01:01:46,130 --> 01:01:48,450
今天就是这样。 

1381
01:01:48,450 --> 01:01:49,650
那我再和你谈谈。 

1382
01:01:50,530 --> 01:01:53,763
-[旁白]有关更多信息，请访问我们@ stanford.edu。 

