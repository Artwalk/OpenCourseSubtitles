1
00:00:00,425 --> 00:00:03,508
（音乐启发） 

2
00:00:04,920 --> 00:00:06,620
-[播音员]斯坦福大学。 

3
00:00:09,470 --> 00:00:12,360
-[讲师]好的，第13讲

4
00:00:12,360 --> 00:00:17,050
2020年春季的斯坦福CS193p。 

5
00:00:17,050 --> 00:00:20,150
今天，我们的主题是持久性。 

6
00:00:20,150 --> 00:00:23,900
就是说，储存生活中的东西

7
00:00:23,900 --> 00:00:27,430
在应用程序启动之间。 

8
00:00:27,430 --> 00:00:28,960
现在，我们实际上已经看到

9
00:00:28,960 --> 00:00:31,100
这些东西已经有点。 

10
00:00:31,100 --> 00:00:34,490
我们将进一步详细介绍

11
00:00:34,490 --> 00:00:37,890
最后两个，CloudKit和文件系统

12
00:00:37,890 --> 00:00:39,460
但是让我们快速回顾一下

13
00:00:39,460 --> 00:00:41,100
关于持久性的知识

14
00:00:41,100 --> 00:00:42,870
我们了解UserDefaults。 

15
00:00:42,870 --> 00:00:46,390
很简单，非常有限，只允许您存储

16
00:00:46,390 --> 00:00:47,960
这些属性列表。 

17
00:00:47,960 --> 00:00:50,820
它很小，仅存储少量数据。 

18
00:00:50,820 --> 00:00:55,420
它也是Swift之前的版本，只是一个笨拙的API。 

19
00:00:55,420 --> 00:00:56,940
但这对演示真的很好， 

20
00:00:56,940 --> 00:00:59,973
这就是为什么我们在本季度使用了那么多的原因。 

21
00:01:00,908 --> 00:01:04,600
我们也较早地了解了Codable和JSON。 

22
00:01:04,600 --> 00:01:07,490
采取自定义结构的好方法

23
00:01:07,490 --> 00:01:09,390
我们已经设计并打开它

24
00:01:09,390 --> 00:01:12,210
转换成很好的互操作格式

25
00:01:12,210 --> 00:01:14,640
要么我们会通过互联网发送， 

26
00:01:14,640 --> 00:01:18,260
也许我们会存储在磁盘上。 

27
00:01:18,260 --> 00:01:20,082
现在，对于那些关注

28
00:01:20,082 --> 00:01:22,460
我编写的Enroute代码

29
00:01:22,460 --> 00:01:24,970
从FlightAware获得数据

30
00:01:24,970 --> 00:01:27,160
会看到来自FlightAware的数据

31
00:01:27,160 --> 00:01:30,370
以JSON的形式出现，我只使用Codable 

32
00:01:30,370 --> 00:01:32,500
将其转换为本地结构。 

33
00:01:32,500 --> 00:01:34,830
这是Codable的另一种用法

34
00:01:34,830 --> 00:01:39,463
正在以JSON格式接收来自人们的数据。 

35
00:01:40,720 --> 00:01:45,560
此UIDocument是UIKit的一部分。 

36
00:01:45,560 --> 00:01:48,490
所以我们在本节课中不会真正谈论它

37
00:01:48,490 --> 00:01:49,870
因为这是一个SwiftUI类。 

38
00:01:49,870 --> 00:01:53,343
但是，如果您有EmojiArt之类的应用程序

39
00:01:53,343 --> 00:01:55,900
确实具有用户所感知的

40
00:01:55,900 --> 00:01:58,790
成为他们正在创建的文档， 

41
00:01:58,790 --> 00:02:00,650
您几乎肯定会想要使用

42
00:02:00,650 --> 00:02:03,210
此UIDocument基础结构。 

43
00:02:03,210 --> 00:02:04,600
这不会是什么

44
00:02:04,600 --> 00:02:07,142
您将为您的最终项目做。 

45
00:02:07,142 --> 00:02:10,500
不只是它是一个非常高级的API， 

46
00:02:10,500 --> 00:02:13,650
由于需要UIkit集成， 

47
00:02:13,650 --> 00:02:15,900
还有一些我们刚刚想到的概念

48
00:02:15,900 --> 00:02:18,360
没有时间掩盖底线

49
00:02:18,360 --> 00:02:20,200
但我只想提一提

50
00:02:20,200 --> 00:02:21,660
它在那里，因为当你， 

51
00:02:21,660 --> 00:02:22,760
如果你在现实世界中走出去， 

52
00:02:22,760 --> 00:02:25,130
并且您创建了具有文档的某种应用， 

53
00:02:25,130 --> 00:02:26,983
您想了解UIDocuments。 

54
00:02:28,600 --> 00:02:30,620
当然有核心数据

55
00:02:30,620 --> 00:02:32,960
功能强大，面向对象， 

56
00:02:32,960 --> 00:02:35,840
极好的SwiftUI集成

57
00:02:35,840 --> 00:02:38,650
通过FetchedResults的东西。 

58
00:02:38,650 --> 00:02:40,960
这确实是必去的地方， 

59
00:02:40,960 --> 00:02:44,144
当我们想将数据存储在iOS应用中时， 

60
00:02:44,144 --> 00:02:45,635
我们将获得核心数据。 

61
00:02:45,635 --> 00:02:47,344
对于大量数据， 

62
00:02:47,344 --> 00:02:48,177
我们要这样做。 

63
00:02:48,177 --> 00:02:49,835
我们不会将其放在UserDefaults中

64
00:02:49,835 --> 00:02:51,286
除非我们正在演示。 

65
00:02:51,286 --> 00:02:52,970
我们将使用核心数据，您明白了为什么， 

66
00:02:52,970 --> 00:02:56,673
它确实是非常强大的数据库系统。 

67
00:02:59,110 --> 00:03:03,580
我今天要谈谈CloudKit。 

68
00:03:03,580 --> 00:03:08,330
这是在iCloud中将数据存储在网络中的一种方式。 

69
00:03:08,330 --> 00:03:11,730
您会看到这样做有很多巨大的优势。 

70
00:03:11,730 --> 00:03:13,560
当您将内容投放到网络上时， 

71
00:03:13,560 --> 00:03:15,510
这意味着现在，用户将看到所有

72
00:03:15,510 --> 00:03:17,890
他们所有设备上的数据

73
00:03:17,890 --> 00:03:19,680
而不是仅仅在他们创建的设备上

74
00:03:19,680 --> 00:03:24,150
记住他们的EmojiArt主题或主题。 

75
00:03:24,150 --> 00:03:27,040
所以这是真的，真的很强大

76
00:03:27,040 --> 00:03:29,980
为了能够做到，将东西存储在网络上。 

77
00:03:29,980 --> 00:03:33,030
CloudKit具有一些不错的功能

78
00:03:33,030 --> 00:03:35,810
与您已经知道的相似

79
00:03:35,810 --> 00:03:38,460
例如，它有自己的小UserDefaults 

80
00:03:38,460 --> 00:03:42,360
类似的东西，您可以在其中存储键值对

81
00:03:42,360 --> 00:03:46,310
在该用户的所有设备上共享的网络上。 

82
00:03:46,310 --> 00:03:48,980
它也可以与Core Data一起很好地玩。 

83
00:03:48,980 --> 00:03:52,190
我知道您是否还记得我们进行新项目时， 

84
00:03:52,190 --> 00:03:54,630
然后单击那里的“使用核心数据”按钮， 

85
00:03:54,630 --> 00:03:57,983
还有一个人说：“哦，也要使用CloudKit。” 

86
00:03:57,983 --> 00:04:00,540
现在，我们将确保您的核心数据数据库

87
00:04:00,540 --> 00:04:02,720
使用CloudKit复制

88
00:04:02,720 --> 00:04:05,170
在所有用户的设备上。 

89
00:04:05,170 --> 00:04:07,220
因此，无论他们将什么放入Core Data中，他们都可以看到。 

90
00:04:07,220 --> 00:04:10,363
那是一个强大的组合。 

91
00:04:11,706 --> 00:04:13,210
而且CloudKit也有机制

92
00:04:13,210 --> 00:04:15,860
用于将文档存储在那里。 

93
00:04:15,860 --> 00:04:19,340
因此，它与UIDocument以及所有这些都集成在一起， 

94
00:04:19,340 --> 00:04:22,170
来制作文档存储，所以CloudKit的确

95
00:04:22,170 --> 00:04:25,080
iCloud总的来说，机制真的很棒

96
00:04:25,080 --> 00:04:27,050
用于将内容保存在网络上

97
00:04:27,050 --> 00:04:29,783
因此用户可以在所有设备上看到它们。 

98
00:04:30,640 --> 00:04:32,120
现在，我们将介绍基础知识

99
00:04:32,120 --> 00:04:33,660
现在可以通过幻灯片了解CloudKit。 

100
00:04:33,660 --> 00:04:36,180
我只是想给你一个什么样的感觉。 

101
00:04:36,180 --> 00:04:38,440
这是您可能想要尝试的API 

102
00:04:38,440 --> 00:04:39,980
并用于您的最终项目。 

103
00:04:39,980 --> 00:04:40,940
有点野心， 

104
00:04:40,940 --> 00:04:44,320
我要告诉你一些捷径

105
00:04:44,320 --> 00:04:46,340
只是最后一个项目的一点点

106
00:04:46,340 --> 00:04:48,380
一旦您对此进行自我介绍。 

107
00:04:48,380 --> 00:04:51,003
毕竟，这是入门课程。 

108
00:04:51,850 --> 00:04:53,347
但是我想你们当中有些人会发现， 

109
00:04:53,347 --> 00:04:56,647
“哇，我真的需要一种存储东西的方法

110
00:04:56,647 --> 00:04:59,360
“可以在所有用户的设备上使用。” 

111
00:04:59,360 --> 00:05:01,430
因此，CloudKit可能是一个不错的选择

112
00:05:01,430 --> 00:05:03,693
您的选择API。 

113
00:05:05,220 --> 00:05:06,560
然后，接下来要谈论的东西

114
00:05:06,560 --> 00:05:09,780
在CloudKit是文件系统之后

115
00:05:09,780 --> 00:05:11,590
本质上是访问文件系统中的任何内容， 

116
00:05:11,590 --> 00:05:14,150
我们通过URL和数据来做， 

117
00:05:14,150 --> 00:05:15,950
您已经了解这些结构， 

118
00:05:15,950 --> 00:05:19,030
还有一个名为FileManager的新结构。 

119
00:05:19,030 --> 00:05:20,420
我将谈论这些事情如何运作， 

120
00:05:20,420 --> 00:05:23,070
然后，我实际上将在此演示， 

121
00:05:23,070 --> 00:05:24,970
我们将在哪里制作我们的EmojiArtDocuments 

122
00:05:24,970 --> 00:05:26,853
被存储在文件系统中。 

123
00:05:28,780 --> 00:05:30,160
那么，CloudKit是什么？ 

124
00:05:30,160 --> 00:05:32,630
它是云中的数据库。 

125
00:05:32,630 --> 00:05:35,570
现在，它是一个易于使用的数据库， 

126
00:05:35,570 --> 00:05:37,580
具有基本的数据库操作， 

127
00:05:37,580 --> 00:05:39,920
不像核心数据那样功能齐全。 

128
00:05:39,920 --> 00:05:43,510
好的，这不是网络上的核心数据。 

129
00:05:43,510 --> 00:05:44,570
现在，最重要的事情之一

130
00:05:44,570 --> 00:05:46,870
了解有关做CloudKit数据库的信息

131
00:05:46,870 --> 00:05:49,130
是异步的。 

132
00:05:49,130 --> 00:05:52,550
做事的所有重要电话

133
00:05:52,550 --> 00:05:54,650
在CloudKit中是异步的。 

134
00:05:54,650 --> 00:05:56,210
您为他们提供了关闭服务， 

135
00:05:56,210 --> 00:05:58,360
它熄灭并在后台线程上执行， 

136
00:05:58,360 --> 00:06:00,570
完成后，它会回叫您关闭

137
00:06:00,570 --> 00:06:02,450
并说这是发生了什么。 

138
00:06:02,450 --> 00:06:04,990
这种编程，异步编程， 

139
00:06:04,990 --> 00:06:06,090
需要一些习惯。 

140
00:06:06,090 --> 00:06:08,487
到目前为止，您已经在本课程中看到了一点。 

141
00:06:08,487 --> 00:06:11,300
但是CloudKit是高度异步的。 

142
00:06:11,300 --> 00:06:13,070
就其本质而言，它正在淘汰

143
00:06:13,070 --> 00:06:14,450
通过网络，其中网络

144
00:06:14,450 --> 00:06:17,203
可能不可用，或者速度可能很慢，等等。 

145
00:06:18,380 --> 00:06:21,830
因此，进行演示是因为

146
00:06:21,830 --> 00:06:23,510
可以是一个很大的演示， 

147
00:06:23,510 --> 00:06:25,820
甚至比Core Data演示更大。 

148
00:06:25,820 --> 00:06:27,820
因此，本季度我将不做演示。 

149
00:06:27,820 --> 00:06:31,260
如果您想回到2015-16春季， 

150
00:06:31,260 --> 00:06:33,520
这门课程在iTunesU上。 

151
00:06:33,520 --> 00:06:35,470
您可以，我认为它仍在iTunesU上， 

152
00:06:35,470 --> 00:06:38,950
您可以观看它，并查看CloudKit演示

153
00:06:38,950 --> 00:06:40,880
我们所做的，大部分仍然适用。 

154
00:06:40,880 --> 00:06:45,070
这些，所有这些云东西都是pre-SwiftUI，甚至是pre-Swift。 

155
00:06:45,070 --> 00:06:49,180
因此，从那时起，这些东西并没有发生太大变化， 

156
00:06:49,180 --> 00:06:50,370
你会得到基本的想法

157
00:06:50,370 --> 00:06:52,170
如果你想回去看那个。 

158
00:06:53,570 --> 00:06:56,210
好的，让我们来概述一下CloudKit。 

159
00:06:56,210 --> 00:06:58,680
我只想定义一些术语

160
00:06:58,680 --> 00:07:00,050
我们在CloudKit中经常使用

161
00:07:00,050 --> 00:07:02,060
所以我们了解我们在说什么。 

162
00:07:02,060 --> 00:07:05,100
第一项是记录类型。 

163
00:07:05,100 --> 00:07:08,110
因此，记录类型就像一个类或结构。 

164
00:07:08,110 --> 00:07:11,500
本身实际上没有类或结构， 

165
00:07:11,500 --> 00:07:12,900
存储在CloudKit中。 

166
00:07:12,900 --> 00:07:14,180
这不像核心数据， 

167
00:07:14,180 --> 00:07:17,180
在本质上我们看起来像我们的对象， 

168
00:07:17,180 --> 00:07:19,150
但是我们确实有称为记录类型的东西， 

169
00:07:19,150 --> 00:07:23,030
这是数据库中的一种东西。 

170
00:07:23,030 --> 00:07:26,750
然后，“字段”一词就是我们用于vars的内容。 

171
00:07:26,750 --> 00:07:29,500
在核心数据中，我们称这些属性。 

172
00:07:29,500 --> 00:07:31,170
在CloudKit中，我们称它们为“字段”。 

173
00:07:31,170 --> 00:07:33,630
这是var，存在的事物

174
00:07:33,630 --> 00:07:37,030
在我们存储的记录类型中。 

175
00:07:37,030 --> 00:07:38,610
然后，有Record一词。 

176
00:07:38,610 --> 00:07:41,070
记录表示记录类型的实例， 

177
00:07:41,070 --> 00:07:44,160
所以这是数据库中的实际情况之一， 

178
00:07:44,160 --> 00:07:45,270
所以当然，您将要存储很多， 

179
00:07:45,270 --> 00:07:48,791
CloudKit数据库中的许多记录。 

180
00:07:48,791 --> 00:07:50,037
这就是您所有数据所在的位置， 

181
00:07:50,037 --> 00:07:53,243
并且记录包含所有字段的值。 

182
00:07:54,740 --> 00:07:56,560
有一种叫做参考的东西

183
00:07:56,560 --> 00:07:59,139
大写R，参考，CKReference。 

184
00:07:59,139 --> 00:08:01,040
您会在所有事物面前看到CK 

185
00:08:01,040 --> 00:08:02,393
我们在CloudKit中所做的。 

186
00:08:03,380 --> 00:08:06,010
这是另一个记录的指针， 

187
00:08:06,010 --> 00:08:10,490
在记录之间建立关系， 

188
00:08:10,490 --> 00:08:12,880
记录类型不完全相同， 

189
00:08:12,880 --> 00:08:14,900
或功能强大（如果您拥有核心数据） 

190
00:08:14,900 --> 00:08:17,660
它会自动保留一组对象

191
00:08:17,660 --> 00:08:19,560
另一方面，它可以保持最新状态， 

192
00:08:19,560 --> 00:08:21,280
以及所有这些业务。 

193
00:08:21,280 --> 00:08:24,330
无论如何，这不是一个完整的关系数据库。 

194
00:08:24,330 --> 00:08:26,850
因此对象之间的引用仍然有意义

195
00:08:26,850 --> 00:08:29,870
但您必须使用此CKReference来做， 

196
00:08:29,870 --> 00:08:31,540
这个对另一个对象的引用， 

197
00:08:31,540 --> 00:08:34,300
我将向您展示代码中的内容。 

198
00:08:34,300 --> 00:08:37,720
然后，有诸如数据库，区域和容器之类的术语。 

199
00:08:37,720 --> 00:08:39,530
容器是数据库的集合。 

200
00:08:39,530 --> 00:08:41,800
数据库中可以包含区域。 

201
00:08:41,800 --> 00:08:44,380
这就是我们划分空间的方式

202
00:08:44,380 --> 00:08:47,797
要在iCloud中存储数据， 

203
00:08:47,797 --> 00:08:50,560
我将简短地讨论一下。 

204
00:08:50,560 --> 00:08:53,550
我将主要讨论顶级数据库

205
00:08:53,550 --> 00:08:55,090
我们使用的，您将在其中使用的一个

206
00:08:55,090 --> 00:08:57,140
三个数据库，您可以看到这一点。 

207
00:08:58,430 --> 00:09:00,070
然后，有一个称为查询的东西。 

208
00:09:00,070 --> 00:09:02,210
查询是数据库搜索。 

209
00:09:02,210 --> 00:09:03,450
这就是我们要进入数据库的地方， 

210
00:09:03,450 --> 00:09:05,170
并尝试找到一些记录， 

211
00:09:05,170 --> 00:09:07,560
一些记录类型的一些实例

212
00:09:07,560 --> 00:09:09,340
符合某些条件。 

213
00:09:09,340 --> 00:09:10,273
这会让您看起来很熟悉

214
00:09:10,273 --> 00:09:11,840
当我们做到这一点。 

215
00:09:11,840 --> 00:09:14,120
最后，有一个订阅。 

216
00:09:14,120 --> 00:09:15,757
所以这就像一个常设查询， 

217
00:09:15,757 --> 00:09:17,830
我们谈到了常规查询

218
00:09:17,830 --> 00:09:21,812
在Core Data中，我们有SwiftUI FetchRequests 

219
00:09:21,812 --> 00:09:23,000
返回这些FetchedResults， 

220
00:09:23,000 --> 00:09:24,240
那是一个长期的查询， 

221
00:09:24,240 --> 00:09:26,110
它总是在更新它们。 

222
00:09:26,110 --> 00:09:28,130
好吧，这也是一个常规查询

223
00:09:28,130 --> 00:09:30,090
但这要复杂得多

224
00:09:30,090 --> 00:09:32,390
在网络上进行常规查询， 

225
00:09:32,390 --> 00:09:34,440
因为你在谈论找出

226
00:09:34,440 --> 00:09:36,660
当iCloud发生变化时， 

227
00:09:36,660 --> 00:09:38,950
然后通知您的应用，哇， 

228
00:09:38,950 --> 00:09:42,560
您设置为始终查询的该查询， 

229
00:09:42,560 --> 00:09:44,210
它发生了变化，但是在网络上却发生了变化， 

230
00:09:44,210 --> 00:09:46,790
您会收到通知，以及您的应用程序得到通知的方式

231
00:09:46,790 --> 00:09:49,160
通过所谓的推送通知。 

232
00:09:49,160 --> 00:09:51,870
这些都是手机的小事

233
00:09:51,870 --> 00:09:53,740
并告诉您某些事情已经发生。 

234
00:09:53,740 --> 00:09:56,300
许多应用程序都具有这些推送通知。 

235
00:09:56,300 --> 00:09:57,750
这就是它的工作原理。 

236
00:09:57,750 --> 00:09:59,760
现在，这超出了本课程的范围

237
00:09:59,760 --> 00:10:01,560
谈论推送通知如何工作， 

238
00:10:01,560 --> 00:10:03,540
以及您对他们的反应。 

239
00:10:03,540 --> 00:10:05,070
这不是我期望的

240
00:10:05,070 --> 00:10:06,630
在您的最终项目中要做的是

241
00:10:06,630 --> 00:10:08,810
订阅，常规查询， 

242
00:10:08,810 --> 00:10:11,710
并处理推送通知。 

243
00:10:11,710 --> 00:10:13,310
您有三个星期的时间来做项目。 

244
00:10:13,310 --> 00:10:14,740
我不希望你花整整一个星期， 

245
00:10:14,740 --> 00:10:16,500
尝试这样做，所以我会

246
00:10:16,500 --> 00:10:18,340
如果您要为最终项目使用CloudKit， 

247
00:10:18,340 --> 00:10:21,113
我不会处理订阅。 

248
00:10:22,020 --> 00:10:24,170
关于使用CloudKit的一件事

249
00:10:24,170 --> 00:10:26,220
是否需要一点点启用。 

250
00:10:26,220 --> 00:10:28,810
我不知道您只是导入Core Data， 

251
00:10:28,810 --> 00:10:30,110
我可以开始使用Core Data 

252
00:10:30,110 --> 00:10:31,530
对于核心数据而言，这是正确的， 

253
00:10:31,530 --> 00:10:34,290
但是对于CloudKit，您实际上需要将其打开。 

254
00:10:34,290 --> 00:10:37,310
如果您转到“功能”标签

255
00:10:37,310 --> 00:10:38,960
在项目设置中，您将看到

256
00:10:38,960 --> 00:10:41,610
有很多功能，例如Apple Pay， 

257
00:10:41,610 --> 00:10:44,380
和游戏中心之类的东西， 

258
00:10:44,380 --> 00:10:45,550
你必须打开

259
00:10:45,550 --> 00:10:47,640
那是因为这些东西

260
00:10:47,640 --> 00:10:50,280
正在访问世界各地的服务器， 

261
00:10:50,280 --> 00:10:53,340
所以他们需要一点授权

262
00:10:53,340 --> 00:10:56,480
和授权，我们称之为这些权利

263
00:10:56,480 --> 00:10:58,770
使您的应用能够执行这些操作。 

264
00:10:58,770 --> 00:10:59,870
但这很容易做到。 

265
00:10:59,870 --> 00:11:02,410
您只需进入此处的“功能”标签， 

266
00:11:02,410 --> 00:11:04,930
并且我们看到iCloud，当您到达那里时它会显示“关闭”。 

267
00:11:04,930 --> 00:11:06,970
只需将其单击为“开”，即可

268
00:11:06,970 --> 00:11:08,610
在这里获得更多用户界面， 

269
00:11:08,610 --> 00:11:10,300
你会看到三种不同

270
00:11:10,300 --> 00:11:12,160
CloudKit中的服务。 

271
00:11:12,160 --> 00:11:14,160
其中的第一个是键值存储， 

272
00:11:14,160 --> 00:11:16,040
那是UserDefaults之类的东西

273
00:11:16,040 --> 00:11:17,080
我跟你说过

274
00:11:17,080 --> 00:11:18,750
然后，iCloud文档就在那里。 

275
00:11:18,750 --> 00:11:20,953
那是用于将文档存储在iCloud中。 

276
00:11:20,953 --> 00:11:22,240
我是告诉你的。 

277
00:11:22,240 --> 00:11:24,400
我们要谈论的是CloudKit， 

278
00:11:24,400 --> 00:11:26,380
是这个数据库，对， 

279
00:11:26,380 --> 00:11:29,090
数据库，记录和字段，以及所有其他内容。 

280
00:11:29,090 --> 00:11:30,440
所以你要打开它， 

281
00:11:30,440 --> 00:11:33,630
然后，您将转到下面的该按钮， 

282
00:11:33,630 --> 00:11:36,960
非常重要的按钮CloudKit仪表板

283
00:11:36,960 --> 00:11:38,680
这个CloudKit仪表板会让你

284
00:11:38,680 --> 00:11:41,500
管理您在CloudKit中的所有活动， 

285
00:11:41,500 --> 00:11:43,500
您所有的记录类型，所有记录， 

286
00:11:43,500 --> 00:11:45,610
查看您所有的数据查询， 

287
00:11:45,610 --> 00:11:49,510
一切都将通过此方法进行管理。 

288
00:11:49,510 --> 00:11:50,780
让我们点击这个按钮， 

289
00:11:50,780 --> 00:11:52,860
或模拟点击此按钮， 

290
00:11:52,860 --> 00:11:54,650
看看我们得到了什么。 

291
00:11:54,650 --> 00:11:55,980
这就是你得到的， 

292
00:11:55,980 --> 00:11:59,130
您访问互联网上的某个网站， 

293
00:11:59,130 --> 00:12:01,270
它可能看起来不完全

294
00:12:01,270 --> 00:12:04,740
就像这样，它说创建于2016年5月15日， 

295
00:12:04,740 --> 00:12:07,450
所以这有点旧，但还是一样的主意

296
00:12:07,450 --> 00:12:09,380
那里发生了什么事， 

297
00:12:09,380 --> 00:12:12,750
这是您正在查看所有记录

298
00:12:12,750 --> 00:12:14,380
和记录类型， 

299
00:12:14,380 --> 00:12:15,795
甚至在标记它们。 

300
00:12:15,795 --> 00:12:16,628
你在右边看到

301
00:12:16,628 --> 00:12:18,690
这是查询，搜索，排序，查询，搜索。 

302
00:12:18,690 --> 00:12:20,210
您正在标记哪些东西

303
00:12:20,210 --> 00:12:21,840
您想查询， 

304
00:12:21,840 --> 00:12:25,470
以及您想对哪些内容进行排序等等。 

305
00:12:25,470 --> 00:12:27,620
您可以添加记录类型和字段， 

306
00:12:27,620 --> 00:12:28,760
还有所有这些东西， 

307
00:12:28,760 --> 00:12:30,580
虽然你通常不这样做

308
00:12:30,580 --> 00:12:33,010
因为关于CloudKit的事情非常有趣

309
00:12:33,010 --> 00:12:36,300
在添加记录类型和字段时， 

310
00:12:36,300 --> 00:12:39,370
它具有动态模式创建。 

311
00:12:39,370 --> 00:12:41,450
所以您有点看那个仪表板， 

312
00:12:41,450 --> 00:12:43,507
你会想：“哦，那有点像地图

313
00:12:43,507 --> 00:12:46,680
“我们拥有核心数据”，这确实是。 

314
00:12:46,680 --> 00:12:48,520
它具有许多相同的功能。 

315
00:12:48,520 --> 00:12:51,110
但是，在Core Data中，您必须进行映射。 

316
00:12:51,110 --> 00:12:53,740
地图就是您的应用程序知道的方式

317
00:12:53,740 --> 00:12:56,350
为您创建哪些类和变量

318
00:12:56,350 --> 00:12:59,960
因此您可以访问数据，在CloudKit中， 

319
00:12:59,960 --> 00:13:01,260
您不必做地图。 

320
00:13:01,260 --> 00:13:03,230
它可以即时建立地图。 

321
00:13:03,230 --> 00:13:06,260
如果您使用特定名称创建记录类型， 

322
00:13:06,260 --> 00:13:09,240
它只是创造了您第一次做这件事， 

323
00:13:09,240 --> 00:13:10,190
繁荣，它创造了它。 

324
00:13:10,190 --> 00:13:13,180
现在，它仅进行动​​态创建

325
00:13:13,180 --> 00:13:15,190
记录类型，字段和内容， 

326
00:13:15,190 --> 00:13:16,770
在开发中

327
00:13:16,770 --> 00:13:18,700
最终，当您的应用发布时， 

328
00:13:18,700 --> 00:13:19,950
当您去App Store时， 

329
00:13:21,330 --> 00:13:22,870
在iTunes Connect上进行设置

330
00:13:22,870 --> 00:13:25,010
让您的应用程序出现在App Store中， 

331
00:13:25,010 --> 00:13:25,917
您将单击一个按钮说， 

332
00:13:25,917 --> 00:13:27,367
“好吧，我要转向生产

333
00:13:27,367 --> 00:13:29,380
“我的CloudKit上的模式”，然后， 

334
00:13:29,380 --> 00:13:31,690
它不会让您进行动态模式创建， 

335
00:13:31,690 --> 00:13:32,600
当然可以

336
00:13:32,600 --> 00:13:35,390
您进行动态模式创建

337
00:13:35,390 --> 00:13:37,530
在开发过程中

338
00:13:37,530 --> 00:13:40,330
到“记录类型”，“字段”以及所需的内容， 

339
00:13:40,330 --> 00:13:43,040
然后，您开始直播。 

340
00:13:43,040 --> 00:13:45,720
让我们简要地看一下代码的外观

341
00:13:45,720 --> 00:13:48,530
例如在编写CloudKit应用程序时。 

342
00:13:48,530 --> 00:13:51,763
您需要做的第一件事是将事物放入数据库。 

343
00:13:51,763 --> 00:13:53,730
有点像ManagedObjectContext 

344
00:13:53,730 --> 00:13:55,380
但这并不是真的，因为

345
00:13:55,380 --> 00:13:58,040
更轻量的概念，这个数据库。 

346
00:13:58,040 --> 00:13:59,530
但是最重​​要的是

347
00:13:59,530 --> 00:14:01,360
您在选择之间是是否想要

348
00:14:01,360 --> 00:14:03,930
一个公共数据库，一个共享数据库， 

349
00:14:03,930 --> 00:14:05,920
或私有数据库。 

350
00:14:05,920 --> 00:14:09,100
因此，私有数据库是普通的iCloud数据库。 

351
00:14:09,100 --> 00:14:11,610
这只是您放置资料的数据库

352
00:14:11,610 --> 00:14:14,900
那是用户的，用户看到了

353
00:14:14,900 --> 00:14:17,990
在他们所有的设备上，这就是普通的数据库。 

354
00:14:17,990 --> 00:14:21,570
共享和公开都是有趣的事情。 

355
00:14:21,570 --> 00:14:24,600
公共的，如果你的话，如果用户放东西

356
00:14:24,600 --> 00:14:26,840
在自己的公共数据库中， 

357
00:14:26,840 --> 00:14:30,760
然后，其他用户（如果他们知道该人的iCloud） 

358
00:14:31,950 --> 00:14:34,630
电子邮件地址等等

359
00:14:34,630 --> 00:14:37,390
他们的应用，然后去看看，看看那些数据。 

360
00:14:37,390 --> 00:14:40,000
因此，这实际上是一种公开发布的数据。 

361
00:14:40,000 --> 00:14:43,090
您可以认为它就像您的网站一样， 

362
00:14:43,090 --> 00:14:45,510
向人们提供这些东西， 

363
00:14:45,510 --> 00:14:47,050
他们可以看到他们想要的一切。 

364
00:14:47,050 --> 00:14:48,927
在iCloud上很少这样做， 

365
00:14:48,927 --> 00:14:49,940
但你可以做到。 

366
00:14:49,940 --> 00:14:51,340
本质上是一种使用iCloud的方法

367
00:14:51,340 --> 00:14:53,800
向世界发布信息。 

368
00:14:53,800 --> 00:14:56,630
然后，他们被共享了，这是邀请- 

369
00:14:56,630 --> 00:14:59,117
仅访问您的私有数据库。 

370
00:14:59,117 --> 00:15:01,410
而这种工作方式就是你最终

371
00:15:01,410 --> 00:15:04,110
向人们发送电子邮件。 

372
00:15:04,110 --> 00:15:05,600
在该电子邮件中，是一个链接， 

373
00:15:05,600 --> 00:15:06,840
当他们点击它时， 

374
00:15:06,840 --> 00:15:10,050
他们的小iCloud共享数据库

375
00:15:10,050 --> 00:15:14,110
可以看到一部分的视图，而不是整个视图， 

376
00:15:14,110 --> 00:15:16,600
私有云别人的数据库。 

377
00:15:16,600 --> 00:15:18,380
这样，你们两个可以共享数据， 

378
00:15:18,380 --> 00:15:20,680
双方都可以添加对象， 

379
00:15:20,680 --> 00:15:23,080
或任何其他取决于所授予的权限。 

380
00:15:23,080 --> 00:15:24,880
添加对象并查看彼此的对象， 

381
00:15:24,880 --> 00:15:26,580
再次，这只是一个小部分， 

382
00:15:26,580 --> 00:15:29,920
所以数据库的一小部分， 

383
00:15:29,920 --> 00:15:32,873
但这是一种分享事物的好方法。 

384
00:15:34,180 --> 00:15:35,420
因此，一旦有了数据库， 

385
00:15:35,420 --> 00:15:36,920
然后，您可以开始创建记录， 

386
00:15:36,920 --> 00:15:38,440
这是您的操作方式。 

387
00:15:38,440 --> 00:15:39,800
要创建记录，您只需说

388
00:15:39,800 --> 00:15:42,280
CKRecord和记录的名称， 

389
00:15:42,280 --> 00:15:43,900
再一次，你不必走了

390
00:15:43,900 --> 00:15:45,070
首先到仪表板。 

391
00:15:45,070 --> 00:15:47,150
您可以这样做，如果这是第一次

392
00:15:47,150 --> 00:15:50,120
曾经创建过CKRecord“ Tweet”， 

393
00:15:50,120 --> 00:15:53,070
然后是Tweets或Record Type Tweet， 

394
00:15:53,070 --> 00:15:55,840
只是将为您在数据库中创建。 

395
00:15:55,840 --> 00:15:57,940
然后，要设置字段的值， 

396
00:15:57,940 --> 00:16:00,370
就像访问字典一样

397
00:16:00,370 --> 00:16:04,040
您说在推文中用方括号括起Field的名称， 

398
00:16:04,040 --> 00:16:06,230
等于值，这就是

399
00:16:06,230 --> 00:16:10,700
在“推文记录类型”中再次创建该文本字段， 

400
00:16:10,700 --> 00:16:12,000
如果以前不存在， 

401
00:16:12,000 --> 00:16:14,280
并将其值设置为该值。 

402
00:16:14,280 --> 00:16:15,680
在这里，我将创建另一个。 

403
00:16:15,680 --> 00:16:17,930
这是Twitter用户的CKRecord。 

404
00:16:17,930 --> 00:16:19,380
这是一个不同的记录类型， 

405
00:16:19,380 --> 00:16:20,750
一种不同的东西。 

406
00:16:20,750 --> 00:16:22,320
我要回推文

407
00:16:22,320 --> 00:16:25,260
并设置其“高音扬声器”字段

408
00:16:25,260 --> 00:16:28,230
成为高音扬声器的参考。 

409
00:16:28,230 --> 00:16:30,263
所以看这里，我不得不说CKReference 

410
00:16:30,263 --> 00:16:33,563
以及我创建的该TwitterUser的记录。 

411
00:16:34,660 --> 00:16:36,100
与Core Data稍有不同。 

412
00:16:36,100 --> 00:16:37,230
您不能直接设置它， 

413
00:16:37,230 --> 00:16:38,860
你必须做一个CKReference的事情， 

414
00:16:38,860 --> 00:16:40,250
然后，注意该动作

415
00:16:40,250 --> 00:16:42,710
基本上说

416
00:16:42,710 --> 00:16:44,890
确定删除推文后会发生什么。 

417
00:16:44,890 --> 00:16:46,650
TwitterUser是否被删除？ 

418
00:16:46,650 --> 00:16:49,263
诸如此类的事情，那种关系。 

419
00:16:50,180 --> 00:16:52,550
这就是我们建立记录类型的方式， 

420
00:16:52,550 --> 00:16:54,980
以及我们的记录及其领域， 

421
00:16:54,980 --> 00:16:57,630
以及对其他对象的引用。 

422
00:16:57,630 --> 00:16:59,240
一旦完成， 

423
00:16:59,240 --> 00:17:00,710
然后，我们要保存它。 

424
00:17:00,710 --> 00:17:02,810
这就是我们要打入网络的地方。 

425
00:17:02,810 --> 00:17:05,390
因此，这是一个异步函数。 

426
00:17:05,390 --> 00:17:07,580
只需调用保存，我们就给它录音， 

427
00:17:07,580 --> 00:17:10,060
您想要保存的CKRecord， 

428
00:17:10,060 --> 00:17:14,830
它将在后台在网络上关闭。 

429
00:17:14,830 --> 00:17:16,880
如果网络中断，可能需要很长时间

430
00:17:16,880 --> 00:17:19,430
否则如果网络最终崩溃，可能会失败， 

431
00:17:19,430 --> 00:17:21,160
但是如果它最终能够通过， 

432
00:17:21,160 --> 00:17:22,840
并写下您想要的信息， 

433
00:17:22,840 --> 00:17:25,278
此推文记录，然后将其称为

434
00:17:25,278 --> 00:17:27,827
您将其退还给您。 

435
00:17:27,827 --> 00:17:31,490
您给它的闭包有两个参数。 

436
00:17:31,490 --> 00:17:34,943
一个是它保存的记录，如果成功， 

437
00:17:34,943 --> 00:17:38,060
另一个是生成的错误

438
00:17:38,060 --> 00:17:39,510
如果不是这样。 

439
00:17:39,510 --> 00:17:41,040
所以这又是Swift之前的版本

440
00:17:41,040 --> 00:17:42,760
在Swift中，我们可能在这里有一个枚举

441
00:17:42,760 --> 00:17:44,300
成功与失败

442
00:17:44,300 --> 00:17:47,430
以及成功记录的相关价值， 

443
00:17:47,430 --> 00:17:49,090
以及错误的相关值

444
00:17:49,090 --> 00:17:49,923
但是我们没有

445
00:17:49,923 --> 00:17:51,133
全部都是Swift之前的。 

446
00:17:52,070 --> 00:17:54,013
所以这两件事中的一项或多项， 

447
00:17:54,013 --> 00:17:56,240
savedRecord或错误，可以为nil。 

448
00:17:56,240 --> 00:17:58,840
错误为零，然后哇，成功， 

449
00:17:58,840 --> 00:18:01,010
你保存了那个东西和savedRecord 

450
00:18:01,010 --> 00:18:03,710
将是您刚刚保存的CKRecord。 

451
00:18:03,710 --> 00:18:05,260
但是如果错误不是nil， 

452
00:18:05,260 --> 00:18:07,480
然后，您必须开始查看错误代码， 

453
00:18:07,480 --> 00:18:09,100
找出问题所在。 

454
00:18:09,100 --> 00:18:12,370
这是网络，因此很多事情都会出错。 

455
00:18:12,370 --> 00:18:16,490
最后有29个不同的CKErrorCodes。 

456
00:18:16,490 --> 00:18:18,040
现在，您不必检查每一个

457
00:18:18,040 --> 00:18:20,270
因为其中有些在保存期间无法发生， 

458
00:18:20,270 --> 00:18:22,840
在其他事情上会发生一些错误。 

459
00:18:22,840 --> 00:18:25,340
但是，如果您真的要这样做， 

460
00:18:25,340 --> 00:18:27,160
并发布您的应用，您需要检查

461
00:18:27,160 --> 00:18:29,960
所有可能在这里合理发生的事情， 

462
00:18:29,960 --> 00:18:31,780
并决定您的应用程序将要做什么

463
00:18:31,780 --> 00:18:35,400
因为您无法保存此记录。 

464
00:18:35,400 --> 00:18:38,490
如果您正在做最后的项目，那么这里又是一个地方。 

465
00:18:38,490 --> 00:18:40,420
我不会反对你

466
00:18:40,420 --> 00:18:42,510
如果您不检查所有这些错误代码。 

467
00:18:42,510 --> 00:18:44,960
也许在一处检查错误代码

468
00:18:44,960 --> 00:18:46,840
只是让我明白

469
00:18:46,840 --> 00:18:48,750
您必须检查错误代码， 

470
00:18:48,750 --> 00:18:50,700
但是否则不要检查它们。 

471
00:18:50,700 --> 00:18:52,490
然后是您的应用程序，您的最终项目

472
00:18:52,490 --> 00:18:54,450
基本上只会惨败

473
00:18:54,450 --> 00:18:57,393
在恶劣的网络条件下，没关系，我们可以。 

474
00:18:58,240 --> 00:18:59,730
这个入门班，您只是在尝试

475
00:18:59,730 --> 00:19:02,870
向您介绍API，例如CloudKit。 

476
00:19:02,870 --> 00:19:06,120
您不是要成为这一切的主人

477
00:19:06,120 --> 00:19:07,580
到本季度末。 

478
00:19:07,580 --> 00:19:10,000
这大大缩小了范围

479
00:19:10,000 --> 00:19:10,833
做CloudKit。 

480
00:19:10,833 --> 00:19:12,720
许多CloudKit正在处理这些错误， 

481
00:19:12,720 --> 00:19:14,610
以及您所做的基础设施

482
00:19:14,610 --> 00:19:17,380
当您无法将内容写到iCloud时。 

483
00:19:17,380 --> 00:19:19,830
因此希望将范围缩小到某种程度

484
00:19:19,830 --> 00:19:21,840
你可以现实地做到这一点

485
00:19:21,840 --> 00:19:23,933
作为最终项目API。 

486
00:19:25,600 --> 00:19:27,390
现在，关于查询记录， 

487
00:19:27,390 --> 00:19:28,850
搜索记录？ 

488
00:19:28,850 --> 00:19:31,310
这应该是您真正熟悉的外观。 

489
00:19:31,310 --> 00:19:32,450
是的，它是NSPredicate， 

490
00:19:32,450 --> 00:19:35,410
与Core Data完全相同的NSPredicate。 

491
00:19:35,410 --> 00:19:36,920
现在它具有相同的对象。 

492
00:19:36,920 --> 00:19:40,240
您不能在那里使用完全相同的格式， 

493
00:19:40,240 --> 00:19:43,210
因为CloudKit数据库不完全

494
00:19:43,210 --> 00:19:45,320
与核心数据一样强大。 

495
00:19:45,320 --> 00:19:46,900
因此，核心数据可以在那里做一些事情

496
00:19:46,900 --> 00:19:50,170
CloudKit不能不说等于等基本东西， 

497
00:19:50,170 --> 00:19:53,580
该文本是否包含此搜索字符串， 

498
00:19:53,580 --> 00:19:55,760
例如，这是一条推文

499
00:19:55,760 --> 00:19:57,860
我们正在这里搜索

500
00:19:57,860 --> 00:20:00,780
这是完全合理的。 

501
00:20:00,780 --> 00:20:02,360
因此，您可以创建所需的谓词， 

502
00:20:02,360 --> 00:20:04,500
然后，您创建一个称为CKQuery的内容， 

503
00:20:04,500 --> 00:20:05,920
就是记录类型

504
00:20:05,920 --> 00:20:08,040
您试图找到的

505
00:20:08,040 --> 00:20:10,050
您本质上在寻找， 

506
00:20:10,050 --> 00:20:12,227
和那个谓词。 

507
00:20:12,227 --> 00:20:15,210
同样，听起来像FetchRequest 

508
00:20:15,210 --> 00:20:19,420
在核心数据中，相似但不完全相同， 

509
00:20:19,420 --> 00:20:21,281
但是你明白了。 

510
00:20:21,281 --> 00:20:22,270
然后，要执行查询， 

511
00:20:22,270 --> 00:20:24,550
当然，您将必须进入网络， 

512
00:20:24,550 --> 00:20:27,900
这就是执行此功能的地方。 

513
00:20:27,900 --> 00:20:29,110
您给它想要的查询， 

514
00:20:29,110 --> 00:20:30,740
然后关闭它， 

515
00:20:30,740 --> 00:20:32,050
那个闭包将被称为

516
00:20:32,050 --> 00:20:34,570
当这件事失败或成功时。 

517
00:20:34,570 --> 00:20:36,390
该关闭也有两个论点。 

518
00:20:36,390 --> 00:20:39,290
一个是记录的可选数组

519
00:20:39,290 --> 00:20:42,070
通过搜索找到它， 

520
00:20:42,070 --> 00:20:43,950
或错误。 

521
00:20:43,950 --> 00:20:45,550
再说一次，如果这是一个错误， 

522
00:20:45,550 --> 00:20:46,520
你必须处理事实

523
00:20:46,520 --> 00:20:48,750
您正在寻找的东西

524
00:20:48,750 --> 00:20:51,493
甚至都没有找到他们。 

525
00:20:52,621 --> 00:20:54,890
如果不是，那么记录将不会为零， 

526
00:20:54,890 --> 00:20:55,723
它将是CKRecord的数组， 

527
00:20:55,723 --> 00:20:58,237
你去了，那里有你的CKRecords 

528
00:20:58,237 --> 00:20:59,630
您正在寻找的。 

529
00:20:59,630 --> 00:21:02,180
因此搜索非常简单

530
00:21:02,180 --> 00:21:04,100
在CloudKit中也是如此。 

531
00:21:04,100 --> 00:21:05,960
这些常规查询只是， 

532
00:21:05,960 --> 00:21:07,580
您选择其中一个CK查询， 

533
00:21:07,580 --> 00:21:09,547
并从本质上将其传达给数据库， 

534
00:21:09,547 --> 00:21:12,130
然后，它在服务器端进行查询， 

535
00:21:12,130 --> 00:21:14,450
然后，每当创建新事物时， 

536
00:21:14,450 --> 00:21:17,380
会更改该查询的结果， 

537
00:21:17,380 --> 00:21:20,030
它已发送到此推送通知。 

538
00:21:20,030 --> 00:21:21,810
如果您想尝试并签出

539
00:21:21,810 --> 00:21:23,820
我如何处理推送通知， 

540
00:21:23,820 --> 00:21:28,340
我该怎么办，请随时尝试。 

541
00:21:28,340 --> 00:21:30,010
再说一次，我觉得太多了

542
00:21:30,010 --> 00:21:32,000
在这里完成您的最终项目。 

543
00:21:32,000 --> 00:21:34,350
您可以看一下UserNotifications框架， 

544
00:21:34,350 --> 00:21:36,000
不只是推送通知， 

545
00:21:36,000 --> 00:21:37,820
而且还可以进行本地通知。 

546
00:21:37,820 --> 00:21:39,290
您可能想检查一下。 

547
00:21:39,290 --> 00:21:41,010
那些很有趣，那就是

548
00:21:41,010 --> 00:21:43,050
您可以设置一些小日历活动

549
00:21:43,050 --> 00:21:46,530
几乎在某个时间发生的事情， 

550
00:21:46,530 --> 00:21:49,390
当您的应用想要提醒用户某些内容时， 

551
00:21:49,390 --> 00:21:51,840
或及时地做某事。 

552
00:21:53,720 --> 00:21:55,020
好的，CloudKit就这样。 

553
00:21:55,020 --> 00:21:56,810
那是CloudKit的介绍。 

554
00:21:56,810 --> 00:21:59,350
让我们来谈谈文件系统， 

555
00:21:59,350 --> 00:22:01,980
iOS设备，我不知道你们是否都知道

556
00:22:01,980 --> 00:22:05,090
但它们本质上是Unix OS 

557
00:22:05,090 --> 00:22:06,190
在他们的心脏， 

558
00:22:06,190 --> 00:22:08,580
他们那里有一个Unix文件系统， 

559
00:22:08,580 --> 00:22:10,360
类似于Unix的文件系统。 

560
00:22:10,360 --> 00:22:11,660
它以斜线开始， 

561
00:22:11,660 --> 00:22:13,740
就像您所有的Unix文件系统一样， 

562
00:22:13,740 --> 00:22:15,510
但是当然，它具有保护措施

563
00:22:15,510 --> 00:22:18,800
而且您看不到或写大部分

564
00:22:18,800 --> 00:22:20,570
那里的Unix文件系统。 

565
00:22:20,570 --> 00:22:22,910
在那里，您可以看到并写入

566
00:22:22,910 --> 00:22:25,180
被称为您的沙箱。 

567
00:22:25,180 --> 00:22:27,870
而且您的沙箱完全隔离了您

568
00:22:27,870 --> 00:22:28,950
来自世界其他地方。 

569
00:22:28,950 --> 00:22:31,440
您的应用看不到其他应用沙箱， 

570
00:22:31,440 --> 00:22:33,160
你看不到沙箱外面

571
00:22:33,160 --> 00:22:34,730
修改系统，当然， 

572
00:22:34,730 --> 00:22:36,117
并以任何方式破坏它， 

573
00:22:36,117 --> 00:22:39,330
这确实是一个好主意，沙盒。 

574
00:22:39,330 --> 00:22:42,180
我希望我们可以在Windows和Mac上使用它， 

575
00:22:42,180 --> 00:22:44,103
和正常的操作系统。 

576
00:22:45,330 --> 00:22:47,440
显然，这对设备很有意义， 

577
00:22:47,440 --> 00:22:49,610
您要在哪里安装和卸载这些应用程序

578
00:22:49,610 --> 00:22:51,850
他们每个人都有自己的沙箱。 

579
00:22:51,850 --> 00:22:53,920
现在，为什么我们要使用此沙箱？ 

580
00:22:53,920 --> 00:22:55,170
这里的三个主要原因。 

581
00:22:55,170 --> 00:22:57,730
一是安全，你不想要任何人

582
00:22:57,730 --> 00:23:00,380
进入沙盒并损坏您的应用

583
00:23:00,380 --> 00:23:02,300
以某种方式影响其数据

584
00:23:02,300 --> 00:23:03,900
或做坏事。 

585
00:23:03,900 --> 00:23:06,250
显然，您的应用程序还有隐私权， 

586
00:23:06,250 --> 00:23:07,890
正在从用户那里收集数据， 

587
00:23:07,890 --> 00:23:09,420
而且你不想要其他应用

588
00:23:09,420 --> 00:23:11,657
才能看到该数据是什么。 

589
00:23:11,657 --> 00:23:15,530
真正被低估但功能强大的部分是清理。 

590
00:23:15,530 --> 00:23:18,330
如果有人从您的设备删除您的应用， 

591
00:23:18,330 --> 00:23:20,570
您想要该应用程序曾经创建的所有内容

592
00:23:20,570 --> 00:23:23,230
或感动消失。 

593
00:23:23,230 --> 00:23:25,760
这就是删除应用程序时发生的情况。 

594
00:23:25,760 --> 00:23:28,140
沙箱已完全删除， 

595
00:23:28,140 --> 00:23:29,960
因此，这个人曾经创造的一切。 

596
00:23:29,960 --> 00:23:33,030
现在，沙箱中有目录， 

597
00:23:33,030 --> 00:23:34,590
备份到iCloud， 

598
00:23:34,590 --> 00:23:36,520
当用户启用iCloud备份时。 

599
00:23:36,520 --> 00:23:38,057
因此，如果有人删除了一个应用，他们说， 

600
00:23:38,057 --> 00:23:40,910
“哦，不，我的文件在那儿，” 

601
00:23:40,910 --> 00:23:43,620
他们可以回去拿他们。 

602
00:23:43,620 --> 00:23:45,710
顺便说一句，当涉及到存储文件时， 

603
00:23:45,710 --> 00:23:47,990
很多时候，我们希望将文档存储在iCloud中。 

604
00:23:47,990 --> 00:23:51,080
这样，如果我们从设备上删除了一个应用， 

605
00:23:51,080 --> 00:23:53,270
它仍然会在我的其他设备上。 

606
00:23:53,270 --> 00:23:54,630
如果我重新安装了该应用， 

607
00:23:54,630 --> 00:23:56,655
我会从iCloud看到它们。 

608
00:23:56,655 --> 00:23:57,580
这就是为什么这是一个好主意的原因

609
00:23:57,580 --> 00:23:59,667
将我们的文档存储在iCloud中。 

610
00:24:01,297 --> 00:24:03,730
好吧，这个沙箱中有什么？ 

611
00:24:03,730 --> 00:24:05,380
好吧，这是一堆目录， 

612
00:24:05,380 --> 00:24:08,960
特殊目录，一种特殊命名的目录。 

613
00:24:08,960 --> 00:24:11,560
其中之一是应用程序目录。 

614
00:24:11,560 --> 00:24:12,740
这是您的可执行文件所在的位置

615
00:24:12,740 --> 00:24:15,320
和您的JPEG，图像或其他任何内容

616
00:24:15,320 --> 00:24:18,750
您将其拖入Xcode以使您的应用正常工作， 

617
00:24:18,750 --> 00:24:20,990
那些人住在那儿，只能在那儿读。 

618
00:24:20,990 --> 00:24:23,800
不，您不能更改您的应用程序， 

619
00:24:23,800 --> 00:24:25,110
向其中添加图片或其他内容， 

620
00:24:25,110 --> 00:24:27,713
您必须在其他地方这样做。 

621
00:24:28,840 --> 00:24:30,040
另一个非常重要的目录

622
00:24:30,040 --> 00:24:32,140
是Documents目录。 

623
00:24:32,140 --> 00:24:33,520
这是您存储什么的地方

624
00:24:33,520 --> 00:24:35,840
用户将其视为文档。 

625
00:24:35,840 --> 00:24:37,760
例如，您的EmojiArtDocuments 

626
00:24:37,760 --> 00:24:39,110
肯定会存储在这里。 

627
00:24:39,110 --> 00:24:40,380
如果您没有将它们存储在iCloud中， 

628
00:24:40,380 --> 00:24:41,840
你一定会把它们存放在这里

629
00:24:41,840 --> 00:24:44,420
但是像表情符号调色板

630
00:24:44,420 --> 00:24:46,460
甚至您也可以记住主题

631
00:24:46,460 --> 00:24:47,757
您可能不会在这里存储。 

632
00:24:47,757 --> 00:24:51,330
用户不喜欢将它们视为文档。 

633
00:24:51,330 --> 00:24:53,030
虽然，那些东西将被存储

634
00:24:53,030 --> 00:24:54,910
在“应用程序支持”目录中， 

635
00:24:54,910 --> 00:24:56,930
那是另一个目录。 

636
00:24:56,930 --> 00:25:00,800
得到iCloud的支持，它是永久的， 

637
00:25:00,800 --> 00:25:03,980
但是用户看不到它们在那里的文档， 

638
00:25:03,980 --> 00:25:06,190
用户正在创建的数据类型

639
00:25:06,190 --> 00:25:08,090
但不是真正面向文档的

640
00:25:08,090 --> 00:25:08,923
细微的区别

641
00:25:08,923 --> 00:25:11,500
并没有太大关系

642
00:25:11,500 --> 00:25:13,020
除非您使用该怎么做

643
00:25:13,020 --> 00:25:15,750
UIDocument内容，您正在使用UIDocument 

644
00:25:15,750 --> 00:25:17,470
我之前提到的那你肯定

645
00:25:17,470 --> 00:25:19,320
想要那些文件，并且只想要那些文件

646
00:25:19,320 --> 00:25:20,410
进入文档结构。 

647
00:25:20,410 --> 00:25:22,430
您不想将它们放入“应用程序”中

648
00:25:22,430 --> 00:25:24,560
您也不想放置应用程序支持

649
00:25:24,560 --> 00:25:25,810
文档结构中的内容

650
00:25:25,810 --> 00:25:29,390
并使用户混淆其中的内容。 

651
00:25:29,390 --> 00:25:31,180
还有一个Caches目录。 

652
00:25:31,180 --> 00:25:32,650
这是临时存储区

653
00:25:32,650 --> 00:25:34,210
所以这是没有得到的存储

654
00:25:34,210 --> 00:25:37,910
备份到iCloud，如果您删除了沙箱， 

655
00:25:37,910 --> 00:25:38,770
它永远消失了。 

656
00:25:38,770 --> 00:25:40,050
所以这是你可以做的

657
00:25:40,050 --> 00:25:42,730
就像再次轻松地从互联网上获得一样， 

658
00:25:42,730 --> 00:25:45,000
您只是在本地缓存的图像

659
00:25:45,000 --> 00:25:46,500
以获得良好的性能。 

660
00:25:46,500 --> 00:25:50,230
但是如果您不得不放弃Caches目录， 

661
00:25:50,230 --> 00:25:51,861
您可以，并且您的应用仍然可以运行

662
00:25:51,861 --> 00:25:53,500
因为它会重新下载

663
00:25:53,500 --> 00:25:57,050
该Caches目录中需要的任何内容。 

664
00:25:57,050 --> 00:25:59,870
如果iOS的磁盘开始变满， 

665
00:25:59,870 --> 00:26:02,120
iOS可能会开始四处搜寻， 

666
00:26:02,120 --> 00:26:04,530
寻找缓存目录和沙箱

667
00:26:04,530 --> 00:26:06,660
真的很大，它可以爆炸

668
00:26:06,660 --> 00:26:08,790
也可以腾出空间

669
00:26:08,790 --> 00:26:10,890
很少发生，大多数人的iOS设备

670
00:26:10,890 --> 00:26:14,020
没有获得完整的磁盘，但是可能会发生。 

671
00:26:14,020 --> 00:26:15,400
还有其他目录， 

672
00:26:15,400 --> 00:26:18,390
您可以在文档中查找。 

673
00:26:18,390 --> 00:26:22,330
让我们来谈谈我们如何发现

674
00:26:22,330 --> 00:26:26,060
这些目录在我们的应用程序中是什么， 

675
00:26:26,060 --> 00:26:28,370
我们将使用一些东西来做到这一点

676
00:26:28,370 --> 00:26:30,013
称为FileManager。 

677
00:26:30,013 --> 00:26:33,090
FileManager是一个对象，一个结构， 

678
00:26:33,090 --> 00:26:35,400
顾名思义，它可以让您， 

679
00:26:35,400 --> 00:26:37,090
管理文件系统中的文件， 

680
00:26:37,090 --> 00:26:40,370
包括找出这些特殊目录在哪里。 

681
00:26:40,370 --> 00:26:43,140
现在，有两种不同的方法可以执行此操作。 

682
00:26:43,140 --> 00:26:46,530
我在这里给您一点复杂的内容。 

683
00:26:46,530 --> 00:26:48,060
有一个更简单的

684
00:26:48,060 --> 00:26:50,180
称为URL。 

685
00:26:50,180 --> 00:26:51,520
这个称为URL。 

686
00:26:51,520 --> 00:26:54,640
我将在演示中使用较简单的一个

687
00:26:54,640 --> 00:26:56,660
这样您就可以同时看到它们。 

688
00:26:56,660 --> 00:26:59,680
那么这个FileManager，我们如何使用FileManager？ 

689
00:26:59,680 --> 00:27:03,010
大多数时候，如果我们在处理主队列， 

690
00:27:03,010 --> 00:27:05,080
我们是大多数文件操作

691
00:27:05,080 --> 00:27:07,820
除非我们正在编写一个巨大的文件，否则很快就会发生。 

692
00:27:07,820 --> 00:27:09,300
因此，我们可以在主队列上执行它们。 

693
00:27:09,300 --> 00:27:10,133
他们不会阻止

694
00:27:10,133 --> 00:27:12,130
就像网络操作一样。 

695
00:27:12,130 --> 00:27:15,360
我们通常使用FileManager的默认设置， 

696
00:27:15,360 --> 00:27:18,090
FileManager.default，它是共享的。 

697
00:27:18,090 --> 00:27:19,900
现在，我们可能不想使用

698
00:27:19,900 --> 00:27:21,430
主队列中的那个。 

699
00:27:21,430 --> 00:27:22,490
在那里，您想要创建自己的

700
00:27:22,490 --> 00:27:24,700
自己的FileManager实例， 

701
00:27:24,700 --> 00:27:26,920
同样，这是一个高级话题。 

702
00:27:26,920 --> 00:27:28,340
所以我们只是要使用共享的

703
00:27:28,340 --> 00:27:30,830
在主队列和功能

704
00:27:30,830 --> 00:27:34,740
我们将在此shared.FileManager.default上调用

705
00:27:34,740 --> 00:27:38,327
这个东西称为domainMask中目录的url， 

706
00:27:38,327 --> 00:27:40,730
并且还有其他适合和创造的东西。 

707
00:27:40,730 --> 00:27:44,140
那么，此URL的四个参数是什么？ 

708
00:27:44,140 --> 00:27:45,360
第一个是

709
00:27:45,360 --> 00:27:47,150
您想要的特殊目录？ 

710
00:27:47,150 --> 00:27:51,180
因此，这是一个枚举FileManager.SearchPathDirectory。 

711
00:27:51,180 --> 00:27:52,420
去看文档， 

712
00:27:52,420 --> 00:27:54,590
你会看到，我认为有12个

713
00:27:54,590 --> 00:27:56,730
或15个不同的特殊目录

714
00:27:56,730 --> 00:27:59,290
在沙箱中，例如“文档”目录， 

715
00:27:59,290 --> 00:28:00,540
应用程序，支持，缓存， 

716
00:28:00,540 --> 00:28:01,580
我们谈论的所有事情， 

717
00:28:01,580 --> 00:28:04,720
每个变量都有一个枚举值。 

718
00:28:04,720 --> 00:28:07,640
第二个参数是在iOS中的domainMask中， 

719
00:28:07,640 --> 00:28:10,170
这始终是.userDomainMask， 

720
00:28:10,170 --> 00:28:13,810
因为在Mac上，我们可能拥有网络域， 

721
00:28:13,810 --> 00:28:16,399
我们正在寻找的共享库。 

722
00:28:16,399 --> 00:28:18,380
但这是在iOS设备上，它是个人设备， 

723
00:28:18,380 --> 00:28:20,680
因此它始终是userDomainMask。 

724
00:28:20,680 --> 00:28:22,463
不用担心适当的创建。 

725
00:28:24,610 --> 00:28:26,890
如果您要写入“文档”目录

726
00:28:26,890 --> 00:28:28,430
例如，这是第一次

727
00:28:28,430 --> 00:28:29,410
您将要创建它， 

728
00:28:29,410 --> 00:28:32,100
所以你可能会创造真实的， 

729
00:28:32,100 --> 00:28:33,423
当您这样做时。 

730
00:28:34,590 --> 00:28:36,127
那会回报你的， 

731
00:28:36,127 --> 00:28:38,710
这些特殊目录的URL。 

732
00:28:38,710 --> 00:28:40,810
现在，您拥有指向特殊目录的URL 

733
00:28:40,810 --> 00:28:42,710
在沙盒中，您可以开始创建

734
00:28:42,710 --> 00:28:43,993
或在其中寻找文件。 

735
00:28:43,993 --> 00:28:45,650
现在，我们该怎么做？ 

736
00:28:45,650 --> 00:28:48,860
我们使用URL中的方法来做到这一点。 

737
00:28:48,860 --> 00:28:50,740
所以我们得到了这个基本URL， 

738
00:28:50,740 --> 00:28:52,570
我们将在URL中使用方法

739
00:28:52,570 --> 00:28:54,452
像appendingPathComponent一样， 

740
00:28:54,452 --> 00:28:58,070
并附加PathExtension以构建路径

741
00:28:58,070 --> 00:29:00,730
到我们正在寻找的任何文件

742
00:29:00,730 --> 00:29:05,210
在这些特殊目录中，就这么简单。 

743
00:29:05,210 --> 00:29:07,727
您还可以询问网址，例如

744
00:29:07,727 --> 00:29:09,817
“这是文件的网址吗？ 

745
00:29:09,817 --> 00:29:13,300
“相对于网络事物或网页的URL？” 

746
00:29:13,300 --> 00:29:14,847
您可以询问网址， 

747
00:29:14,847 --> 00:29:18,130
“为我提供此文件中某些资源的价值，” 

748
00:29:18,130 --> 00:29:20,090
就像它的创建日期一样

749
00:29:20,090 --> 00:29:22,130
或者它是否是目录， 

750
00:29:22,130 --> 00:29:24,460
或此文件的大小。 

751
00:29:24,460 --> 00:29:27,150
同样，此API也是pre-Swift， 

752
00:29:27,150 --> 00:29:28,940
不是那么奇怪，除了

753
00:29:28,940 --> 00:29:31,450
你给它什么价值的钥匙

754
00:29:31,450 --> 00:29:32,750
您想要这个URL， 

755
00:29:32,750 --> 00:29:34,860
例如其创建日期或文件大小等

756
00:29:34,860 --> 00:29:36,780
它会给你一本字典， 

757
00:29:36,780 --> 00:29:38,810
你给它的那些钥匙

758
00:29:38,810 --> 00:29:41,160
是键，值在任何。 

759
00:29:41,160 --> 00:29:43,430
原因值必须存在于Any中

760
00:29:43,430 --> 00:29:44,930
因为它可能是一个日期， 

761
00:29:44,930 --> 00:29:47,970
可能是文件大小，可能是整数， 

762
00:29:47,970 --> 00:29:49,790
这样的事情。 

763
00:29:49,790 --> 00:29:51,700
这就是您查找URL的方式。 

764
00:29:51,700 --> 00:29:54,360
因此，URL是互动的重要组成部分

765
00:29:54,360 --> 00:29:57,113
文件系统，就像FileManager一样。 

766
00:29:58,089 --> 00:30:00,730
另一个重要的结构是数据。 

767
00:30:00,730 --> 00:30:02,180
数据是我们实际的方式

768
00:30:02,180 --> 00:30:03,957
将数据放到文件系统上， 

769
00:30:03,957 --> 00:30:06,860
而且您已经知道如何读取数据

770
00:30:06,860 --> 00:30:09,160
从互联网使用Data的contentsOf URL。 

771
00:30:11,339 --> 00:30:13,070
您可以使用文件网址执行相同的操作， 

772
00:30:13,070 --> 00:30:15,700
这样便可以从磁盘读取文件， 

773
00:30:15,700 --> 00:30:17,880
文件系统中没有数据。 

774
00:30:17,880 --> 00:30:19,270
哦，写作也是如此。 

775
00:30:19,270 --> 00:30:20,503
有一个写（到URL：URL，...）， 

776
00:30:21,409 --> 00:30:22,857
然后您将其发送到数据中

777
00:30:22,857 --> 00:30:26,930
并将其自身的内容放入该URL， 

778
00:30:26,930 --> 00:30:28,400
在文件系统中。 

779
00:30:28,400 --> 00:30:31,160
两者都几乎没有读写选项。 

780
00:30:31,160 --> 00:30:34,450
写作的是唯一的非常

781
00:30:34,450 --> 00:30:36,600
有趣。例如，原子地写。 

782
00:30:36,600 --> 00:30:38,430
因此，如果您要编写一个巨大的文件， 

783
00:30:38,430 --> 00:30:40,980
假设磁盘填满了一半， 

784
00:30:40,980 --> 00:30:43,670
该文件现在将不会处于损坏状态

785
00:30:43,670 --> 00:30:45,810
写到一半时，它将恢复原状

786
00:30:45,810 --> 00:30:48,553
到尝试执行此写操作之前的状态。 

787
00:30:48,553 --> 00:30:50,120
所以这是一个原子交易。 

788
00:30:50,120 --> 00:30:52,150
本质上，它写入一个临时文件。 

789
00:30:52,150 --> 00:30:54,280
如果成功的话，它将移动它

790
00:30:54,280 --> 00:30:57,023
输入您要写入的网址。 

791
00:30:59,120 --> 00:31:01,660
FileManager还可以帮助您

792
00:31:01,660 --> 00:31:03,810
了解文件系统中正在发生的事情， 

793
00:31:03,810 --> 00:31:06,240
类似于URL在做什么。 

794
00:31:06,240 --> 00:31:07,780
它也可以做类似的事情， 

795
00:31:07,780 --> 00:31:10,630
向我显示该目录中的所有文件， 

796
00:31:10,630 --> 00:31:13,990
或将此文件从该URL移至该URL， 

797
00:31:13,990 --> 00:31:17,350
或复制此文件，请复制此URL。 

798
00:31:17,350 --> 00:31:20,130
我要展示，而不是浏览幻灯片， 

799
00:31:20,130 --> 00:31:21,240
展示给你所有的东西

800
00:31:21,240 --> 00:31:22,460
首先，FileManager可以做到的

801
00:31:22,460 --> 00:31:24,540
您可以看一下文档， 

802
00:31:24,540 --> 00:31:26,130
但我实际上要告诉你

803
00:31:26,130 --> 00:31:27,860
在这里的演示中。 

804
00:31:27,860 --> 00:31:30,170
我想说明一下FileManager的一件事， 

805
00:31:30,170 --> 00:31:32,260
它有一个叫做委托的东西。 

806
00:31:32,260 --> 00:31:34,610
委托只是一个变种。 

807
00:31:34,610 --> 00:31:37,800
那个var是您设置的对象， 

808
00:31:37,800 --> 00:31:39,800
并且该对象将被通知

809
00:31:39,800 --> 00:31:41,450
当某些事情发生时

810
00:31:41,450 --> 00:31:42,520
在FileManager中。 

811
00:31:42,520 --> 00:31:44,780
随着FileManager的移动，文件移动， 

812
00:31:44,780 --> 00:31:49,490
尝试做事，它将与它的代表交谈， 

813
00:31:49,490 --> 00:31:50,540
并请你做点事。 

814
00:31:50,540 --> 00:31:54,140
现在，这是UIKit的基础委托对象。 

815
00:31:54,140 --> 00:31:55,910
在UIKit中到处都有代表， 

816
00:31:55,910 --> 00:31:58,243
我们将在下一讲中看到

817
00:31:58,243 --> 00:31:59,490
因为我们将要开始谈论UIKit 

818
00:31:59,490 --> 00:32:02,130
与SwiftUI集成。 

819
00:32:02,130 --> 00:32:04,070
但是，如果您正在查看FileManager， 

820
00:32:04,070 --> 00:32:05,807
您可能会想，“这是什么委托对象？ 

821
00:32:05,807 --> 00:32:07,260
“以前从未见过。” 

822
00:32:07,260 --> 00:32:09,890
而且我认为您不需要FileManager的委托

823
00:32:09,890 --> 00:32:12,200
在FileManager中完成大多数工作。 

824
00:32:12,200 --> 00:32:14,400
我们将进行演示， 

825
00:32:14,400 --> 00:32:16,330
甚至从未设置过代表， 

826
00:32:16,330 --> 00:32:17,867
但我只是不想让你感到惊讶， 

827
00:32:17,867 --> 00:32:19,370
“哦，这是代表什么？” 

828
00:32:19,370 --> 00:32:20,430
本质上只是一个对象

829
00:32:20,430 --> 00:32:22,130
当事情发生时得到通知

830
00:32:22,130 --> 00:32:24,023
在FileManager操作期间。 

831
00:32:25,160 --> 00:32:27,180
好的，所以一个演示值得一千个单词。 

832
00:32:27,180 --> 00:32:29,270
就像我们常说的，成千上万的单词

833
00:32:29,270 --> 00:32:31,230
因此，让我们检查一下。 

834
00:32:31,230 --> 00:32:32,690
今天我们要在演示中做什么

835
00:32:32,690 --> 00:32:36,950
将我们的EmojiArtDocuments存储到文件系统中

836
00:32:36,950 --> 00:32:38,990
而不是愚蠢的UserDefaults， 

837
00:32:38,990 --> 00:32:40,400
那是演示软件。 

838
00:32:40,400 --> 00:32:42,580
在文件系统中存储更有意义。 

839
00:32:42,580 --> 00:32:45,640
将它们存储在iCloud中比这更有意义。 

840
00:32:45,640 --> 00:32:47,714
但是我们会把它们存放在那里

841
00:32:47,714 --> 00:32:48,830
这将能够向我们展示

842
00:32:48,830 --> 00:32:50,393
访问文件系统的所有部分

843
00:32:50,393 --> 00:32:52,710
因为我们必须获得一个URL 

844
00:32:52,710 --> 00:32:54,610
到我们的Documents目录， 

845
00:32:54,610 --> 00:32:57,130
所以我们将使用URL来做到这一点， 

846
00:32:57,130 --> 00:32:59,150
和FileManager来做到这一点。 

847
00:32:59,150 --> 00:33:01,170
然后，我们要写出数据，当然， 

848
00:33:01,170 --> 00:33:03,040
使用数据对象。 

849
00:33:03,040 --> 00:33:06,770
然后，我还将使我的DocumentChooser正常工作， 

850
00:33:06,770 --> 00:33:09,850
因此删除文档，添加新文档， 

851
00:33:09,850 --> 00:33:11,820
将不得不工作。 

852
00:33:11,820 --> 00:33:13,790
因此，我们必须使用FileManager 

853
00:33:13,790 --> 00:33:15,325
做一些文件系统操作

854
00:33:15,325 --> 00:33:17,863
使这些东西也能正常工作。 

855
00:33:18,830 --> 00:33:21,393
因此，现在让我们深入研究该演示。 

856
00:33:23,530 --> 00:33:26,670
因此，此演示的目标是使

857
00:33:26,670 --> 00:33:31,660
EmojiArtDocumentStore停止自行存储， 

858
00:33:31,660 --> 00:33:33,823
就在这里，还有EmojiArtDocuments， 

859
00:33:35,770 --> 00:33:38,450
在这里，在UserDefaults中。 

860
00:33:38,450 --> 00:33:40,470
相反，我们希望他们存储

861
00:33:40,470 --> 00:33:44,073
在作为iOS基础的Unix文件系统中。 

862
00:33:44,980 --> 00:33:46,790
因此，实际上我们必须修复两件事。 

863
00:33:46,790 --> 00:33:49,330
我们必须获取要存储在文件系统中的文档， 

864
00:33:49,330 --> 00:33:51,600
而且我们必须获得DocumentStore 

865
00:33:51,600 --> 00:33:53,120
在文件系统中寻找

866
00:33:53,120 --> 00:33:55,520
而不是查看UserDefaults。 

867
00:33:55,520 --> 00:33:57,500
让我们从这里开始文档， 

868
00:33:57,500 --> 00:34:00,770
我要将此功能添加到商店中

869
00:34:00,770 --> 00:34:03,380
以及要在文件系统中工作的文档， 

870
00:34:03,380 --> 00:34:06,370
并保留此UserDefaults功能， 

871
00:34:06,370 --> 00:34:08,470
万一有人想要代替。 

872
00:34:08,470 --> 00:34:11,313
没有理由破坏我们以前拥有的东西。 

873
00:34:12,600 --> 00:34:15,230
所以在这里创建一个EmojiArtDocument 

874
00:34:15,230 --> 00:34:17,730
将自身存储在文件系统中

875
00:34:17,730 --> 00:34:19,150
只是为了我

876
00:34:19,150 --> 00:34:21,360
一个不同的初始化问题。 

877
00:34:21,360 --> 00:34:23,617
因此，此init需要一个UUID， 

878
00:34:23,617 --> 00:34:26,650
并将其默认存储。 

879
00:34:26,650 --> 00:34:31,160
我要使用我的init，而不要使用URL。 

880
00:34:31,160 --> 00:34:32,980
这就是URL 

881
00:34:32,980 --> 00:34:35,130
用于阅读文档

882
00:34:35,130 --> 00:34:36,800
从文件系统开始， 

883
00:34:36,800 --> 00:34:38,480
然后，还要保存文档

884
00:34:38,480 --> 00:34:40,110
每当我们想要自动保存时， 

885
00:34:40,110 --> 00:34:42,760
我们将为此使用该URL。 

886
00:34:42,760 --> 00:34:45,090
我们仍然需要设置我们的ID 

887
00:34:45,090 --> 00:34:48,600
成为一些UUID，因为此ID 

888
00:34:48,600 --> 00:34:50,950
是我们可识别的一部分，对吧？ 

889
00:34:50,950 --> 00:34:52,860
因此，我们仍然需要这样做。 

890
00:34:52,860 --> 00:34:55,310
但是在这里，我们还将抓住

891
00:34:55,310 --> 00:35:00,033
保留此网址并将其放入一个小变量中。 

892
00:35:01,000 --> 00:35:04,180
我们将使用此URL加载此内容

893
00:35:04,180 --> 00:35:06,120
并自动保存，让我们开始吧

894
00:35:06,120 --> 00:35:08,270
加载它。 

895
00:35:08,270 --> 00:35:09,730
实际上，这很简单。 

896
00:35:09,730 --> 00:35:14,730
我们已经知道如何从URL加载EmojiArt， 

897
00:35:14,990 --> 00:35:17,217
因为我们知道如何从URL获取数据， 

898
00:35:17,217 --> 00:35:20,380
而且我们知道如何从Data中加载EmojiArt。 

899
00:35:20,380 --> 00:35:22,937
所以我们在这里做表情符号艺术吧

900
00:35:22,937 --> 00:35:24,810
我们将传递一些JSON， 

901
00:35:24,810 --> 00:35:29,810
试图获取此URL的内容

902
00:35:31,080 --> 00:35:33,230
从文件系统中，如果我们不能这样做， 

903
00:35:33,230 --> 00:35:36,150
顺便说一句，让我们做一个空白的EmojiArt， 

904
00:35:36,150 --> 00:35:38,400
因为也许他们给了我们网址

905
00:35:38,400 --> 00:35:39,770
他们希望我们保存到

906
00:35:39,770 --> 00:35:42,690
但是目前没有这样的文件， 

907
00:35:42,690 --> 00:35:44,440
因此，我们将为他们创建一个空白文件。 

908
00:35:44,440 --> 00:35:47,150
所以数据内容相同

909
00:35:47,150 --> 00:35:49,370
当我们获取时使用的

910
00:35:49,370 --> 00:35:50,670
互联网上的东西

911
00:35:50,670 --> 00:35:53,783
我们现在将它与文件URL一起使用。 

912
00:35:55,160 --> 00:35:57,700
哦，我们还是想获取背景

913
00:35:57,700 --> 00:36:02,390
无论从何而来的图像数据。 

914
00:36:02,390 --> 00:36:05,520
而且我们仍然想在这里做autosaveCancellable。 

915
00:36:05,520 --> 00:36:06,480
但是，当然，我们不会

916
00:36:06,480 --> 00:36:08,750
自动保存到UserDefaults中。 

917
00:36:08,750 --> 00:36:10,800
这次，我们要进行autosaveCancellable 

918
00:36:12,430 --> 00:36:14,623
同步我们的EmojiArt。 

919
00:36:16,860 --> 00:36:19,270
对于此自动保存，我们希望

920
00:36:19,270 --> 00:36:23,770
保存我们的EmojiArt，有一些功能可以做到这一点， 

921
00:36:23,770 --> 00:36:27,793
私人功能保存很少，需要保存EmojiArt。 

922
00:36:29,430 --> 00:36:32,610
而所有这些要做的就是

923
00:36:32,610 --> 00:36:35,810
与我们在此处使用此数据所做的操作相反。 

924
00:36:35,810 --> 00:36:39,730
我们要说的是，如果我们的网址不是nil， 

925
00:36:39,730 --> 00:36:42,550
换句话说，我们就是EmojiArtDocument 

926
00:36:42,550 --> 00:36:45,000
保存到文件系统， 

927
00:36:45,000 --> 00:36:49,340
然后，我们将尝试使用EmojiArt的json 

928
00:36:49,340 --> 00:36:52,733
将其自身写入我们的网址。 

929
00:36:53,780 --> 00:36:55,953
一个班轮在这里写自己。 

930
00:36:57,050 --> 00:36:59,720
现在，我想做的另一件事

931
00:36:59,720 --> 00:37:02,703
在这里，每次更改时我都会自动保存。 

932
00:37:03,620 --> 00:37:06,270
如果有人在我身上更改此网址怎么办？ 

933
00:37:06,270 --> 00:37:09,466
因此，我的文档正在写到某个URL， 

934
00:37:09,466 --> 00:37:12,010
自动保存，然后他们更改此URL。 

935
00:37:12,010 --> 00:37:13,750
好吧，下次我自动保存时， 

936
00:37:13,750 --> 00:37:15,930
没关系，它将写入此URL。 

937
00:37:15,930 --> 00:37:18,560
但是我要比这更直接。 

938
00:37:18,560 --> 00:37:21,090
我要在这里放一个didSet 

939
00:37:21,090 --> 00:37:25,740
确实保存了我自己的EmojiArt， 

940
00:37:25,740 --> 00:37:29,390
只是为了立即保存到新的URL 

941
00:37:29,390 --> 00:37:31,410
如果有人把它放在我身上。 

942
00:37:31,410 --> 00:37:35,050
可能并不关键，但我认为

943
00:37:35,050 --> 00:37:38,050
如果有人在我的文档上设置了新的网址， 

944
00:37:38,050 --> 00:37:39,820
他们可能想要漂亮

945
00:37:39,820 --> 00:37:41,260
快把那东西写出来， 

946
00:37:41,260 --> 00:37:42,650
他们不想依赖用户

947
00:37:42,650 --> 00:37:44,830
必须添加表情符号或其他内容

948
00:37:44,830 --> 00:37:46,400
导致自动保存完成。 

949
00:37:48,011 --> 00:37:50,440
就是这样，实际上就是所有需要的

950
00:37:50,440 --> 00:37:52,770
让我们的EmojiArt自己写

951
00:37:52,770 --> 00:37:55,373
到一个URL，非常简单。 

952
00:37:56,320 --> 00:37:59,540
现在，这整个难题的另一部分

953
00:37:59,540 --> 00:38:01,020
回到我们的商店在这里， 

954
00:38:01,020 --> 00:38:04,020
因为现在，我们的商店保留了名称

955
00:38:04,020 --> 00:38:06,640
这里的一个小词典中的所有文档， 

956
00:38:06,640 --> 00:38:09,657
这是从UserDefaults读取和写入的， 

957
00:38:09,657 --> 00:38:14,390
并且我们希望这些名称来自文件系统。 

958
00:38:14,390 --> 00:38:18,490
所以我们想调查某个地方的目录的URL， 

959
00:38:18,490 --> 00:38:20,137
查看其中的所有文件， 

960
00:38:20,137 --> 00:38:23,140
并将其用作所有文档的名称

961
00:38:23,140 --> 00:38:24,640
在那里。 

962
00:38:24,640 --> 00:38:26,360
所以这也是我们可以做的

963
00:38:26,360 --> 00:38:30,000
在不破坏我们现有的init名称的情况下， 

964
00:38:30,000 --> 00:38:32,710
它的去向，并在UserDefaults中查找。 

965
00:38:32,710 --> 00:38:34,750
为此，我们可以进行一个新的初始化。 

966
00:38:34,750 --> 00:38:38,660
这个初始化将要建立一个目录， 

967
00:38:38,660 --> 00:38:41,110
这只是一个URL。 

968
00:38:41,110 --> 00:38:42,950
我们将在此目录中查找

969
00:38:42,950 --> 00:38:44,600
并加载我们的documentNames， 

970
00:38:44,600 --> 00:38:47,943
任何文件，以及我们在此处找到的任何文件。 

971
00:38:49,340 --> 00:38:50,840
现在，我们叫什么名字？ 

972
00:38:50,840 --> 00:38:52,970
您记得我们的商店在这里有一个名字， 

973
00:38:52,970 --> 00:38:55,070
名称的初始位置，以便我们提供名称， 

974
00:38:55,070 --> 00:38:56,840
这是商店本身的名称， 

975
00:38:56,840 --> 00:38:58,380
不是任何文件的名称， 

976
00:38:58,380 --> 00:39:00,260
只是商店本身的名称。 

977
00:39:00,260 --> 00:39:02,770
我们也可以在这里作为论点

978
00:39:02,770 --> 00:39:05,350
或其他参数名称，但很有趣， 

979
00:39:05,350 --> 00:39:07,520
我要在这里设置我们的名字

980
00:39:07,520 --> 00:39:12,053
等于我们目录的lastPathComponent。 

981
00:39:12,960 --> 00:39:14,880
现在，这可能不是很好

982
00:39:14,880 --> 00:39:17,530
因为也许这是一个内部目录

983
00:39:17,530 --> 00:39:18,520
存储我们的文档。 

984
00:39:18,520 --> 00:39:19,920
所以我要最终做到这一点

985
00:39:19,920 --> 00:39:21,880
是我们的Documents目录。 

986
00:39:21,880 --> 00:39:22,783
所以这看起来会很好

987
00:39:22,783 --> 00:39:25,270
因为我认为这叫做文档， 

988
00:39:25,270 --> 00:39:28,070
但我主要是想这样做给你看

989
00:39:28,070 --> 00:39:30,940
抓住最后一个组件的样子

990
00:39:30,940 --> 00:39:34,390
并将其放在我们将在用户界面中看到的内容中

991
00:39:34,390 --> 00:39:36,240
但是，实际上，可能想要另一个

992
00:39:36,240 --> 00:39:37,723
名称在那里。 

993
00:39:38,830 --> 00:39:41,040
因此，我们将进入该目录。 

994
00:39:41,040 --> 00:39:45,890
假设self.directory等于该目录， 

995
00:39:45,890 --> 00:39:49,823
把它放到一个私有的var目录中， 

996
00:39:50,780 --> 00:39:51,973
这是一个URL。 

997
00:39:53,140 --> 00:39:54,720
所以这个URL和这个目录

998
00:39:54,720 --> 00:39:57,730
指向我们所有文件的存储位置。 

999
00:39:57,730 --> 00:40:01,780
我们显然要创建此DocumentStore 

1000
00:40:01,780 --> 00:40:06,310
可能与我们在沙箱中的“文档”目录有关。 

1001
00:40:06,310 --> 00:40:07,950
但是，我们会得到一点。 

1002
00:40:07,950 --> 00:40:09,440
现在，我们要建立这个DocumentStore 

1003
00:40:09,440 --> 00:40:12,540
因此它可以与任何位置的任何目录一起使用。 

1004
00:40:12,540 --> 00:40:15,070
您将想要的目录传递给它的init， 

1005
00:40:15,070 --> 00:40:16,900
只是要打开它， 

1006
00:40:16,900 --> 00:40:19,113
并查看其中的所有文件。 

1007
00:40:19,980 --> 00:40:22,240
现在，如何打开它， 

1008
00:40:22,240 --> 00:40:23,690
并查看其中的所有文件？ 

1009
00:40:23,690 --> 00:40:26,230
我们如何找出目录中有哪些文件？ 

1010
00:40:26,230 --> 00:40:29,077
好吧，我们将使用FileManager的东西， 

1011
00:40:29,077 --> 00:40:31,610
它有一个非常酷的小功能。 

1012
00:40:31,610 --> 00:40:33,770
我要叫这个文件

1013
00:40:33,770 --> 00:40:38,500
让文档等于FileManager.default， 

1014
00:40:38,500 --> 00:40:40,000
那是共享的。 

1015
00:40:40,000 --> 00:40:43,020
给我contentsOfDirectory。 

1016
00:40:43,020 --> 00:40:44,700
您可以看到这里有几个。 

1017
00:40:44,700 --> 00:40:47,600
我想要这个目录atPath 

1018
00:40:47,600 --> 00:40:51,660
我目录的路径，directory.path。 

1019
00:40:51,660 --> 00:40:56,430
实际上，这里的路径是一个URL方法或var， 

1020
00:40:56,430 --> 00:41:00,770
并且此var以字符串形式返回此URL。 

1021
00:41:00,770 --> 00:41:03,010
这就是FileManager的很多事情

1022
00:41:03,010 --> 00:41:04,840
把这些路径当作字符串， 

1023
00:41:04,840 --> 00:41:07,875
其中一些采用网址，但有些可以采用字符串。 

1024
00:41:07,875 --> 00:41:09,490
这个碰巧很方便

1025
00:41:09,490 --> 00:41:12,623
因为这里只需要一个很好的论点。 

1026
00:41:13,683 --> 00:41:14,750
现在，您可以看到我们有一个错误， 

1027
00:41:14,750 --> 00:41:17,420
呼叫可以抛出，但未标记为try。 

1028
00:41:17,420 --> 00:41:21,280
所以我可以说尝试？这里， 

1029
00:41:21,280 --> 00:41:25,210
但我实际上要在这里做

1030
00:41:25,210 --> 00:41:28,540
因为我要你看看

1031
00:41:28,540 --> 00:41:31,730
每隔一段时间，以便您了解发生了什么。 

1032
00:41:31,730 --> 00:41:33,530
否则，我会让你离开这堂课， 

1033
00:41:33,530 --> 00:41:35,790
而且您会一直尝试吗？， 

1034
00:41:35,790 --> 00:41:37,430
而且你不会考虑这个事实

1035
00:41:37,430 --> 00:41:40,070
我们可以尝试不带问号的情况， 

1036
00:41:40,070 --> 00:41:41,733
并捕获错误。 

1037
00:41:42,760 --> 00:41:44,010
我还要进行另一个演示， 

1038
00:41:44,010 --> 00:41:45,330
我们将在这里再次进行。 

1039
00:41:45,330 --> 00:41:46,393
现在，我可以暂时

1040
00:41:46,393 --> 00:41:49,030
我可能会打印出此错误， 

1041
00:41:49,030 --> 00:41:54,030
“ EmojiArtDocumentStore无法从目录创建商店” 

1042
00:41:56,430 --> 00:41:58,720
让我们打印出目录。 

1043
00:41:58,720 --> 00:42:00,460
在这里尝试过

1044
00:42:00,460 --> 00:42:03,360
我们甚至会打印出错误的localizedDescription。 

1045
00:42:05,920 --> 00:42:07,750
例如，我们可能想要

1046
00:42:07,750 --> 00:42:11,050
使其成为失败的初始化器， 

1047
00:42:11,050 --> 00:42:14,050
然后在这里返回nil 

1048
00:42:14,050 --> 00:42:16,650
因此，这是一种错误处理方式。 

1049
00:42:16,650 --> 00:42:18,700
您真的很想思考

1050
00:42:18,700 --> 00:42:20,410
你的策略是什么

1051
00:42:20,410 --> 00:42:22,050
您是否要通知用户， 

1052
00:42:22,050 --> 00:42:24,000
你会尝试恢复吗？ 

1053
00:42:24,000 --> 00:42:25,870
我有点想恢复

1054
00:42:25,870 --> 00:42:27,690
尽可能地，但出于同样的原因， 

1055
00:42:27,690 --> 00:42:29,470
您不想误导您的用户

1056
00:42:29,470 --> 00:42:31,140
以某种方式思考

1057
00:42:31,140 --> 00:42:33,090
他们以为是可行的， 

1058
00:42:33,090 --> 00:42:35,143
无效，反之亦然。 

1059
00:42:36,280 --> 00:42:37,660
好吧，所以我们有了文件。 

1060
00:42:37,660 --> 00:42:39,870
这是一个字符串数组。 

1061
00:42:39,870 --> 00:42:41,370
如果在这里查看它，则为字符串数组。 

1062
00:42:41,370 --> 00:42:43,010
这些字符串只是名称

1063
00:42:43,010 --> 00:42:45,515
该目录中的所有文件。 

1064
00:42:45,515 --> 00:42:46,650
再简单不过了。 

1065
00:42:46,650 --> 00:42:48,350
因此，让我们逐一介绍一下。 

1066
00:42:49,890 --> 00:42:52,160
而对于每一个，我将创建

1067
00:42:52,160 --> 00:42:56,700
我在该文件中找到的EmojiArtDocument， 

1068
00:42:56,700 --> 00:42:59,020
EmojiArtDocument，它很棒。 

1069
00:42:59,020 --> 00:43:01,233
我们刚刚添加了EmojiArtDocument URL。 

1070
00:43:02,340 --> 00:43:05,430
那么，如何创建此文档的URL？ 

1071
00:43:05,430 --> 00:43:06,680
这个文件是字串， 

1072
00:43:06,680 --> 00:43:08,377
这只是文件名， 

1073
00:43:08,377 --> 00:43:10,300
我在这里有目录

1074
00:43:10,300 --> 00:43:12,380
所以我要去目录

1075
00:43:12,380 --> 00:43:15,963
我将添加一个路径组件， 

1076
00:43:17,400 --> 00:43:19,683
那是那个文件名。 

1077
00:43:20,610 --> 00:43:22,700
所以我只是在这里创建另一个URL 

1078
00:43:22,700 --> 00:43:25,000
从我们的目录URL中添加

1079
00:43:25,000 --> 00:43:26,640
重新输入文件名称。 

1080
00:43:26,640 --> 00:43:29,170
我正在为每个文档进行此操作

1081
00:43:29,170 --> 00:43:31,910
我在那个目录中找到的，超级简单。 

1082
00:43:31,910 --> 00:43:33,300
当我有这份文件时

1083
00:43:33,300 --> 00:43:36,230
我要将其添加到我自己的documentNames中， 

1084
00:43:37,160 --> 00:43:42,160
此EmojiArtDocument，其名称为document。 

1085
00:43:44,810 --> 00:43:47,700
现在，我们更新了内部数据结构

1086
00:43:47,700 --> 00:43:49,247
反映文件系统中的内容， 

1087
00:43:49,247 --> 00:43:51,730
我们在初始化时就完成了

1088
00:43:51,730 --> 00:43:54,070
现在，我们还有很多工作要做

1089
00:43:54,070 --> 00:43:56,000
所有这些添加和删除， 

1090
00:43:56,000 --> 00:43:57,500
并更改文件名称。 

1091
00:43:57,500 --> 00:44:00,400
我们将不得不保持文件系统同步

1092
00:44:00,400 --> 00:44:03,650
但是至少我们从右脚开始

1093
00:44:03,650 --> 00:44:05,760
通过拥有我们的内部数据结构

1094
00:44:05,760 --> 00:44:07,413
从文件系统加载。 

1095
00:44:08,710 --> 00:44:10,300
这几乎是所有必要的。 

1096
00:44:10,300 --> 00:44:13,470
现在，让我们回到SceneDelegate 

1097
00:44:13,470 --> 00:44:16,200
在这里，我们正在创建此DocumentStore 

1098
00:44:16,200 --> 00:44:20,084
我们从UserDefaults中获得了名为EmojiArt 

1099
00:44:20,084 --> 00:44:22,150
而不是这样做，让我们开始吧

1100
00:44:22,150 --> 00:44:27,047
让我们的商店等于EmojiArtDocumentStore， 

1101
00:44:29,160 --> 00:44:32,330
其目录是URL， 

1102
00:44:32,330 --> 00:44:35,990
该URL将成为我们的Documents目录

1103
00:44:35,990 --> 00:44:39,170
在我们的沙箱中，那个特殊目录。 

1104
00:44:39,170 --> 00:44:42,340
每个人都从幻灯片中记得我们是如何做到的？ 

1105
00:44:42,340 --> 00:44:44,840
再说一次url = 

1106
00:44:44,840 --> 00:44:48,290
我们将使用共享的FileManager。 

1107
00:44:48,290 --> 00:44:49,999
在幻灯片中，我向您展示了这一幅

1108
00:44:49,999 --> 00:44:53,470
SearchPathDirectory的URL 

1109
00:44:53,470 --> 00:44:55,533
在适当的创建过程中，还记得吗？ 

1110
00:44:55,533 --> 00:44:59,690
当您在此处说不同的名称时，它称为URL，即复数形式。 

1111
00:44:59,690 --> 00:45:03,800
并且您仍然指定所需的特殊目录。 

1112
00:45:03,800 --> 00:45:07,470
所以我想要documentDirectory，在那儿要小心。 

1113
00:45:07,470 --> 00:45:09,770
您不想做documentationDirectory， 

1114
00:45:09,770 --> 00:45:11,840
您需要documentDirectory。 

1115
00:45:11,840 --> 00:45:12,960
什么是documentDirectory？ 

1116
00:45:12,960 --> 00:45:16,600
而且我们总是在userDomainMask中， 

1117
00:45:16,600 --> 00:45:20,190
iOS是用于单个设备的操作系统， 

1118
00:45:20,190 --> 00:45:23,370
所以我们总是给用户的Document目录， 

1119
00:45:23,370 --> 00:45:25,070
而不是网络上的共享者， 

1120
00:45:25,070 --> 00:45:26,780
或类似的东西。 

1121
00:45:26,780 --> 00:45:30,690
现在，此URL的版本返回它们的数组， 

1122
00:45:30,690 --> 00:45:32,410
再次，因为在其他平台上， 

1123
00:45:32,410 --> 00:45:35,570
您这里可能有多个口罩， 

1124
00:45:35,570 --> 00:45:37,540
用户掩码，网络掩码，因此您可能

1125
00:45:37,540 --> 00:45:39,200
得到多个回应。 

1126
00:45:39,200 --> 00:45:41,860
在这里，我们只会得到一个。 

1127
00:45:41,860 --> 00:45:45,160
我要在这里丢一个感叹号

1128
00:45:45,160 --> 00:45:47,790
假设我总是

1129
00:45:47,790 --> 00:45:50,570
在这里有我的documentDirectory。 

1130
00:45:50,570 --> 00:45:54,720
并在此放置一个感叹号， 

1131
00:45:54,720 --> 00:45:56,930
那是不正确的，并且崩溃了。 

1132
00:45:56,930 --> 00:46:00,410
我至少会发现在我的开发期间， 

1133
00:46:00,410 --> 00:46:02,010
但是要出货的时候

1134
00:46:02,010 --> 00:46:05,410
也许，我会在使用此类商店的地方做一些事情

1135
00:46:05,410 --> 00:46:07,440
如果由于某种原因我不能

1136
00:46:07,440 --> 00:46:10,110
我没有documentDirectory。 

1137
00:46:10,110 --> 00:46:11,848
就是这样。 

1138
00:46:11,848 --> 00:46:13,300
我们有商店，开始吧！ 

1139
00:46:13,300 --> 00:46:14,550
看看这里发生了什么。 

1140
00:46:16,200 --> 00:46:19,410
好吧，所以这可能有效

1141
00:46:19,410 --> 00:46:21,110
因为这里没有文件。 

1142
00:46:21,110 --> 00:46:23,470
看，我们的文件系统中没有文件， 

1143
00:46:23,470 --> 00:46:26,400
我们沙箱中的documentDirectory可能为空。 

1144
00:46:26,400 --> 00:46:27,960
所以一切顺利。 

1145
00:46:27,960 --> 00:46:30,890
是的，也许我们可以在此处添加一些文档， 

1146
00:46:30,890 --> 00:46:33,870
但这实际上并没有将它们添加到文件系统中。 

1147
00:46:33,870 --> 00:46:38,470
如果我停止并重新运行，这些文档， 

1148
00:46:38,470 --> 00:46:40,923
当然没有变化，因为“ +”没有做任何事情， 

1149
00:46:40,923 --> 00:46:45,220
只是将其添加到我们的本地小文件名中

1150
00:46:45,220 --> 00:46:49,100
数据结构在我们的DocumentStore中。 

1151
00:46:49,100 --> 00:46:52,170
因此，这对文件系统没有影响。 

1152
00:46:52,170 --> 00:46:54,420
所以我们需要在这里更新这些东西， 

1153
00:46:54,420 --> 00:46:57,710
addDocument，removeDocument甚至setName， 

1154
00:46:57,710 --> 00:46:59,800
也会影响文件系统。 

1155
00:46:59,800 --> 00:47:00,944
那会很棒

1156
00:47:00,944 --> 00:47:01,777
因为我们会有机会

1157
00:47:01,777 --> 00:47:03,890
看看我们如何影响文件系统。 

1158
00:47:03,890 --> 00:47:07,500
我们已经学习了如何读取目录的内容。 

1159
00:47:07,500 --> 00:47:09,300
现在，让我们学习例如

1160
00:47:09,300 --> 00:47:11,173
删除文件之类的东西。 

1161
00:47:12,110 --> 00:47:13,550
所以让我们先做addDocument， 

1162
00:47:13,550 --> 00:47:15,720
这样我们可以得到一些文件

1163
00:47:15,720 --> 00:47:17,560
在我们的documentDirectory中。 

1164
00:47:17,560 --> 00:47:20,170
而且addDocument有一点

1165
00:47:20,170 --> 00:47:22,340
一个有趣的方面

1166
00:47:22,340 --> 00:47:25,000
当我们开始存储在文件系统中时。 

1167
00:47:25,000 --> 00:47:26,747
当我们将其存储在UserDefaults中时， 

1168
00:47:26,747 --> 00:47:28,870
我们可以有两个，三个或四个文档

1169
00:47:28,870 --> 00:47:30,815
名称完全相同。 

1170
00:47:30,815 --> 00:47:32,060
那很好。 

1171
00:47:32,060 --> 00:47:34,250
但是在文件系统中，这是不允许的。 

1172
00:47:34,250 --> 00:47:36,860
文件系统，您只会得到一个文档

1173
00:47:36,860 --> 00:47:38,940
某个文件名。 

1174
00:47:38,940 --> 00:47:40,460
就是那样子。 

1175
00:47:40,460 --> 00:47:41,710
这就是文件系统的工作方式。 

1176
00:47:41,710 --> 00:47:44,010
我们区分文件系统中的事物

1177
00:47:44,010 --> 00:47:46,140
按文件名。 

1178
00:47:46,140 --> 00:47:48,800
所以我要在这里小心一点

1179
00:47:48,800 --> 00:47:51,650
如果我正在处理文件系统， 

1180
00:47:51,650 --> 00:47:54,390
不只是使用传递给我的名字， 

1181
00:47:54,390 --> 00:47:56,530
甚至默认为“无标题”。 

1182
00:47:56,530 --> 00:47:58,960
我必须确保该名称不存在。 

1183
00:47:58,960 --> 00:48:01,460
我要在这里做的是

1184
00:48:01,460 --> 00:48:04,360
我将创建一个唯一的名称。 

1185
00:48:04,360 --> 00:48:06,400
所以我要去这里

1186
00:48:06,400 --> 00:48:10,360
让uniqueName等于这个名字

1187
00:48:10,360 --> 00:48:13,430
您要我做的，独特的， 

1188
00:48:13,430 --> 00:48:15,180
我有一个很好的函数

1189
00:48:15,180 --> 00:48:20,180
调用withRespectTo documentNames.values。 

1190
00:48:20,620 --> 00:48:23,400
所以这个独特

1191
00:48:23,400 --> 00:48:26,527
相对于其他其他String的此String。 

1192
00:48:26,527 --> 00:48:27,690
还有其他字符串

1193
00:48:27,690 --> 00:48:28,970
是我的documentNames的值。 

1194
00:48:28,970 --> 00:48:32,620
换句话说，我已经知道的documentNames。 

1195
00:48:32,620 --> 00:48:35,810
让我们一起来看看RespectTo真正独特的快速功能。 

1196
00:48:35,810 --> 00:48:37,660
在EmojiArtExtensions中。 

1197
00:48:38,959 --> 00:48:40,550
这是一个真正简单的小功能。 

1198
00:48:40,550 --> 00:48:42,710
它只是创造了我自己的副本， 

1199
00:48:42,710 --> 00:48:44,000
这在字符串中对吗？ 

1200
00:48:44,000 --> 00:48:49,000
我自己的副本，当我在其他字符串中时， 

1201
00:48:49,510 --> 00:48:52,010
我要增加自己。 

1202
00:48:52,010 --> 00:48:54,220
现在，我自己正在增加什么？ 

1203
00:48:54,220 --> 00:48:56,270
这是我在String中添加的新内容， 

1204
00:48:56,270 --> 00:48:59,760
它在字符串末尾放置一个数字

1205
00:48:59,760 --> 00:49:02,000
并根据需要增加它

1206
00:49:02,000 --> 00:49:04,290
最终找到一个唯一的号码。 

1207
00:49:04,290 --> 00:49:07,740
因此，如果我叫“无标题”， 

1208
00:49:07,740 --> 00:49:10,230
还有另外一些叫做“无标题”的东西， 

1209
00:49:10,230 --> 00:49:12,487
我最终将成为“ Untitled1” 

1210
00:49:12,487 --> 00:49:13,887
如果我叫“ Untitled1”， 

1211
00:49:14,780 --> 00:49:17,270
我确实增加了这个小代码， 

1212
00:49:17,270 --> 00:49:18,320
您稍后可以查看， 

1213
00:49:18,320 --> 00:49:20,030
实际上这是一个有趣的代码， 

1214
00:49:20,030 --> 00:49:23,640
将去“ Untitled2”，“ Untitled3”，“ Untitled4”， 

1215
00:49:23,640 --> 00:49:25,663
直到找到唯一的名称。 

1216
00:49:26,544 --> 00:49:29,420
因此，这只是一种简单，简单的棘手事情。 

1217
00:49:29,420 --> 00:49:31,087
但我实际上正在向您展示， 

1218
00:49:31,087 --> 00:49:33,860
我之所以使用它，是因为我想向您展示其他内容。 

1219
00:49:33,860 --> 00:49:35,670
如果我们回到商店， 

1220
00:49:35,670 --> 00:49:37,070
我写的这一行代码

1221
00:49:37,070 --> 00:49:39,210
那样做，实际上没有用。 

1222
00:49:39,210 --> 00:49:42,480
它说不能转换类型的值

1223
00:49:42,480 --> 00:49:45,740
字典<EmojiArt，字符串>。值

1224
00:49:45,740 --> 00:49:47,753
到期望的类型，即字符串数组。 

1225
00:49:49,340 --> 00:49:51,640
是的，的确是我的EmojiArt扩展

1226
00:49:51,640 --> 00:49:53,640
接受其他字符串数组， 

1227
00:49:53,640 --> 00:49:56,760
它希望与RespectTo保持唯一。 

1228
00:49:56,760 --> 00:50:01,130
但是回到这里，这不是一个字符串数组。 

1229
00:50:01,130 --> 00:50:03,540
如果您有一个字典，例如documentNames， 

1230
00:50:03,540 --> 00:50:05,440
而您要求它的价值， 

1231
00:50:05,440 --> 00:50:08,710
您不会得到这些东西的数组。 

1232
00:50:08,710 --> 00:50:10,830
你会得到一个特殊的类型

1233
00:50:10,830 --> 00:50:13,780
是这些东西的集合。 

1234
00:50:13,780 --> 00:50:16,150
所以我们在这里使用函数式编程

1235
00:50:16,150 --> 00:50:18,240
创建，返回一些

1236
00:50:18,240 --> 00:50:21,090
它不是数组，而是集合。 

1237
00:50:21,090 --> 00:50:23,970
现在，我的独特身份真的应该和我一样快乐

1238
00:50:23,970 --> 00:50:27,440
与字符串集合（作为数组）一起使用。 

1239
00:50:27,440 --> 00:50:30,770
例如，一组字符串应该在这里工作。 

1240
00:50:30,770 --> 00:50:32,380
如果我想我的名字唯一

1241
00:50:32,380 --> 00:50:35,110
关于其他字符串集，这应该可以工作。 

1242
00:50:35,110 --> 00:50:37,400
当然，我希望能够通过

1243
00:50:37,400 --> 00:50:42,140
这些字典值，无论此集合是什么。 

1244
00:50:42,140 --> 00:50:44,090
那我该怎么做呢？ 

1245
00:50:44,090 --> 00:50:47,110
所以这不再需要String数组了， 

1246
00:50:47,110 --> 00:50:49,870
但实际上需要一个Collection 

1247
00:50:49,870 --> 00:50:53,093
以及该集合中包含字符串的位置。 

1248
00:50:53,930 --> 00:50:56,420
为此，这不是面向对象的编程， 

1249
00:50:56,420 --> 00:50:59,150
所以它不像Set，Array， 

1250
00:50:59,150 --> 00:51:01,250
从某个类或集合继承， 

1251
00:51:01,250 --> 00:51:03,100
这是函数式编程。 

1252
00:51:03,100 --> 00:51:06,200
因此，我们将以这种方式一直执行这些操作， 

1253
00:51:06,200 --> 00:51:09,020
不在乎和约束。 

1254
00:51:09,020 --> 00:51:11,540
因此，这是制约​​和收获。 

1255
00:51:11,540 --> 00:51:12,373
那么我们该怎么做呢？ 

1256
00:51:12,373 --> 00:51:14,480
我要在这里创建一个不在乎的

1257
00:51:14,480 --> 00:51:16,960
我将其称为StringCollection。 

1258
00:51:16,960 --> 00:51:19,260
所以我要尊重自己

1259
00:51:19,260 --> 00:51:21,340
一些StringCollection。 

1260
00:51:21,340 --> 00:51:24,080
现在，我不是完全不在乎这个。 

1261
00:51:24,080 --> 00:51:25,943
它必须是一个Collection， 

1262
00:51:25,943 --> 00:51:28,280
因为我想包含它， 

1263
00:51:28,280 --> 00:51:30,410
而且还必须包含Strings， 

1264
00:51:30,410 --> 00:51:33,820
因为我正在尝试使用RespectTo字符串进行唯一化。 

1265
00:51:33,820 --> 00:51:36,920
那么，只需要一个这样的函数，怎么会不在乎呢？ 

1266
00:51:36,920 --> 00:51:40,080
这不是不在乎String或其他东西， 

1267
00:51:40,080 --> 00:51:42,760
它本身就是一个小功能， 

1268
00:51:42,760 --> 00:51:45,090
想要一个不在乎。 

1269
00:51:45,090 --> 00:51:47,387
它使用<StringCollection>做到这一点。 

1270
00:51:49,330 --> 00:51:51,770
这与在类型上进行操作非常相似， 

1271
00:51:51,770 --> 00:51:54,870
一个结构，或其他任何东西，就在这里做。 

1272
00:51:54,870 --> 00:51:57,010
而且我也可以在哪里做。 

1273
00:51:57,010 --> 00:52:01,740
所以我要在这里做这个StringCollection 

1274
00:52:01,740 --> 00:52:04,650
是一个收藏，必须是一个收藏， 

1275
00:52:04,650 --> 00:52:08,730
而且，在StringCollection的

1276
00:52:08,730 --> 00:52:11,690
元素等于字符串。 

1277
00:52:11,690 --> 00:52:16,230
所以this.Element在Collection中是无关紧要的。 

1278
00:52:16,230 --> 00:52:18,960
请记住，像Collection这样的协议

1279
00:52:18,960 --> 00:52:22,060
它可以有一个无关类型。 

1280
00:52:22,060 --> 00:52:24,660
因此，它有一个，只是元素， 

1281
00:52:24,660 --> 00:52:26,380
和Array具有相同的

1282
00:52:26,380 --> 00:52:29,680
一套有这个，因为他们得到了

1283
00:52:29,680 --> 00:52:31,530
来自Collection的原因是因为他们实施了

1284
00:52:31,530 --> 00:52:33,300
收集协议。 

1285
00:52:33,300 --> 00:52:36,050
所以我只是为了使这项工作受限制。 

1286
00:52:36,050 --> 00:52:37,170
看，这就是它的工作原理。 

1287
00:52:37,170 --> 00:52:39,840
由于包含在集合中， 

1288
00:52:39,840 --> 00:52:43,010
当然，我们可以在这里做一些事情

1289
00:52:43,010 --> 00:52:45,060
是面向字符串的，因为我确保

1290
00:52:45,060 --> 00:52:46,920
这是字符串的集合。 

1291
00:52:46,920 --> 00:52:48,610
不仅如此，回到这里， 

1292
00:52:48,610 --> 00:52:51,510
当我重新编译时，它将起作用。 

1293
00:52:51,510 --> 00:52:52,730
这不再是抱怨

1294
00:52:52,730 --> 00:52:55,210
因为这是字符串的集合

1295
00:52:55,210 --> 00:52:56,870
因为这是字典

1296
00:52:56,870 --> 00:52:58,703
具有字符串作为其值。 

1297
00:53:00,220 --> 00:53:02,250
是的，我只是想绕道走

1298
00:53:02,250 --> 00:53:04,040
从我们所做的事情开始

1299
00:53:04,040 --> 00:53:06,443
另一个功能编程问题在您身边。 

1300
00:53:07,690 --> 00:53:10,040
好吧，所以我们在这里有一个唯一的名字， 

1301
00:53:10,040 --> 00:53:12,430
因此我们可以使用这个uniqueName添加文档。 

1302
00:53:12,430 --> 00:53:13,300
因此，让我们这样做。 

1303
00:53:13,300 --> 00:53:15,610
我要在这里建立文件

1304
00:53:15,610 --> 00:53:19,073
作为一个局部变量。 

1305
00:53:20,010 --> 00:53:21,720
然后，我要说的是

1306
00:53:21,720 --> 00:53:23,183
如果我可以让网址

1307
00:53:24,130 --> 00:53:26,710
这将是该文档的URL 

1308
00:53:26,710 --> 00:53:28,980
我要添加，我要添加一个新文档， 

1309
00:53:28,980 --> 00:53:31,210
所以我要为该文档创建一个URL。 

1310
00:53:31,210 --> 00:53:35,500
这是我的商店所在的目录， 

1311
00:53:35,500 --> 00:53:39,433
appendingPathComponent，即唯一名称。 

1312
00:53:40,580 --> 00:53:43,340
这就是我想要的网址

1313
00:53:43,340 --> 00:53:46,080
创建这个新的EmojiArtDocument是。 

1314
00:53:46,080 --> 00:53:48,810
现在，我在做是否允许，因为可能是我的目录

1315
00:53:48,810 --> 00:53:51,240
为零，因为有人做了名为

1316
00:53:51,240 --> 00:53:53,230
而不是执行init目录。 

1317
00:53:53,230 --> 00:53:55,990
在这种情况下，我的商店不是基于文件系统的， 

1318
00:53:55,990 --> 00:54:00,980
所以我的网址为零，所以我无法获得此文档的网址。 

1319
00:54:00,980 --> 00:54:03,330
但是，如果我可以获取此文档的网址， 

1320
00:54:03,330 --> 00:54:08,170
然后，该文档将成为EmojiArtDocument 

1321
00:54:08,170 --> 00:54:11,290
使用该URL，让我们创建一个新的EmojiArtDocument。 

1322
00:54:11,290 --> 00:54:13,740
如果不是，如果我们只是在做UserDefaults的事情， 

1323
00:54:13,740 --> 00:54:16,763
那么，该文档只是一个空白的EmojiArtDocument。 

1324
00:54:18,610 --> 00:54:20,400
全新，因为我们在addDocument中， 

1325
00:54:20,400 --> 00:54:22,650
我们正在添加新文档。 

1326
00:54:22,650 --> 00:54:24,870
让我们先在这里注意我们的错误。 

1327
00:54:24,870 --> 00:54:27,140
哦，是的，的确，我们不想添加

1328
00:54:27,140 --> 00:54:29,180
空白文档，我们将添加

1329
00:54:29,180 --> 00:54:31,650
我们刚刚创建的此文档。 

1330
00:54:31,650 --> 00:54:32,483
这就是为什么你的警告， 

1331
00:54:32,483 --> 00:54:34,640
您必须始终注意这些警告。 

1332
00:54:34,640 --> 00:54:36,860
另外，请确保我们正在使用

1333
00:54:36,860 --> 00:54:39,230
我们刚刚创建的uniqueName 

1334
00:54:39,230 --> 00:54:41,093
作为那里的文件名。 

1335
00:54:43,260 --> 00:54:44,730
好的，所以我们这里没有文件。 

1336
00:54:44,730 --> 00:54:48,150
让我们看看，加上，希望创建了一个文件

1337
00:54:48,150 --> 00:54:50,790
在我们的文件系统中。 

1338
00:54:50,790 --> 00:54:52,784
那另一个呢？ 

1339
00:54:52,784 --> 00:54:54,640
哇，我们得到了独一无二的另一个？ 

1340
00:54:54,640 --> 00:54:56,570
哇，它增加了，好的，所以我们的

1341
00:54:56,570 --> 00:54:58,200
增量代码也可以正常工作。 

1342
00:54:58,200 --> 00:55:00,270
现在，希望我们辞职回到这里， 

1343
00:55:00,270 --> 00:55:03,780
这三个文件将在文件系统中。 

1344
00:55:03,780 --> 00:55:06,580
他们是优秀的。 

1345
00:55:06,580 --> 00:55:08,440
好的，下一步，删除。 

1346
00:55:08,440 --> 00:55:12,040
因此，我们在这里说，让我们摆脱“ Untitled1”。 

1347
00:55:12,040 --> 00:55:13,710
哦，虫子工作了，很好。 

1348
00:55:13,710 --> 00:55:14,823
现在，让我们重新运行。 

1349
00:55:16,290 --> 00:55:17,533
哦，“ Untitled1”又回来了。 

1350
00:55:17,533 --> 00:55:20,220
是的，对，因为我们没有， 

1351
00:55:20,220 --> 00:55:22,110
当我们在此处点击“完成”并说“删除”时， 

1352
00:55:22,110 --> 00:55:24,280
我们实际上并没有在文件系统中删除它， 

1353
00:55:24,280 --> 00:55:27,013
我们在文档名称中删除了它，就是这样。 

1354
00:55:28,076 --> 00:55:31,770
好吧，所以我们得在这里修复removeDocument 

1355
00:55:31,770 --> 00:55:34,770
从文件系统中删除事物。 

1356
00:55:34,770 --> 00:55:35,840
那可能是最简单的

1357
00:55:35,840 --> 00:55:37,720
我们需要做的所有事情。 

1358
00:55:37,720 --> 00:55:38,640
我们只是看看我们是否可以

1359
00:55:38,640 --> 00:55:41,460
得到那个东西的URL， 

1360
00:55:41,460 --> 00:55:44,000
我们必须从它的名字中得到

1361
00:55:44,000 --> 00:55:47,193
那是我们对该文档的documentNames。 

1362
00:55:48,140 --> 00:55:51,740
然后，让URL等于我们的目录， 

1363
00:55:51,740 --> 00:55:56,740
并附加该名称的PathComponent。 

1364
00:55:58,100 --> 00:56:00,660
因此，如果我们试图删除此文档， 

1365
00:56:00,660 --> 00:56:02,780
已经有一个名字了， 

1366
00:56:02,780 --> 00:56:04,360
我们可以用它制作一个URL， 

1367
00:56:04,360 --> 00:56:07,410
表示我们是位于目录中的商店。 

1368
00:56:07,410 --> 00:56:08,500
我们只是要删除它。 

1369
00:56:08,500 --> 00:56:09,570
那是另一回事

1370
00:56:09,570 --> 00:56:11,530
我们的FileManager可以为我们做。 

1371
00:56:11,530 --> 00:56:14,324
FileManager.default共享一个， 

1372
00:56:14,324 --> 00:56:17,713
URL，kaboom上的removeItem。 

1373
00:56:18,780 --> 00:56:19,997
再说一次，像大多数这些

1374
00:56:19,997 --> 00:56:23,360
FileManagers的东西，这会抛出。 

1375
00:56:23,360 --> 00:56:25,200
在这种情况下，我要走了

1376
00:56:25,200 --> 00:56:26,840
做尝试？ 

1377
00:56:26,840 --> 00:56:29,050
因为我们正在尝试删除此文档， 

1378
00:56:29,050 --> 00:56:29,990
而且我无法删除它。 

1379
00:56:29,990 --> 00:56:31,840
我不确定该怎么办。 

1380
00:56:31,840 --> 00:56:33,470
我以为我可以看看这些错误， 

1381
00:56:33,470 --> 00:56:37,170
看看是否有某种方式可以恢复

1382
00:56:37,170 --> 00:56:39,830
但可能不太可能。 

1383
00:56:39,830 --> 00:56:42,313
做到了，removeDocument完成了。 

1384
00:56:44,573 --> 00:56:47,840
现在，让我们尝试删除“ Untitled1”。 

1385
00:56:47,840 --> 00:56:50,183
好的，完成，然后重新运行。 

1386
00:56:51,800 --> 00:56:56,800
消失了，很好，将其添加回去，再添加一个。 

1387
00:56:56,850 --> 00:56:59,640
我们去这里，删除“ Untitled3”， 

1388
00:56:59,640 --> 00:57:03,813
让我们删除“无标题”，完成，然后重新运行。 

1389
00:57:05,270 --> 00:57:09,840
哇，好的，我想我们在这里的最后一个是重命名。 

1390
00:57:09,840 --> 00:57:11,547
所以，如果我在这里编辑，然后说， 

1391
00:57:11,547 --> 00:57:14,427
“我想改回“无标题”， 

1392
00:57:14,427 --> 00:57:17,080
“而且我完成了，”看起来很有效。 

1393
00:57:17,080 --> 00:57:22,080
三连胜，哦，不，“ Untitled1”又回来了。 

1394
00:57:22,460 --> 00:57:25,030
再说一次，我在重命名。 

1395
00:57:25,030 --> 00:57:26,740
它对文件系统没有影响， 

1396
00:57:26,740 --> 00:57:28,760
所以它回来并显示给您

1397
00:57:28,760 --> 00:57:31,023
重新运行时文件系统中的内容。 

1398
00:57:31,880 --> 00:57:33,980
让我们更改setName。 

1399
00:57:33,980 --> 00:57:36,930
这只是更改URL的问题

1400
00:57:36,930 --> 00:57:39,370
将此文档作为URL 

1401
00:57:39,370 --> 00:57:40,830
该名称适用。 

1402
00:57:40,830 --> 00:57:44,630
因此，如果我可以让url等于我们的目录

1403
00:57:44,630 --> 00:57:49,630
通过附加此名称的PathComponent 

1404
00:57:49,650 --> 00:57:51,780
您想设置为新事物， 

1405
00:57:51,780 --> 00:57:56,420
然后，document.url = url。 

1406
00:57:56,420 --> 00:57:59,130
我刚刚改变了发生这种情况的地方。 

1407
00:57:59,130 --> 00:58:02,040
现在，我知道，另一件事是， 

1408
00:58:02,040 --> 00:58:04,550
如果这是重命名怎么办？ 

1409
00:58:04,550 --> 00:58:06,890
好吧，有人说了文件名， 

1410
00:58:06,890 --> 00:58:09,550
它已经在某个地方了

1411
00:58:09,550 --> 00:58:12,170
在我们的文档名称中使用其他名称。 

1412
00:58:12,170 --> 00:58:14,050
很高兴注意这一点。 

1413
00:58:14,050 --> 00:58:17,633
如果我们删除旧文档该怎么办？ 

1414
00:58:18,784 --> 00:58:21,400
如果我们在更改其网址之前删除了该旧文档， 

1415
00:58:21,400 --> 00:58:23,790
它将其旧网址删除， 

1416
00:58:23,790 --> 00:58:26,800
现在，我们将其放在新的URL中。 

1417
00:58:26,800 --> 00:58:29,540
但是命名还有另一件事， 

1418
00:58:29,540 --> 00:58:32,810
这有点棘手，类似于addDocument， 

1419
00:58:32,810 --> 00:58:35,340
如果您尝试设置名称该怎么办

1420
00:58:35,340 --> 00:58:37,650
同名文件

1421
00:58:37,650 --> 00:58:40,712
像其他一些文件一样

1422
00:58:40,712 --> 00:58:45,360
哦，是的，我们可以尝试一些独特的职业

1423
00:58:45,360 --> 00:58:47,010
或类似的东西。 

1424
00:58:47,010 --> 00:58:48,290
但我实际上认为该策略

1425
00:58:48,290 --> 00:58:51,420
我要用的就是我要拒绝该请求。 

1426
00:58:51,420 --> 00:58:54,010
我只是要忽略它。 

1427
00:58:54,010 --> 00:58:56,590
再说一次，也许我想增强这个功能

1428
00:58:56,590 --> 00:58:59,080
返回布尔，无论我是否能够

1429
00:58:59,080 --> 00:59:00,500
实际上要重命名， 

1430
00:59:00,500 --> 00:59:03,600
然后，UI可以发出警报，无论如何。 

1431
00:59:03,600 --> 00:59:05,920
我们正在做一个演示，所以我不会做任何事情。 

1432
00:59:05,920 --> 00:59:10,060
我只是不允许在这里进行重命名， 

1433
00:59:10,060 --> 00:59:12,950
如果您要在文件系统中执行一项操作， 

1434
00:59:12,950 --> 00:59:14,800
这个名字存在。 

1435
00:59:14,800 --> 00:59:15,770
所以我要那样做

1436
00:59:15,770 --> 00:59:19,920
我要说的是，如果这样做，我会这样做

1437
00:59:19,920 --> 00:59:24,880
如果documentNames.values不包含此名称， 

1438
00:59:24,880 --> 00:59:28,120
然后，我很乐意为您重命名。 

1439
00:59:28,120 --> 00:59:29,640
否则，我不会这样做。 

1440
00:59:29,640 --> 00:59:31,390
实际上，否则，我将无能为力。 

1441
00:59:31,390 --> 00:59:36,267
因此，让我们将其放在另一个这样的地方。 

1442
00:59:36,267 --> 00:59:38,230
然后在这里做

1443
00:59:38,230 --> 00:59:42,573
仅当此名称不冲突时。 

1444
00:59:43,590 --> 00:59:44,990
好吧，让我们看看UI中发生了什么

1445
00:59:44,990 --> 00:59:46,240
如果我只是采取这种策略， 

1446
00:59:46,240 --> 00:59:51,090
只是不允许重命名，即重命名。 

1447
00:59:51,090 --> 00:59:52,040
因此，我们开始尝试。 

1448
00:59:52,040 --> 00:59:53,600
好吧，首先，让我们看看重命名是否有效。 

1449
00:59:53,600 --> 00:59:55,160
所以在这里我要做“ Untitled1” 

1450
00:59:55,160 --> 00:59:58,040
我将其重命名为“无标题”。 

1451
00:59:58,040 --> 00:59:59,350
那不是别的名字

1452
00:59:59,350 --> 01:00:00,873
很好，让我们重新运行。 

1453
01:00:02,644 --> 01:00:04,520
哦，它在文件系统中重命名了。 

1454
01:00:04,520 --> 01:00:08,200
好吧，让我们尝试一下，并使用这个“ Untitled2”， 

1455
01:00:08,200 --> 01:00:11,387
然后将其命名为“无标题”。 

1456
01:00:11,387 --> 01:00:14,450
哦，看，它不允许我这样做。 

1457
01:00:14,450 --> 01:00:16,050
但是当我回去时，它就在这里。 

1458
01:00:16,050 --> 01:00:19,697
很有意思，所以让我们尝试“ Untitled1”。 

1459
01:00:19,697 --> 01:00:22,500
是的，那行得通，好吧，让我们再添加一些。 

1460
01:00:22,500 --> 01:00:26,587
让我们尝试将“ Untitled4”重命名为“ Untitled2”。 

1461
01:00:28,100 --> 01:00:30,920
做完了，哦，不允许，就回去了。 

1462
01:00:30,920 --> 01:00:32,610
但是当我回到编辑状态时

1463
01:00:32,610 --> 01:00:34,640
它仍然为我保持“ 2”。 

1464
01:00:34,640 --> 01:00:38,713
所以也许我真的想要“ 21”或我想要“ 2a”， 

1465
01:00:40,403 --> 01:00:41,837
这样的东西。 

1466
01:00:41,837 --> 01:00:44,160
而且，它允许。 

1467
01:00:44,160 --> 01:00:46,673
因此，我们刚刚拒绝也不错。 

1468
01:00:47,960 --> 01:00:50,360
我可能会希望在那儿有一个警报， 

1469
01:00:50,360 --> 01:00:54,530
可能只是因为用户可能有点困惑。 

1470
01:00:54,530 --> 01:00:55,910
他们在这里，他们这样说， 

1471
01:00:55,910 --> 01:00:57,757
他们打了“完成”，然后他们想，“哦，他们做到了， 

1472
01:00:57,757 --> 01:00:59,857
“但是哦，那是“ 2a”，它回来了。 

1473
01:00:59,857 --> 01:01:00,690
“这是怎么回事？ 

1474
01:01:00,690 --> 01:01:01,717
“我试图重命名。” 

1475
01:01:02,640 --> 01:01:04,650
是的，他们可能会或可能不会注意到

1476
01:01:04,650 --> 01:01:05,890
还有另一个名字。 

1477
01:01:05,890 --> 01:01:08,090
所以也许是一个警报，该名称已经

1478
01:01:08,090 --> 01:01:09,533
在这里使用会很好。 

1479
01:01:11,530 --> 01:01:12,827
但是我们在这里学习文件系统， 

1480
01:01:12,827 --> 01:01:14,960
我认为我们做到了。 

1481
01:01:14,960 --> 01:01:18,150
我们在这里展示了文件系统的许多不同部分。 

1482
01:01:18,150 --> 01:01:20,040
我们从文档开始

1483
01:01:20,040 --> 01:01:22,780
只是学习我们如何使用数据， 

1484
01:01:22,780 --> 01:01:25,540
和URL来改变我们的阅读， 

1485
01:01:25,540 --> 01:01:28,355
并写入文件系统， 

1486
01:01:28,355 --> 01:01:29,490
而不是UserDefaults。 

1487
01:01:29,490 --> 01:01:32,750
这在这里非常容易。 

1488
01:01:32,750 --> 01:01:34,550
然后，当我们去商店时， 

1489
01:01:34,550 --> 01:01:36,620
我们了解了有关FileManager的很多知识， 

1490
01:01:36,620 --> 01:01:39,120
共享的FileManager之类的

1491
01:01:39,120 --> 01:01:41,110
目录的所有内容， 

1492
01:01:41,110 --> 01:01:43,210
然后，如何使用FileManager进行操作

1493
01:01:43,210 --> 01:01:44,813
例如删除文件。 

1494
01:01:46,100 --> 01:01:48,320
就是这个演示

1495
01:01:48,320 --> 01:01:50,810
希望你有机会

1496
01:01:50,810 --> 01:01:54,140
将此整合到您的最终项目中。 

1497
01:01:54,140 --> 01:01:55,310
这很简单， 

1498
01:01:55,310 --> 01:01:57,700
通常您确实有存储要求， 

1499
01:01:57,700 --> 01:02:00,200
而且我不想看到您所有的最终项目

1500
01:02:00,200 --> 01:02:02,314
将所有内容存储在UserDefaults中。 

1501
01:02:02,314 --> 01:02:03,490
我绝对很想看看

1502
01:02:03,490 --> 01:02:07,560
一些核心数据和/或文件系统， 

1503
01:02:07,560 --> 01:02:10,323
甚至CloudKit，那都很棒。 

1504
01:02:11,480 --> 01:02:14,733
-[播音员]有关更多信息，请访问stanford.edu。 

