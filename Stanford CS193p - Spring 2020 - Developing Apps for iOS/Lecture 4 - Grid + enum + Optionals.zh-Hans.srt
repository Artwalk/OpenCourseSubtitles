1
00:00:01,219 --> 00:00:03,802
（柔和的音乐） 

2
00:00:04,940 --> 00:00:06,590
-[旁白]斯坦福大学。 

3
00:00:08,170 --> 00:00:10,580
-[讲师]我们回来了，第四节课。 

4
00:00:10,580 --> 00:00:15,160
斯坦福CS193p，2020年春季。 

5
00:00:15,160 --> 00:00:18,210
今天，我将从一个大型演示开始， 

6
00:00:18,210 --> 00:00:20,670
这将是制作我们的纸牌游戏

7
00:00:20,670 --> 00:00:23,980
排成一排，而不是排成一排， 

8
00:00:23,980 --> 00:00:27,280
毫无疑问，这将使我们的游戏变得更好

9
00:00:27,280 --> 00:00:29,640
但这也将是一个很好的例子

10
00:00:29,640 --> 00:00:32,430
使用协议进行泛型的过程， 

11
00:00:32,430 --> 00:00:34,730
并用作类型。 

12
00:00:34,730 --> 00:00:37,040
我们将学习更多有关成为容器的信息

13
00:00:37,040 --> 00:00:38,470
因为我们要建立自己的

14
00:00:38,470 --> 00:00:41,970
行和列容器查看我们的卡。 

15
00:00:41,970 --> 00:00:44,820
演示之后，我们将跳回到此处的幻灯片。 

16
00:00:44,820 --> 00:00:47,300
我们将进一步讨论Swift类型的系统， 

17
00:00:47,300 --> 00:00:51,050
特别是类型枚举。 

18
00:00:51,050 --> 00:00:53,780
然后在那之后，我们将继续幻灯片

19
00:00:53,780 --> 00:00:56,590
并讨论最重要的类型之一

20
00:00:56,590 --> 00:00:59,583
在所有Swift中，Optional是一个枚举。 

21
00:01:01,001 --> 00:01:03,650
可选非常重要，我要去

22
00:01:03,650 --> 00:01:05,440
之后立即返回演示

23
00:01:05,440 --> 00:01:08,390
并向您展示两个非常重要的例子

24
00:01:08,390 --> 00:01:12,393
在Swift中使用Optional设计代码的过程。 

25
00:01:13,380 --> 00:01:15,853
因此，让我们开始该演示。 

26
00:01:16,920 --> 00:01:20,550
好吧，这是修复此主要缺陷的类型

27
00:01:20,550 --> 00:01:23,020
在我们的游戏中，这是所有的牌

28
00:01:23,020 --> 00:01:24,410
在一排， 

29
00:01:24,410 --> 00:01:26,900
而且我们知道我们可以更有效率

30
00:01:26,900 --> 00:01:30,280
如果我们有行和列，请使用此空间。 

31
00:01:30,280 --> 00:01:33,930
我们将通过在此处替换HStack来做到这一点

32
00:01:33,930 --> 00:01:35,770
与网格。 

33
00:01:35,770 --> 00:01:39,770
现在，在本节课的录音中， 

34
00:01:39,770 --> 00:01:42,580
SwiftUI中没有Grid之类的东西， 

35
00:01:42,580 --> 00:01:44,017
所以我们要写些。 

36
00:01:44,017 --> 00:01:47,160
它实际上为我们提供了一个绝佳的机会

37
00:01:47,160 --> 00:01:51,570
了解有关ZStack之类的工作原理的大量信息。 

38
00:01:51,570 --> 00:01:55,080
因此，我们知道ZStack就在这里接受此参数， 

39
00:01:55,080 --> 00:01:56,830
这是一个功能。 

40
00:01:56,830 --> 00:01:58,397
花括号表示它是一个功能。 

41
00:01:58,397 --> 00:02:00,920
这个函数不带参数， 

42
00:02:00,920 --> 00:02:05,420
与ForEach不同，它创建视图的功能

43
00:02:05,420 --> 00:02:06,960
吵架

44
00:02:06,960 --> 00:02:09,900
但是ZStack，这里构建的View 

45
00:02:09,900 --> 00:02:11,200
非常强大。 

46
00:02:11,200 --> 00:02:13,960
它可能是其他视图的列表。 

47
00:02:13,960 --> 00:02:17,800
可以是如果-则是其组合。 

48
00:02:17,800 --> 00:02:20,990
所以这个可以建立的特殊功能

49
00:02:20,990 --> 00:02:24,783
这些复杂的View称为ViewBuilder。 

50
00:02:25,830 --> 00:02:28,300
而且我们还不会使用ViewBuilder。 

51
00:02:28,300 --> 00:02:30,600
我们最终将了解ViewBuilder。 

52
00:02:30,600 --> 00:02:34,420
所以我们的网格只会有一个简单的视图

53
00:02:34,420 --> 00:02:38,020
它将使用ForEach复制， 

54
00:02:38,020 --> 00:02:39,950
与ForEach完全相同， 

55
00:02:39,950 --> 00:02:42,790
在每个位置放一个特定的视图

56
00:02:42,790 --> 00:02:44,530
在行和列中。 

57
00:02:44,530 --> 00:02:49,240
因此，我们的Grid确实将像Grid一样组合HStack， 

58
00:02:49,240 --> 00:02:51,980
除了2D HStack，如果您想考虑一下， 

59
00:02:51,980 --> 00:02:54,480
像这样的ForEach。 

60
00:02:54,480 --> 00:02:59,110
我们将采取一系列可识别的事物， 

61
00:02:59,110 --> 00:03:03,620
像这些卡片，然后我们将传递一个函数

62
00:03:03,620 --> 00:03:07,260
以可识别事物之一作为论据， 

63
00:03:07,260 --> 00:03:09,290
并返回要使用的视图

64
00:03:09,290 --> 00:03:11,820
在网格中的该位置绘制。 

65
00:03:11,820 --> 00:03:13,433
这里很简单。 

66
00:03:14,460 --> 00:03:15,893
因此，让我们创建该视图。 

67
00:03:15,893 --> 00:03:17,720
我们将在这里转到“新建文件”。 

68
00:03:17,720 --> 00:03:20,530
我们将其放入自己的文件中，因为这确实

69
00:03:20,530 --> 00:03:23,380
一个非常强大的可重用对象。 

70
00:03:23,380 --> 00:03:26,690
我们可以在需要网格的所有应用程序中使用它。 

71
00:03:26,690 --> 00:03:29,500
这是一个SwiftUI视图，所以我要单击此处。 

72
00:03:29,500 --> 00:03:31,070
我将其称为Grid。 

73
00:03:31,070 --> 00:03:33,260
要仔细检查它是其中之一

74
00:03:33,260 --> 00:03:36,110
黄色的文件夹在这里，这个内容

75
00:03:36,110 --> 00:03:39,850
有点匹配，而且确实如此，所以我们很好。 

76
00:03:39,850 --> 00:03:43,500
这是我们的网格，当然，我们会得到“ Hello，World！” 

77
00:03:43,500 --> 00:03:46,270
您会记得下面的这段代码

78
00:03:46,270 --> 00:03:50,270
是为了把我们吸引到我们的画布上。 

79
00:03:50,270 --> 00:03:53,160
但是这个网格是完全通用的。 

80
00:03:53,160 --> 00:03:55,950
因此，如果我们要使该预览工作正常进行， 

81
00:03:55,950 --> 00:03:59,390
我们需要为此提供一些测试数据。 

82
00:03:59,390 --> 00:04:01,700
而且在本演示中我们不会这样做

83
00:04:01,700 --> 00:04:04,270
但将来有一天，也许你可以做到

84
00:04:04,270 --> 00:04:05,690
作为练习。 

85
00:04:05,690 --> 00:04:08,330
但是，如果您删除了它并需要它， 

86
00:04:08,330 --> 00:04:11,863
在画布上会在此处说“创建预览”。 

87
00:04:13,000 --> 00:04:16,020
好吧，所以我们必须开始使用Grid。 

88
00:04:16,020 --> 00:04:19,000
我们要做的第一件事是它的两个论点。 

89
00:04:19,000 --> 00:04:23,880
第一个参数是此可识别数组， 

90
00:04:23,880 --> 00:04:25,860
第二个参数是这个函数

91
00:04:25,860 --> 00:04:28,480
它采用一个Identifiables并提供一个View。 

92
00:04:28,480 --> 00:04:31,980
因此，让我们将这两个参数作为vars获取。 

93
00:04:31,980 --> 00:04:36,980
因此，第一个变量是“项目”，即“项目数组”。 

94
00:04:38,310 --> 00:04:41,640
Grid中对我们来说这一项是无关紧要的。 

95
00:04:41,640 --> 00:04:45,750
我们真的不在乎那个东西是什么。 

96
00:04:45,750 --> 00:04:46,583
可能是任何东西。 

97
00:04:46,583 --> 00:04:50,230
这将是一张卡片，但是没有理由

98
00:04:50,230 --> 00:04:51,600
因为它是任何特殊的东西， 

99
00:04:51,600 --> 00:04:53,430
所以对我们来说不在乎。 

100
00:04:53,430 --> 00:04:56,379
同样，第二个论点

101
00:04:56,379 --> 00:04:59,240
viewForItem我将其称为函数。 

102
00:04:59,240 --> 00:05:02,420
这个函数需要一个Item作为参数， 

103
00:05:02,420 --> 00:05:05,500
它返回一些ItemView， 

104
00:05:05,500 --> 00:05:07,460
这是另一个我们不在乎的。 

105
00:05:07,460 --> 00:05:10,540
我们真的不在乎您提供哪种视图

106
00:05:10,540 --> 00:05:13,957
对于每个项目，都不必关心ItemView。 

107
00:05:14,980 --> 00:05:19,060
一个好的开始，我们实际上可以在这里解决。 

108
00:05:19,060 --> 00:05:23,000
不幸的是，我们必须在此命名该项目。 

109
00:05:23,000 --> 00:05:27,030
这真的是viewForItem， 

110
00:05:27,030 --> 00:05:29,170
放在那边

111
00:05:29,170 --> 00:05:32,860
但这是此函数的最后一个参数， 

112
00:05:32,860 --> 00:05:35,350
所以我们知道当最后一个参数

113
00:05:35,350 --> 00:05:38,320
一个功能是另一个功能， 

114
00:05:38,320 --> 00:05:41,630
那么我们就可以删除该标签，将其关闭， 

115
00:05:41,630 --> 00:05:44,940
并让我们的功能有点浮在外面。 

116
00:05:44,940 --> 00:05:48,360
因此，这是我们网格的最后一个参数。 

117
00:05:48,360 --> 00:05:52,000
这就是它的两个变量，这个变量和viewForItem。 

118
00:05:52,000 --> 00:05:54,320
就像我们在这里叫CardView一样

119
00:05:54,320 --> 00:05:58,380
我们必须将其变量初始化为这个Card变量， 

120
00:05:58,380 --> 00:06:00,000
网格在这里也是一样。 

121
00:06:00,000 --> 00:06:02,030
我们正在初始化它的两个变量。 

122
00:06:03,250 --> 00:06:05,850
现在可能是谈论它的好时机

123
00:06:05,850 --> 00:06:09,050
ForEach不必具有此标签项？ 

124
00:06:09,050 --> 00:06:13,510
当我们有了ForEach时，它就有了可迭代的东西

125
00:06:13,510 --> 00:06:15,280
里面有可识别的东西

126
00:06:15,280 --> 00:06:16,970
怎么没有争论呢？ 

127
00:06:16,970 --> 00:06:20,410
好吧，它使用的是您熟知的技术。 

128
00:06:20,410 --> 00:06:22,240
所以我们也要在Grid中做

129
00:06:22,240 --> 00:06:24,460
这只是一个初始化。 

130
00:06:24,460 --> 00:06:27,780
所以通常你可能会有你的init说项目

131
00:06:27,780 --> 00:06:32,780
是Item的数组，viewForItem是一个函数

132
00:06:32,910 --> 00:06:36,353
它接受一个I​​tem并返回一些ItemView。 

133
00:06:37,246 --> 00:06:38,847
那将是正常的初始化。 

134
00:06:38,847 --> 00:06:41,020
在这里，您只想

135
00:06:41,020 --> 00:06:43,210
初始化您的变量，例如项。 

136
00:06:43,210 --> 00:06:45,790
好吧，这等于传入的项目。 

137
00:06:45,790 --> 00:06:49,530
然后是viewForItem，它等于viewForItem 

138
00:06:49,530 --> 00:06:50,930
这已经过去了。 

139
00:06:50,930 --> 00:06:53,960
顺便说一句，斯威夫特在这里会很困惑

140
00:06:53,960 --> 00:06:58,240
因为它不知道这是什么

141
00:06:58,240 --> 00:06:59,680
以及这是什么项目。 

142
00:06:59,680 --> 00:07:02,570
我们对该函数有一个局部参数，称为items， 

143
00:07:02,570 --> 00:07:05,760
然后我们有一个称为项的属性。 

144
00:07:05,760 --> 00:07:08,520
这样您就可以在这里轻松解决Swift的困惑

145
00:07:08,520 --> 00:07:13,520
通过说出self.items和self.viewForItem。 

146
00:07:13,570 --> 00:07:15,813
这是不得不将自己放在这里的另一个原因

147
00:07:15,813 --> 00:07:20,700
比我们看到的明确的自我blah-blah命中修复方法要好。 

148
00:07:20,700 --> 00:07:22,160
但这在这里有意义，对吗？ 

149
00:07:22,160 --> 00:07:24,970
通过执行self.items，现在Swift知道我们在说

150
00:07:24,970 --> 00:07:26,210
关于绿色的， 

151
00:07:26,210 --> 00:07:28,263
而且这个一定是黑色的。 

152
00:07:29,620 --> 00:07:33,230
现在，这使我们可以将这个限制

153
00:07:33,230 --> 00:07:34,550
作为外部名称。 

154
00:07:34,550 --> 00:07:36,710
记住下标是外部名称

155
00:07:36,710 --> 00:07:40,260
表示不提供外部名称， 

156
00:07:40,260 --> 00:07:42,877
而这正是这里发生的事情。 

157
00:07:42,877 --> 00:07:45,980
如果我重建，你会看到

158
00:07:45,980 --> 00:07:48,300
这段代码在这里，非常好。 

159
00:07:49,590 --> 00:07:53,570
但是，我们的网格仍然存在问题。 

160
00:07:53,570 --> 00:07:55,270
这个错误就在这里。 

161
00:07:55,270 --> 00:07:58,157
它说：“分配非转义参数

162
00:07:58,157 --> 00:08:02,500
“将'viewForItem'转换为@转义的闭包。” 

163
00:08:02,500 --> 00:08:05,450
所以我将尝试解释这种逃逸的关闭

164
00:08:05,450 --> 00:08:06,840
在短短几分钟内。 

165
00:08:06,840 --> 00:08:10,097
通常，我实际上可能会有幻灯片。 

166
00:08:10,097 --> 00:08:14,270
我本季将跳过该季度，因为在SwiftUI中， 

167
00:08:14,270 --> 00:08:16,190
由于我们正在执行函数式编程， 

168
00:08:16,190 --> 00:08:18,270
几乎所有东西都是价值类型

169
00:08:18,270 --> 00:08:21,560
以及这个逃逸的东西关闭的问题

170
00:08:21,560 --> 00:08:23,660
试图在这里解决

171
00:08:23,660 --> 00:08:26,510
在SwiftUI中确实非常罕见。 

172
00:08:26,510 --> 00:08:30,617
当我们进行面向对象编程时，发生了很多事情

173
00:08:30,617 --> 00:08:31,450
在UIkit中。 

174
00:08:32,570 --> 00:08:34,920
所以，这就是发生的事情。 

175
00:08:34,920 --> 00:08:37,090
这里传递的这个功能

176
00:08:37,090 --> 00:08:39,600
为给定项目创建视图

177
00:08:39,600 --> 00:08:42,780
在此初始值设定项中未实际使用。 

178
00:08:42,780 --> 00:08:46,090
我们将其盐腌入var中，稍后再调用。 

179
00:08:46,090 --> 00:08:47,950
我们要在我们体内称呼它

180
00:08:47,950 --> 00:08:50,050
当我们需要实际创建视图时

181
00:08:50,050 --> 00:08:52,120
对于我们所有的物品。 

182
00:08:52,120 --> 00:08:56,350
因此，我们必须标记这种功能@escaping。 

183
00:08:57,980 --> 00:09:00,140
您可以将其视为此功能

184
00:09:00,140 --> 00:09:04,190
将从这个初始化程序中逃脱

185
00:09:04,190 --> 00:09:05,703
没有被叫。 

186
00:09:06,550 --> 00:09:08,330
现在，Swift必须要小心， 

187
00:09:08,330 --> 00:09:10,230
它实际上非常强大

188
00:09:10,230 --> 00:09:12,270
并且知道如何处理这些功能

189
00:09:12,270 --> 00:09:14,250
以后可能会打电话给您。 

190
00:09:14,250 --> 00:09:15,990
为什么会是一个问题？ 

191
00:09:15,990 --> 00:09:18,420
好吧，让我们回顾这里

192
00:09:18,420 --> 00:09:20,170
传递此功能。 

193
00:09:20,170 --> 00:09:24,980
无论此处包含什么代码，都必须稍后才能调用。 

194
00:09:24,980 --> 00:09:27,810
因此，如果我们使用任何变量，尤其是如果我们使用

195
00:09:27,810 --> 00:09:31,150
局部变量或此函数中的某些内容， 

196
00:09:31,150 --> 00:09:34,420
将来必须存在

197
00:09:34,420 --> 00:09:36,563
该函数执行时。 

198
00:09:37,410 --> 00:09:41,040
现在，斯威夫特如何完成这项奇妙的壮举

199
00:09:41,040 --> 00:09:45,440
把所有东西都留在这里直到将来？ 

200
00:09:45,440 --> 00:09:48,400
好吧，它是通过创建函数类型来实现的

201
00:09:48,400 --> 00:09:50,150
是参考类型。 

202
00:09:50,150 --> 00:09:55,080
就像类一样，我们的ViewModel是引用类型， 

203
00:09:55,080 --> 00:09:56,670
他们住在堆里。 

204
00:09:56,670 --> 00:09:57,750
它们存储在内存中。 

205
00:09:57,750 --> 00:09:59,140
人们有指向他们的指针。 

206
00:09:59,140 --> 00:10:02,680
这些功能相同，可以稍后调用。 

207
00:10:02,680 --> 00:10:06,160
它们生活在堆中，并且有指向它们的指针。 

208
00:10:06,160 --> 00:10:11,160
现在，这里的东西也可能存在于堆中。 

209
00:10:11,550 --> 00:10:15,290
例如，如果这里的任何东西都是类， 

210
00:10:15,290 --> 00:10:18,340
那么这里的自我将成为一个指针

211
00:10:18,340 --> 00:10:19,760
堆中的东西。 

212
00:10:19,760 --> 00:10:23,490
而我们试图在Swift中避免的问题

213
00:10:23,490 --> 00:10:27,960
在自我中有一些变种

214
00:10:27,960 --> 00:10:30,480
实际指向此功能

215
00:10:30,480 --> 00:10:34,880
因为我们知道这个功能在这里指向自我。 

216
00:10:34,880 --> 00:10:36,430
他们俩都会在堆里。 

217
00:10:36,430 --> 00:10:37,630
该函数保存在堆中

218
00:10:37,630 --> 00:10:39,520
因为它将稍后执行。 

219
00:10:39,520 --> 00:10:42,210
函数内部的所有内容都保留在堆中

220
00:10:42,210 --> 00:10:44,720
以便以后可以正确执行。 

221
00:10:44,720 --> 00:10:47,440
因此，如果这里有任何提示， 

222
00:10:47,440 --> 00:10:49,810
我们遇到了堆中有两件事的情况

223
00:10:49,810 --> 00:10:51,840
互相指向。 

224
00:10:51,840 --> 00:10:54,670
以及Swift清理内存的方式

225
00:10:54,670 --> 00:10:57,060
当没有人指出某事时

226
00:10:57,060 --> 00:10:59,010
它清理内存并释放它

227
00:10:59,010 --> 00:11:00,390
供其他人使用。 

228
00:11:00,390 --> 00:11:02,520
好吧，如果两件事互相指向

229
00:11:02,520 --> 00:11:03,800
他们都在堆里， 

230
00:11:03,800 --> 00:11:05,870
他们永远也不会消失

231
00:11:05,870 --> 00:11:07,740
因为它们总是相互之间有一个指针。 

232
00:11:07,740 --> 00:11:10,750
这就是所谓的记忆周期。 

233
00:11:10,750 --> 00:11:14,440
所以，这整个过程就是要努力做到

234
00:11:14,440 --> 00:11:17,210
这样我们就可以检测到记忆周期

235
00:11:17,210 --> 00:11:20,590
通过查看这些转义功能。 

236
00:11:20,590 --> 00:11:25,590
令人惊讶的是，这也是为什么您会收到关于自我的警告。 

237
00:11:26,190 --> 00:11:28,590
你知道我们什么时候不放点

238
00:11:28,590 --> 00:11:30,560
在我们的onTapGesture函数中

239
00:11:30,560 --> 00:11:32,360
我们将得到这个错误，说

240
00:11:32,360 --> 00:11:34,660
这需要明确的自我

241
00:11:34,660 --> 00:11:37,400
使捕获语义明确。 

242
00:11:37,400 --> 00:11:40,140
捕获语义意味着事实

243
00:11:40,140 --> 00:11:42,720
捕捉这里的一切， 

244
00:11:42,720 --> 00:11:46,010
在此onTapGesture函数中， 

245
00:11:46,010 --> 00:11:48,510
并将其保留在堆中，以便在onTapGesture 

246
00:11:48,510 --> 00:11:52,500
将来在有人点击此即时贴时执行

247
00:11:52,500 --> 00:11:54,600
这些东西仍然存在。 

248
00:11:54,600 --> 00:11:55,720
好吧，如果您看这段代码， 

249
00:11:55,720 --> 00:11:58,420
您在想，“哦，我想它捕获了ViewModel，” 

250
00:11:58,420 --> 00:12:02,120
但实际上它必须捕获自己。 

251
00:12:02,120 --> 00:12:04,120
所以它让你输入自我

252
00:12:04,120 --> 00:12:05,950
让你意识到，哦，是的， 

253
00:12:05,950 --> 00:12:08,797
这个功能将使自己成为记忆。 

254
00:12:08,797 --> 00:12:11,160
然后，您可以验证自己实际上并没有

255
00:12:11,160 --> 00:12:13,870
以某种方式直接或间接地回来

256
00:12:13,870 --> 00:12:16,820
并指向此功能， 

257
00:12:16,820 --> 00:12:19,920
在这种情况下它不会执行此操作，因为在这里， 

258
00:12:19,920 --> 00:12:22,270
我们的ViewModel从不指向我们的视图。 

259
00:12:22,270 --> 00:12:24,900
视图指向ViewModel，但不指向反向， 

260
00:12:24,900 --> 00:12:26,160
所以没问题

261
00:12:26,160 --> 00:12:29,580
但更重要的是，因为这个自我点

262
00:12:29,580 --> 00:12:31,410
反正不存在于堆中。 

263
00:12:31,410 --> 00:12:35,260
这个自我点就是这个结构，自我就是这个结构。 

264
00:12:35,260 --> 00:12:36,950
结构是值类型。 

265
00:12:36,950 --> 00:12:38,300
他们不住在堆里。 

266
00:12:38,300 --> 00:12:41,080
因此，无论如何都没有必要。 

267
00:12:41,080 --> 00:12:45,130
这就是已经公开批准的解决方案， 

268
00:12:45,130 --> 00:12:47,220
你可能会看到几个月

269
00:12:47,220 --> 00:12:49,120
制作完这段视频之后。 

270
00:12:49,120 --> 00:12:52,310
所以这部影片很快就会过时了。 

271
00:12:52,310 --> 00:12:55,530
但解决方法基本上是自我，在这种情况下， 

272
00:12:55,530 --> 00:12:57,990
这些转义功能之一的内部

273
00:12:57,990 --> 00:12:59,620
会被堆在堆里

274
00:12:59,620 --> 00:13:01,680
如果自我不生活在堆里， 

275
00:13:01,680 --> 00:13:05,600
换句话说，它是一个值类型，一个结构或一个枚举， 

276
00:13:05,600 --> 00:13:09,010
那么您不需要出现此错误

277
00:13:09,010 --> 00:13:11,747
并警告您：“嘿，在上面加点

278
00:13:11,747 --> 00:13:13,807
“因此，请确保您没有记忆周期

279
00:13:13,807 --> 00:13:15,187
“自我指向此功能的地方， 

280
00:13:15,187 --> 00:13:16,620
“这个功能指向自我。” 

281
00:13:16,620 --> 00:13:19,230
那不可能发生，因为没有两件事

282
00:13:19,230 --> 00:13:20,470
在可能指向对方的堆中

283
00:13:20,470 --> 00:13:22,280
因为自我是一种结构。 

284
00:13:22,280 --> 00:13:24,530
这是一个值类型，不存在于堆中。 

285
00:13:26,000 --> 00:13:29,600
因此，您只需要快速了解一下

286
00:13:29,600 --> 00:13:32,550
所有这些转义，你甚至现在都明白

287
00:13:32,550 --> 00:13:34,060
这个自我点是什么。 

288
00:13:34,060 --> 00:13:36,480
如果你听不懂我说的话

289
00:13:36,480 --> 00:13:40,540
关于这些转义功能和这个自圆点， 

290
00:13:40,540 --> 00:13:43,280
真的，我认为您不必为此担心

291
00:13:43,280 --> 00:13:44,113
有几个原因。 

292
00:13:44,113 --> 00:13:46,440
一，这周的读物，你会读

293
00:13:46,440 --> 00:13:48,550
关于这些闭包，这些功能

294
00:13:48,550 --> 00:13:51,870
在线捕捉他们需要的东西

295
00:13:51,870 --> 00:13:53,670
以便以后执行。 

296
00:13:53,670 --> 00:13:56,090
因此，当您阅读该书时，也许您会理解的。 

297
00:13:56,090 --> 00:13:57,440
当然，您始终可以选择

298
00:13:57,440 --> 00:14:01,090
进入课堂论坛，询问更多有关澄清的信息。 

299
00:14:01,090 --> 00:14:05,160
最后，使用SwiftUI并不是那么重要

300
00:14:05,160 --> 00:14:09,110
因为这么多的自我点只是值类型。 

301
00:14:09,110 --> 00:14:12,840
例如，视图中的所有内容都是值类型。 

302
00:14:12,840 --> 00:14:15,170
我们的ViewModel，是一个类。 

303
00:14:15,170 --> 00:14:17,730
它有可能。 

304
00:14:17,730 --> 00:14:20,070
但是由于ViewModel从不指向任何东西

305
00:14:20,070 --> 00:14:22,160
在视图中，我们永远不必担心

306
00:14:22,160 --> 00:14:25,720
关于视图中创建这些内存周期的任何内容。 

307
00:14:25,720 --> 00:14:26,553
这将是非常罕见的。 

308
00:14:26,553 --> 00:14:28,840
可以做，但是非常非常罕见。 

309
00:14:28,840 --> 00:14:30,800
所以最重要的是，我认为您不必担心

310
00:14:30,800 --> 00:14:31,890
这么多。 

311
00:14:31,890 --> 00:14:33,240
唯一会困扰你的事情

312
00:14:33,240 --> 00:14:36,160
是你总是要把自我点

313
00:14:36,160 --> 00:14:37,500
在这些事情面前， 

314
00:14:37,500 --> 00:14:39,910
否则您将不得不处理此错误

315
00:14:39,910 --> 00:14:44,360
并执行此操作，单击它，然后一直进行修复。 

316
00:14:44,360 --> 00:14:47,290
同样，这只是您要做的事情

317
00:14:47,290 --> 00:14:49,750
直到这个公开事物的beta发布， 

318
00:14:49,750 --> 00:14:51,850
并希望在几个月内。 

319
00:14:51,850 --> 00:14:53,890
但是，最坏的情况是几个月。 

320
00:14:53,890 --> 00:14:56,380
在那之后，您将不必为此担心

321
00:14:56,380 --> 00:14:58,460
完全是因为不把自己放在这里

322
00:14:58,460 --> 00:15:02,120
当self是一个值类型时，不会生成此警告。 

323
00:15:02,120 --> 00:15:04,063
那就是建议的解决方法。 

324
00:15:05,330 --> 00:15:07,600
好吧，仅此而已。 

325
00:15:07,600 --> 00:15:10,290
这一切都是因为我们收到了这个警告

326
00:15:10,290 --> 00:15:12,180
告诉我们我们必须在这里逃跑

327
00:15:12,180 --> 00:15:16,288
因为确实，此函数确实会从此init逃脱

328
00:15:16,288 --> 00:15:18,530
因为我们把它放在这个变量中。 

329
00:15:18,530 --> 00:15:19,853
让我们做自己的身体。 

330
00:15:21,500 --> 00:15:24,180
我们的身体不是“你好，世界！”明显。 

331
00:15:24,180 --> 00:15:25,630
我们的身体实际上很简单。 

332
00:15:25,630 --> 00:15:28,985
这只是我们所有产品的前身。 

333
00:15:28,985 --> 00:15:31,993
对于我们的每个项目，我们将返回

334
00:15:31,993 --> 00:15:35,070
该Item的viewForItem。 

335
00:15:35,070 --> 00:15:37,345
我们将调用我们的函数viewForItem。 

336
00:15:37,345 --> 00:15:39,927
这是一个变量，这就是我们要称之为的函数。 

337
00:15:39,927 --> 00:15:41,480
当然，我们想要ForEach。 

338
00:15:41,480 --> 00:15:44,520
它还具有用于视图的转义功能， 

339
00:15:44,520 --> 00:15:46,663
所以我们必须说点自我。 

340
00:15:48,250 --> 00:15:52,050
这给我们带来了一些错误，让我们来看一下。 

341
00:15:52,050 --> 00:15:54,827
第一个说：“无法转换类型的值

342
00:15:54,827 --> 00:15:58,880
“预期参数类型为“ Range of Int”的项目数组。” 

343
00:15:58,880 --> 00:16:01,880
哦，不，我们看到了这个确切的论点问题

344
00:16:01,880 --> 00:16:05,230
当我们第一次在这里做ForEach时。 

345
00:16:05,230 --> 00:16:06,770
我们正在通过这张纸牌

346
00:16:06,770 --> 00:16:09,080
而且我们就像，哦，我以为我可以做到。 

347
00:16:09,080 --> 00:16:11,670
我们过去传递的零点数少于

348
00:16:11,670 --> 00:16:14,350
我们去了Array，我告诉过你

349
00:16:14,350 --> 00:16:16,310
此ForEach采用一个数组。 

350
00:16:16,310 --> 00:16:18,060
但是我们了解到这是一个数组

351
00:16:18,060 --> 00:16:21,160
只有可识别的事物。 

352
00:16:21,160 --> 00:16:23,580
所以我们在这里有同样的问题。 

353
00:16:23,580 --> 00:16:27,060
该项目的这个ForEach必须是一个数组

354
00:16:27,060 --> 00:16:29,290
可识别的事物。 

355
00:16:29,290 --> 00:16:33,730
嗯，这对我们来说是个问题，因为Item是无关紧要的。 

356
00:16:33,730 --> 00:16:36,260
我们不知道这是什么东西。 

357
00:16:36,260 --> 00:16:39,590
但是，这是我们在行为中获得约束和收获的地方。 

358
00:16:39,590 --> 00:16:44,590
我们要说项目在哪里可识别。 

359
00:16:44,640 --> 00:16:47,360
所以现在我们创建了一个仅适用于

360
00:16:47,360 --> 00:16:50,750
当您不在乎时，可以忽略此内容。 

361
00:16:50,750 --> 00:16:52,600
因此，这仍然可以是任何东西。 

362
00:16:52,600 --> 00:16:54,500
但是它必须是可识别的。 

363
00:16:54,500 --> 00:16:56,970
这就是我在幻灯片中所说的， 

364
00:16:56,970 --> 00:16:59,270
有点关心的事情。 

365
00:16:59,270 --> 00:17:00,910
我们有点关心Item。 

366
00:17:00,910 --> 00:17:02,833
我们关心它是可识别的。 

367
00:17:03,780 --> 00:17:05,905
所以现在我们这里有一个不同的错误。 

368
00:17:05,905 --> 00:17:07,287
这个ForEach错误是说

369
00:17:07,287 --> 00:17:10,967
“归还财产'身体'的类型”，这就是我们的身体， 

370
00:17:10,967 --> 00:17:15,680
“要求'ItemView'符合'View'。” 

371
00:17:15,680 --> 00:17:17,230
那么什么是ItemView？ 

372
00:17:17,230 --> 00:17:19,847
这是此函数的返回类型。 

373
00:17:19,847 --> 00:17:21,670
当然，这很有意义

374
00:17:21,670 --> 00:17:26,320
因为ForEach只能使用视图来拥有视图

375
00:17:26,320 --> 00:17:27,153
这些物品。 

376
00:17:27,153 --> 00:17:29,040
这必须是一个视图。 

377
00:17:29,040 --> 00:17:32,590
因此，这里的ViewForItem返回类型是ItemView， 

378
00:17:32,590 --> 00:17:33,680
它必须是一个视图。 

379
00:17:33,680 --> 00:17:34,930
那是什么类型？ 

380
00:17:34,930 --> 00:17:37,240
这也不在乎。 

381
00:17:37,240 --> 00:17:38,550
我们将在这里做同样的事情。 

382
00:17:38,550 --> 00:17:41,523
ItemView必须是一个View。 

383
00:17:42,550 --> 00:17:45,550
大家都看到了我们如何连接泛型， 

384
00:17:45,550 --> 00:17:50,550
这是带有协议的非常通用的结构。 

385
00:17:50,750 --> 00:17:55,420
这些是协议，我们正在使用它们来约束

386
00:17:55,420 --> 00:17:57,623
这些无关紧要的工作。 

387
00:18:00,140 --> 00:18:03,600
我们在这里要做的下一件事是我们是一个容器。 

388
00:18:03,600 --> 00:18:05,980
网格包含所有这些视图。 

389
00:18:05,980 --> 00:18:07,450
它将它们放在行和列中。 

390
00:18:07,450 --> 00:18:08,770
它包含它们。 

391
00:18:08,770 --> 00:18:11,530
而且我们知道容器的工作就是占用空间

392
00:18:11,530 --> 00:18:14,260
提供给他们并划分

393
00:18:14,260 --> 00:18:16,270
里面的东西。 

394
00:18:16,270 --> 00:18:18,660
这意味着我们需要找出多少空间

395
00:18:18,660 --> 00:18:19,997
已分配给我们。 

396
00:18:19,997 --> 00:18:21,580
我们知道该怎么做。 

397
00:18:21,580 --> 00:18:23,587
那就是GeometryReader。 

398
00:18:23,587 --> 00:18:24,883
好的，GeometryReader。 

399
00:18:26,050 --> 00:18:28,710
几何形状将允许我们

400
00:18:28,710 --> 00:18:31,350
找出给网格多少空间， 

401
00:18:31,350 --> 00:18:34,643
然后我们将要交给这些家伙。 

402
00:18:36,410 --> 00:18:37,593
所以，把它放在这里。 

403
00:18:38,620 --> 00:18:40,730
现在，一旦放在这里， 

404
00:18:40,730 --> 00:18:43,780
当然，我们会遇到物品的自残问题。 

405
00:18:43,780 --> 00:18:46,830
我将使用与上次相同的解决方案， 

406
00:18:46,830 --> 00:18:48,420
我要在这里创建一个名为

407
00:18:48,420 --> 00:18:49,570
主体（尺寸：CGSize）。 

408
00:18:51,330 --> 00:18:54,260
当然会返回一些视图。 

409
00:18:54,260 --> 00:18:58,907
我要把我的代码放在这里。 

410
00:18:58,907 --> 00:19:01,807
在这里，我要做一个self.body（for：geometry.size）。 

411
00:19:04,200 --> 00:19:05,820
再说一次，这纯粹是为了做到这一点

412
00:19:05,820 --> 00:19:08,950
因此我不必在此体内做自我标记。 

413
00:19:08,950 --> 00:19:11,610
就像GeometryReader逃逸一样

414
00:19:11,610 --> 00:19:13,420
所以我们做了这个self.body， 

415
00:19:13,420 --> 00:19:16,610
ForEach也正在逃避， 

416
00:19:16,610 --> 00:19:18,010
所以我要在这里做同样的事情

417
00:19:18,010 --> 00:19:19,560
self.body（用于商品，尺寸）。 

418
00:19:22,374 --> 00:19:23,820
我要搬到

419
00:19:25,540 --> 00:19:30,350
另一个小功能主体（用于物品，尺寸） 

420
00:19:30,350 --> 00:19:31,463
打开一些视图。 

421
00:19:33,050 --> 00:19:35,960
现在，我不需要在这里加点。 

422
00:19:35,960 --> 00:19:37,003
只是返回。 

423
00:19:38,780 --> 00:19:41,660
因此，我们在这里很好地安排了代码。 

424
00:19:41,660 --> 00:19:43,760
我们剩下要做的，信不信由你， 

425
00:19:43,760 --> 00:19:48,070
实际上是为这些视图提供我们的一些空间， 

426
00:19:48,070 --> 00:19:49,440
然后定位它们。 

427
00:19:49,440 --> 00:19:50,530
这就是容器的作用。 

428
00:19:50,530 --> 00:19:53,178
提供空间，他们就位。 

429
00:19:53,178 --> 00:19:54,970
为此，我们需要做一些数学运算

430
00:19:54,970 --> 00:19:56,550
因为我们得到了这个空间， 

431
00:19:56,550 --> 00:20:00,250
现在我们需要将其除以许多项

432
00:20:00,250 --> 00:20:01,840
我们在这里。 

433
00:20:01,840 --> 00:20:05,150
为了做那个数学，我实际上写了一些代码

434
00:20:05,150 --> 00:20:07,973
我给你的，我们将在这里使用。 

435
00:20:07,973 --> 00:20:09,350
让我们将其拖入。 

436
00:20:09,350 --> 00:20:11,410
顺便说一下，当您拖入代码时， 

437
00:20:11,410 --> 00:20:13,660
如果需要，请务必执行此操作。 

438
00:20:13,660 --> 00:20:15,370
几乎总是您想要的。 

439
00:20:15,370 --> 00:20:18,520
您希望将该代码的副本放入您的项目中。 

440
00:20:18,520 --> 00:20:21,250
否则，它将指向您的桌面

441
00:20:21,250 --> 00:20:22,850
或从何处拖动它。 

442
00:20:23,830 --> 00:20:25,430
好的，我们完成了。 

443
00:20:25,430 --> 00:20:27,310
因此，在这里让我们看一下这一点。 

444
00:20:27,310 --> 00:20:28,860
这是数学，这是GridLayout。 

445
00:20:28,860 --> 00:20:30,440
数学，它会进行此计算， 

446
00:20:30,440 --> 00:20:32,170
让我们来看一下。 

447
00:20:32,170 --> 00:20:37,170
现在，我在这里折叠了init和这两个var和func 

448
00:20:38,520 --> 00:20:41,680
因为我们不会看这些的实现。 

449
00:20:41,680 --> 00:20:44,530
在这堂课之后，我确实鼓励你， 

450
00:20:44,530 --> 00:20:47,190
去看看实现， 

451
00:20:47,190 --> 00:20:48,700
看看是否可以解决。 

452
00:20:48,700 --> 00:20:51,550
您需要本讲义的其余部分来掌握相关知识

453
00:20:51,550 --> 00:20:54,010
才能真正了解它在做什么， 

454
00:20:54,010 --> 00:20:56,380
但是尝试并理解这是一个很好的练习。 

455
00:20:56,380 --> 00:20:57,710
大约只有10行代码， 

456
00:20:57,710 --> 00:21:00,060
因此您应该不会有太多麻烦。 

457
00:21:00,910 --> 00:21:02,760
但是，这是GridLayout的作用。 

458
00:21:02,760 --> 00:21:07,760
其初始值设定项包含许多项目和一个大小， 

459
00:21:08,090 --> 00:21:10,510
并将其除以这些项目。 

460
00:21:10,510 --> 00:21:12,650
它完全符合Grid的要求。 

461
00:21:12,650 --> 00:21:17,310
现在，它甚至还允许您指定所需的宽高比。 

462
00:21:17,310 --> 00:21:20,200
它不能保证，但是可以尝试接近它。 

463
00:21:20,200 --> 00:21:23,350
就是这样，我们只需创建一个做到这一点的GridLayout。 

464
00:21:23,350 --> 00:21:25,530
然后我们在这里有一个变量，它将告诉我们大小

465
00:21:25,530 --> 00:21:27,180
大小相同的商品中， 

466
00:21:27,180 --> 00:21:28,680
所以这就是大小。 

467
00:21:28,680 --> 00:21:31,840
然后还将每个项目的位置作为一个点。 

468
00:21:31,840 --> 00:21:34,030
这是每个项目的中心， 

469
00:21:34,030 --> 00:21:36,120
同样，这正是Grid想要的。 

470
00:21:36,120 --> 00:21:38,600
所以GridLayout绝对是考虑到Grid的， 

471
00:21:38,600 --> 00:21:43,060
但这几乎是CGSize的通用划分

472
00:21:43,910 --> 00:21:46,710
一定数量的项目。 

473
00:21:46,710 --> 00:21:48,450
因此，让我们创建此GridLayout 

474
00:21:48,450 --> 00:21:50,280
通过在此处调用此初始化程序。 

475
00:21:50,280 --> 00:21:53,430
我要在我的GeometryReader中完成它。 

476
00:21:53,430 --> 00:21:56,930
实际上，我将更改此尺寸的传递

477
00:21:56,930 --> 00:21:59,890
而是传递GridLayout。 

478
00:21:59,890 --> 00:22:03,000
而itemCount只是Items的数量

479
00:22:03,000 --> 00:22:03,860
我们有。 

480
00:22:03,860 --> 00:22:07,180
这是我们的项目Array，在这里，其数量。 

481
00:22:07,180 --> 00:22:10,620
我将跳过所需的宽高比的东西。 

482
00:22:10,620 --> 00:22:13,260
我们将使用任何默认值。 

483
00:22:13,260 --> 00:22:15,410
希望您在阅读中看到可以

484
00:22:15,410 --> 00:22:19,040
函数的默认参数，并且GridLayout使用它。 

485
00:22:19,040 --> 00:22:20,350
但是你一定要有尺寸

486
00:22:20,350 --> 00:22:24,057
这当然是在geometry.size中。 

487
00:22:24,057 --> 00:22:26,310
而且我们仍然在这里的GeometryReader 

488
00:22:26,310 --> 00:22:29,130
所以这个项目必须是self.items。 

489
00:22:29,130 --> 00:22:31,103
这是一个实例变量。 

490
00:22:32,220 --> 00:22:33,520
因此，我更改了此正文。 

491
00:22:33,520 --> 00:22:37,963
现在不再是尺寸的主体，而是布局的主体。 

492
00:22:39,450 --> 00:22:40,773
GridLayout在这里。 

493
00:22:42,080 --> 00:22:44,680
同样，我将不得不通过

494
00:22:44,680 --> 00:22:46,830
所以现在是body（for：项目，in：布局）。 

495
00:22:49,383 --> 00:22:52,590
所以这也使它成为布局， 

496
00:22:52,590 --> 00:22:54,453
沿线向下传递。 

497
00:22:56,140 --> 00:22:58,460
现在我们在这里，我们有了这个布局， 

498
00:22:58,460 --> 00:23:01,970
并且我们已经按照尺寸大小列出了商品的数量。 

499
00:23:01,970 --> 00:23:06,660
因此，我们可以轻松地进行诸如为这些视图提供空间， 

500
00:23:06,660 --> 00:23:08,470
我们用框架来做。 

501
00:23:08,470 --> 00:23:10,270
所以我们要说框架的宽度

502
00:23:10,270 --> 00:23:13,600
是布局的itemSize.width， 

503
00:23:13,600 --> 00:23:18,133
框架的高度为layout.itemSize.height。 

504
00:23:18,133 --> 00:23:21,490
我们将提供相同的小空间

505
00:23:21,490 --> 00:23:25,330
每个物品的空间。 

506
00:23:25,330 --> 00:23:28,680
这就是GridLayout中的itemSize。 

507
00:23:28,680 --> 00:23:31,570
再次，GridLayout创建了这么多项目

508
00:23:31,570 --> 00:23:33,440
在提供给我们的尺寸上。 

509
00:23:33,440 --> 00:23:35,510
这就是我们将其划分的方式。 

510
00:23:35,510 --> 00:23:37,860
然后我们必须定位视图

511
00:23:37,860 --> 00:23:39,410
所以我们按位置来做。 

512
00:23:39,410 --> 00:23:41,380
这就是我们要做的功能。 

513
00:23:41,380 --> 00:23:45,570
我们将其放置在版面的位置

514
00:23:45,570 --> 00:23:48,000
ofItemAt索引。 

515
00:23:48,000 --> 00:23:51,630
因此，这已被索引，就像我们使用卡片时一样。 

516
00:23:51,630 --> 00:23:55,230
所以我们必须找到该项目的索引

517
00:23:55,230 --> 00:23:57,173
在我们的商品数组中。 

518
00:23:58,040 --> 00:23:59,460
没问题，我们有点知道该怎么做。 

519
00:23:59,460 --> 00:24:01,850
我们说让索引相等， 

520
00:24:01,850 --> 00:24:03,690
嗯，我知道该怎么做。 

521
00:24:03,690 --> 00:24:08,620
我要在此商品的自我索引上创建一个函数。 

522
00:24:09,460 --> 00:24:12,777
我要去这里说（项的）func索引。 

523
00:24:14,541 --> 00:24:18,320
并且它将返回一个Int，即数组的索引。 

524
00:24:18,320 --> 00:24:20,570
我们先在这里返回零

525
00:24:20,570 --> 00:24:23,340
然后我们马上填写。 

526
00:24:23,340 --> 00:24:25,780
现在，这将再次让Swift感到困惑

527
00:24:25,780 --> 00:24:28,080
因为您有索引，此局部变量， 

528
00:24:28,080 --> 00:24:30,640
然后索引此函数。 

529
00:24:30,640 --> 00:24:34,260
因此，我们可以用相同的方法再次修复该问题。 

530
00:24:34,260 --> 00:24:37,710
现在知道该索引是函数， 

531
00:24:37,710 --> 00:24:40,890
这个索引是我们正在创建的局部变量。 

532
00:24:40,890 --> 00:24:43,000
因此，我们实际上使用了自我点。 

533
00:24:43,000 --> 00:24:46,870
即使他们使用值类型进行更改

534
00:24:46,870 --> 00:24:49,350
没有像这样标记自我点， 

535
00:24:49,350 --> 00:24:51,600
我们有时还是想使用自点

536
00:24:51,600 --> 00:24:56,410
定义属性之间的区别

537
00:24:56,410 --> 00:24:58,480
或函数与局部变量

538
00:24:58,480 --> 00:25:00,173
或函数的参数。 

539
00:25:01,660 --> 00:25:04,410
好吧，在这里的索引中，我们如何找到该项目

540
00:25:04,410 --> 00:25:05,243
在数组中？ 

541
00:25:05,243 --> 00:25:06,270
好吧，你猜怎么着？ 

542
00:25:06,270 --> 00:25:09,000
这些项目是可识别的。 

543
00:25:09,000 --> 00:25:10,387
也许你们当中有些像

544
00:25:10,387 --> 00:25:12,530
“嗯，这似乎太熟悉了。” 

545
00:25:12,530 --> 00:25:15,160
是的，我们要做索引

546
00:25:15,160 --> 00:25:19,470
以零点表示的点数小于items.count 

547
00:25:19,470 --> 00:25:20,540
我们有。 

548
00:25:20,540 --> 00:25:24,590
如果该[index] .id中的项目

549
00:25:24,590 --> 00:25:27,590
等于该商品的ID， 

550
00:25:27,590 --> 00:25:30,985
然后我们将返回该索引。 

551
00:25:30,985 --> 00:25:33,120
否则我们将返回零， 

552
00:25:33,120 --> 00:25:38,120
这与我们上次这样做一样虚假。 

553
00:25:38,320 --> 00:25:41,900
现在，此功能有点双重伪造。 

554
00:25:41,900 --> 00:25:44,850
这是虚假的，因为我们仍在执行此返回零。 

555
00:25:44,850 --> 00:25:47,060
换句话说，如果我们找不到项目

556
00:25:47,060 --> 00:25:50,070
在我们的商品中，我们将只退回第一件商品， 

557
00:25:50,070 --> 00:25:51,387
索引为零。 

558
00:25:51,387 --> 00:25:52,800
真是假

559
00:25:52,800 --> 00:25:56,220
但是，还有一个错误是，这段代码是完全一样的， 

560
00:25:56,220 --> 00:26:01,220
是的，因为此代码在我们的模型中。 

561
00:26:01,520 --> 00:26:03,770
所以，伙计，你永远不想写

562
00:26:03,770 --> 00:26:06,160
完全一样的代码，像这样两次。 

563
00:26:06,160 --> 00:26:09,400
那只是糟糕的编程。 

564
00:26:09,400 --> 00:26:11,850
好吧，我们会在一分钟内解决它。 

565
00:26:11,850 --> 00:26:13,820
但是首先让我们看看我们的网格是否有效。 

566
00:26:13,820 --> 00:26:16,200
信不信由你，这就是我们网格所需要的。 

567
00:26:16,200 --> 00:26:17,033
没有别的了。 

568
00:26:17,033 --> 00:26:19,390
因此，我们得到了提供给我们的空间。 

569
00:26:19,390 --> 00:26:21,640
我们使用此GridLayout对其进行划分， 

570
00:26:21,640 --> 00:26:25,800
然后我们将其提供给其中的小子视图， 

571
00:26:25,800 --> 00:26:28,370
然后我们将它们放置在那些位置

572
00:26:28,370 --> 00:26:29,871
在GridLayout中。 

573
00:26:29,871 --> 00:26:33,000
这就是所需要的，所以让我们在这里进行一下测试。 

574
00:26:33,000 --> 00:26:34,023
看看是否有效。 

575
00:26:35,478 --> 00:26:36,450
嗯，确实如此。 

576
00:26:36,450 --> 00:26:39,410
瞧瞧，我们的六张卡已不再连续。 

577
00:26:39,410 --> 00:26:43,190
让我们去风景，看看，它调整了卡片的大小

578
00:26:43,190 --> 00:26:44,600
以更好地适应空间。 

579
00:26:44,600 --> 00:26:46,700
现在，我想要一点填充

580
00:26:46,700 --> 00:26:50,000
卡之间，但这是回事

581
00:26:50,000 --> 00:26:52,040
当我们创建CardView时

582
00:26:52,040 --> 00:26:55,460
我们可以在上面放一些填充物。 

583
00:26:55,460 --> 00:26:57,990
如果我们在这些CardView周围放置一些填充

584
00:26:57,990 --> 00:27:00,790
在网格内部，嗯，我们得到了填充。 

585
00:27:00,790 --> 00:27:01,900
很好。 

586
00:27:01,900 --> 00:27:03,670
也许我们不需要太多填充。 

587
00:27:03,670 --> 00:27:06,840
也许我们只想填充五个。 

588
00:27:06,840 --> 00:27:07,743
运行它。 

589
00:27:10,179 --> 00:27:11,829
呵呵，看起来不错。 

590
00:27:12,970 --> 00:27:15,820
好的，既然我们的网格正在工作， 

591
00:27:15,820 --> 00:27:19,110
让我们去修复我们这里存在的虚假代码， 

592
00:27:19,110 --> 00:27:21,510
这是项目的索引。 

593
00:27:21,510 --> 00:27:23,460
这是假的，因为这完全重复了

594
00:27:23,460 --> 00:27:24,810
这另一件事。 

595
00:27:24,810 --> 00:27:26,933
让我们考虑一下这里发生的事情。 

596
00:27:26,933 --> 00:27:30,810
在这两种情况下，我们实际上是在要求什么？ 

597
00:27:30,810 --> 00:27:34,660
我们有一系列可识别的事物， 

598
00:27:34,660 --> 00:27:38,010
希望我们有其中之一。 

599
00:27:38,010 --> 00:27:40,500
我们知道它也是可识别的。 

600
00:27:40,500 --> 00:27:42,870
我们想看看是否可以找到它。 

601
00:27:42,870 --> 00:27:46,823
因此，听起来更像是Array。 

602
00:27:48,630 --> 00:27:51,460
让我们向Array添加一个执行此操作的函数。 

603
00:27:51,460 --> 00:27:53,123
扩展数组。 

604
00:27:54,190 --> 00:27:59,190
但仅限于数组中的元素

605
00:27:59,730 --> 00:28:01,390
是可识别的。 

606
00:28:01,390 --> 00:28:03,873
因此，它又是制约与收获。 

607
00:28:04,890 --> 00:28:07,930
此扩展仅将添加此功能

608
00:28:07,930 --> 00:28:10,483
我们想要添加到此类数组中的内容。 

609
00:28:11,380 --> 00:28:12,700
因此，它是相同的功能。 

610
00:28:12,700 --> 00:28:14,250
实际上，我只是要复制并粘贴

611
00:28:14,250 --> 00:28:16,820
我们将对其进行修改，甚至剪切并粘贴。 

612
00:28:16,820 --> 00:28:18,073
切掉那边。 

613
00:28:19,180 --> 00:28:20,370
将此粘贴在这里。 

614
00:28:20,370 --> 00:28:21,740
这里不一样

615
00:28:21,740 --> 00:28:23,883
因为我们在这里看物品。 

616
00:28:24,780 --> 00:28:27,420
显然，这是一个数组函数， 

617
00:28:27,420 --> 00:28:29,790
所以现在物品是自我。 

618
00:28:29,790 --> 00:28:30,910
还有同样的事情。 

619
00:28:30,910 --> 00:28:32,320
这不是物品的数量。 

620
00:28:32,320 --> 00:28:34,163
这是自我的计数。 

621
00:28:35,312 --> 00:28:39,470
这个项目的类型，项目的索引，不是项目。 

622
00:28:39,470 --> 00:28:42,540
这是元素，因为这就是我们要寻找的

623
00:28:42,540 --> 00:28:43,373
在一个数组。 

624
00:28:43,373 --> 00:28:46,170
我们有一个数组，其元素都是可识别的

625
00:28:46,170 --> 00:28:48,630
我们在这里说的是获取索引

626
00:28:48,630 --> 00:28:52,010
可识别的此数组的元素之一

627
00:28:52,010 --> 00:28:52,973
通过查找。 

628
00:28:54,270 --> 00:28:57,410
现在，这是正确的，这做对了， 

629
00:28:57,410 --> 00:29:01,330
但实际上我不喜欢在这里选择的命名。 

630
00:29:01,330 --> 00:29:03,980
关于这一点的一件事是它实际上并没有返回

631
00:29:03,980 --> 00:29:06,310
该项目的索引。 

632
00:29:06,310 --> 00:29:10,120
它返回找到的第一个。 

633
00:29:10,120 --> 00:29:12,870
从零开始遍历数组， 

634
00:29:12,870 --> 00:29:15,280
当找到一个时，将其返回。 

635
00:29:15,280 --> 00:29:19,743
因此，这确实是此项的第一个索引。 

636
00:29:20,780 --> 00:29:22,860
我也不喜欢这个词。 

637
00:29:22,860 --> 00:29:25,230
项目在网格中有意义

638
00:29:25,230 --> 00:29:26,260
因为我们有物品。 

639
00:29:26,260 --> 00:29:28,140
“项目”一词遍地都是。 

640
00:29:28,140 --> 00:29:31,690
但实际上在Array中，Item不是一回事。 

641
00:29:31,690 --> 00:29:34,270
有元素，但没有项目。 

642
00:29:34,270 --> 00:29:37,470
实际上，这是第一个索引

643
00:29:37,470 --> 00:29:40,220
匹配该元素。 

644
00:29:40,220 --> 00:29:44,370
所以我将使用firstIndex匹配作为我的名字。 

645
00:29:44,370 --> 00:29:47,100
感觉更像是Array函数， 

646
00:29:47,100 --> 00:29:49,103
firstIndex与此元素匹配。 

647
00:29:50,100 --> 00:29:52,080
那么，我们如何在这里使用它呢？ 

648
00:29:52,080 --> 00:29:53,730
而不是self.index， 

649
00:29:53,730 --> 00:29:57,290
我们只是说项目，数组， 

650
00:29:57,290 --> 00:30:02,290
点firstIndex匹配项。 

651
00:30:03,720 --> 00:30:06,150
因此，我们要求Array立即执行此操作， 

652
00:30:06,150 --> 00:30:09,290
去找到与该项目匹配的第一个索引。 

653
00:30:09,290 --> 00:30:11,610
我们可以在这里做完全相同的事情。 

654
00:30:11,610 --> 00:30:14,260
我们甚至不再需要此功能。 

655
00:30:14,260 --> 00:30:17,740
我们在这里得到它是因为我们知道我们的卡阵列

656
00:30:17,740 --> 00:30:22,740
在这里可以做与Card匹配的firstIndex。 

657
00:30:26,000 --> 00:30:27,700
因此，我们正在重用此代码。 

658
00:30:27,700 --> 00:30:31,030
看看我们的模型有多小。 

659
00:30:31,030 --> 00:30:33,307
它很小，这里几乎没有任何代码。 

660
00:30:33,307 --> 00:30:35,670
其中一些是因为我们刚刚制作了Array 

661
00:30:35,670 --> 00:30:38,140
查找此功能的功能更强大。 

662
00:30:38,140 --> 00:30:39,380
与网格相同。 

663
00:30:39,380 --> 00:30:42,180
网格的代码量很少

664
00:30:42,180 --> 00:30:44,580
因为我们利用了这个数组。 

665
00:30:44,580 --> 00:30:47,320
现在，这与Grid无关。 

666
00:30:47,320 --> 00:30:50,040
因此它不属于Grid.swift。 

667
00:30:50,040 --> 00:30:53,410
因此，我将其剪切为Grid.swift。 

668
00:30:53,410 --> 00:30:56,803
我将其放入自己的文件中。 

669
00:30:58,150 --> 00:30:59,550
它不是SwiftUI视图。 

670
00:30:59,550 --> 00:31:01,360
这只是一个普通的Swift文件。 

671
00:31:01,360 --> 00:31:04,140
现在，当我们进行这样的扩展时， 

672
00:31:04,140 --> 00:31:08,010
我们通常将文件扩展名为Array，我们正在扩展的东西， 

673
00:31:08,010 --> 00:31:10,500
加上某种描述符

674
00:31:10,500 --> 00:31:12,210
是什么样的东西

675
00:31:12,210 --> 00:31:16,080
因此，这是可识别的

676
00:31:16,080 --> 00:31:17,963
数组+可识别。 

677
00:31:19,220 --> 00:31:20,540
因此，让我们进入这里。 

678
00:31:20,540 --> 00:31:21,610
在那里。 

679
00:31:21,610 --> 00:31:22,730
粘贴进去。 

680
00:31:22,730 --> 00:31:26,720
请注意，这是导入基金会， 

681
00:31:26,720 --> 00:31:28,200
很好。 

682
00:31:28,200 --> 00:31:29,033
这不是UI问题。 

683
00:31:29,033 --> 00:31:32,510
这纯粹是数组和可标识的。 

684
00:31:32,510 --> 00:31:34,193
这些都不是UI的东西。 

685
00:31:35,500 --> 00:31:37,360
所以我们回到网格。 

686
00:31:37,360 --> 00:31:40,437
在这里进行构建，以便它注意到所有这些东西。 

687
00:31:40,437 --> 00:31:44,830
并确保我们的模型也可以正常工作。 

688
00:31:44,830 --> 00:31:47,480
没有错误，实际上，我们整个程序都没有错误。 

689
00:31:47,480 --> 00:31:50,863
让我们运行，确保数组确实正在执行。 

690
00:31:53,770 --> 00:31:58,020
好的，我们再次使用整个概念

691
00:31:58,020 --> 00:31:59,280
的约束和收获。 

692
00:31:59,280 --> 00:32:04,060
在这里，我们限制了数组的无关类型

693
00:32:04,060 --> 00:32:05,500
这样就可以识别它们

694
00:32:05,500 --> 00:32:07,970
这样我们就可以使用此功能。 

695
00:32:07,970 --> 00:32:11,640
对于所有标识了元素的数组，它们都会得到此结果。 

696
00:32:11,640 --> 00:32:15,060
没有没有可识别元素的数组， 

697
00:32:15,060 --> 00:32:17,223
他们甚至看不到此功能。 

698
00:32:17,223 --> 00:32:19,310
甚至在Xcode中也无法完全逃脱。 

699
00:32:19,310 --> 00:32:20,313
甚至不在那里。 

700
00:32:21,740 --> 00:32:22,650
而且我们正在做同样的事情

701
00:32:22,650 --> 00:32:24,280
在这里有限制和收获

702
00:32:24,280 --> 00:32:27,100
使其成为我们的网格始终是网格

703
00:32:27,100 --> 00:32:31,670
可识别的事物，将两个事物匹配为视图。 

704
00:32:31,670 --> 00:32:33,100
本演示就是这样。 

705
00:32:33,100 --> 00:32:35,860
所以我要回到幻灯片， 

706
00:32:35,860 --> 00:32:37,930
我们将解决此问题。 

707
00:32:37,930 --> 00:32:40,700
我们需要Swift中称为Optional的类型， 

708
00:32:40,700 --> 00:32:43,540
一个非常非常重要的类型，它是一个枚举。 

709
00:32:43,540 --> 00:32:46,060
因此，让我们快速回顾一下枚举是什么， 

710
00:32:46,060 --> 00:32:47,360
然后我们将讨论

711
00:32:47,360 --> 00:32:49,785
这个非常重要的类型，可选。 

712
00:32:49,785 --> 00:32:53,250
枚举只是另一种类型，例如struct或class， 

713
00:32:53,250 --> 00:32:57,320
但是对于枚举，该值是离散的。 

714
00:32:57,320 --> 00:33:01,120
这里的好例子，FastFoodMenuItem是一个汉堡包

715
00:33:01,120 --> 00:33:03,350
还是薯条，饮料或饼干。 

716
00:33:03,350 --> 00:33:04,260
别无其他

717
00:33:04,260 --> 00:33:05,900
要成为这四件事之一。 

718
00:33:05,900 --> 00:33:07,480
那是菜单上唯一的东西， 

719
00:33:07,480 --> 00:33:10,683
它必须是其中之一，并且只是其中之一。 

720
00:33:11,900 --> 00:33:15,350
像结构一样，枚举是一种值类型。 

721
00:33:15,350 --> 00:33:17,290
传递时被复制。 

722
00:33:17,290 --> 00:33:18,400
它不存在于堆中。 

723
00:33:18,400 --> 00:33:19,970
没有指向它的指针。 

724
00:33:19,970 --> 00:33:21,253
这是一个值类型。 

725
00:33:22,410 --> 00:33:25,690
现在，Swift中的枚举最酷的地方是

726
00:33:25,690 --> 00:33:27,840
与大多数其他语言不同， 

727
00:33:27,840 --> 00:33:30,240
是每个离散值

728
00:33:30,240 --> 00:33:32,267
可以有一些相关的数据

729
00:33:32,267 --> 00:33:35,840
这是特定于特定离散值的。 

730
00:33:35,840 --> 00:33:39,570
例如，我们这里有汉堡包。 

731
00:33:39,570 --> 00:33:41,670
如果FastFoodMenuItem是一个汉堡包， 

732
00:33:41,670 --> 00:33:43,380
我们要说多少馅饼？ 

733
00:33:43,380 --> 00:33:46,360
这是两倍还是三倍还是单倍？ 

734
00:33:46,360 --> 00:33:49,910
如果是薯条，这是大薯条还是小薯条？ 

735
00:33:49,910 --> 00:33:54,110
如果是饮料，您会在那看到，您有饮料， 

736
00:33:54,110 --> 00:33:57,080
是可乐，胡椒博士等等。 

737
00:33:57,080 --> 00:33:59,100
请注意，这里没有为String命名， 

738
00:33:59,100 --> 00:34:01,680
因此这些东西不必一定要有名字。 

739
00:34:01,680 --> 00:34:04,980
您在这里看到的这种黄色语法

740
00:34:04,980 --> 00:34:07,990
从阅读中可能看起来很熟悉。 

741
00:34:07,990 --> 00:34:09,703
这只是一个元组。 

742
00:34:11,060 --> 00:34:15,190
因此，所有元组规则都允许您使用标签

743
00:34:15,190 --> 00:34:18,600
或没有标签，并在这里有您想要的数量， 

744
00:34:18,600 --> 00:34:20,440
全部完全有效

745
00:34:20,440 --> 00:34:23,023
作为此处的关联数据值。 

746
00:34:25,170 --> 00:34:28,040
那么如何设置枚举的值呢？ 

747
00:34:28,040 --> 00:34:29,550
非常简单

748
00:34:29,550 --> 00:34:31,970
你只说枚举的名字， 

749
00:34:31,970 --> 00:34:35,750
如FastFoodMenuItem，点，离散值， 

750
00:34:35,750 --> 00:34:38,830
汉堡或饼干，例如这里。 

751
00:34:38,830 --> 00:34:41,890
现在，当然，如果有关联的数据， 

752
00:34:41,890 --> 00:34:44,630
您必须提供相关数据。 

753
00:34:44,630 --> 00:34:47,566
在这种情况下，汉堡（馅饼：2）。 

754
00:34:47,566 --> 00:34:51,233
它无法制造汉堡包

755
00:34:51,233 --> 00:34:53,220
如果不知道有多少馅饼

756
00:34:54,160 --> 00:34:56,230
现在Swift可以在这里进行类型推断

757
00:34:56,230 --> 00:34:58,750
这样您就不必键入FastFoodMenuItem 

758
00:34:58,750 --> 00:35:01,130
双方平等。 

759
00:35:01,130 --> 00:35:02,670
但是您必须小心一点。 

760
00:35:02,670 --> 00:35:04,770
你必须把它放在平等的一面

761
00:35:04,770 --> 00:35:06,560
因为如果你只是说

762
00:35:06,560 --> 00:35:09,030
var yetAnotherItem等于Cookie， 

763
00:35:09,030 --> 00:35:10,950
Swift没有足够的信息

764
00:35:10,950 --> 00:35:14,030
推断我们在这里谈论快餐菜单项。 

765
00:35:14,030 --> 00:35:16,355
可能是任何有cookie的东西。 

766
00:35:16,355 --> 00:35:20,210
所以你必须在某个地方出现FastFoodMenuItem 

767
00:35:20,210 --> 00:35:22,123
以便Swift可以推断。 

768
00:35:23,660 --> 00:35:25,760
我们如何检查值？ 

769
00:35:25,760 --> 00:35:27,830
您可能会认为这就像一个假设。 

770
00:35:27,830 --> 00:35:30,943
你知道，如果这个菜单项等于一个汉堡， 

771
00:35:30,943 --> 00:35:32,250
然后做点什么。 

772
00:35:32,250 --> 00:35:33,710
但是我们不使用if枚举。 

773
00:35:33,710 --> 00:35:36,510
我们使用此表达式开关。 

774
00:35:36,510 --> 00:35:38,600
现在，开关以其他语言存在。 

775
00:35:38,600 --> 00:35:40,230
它在Swift中非常强大， 

776
00:35:40,230 --> 00:35:43,410
不仅用于检查您将要看到的枚举， 

777
00:35:43,410 --> 00:35:45,170
但是它有正则表达式匹配

778
00:35:45,170 --> 00:35:46,003
和各种各样的东西。 

779
00:35:46,003 --> 00:35:48,310
再一次，你希望读到

780
00:35:48,310 --> 00:35:49,683
在阅读作业中。 

781
00:35:50,960 --> 00:35:53,670
因此，如果我想检查menuItem的值， 

782
00:35:53,670 --> 00:35:55,100
我要打开menuItem， 

783
00:35:55,100 --> 00:35:57,340
然后有一个案例陈述

784
00:35:57,340 --> 00:35:59,547
对于每个可能的menuItem。 

785
00:35:59,547 --> 00:36:02,860
它必须是每一个。 

786
00:36:02,860 --> 00:36:05,350
现在，我不在这里

787
00:36:05,350 --> 00:36:08,850
关联的数据，在这里我可以忽略它。 

788
00:36:08,850 --> 00:36:12,320
我仍然可以看到FastFoodMenuItem.hamburger的情况

789
00:36:12,320 --> 00:36:13,950
打印单词burger。 

790
00:36:13,950 --> 00:36:15,650
我不能说是多少馅饼

791
00:36:15,650 --> 00:36:17,720
因为我没有看相关的数据。 

792
00:36:17,720 --> 00:36:19,080
我要告诉你一秒钟。 

793
00:36:19,080 --> 00:36:21,773
但是我仍然可以在这里打印汉堡。 

794
00:36:23,350 --> 00:36:25,430
斯威夫特当然可以推断

795
00:36:25,430 --> 00:36:27,090
这些都是快餐菜单项， 

796
00:36:27,090 --> 00:36:28,050
所以你不必说

797
00:36:28,050 --> 00:36:31,390
每次都是FastFoodMenuItem.hamburger。 

798
00:36:31,390 --> 00:36:32,970
您可以仅打开menuItem。 

799
00:36:32,970 --> 00:36:35,190
使用.hamburger，.fries和.drink。 

800
00:36:35,190 --> 00:36:38,473
在这种情况下，它知道menuItem是FastFoodMenuItem。 

801
00:36:40,260 --> 00:36:42,430
顺便说一句，开关要求您遮盖

802
00:36:42,430 --> 00:36:44,110
每一个可能的情况。 

803
00:36:44,110 --> 00:36:46,310
因此，您可能会有一个案例，例如汉堡包， 

804
00:36:46,310 --> 00:36:47,180
你不在乎的

805
00:36:47,180 --> 00:36:49,450
您不想打印出汉堡包。 

806
00:36:49,450 --> 00:36:51,380
在这种情况下，您可以说休息一下。 

807
00:36:51,380 --> 00:36:53,980
因此，突破突围， 

808
00:36:53,980 --> 00:36:57,120
并说案子.hamburger中断意味着它将无能为力

809
00:36:57,120 --> 00:37:00,000
如果菜单项是汉堡包。 

810
00:37:00,000 --> 00:37:03,310
同样，如果您真的只关心几种情况

811
00:37:03,310 --> 00:37:06,120
其他所有，您都可以执行一些默认行为， 

812
00:37:06,120 --> 00:37:08,790
您可以使用特殊关键字default。 

813
00:37:08,790 --> 00:37:12,010
因此，如果您未列出，则会发生默认情况

814
00:37:12,010 --> 00:37:13,890
具体情况。 

815
00:37:13,890 --> 00:37:15,050
但是您必须做另一件事。 

816
00:37:15,050 --> 00:37:17,210
要么你有所有的情况

817
00:37:17,210 --> 00:37:19,470
而那些你不在乎的人会爆发出来， 

818
00:37:19,470 --> 00:37:21,090
或者你只能有一些情况， 

819
00:37:21,090 --> 00:37:22,863
但是您必须提供此默认情况。 

820
00:37:22,863 --> 00:37:24,870
通常在交换机中是必需的。 

821
00:37:24,870 --> 00:37:27,070
不只是枚举，而且在Swift中， 

822
00:37:27,070 --> 00:37:29,850
开关需要完全覆盖

823
00:37:29,850 --> 00:37:31,273
所有的可能性。 

824
00:37:33,350 --> 00:37:35,150
那相关的数据呢？ 

825
00:37:35,150 --> 00:37:37,280
好吧，我们也可以在切换中做到这一点。 

826
00:37:37,280 --> 00:37:40,100
我们只在这里以黄色添加您看到的内容

827
00:37:40,100 --> 00:37:41,820
当我们说案例。汉堡时， 

828
00:37:41,820 --> 00:37:44,570
我们说括号，让pattyCount。 

829
00:37:44,570 --> 00:37:47,380
这将获取与汉堡相关的数据

830
00:37:47,380 --> 00:37:51,490
并将其分配给这个很小的局部变量pattyCount 

831
00:37:51,490 --> 00:37:54,070
仅对此打印语句有效

832
00:37:54,070 --> 00:37:57,130
或这个汉堡之后发生的一切。 

833
00:37:57,130 --> 00:37:59,060
炸薯条也是一样。 

834
00:37:59,060 --> 00:38:01,350
例如，这种饮料很有趣。 

835
00:38:01,350 --> 00:38:04,640
因此，饮料将抢占品牌和盎司。 

836
00:38:04,640 --> 00:38:08,320
请注意，盎司在我声明时曾经带有标签， 

837
00:38:08,320 --> 00:38:11,016
但是我没有在那做，没关系

838
00:38:11,016 --> 00:38:11,849
因为这是元组。 

839
00:38:11,849 --> 00:38:15,560
元组，如果要在两面都可以使用标签， 

840
00:38:15,560 --> 00:38:16,880
声明和使用它。 

841
00:38:16,880 --> 00:38:20,060
因此，这是完全相同的事情

842
00:38:20,060 --> 00:38:22,850
您可以在其中获取关联的值

843
00:38:22,850 --> 00:38:24,583
但是，您想抓住它。 

844
00:38:26,500 --> 00:38:28,600
好吧，让我们看看。 

845
00:38:28,600 --> 00:38:32,730
方法，是的，您可以在枚举上使用方法。 

846
00:38:32,730 --> 00:38:36,000
无论您想做什么，它几乎都是无限的。 

847
00:38:36,000 --> 00:38:39,350
属性，您可以计算出属性， 

848
00:38:39,350 --> 00:38:41,910
但是您不能有任何存储的属性。 

849
00:38:41,910 --> 00:38:44,720
带有枚举的所有存储

850
00:38:44,720 --> 00:38:47,260
仅在这些关联的值中， 

851
00:38:47,260 --> 00:38:50,200
有点意思，因为一个枚举是一个离散的事情。 

852
00:38:50,200 --> 00:38:52,900
拥有其他数据真的没有任何意义

853
00:38:52,900 --> 00:38:54,110
适用于所有这些。 

854
00:38:54,110 --> 00:38:55,410
那不是离散的。 

855
00:38:56,402 --> 00:38:58,993
因此，这就是为什么您必须这样做。 

856
00:39:02,250 --> 00:39:03,170
开启自我。 

857
00:39:03,170 --> 00:39:07,190
好吧，如果您的枚举中包含函数， 

858
00:39:07,190 --> 00:39:09,870
它实际上应该告诉你一些东西

859
00:39:09,870 --> 00:39:12,210
关于枚举，这是很常见的

860
00:39:12,210 --> 00:39:13,520
具有这些功能。 

861
00:39:13,520 --> 00:39:17,340
这里我有这个函数isIncludedInSpecialOrder号， 

862
00:39:17,340 --> 00:39:20,610
会说这个FastFoodMenuItem 

863
00:39:20,610 --> 00:39:22,910
包含在特定的特殊顺序中。 

864
00:39:22,910 --> 00:39:25,830
为此，我必须打开自己

865
00:39:25,830 --> 00:39:28,470
看看我是什么，看看我是否被包括在内

866
00:39:28,470 --> 00:39:29,790
以这种特殊的顺序。 

867
00:39:29,790 --> 00:39:32,400
这样您就可以看到我有很多示例。 

868
00:39:32,400 --> 00:39:35,620
我想更仔细地研究这些例子之一， 

869
00:39:35,620 --> 00:39:37,610
这是这个饮料的例子。 

870
00:39:37,610 --> 00:39:41,480
请注意，它正在开关中获取关联的值

871
00:39:41,480 --> 00:39:43,910
盎司，但它忽略了

872
00:39:43,910 --> 00:39:45,280
无论是可乐还是胡椒博士。 

873
00:39:45,280 --> 00:39:46,490
我们不在乎。 

874
00:39:46,490 --> 00:39:48,570
是否包含在内都没有关系

875
00:39:48,570 --> 00:39:49,890
以特殊的顺序。 

876
00:39:49,890 --> 00:39:54,290
因此，此下标是无需关注的地方， 

877
00:39:54,290 --> 00:39:56,330
本质上，我不感兴趣。 

878
00:39:56,330 --> 00:39:58,140
就像我们有功能一样

879
00:39:58,140 --> 00:40:00,770
它具有带有外部名称的参数

880
00:40:00,770 --> 00:40:03,160
和内部名称，我们使用下划线表示

881
00:40:03,160 --> 00:40:05,610
我们对外部名称不感兴趣，请勿使用它。 

882
00:40:05,610 --> 00:40:07,290
这也是这里的意思。 

883
00:40:07,290 --> 00:40:10,740
所以这就是如果您有一些相关的价值

884
00:40:10,740 --> 00:40:12,260
作为具有多个要素的元组， 

885
00:40:12,260 --> 00:40:14,020
您可以忽略其中一些

886
00:40:14,020 --> 00:40:15,570
当您获取值时。 

887
00:40:19,890 --> 00:40:22,140
枚举可以通过协议来约束和收获

888
00:40:22,140 --> 00:40:24,320
就像结构和类一样。 

889
00:40:24,320 --> 00:40:27,120
有一个非常有趣的协议，称为CaseIterable。 

890
00:40:28,180 --> 00:40:32,046
CaseIterable，您将获得一个名为allCases的变量。 

891
00:40:32,046 --> 00:40:34,570
它是静态var，因此您将其发送给类型， 

892
00:40:34,570 --> 00:40:37,850
就像这里，在这里看到的TeslaModel.allCases。 

893
00:40:37,850 --> 00:40:42,490
这只会给您带来麻烦

894
00:40:42,490 --> 00:40:46,207
在所有情况下，您都可以做一些事情。 

895
00:40:46,207 --> 00:40:47,730
那可能是非常有价值的。 

896
00:40:47,730 --> 00:40:50,090
在作业三中，您可能要去

897
00:40:50,090 --> 00:40:51,980
需要使用它。 

898
00:40:51,980 --> 00:40:53,920
现在我们知道了一个枚举， 

899
00:40:53,920 --> 00:40:57,550
我们可以谈论最重要的枚举

900
00:40:57,550 --> 00:41:02,333
在所有Swift中，这称为Optional。 

901
00:41:03,870 --> 00:41:07,000
因此，一个Optional基本上看起来像这样。 

902
00:41:07,000 --> 00:41:09,870
它有两个离散值。 

903
00:41:09,870 --> 00:41:14,760
一种情况是没有情况，一种情况是一些情况。 

904
00:41:14,760 --> 00:41:17,900
在某些情况下，它具有关联的价值， 

905
00:41:17,900 --> 00:41:19,077
不在乎。 

906
00:41:19,077 --> 00:41:21,590
因此，可选，可选适用于任何类型。 

907
00:41:21,590 --> 00:41:24,570
不管它是什么类型。 

908
00:41:24,570 --> 00:41:26,620
因此从本质上讲，Optional是

909
00:41:26,620 --> 00:41:29,560
是一个固定的情况，就是这样， 

910
00:41:29,560 --> 00:41:33,100
或没有设置的情况，就是没有。 

911
00:41:33,100 --> 00:41:34,890
这就是可选的。 

912
00:41:34,890 --> 00:41:36,350
本质上是一种类型。 

913
00:41:36,350 --> 00:41:38,370
您将拥有Optional类型的变量。 

914
00:41:38,370 --> 00:41:40,450
他们将被设置或未设置。 

915
00:41:40,450 --> 00:41:43,370
如果设置了它们，它们将具有关联的价值

916
00:41:43,370 --> 00:41:48,370
某种类型，而Optional不在乎是什么类型。 

917
00:41:48,940 --> 00:41:50,070
那么我们在哪里使用Optional？ 

918
00:41:50,070 --> 00:41:53,090
好吧，您可以想象我们会随时使用它

919
00:41:53,090 --> 00:41:55,460
我们有一个变量，其值

920
00:41:55,460 --> 00:42:00,020
可能未设置，未指定或不确定， 

921
00:42:00,020 --> 00:42:01,403
诸如此类的东西。 

922
00:42:02,450 --> 00:42:03,320
有什么例子？ 

923
00:42:03,320 --> 00:42:08,080
好吧，该假返回的firstIndex匹配类型。 

924
00:42:08,080 --> 00:42:10,270
如果匹配的东西不在数组中， 

925
00:42:10,270 --> 00:42:12,280
我们目前返回零。 

926
00:42:12,280 --> 00:42:13,840
那是数组中的第一个元素。 

927
00:42:13,840 --> 00:42:15,040
那是完全错误的。 

928
00:42:15,040 --> 00:42:17,450
因此，我们将拥有firstIndex匹配的

929
00:42:17,450 --> 00:42:19,460
返回类型为Optional。 

930
00:42:19,460 --> 00:42:24,040
这将是一个Optional，而相关的值为Int。 

931
00:42:24,040 --> 00:42:26,190
因此，它要么返回设置，要么不设置。 

932
00:42:26,190 --> 00:42:29,190
如果能够的话，它将返回设置

933
00:42:30,420 --> 00:42:32,430
关联的值将是索引。 

934
00:42:32,430 --> 00:42:36,180
否则它将返回未设置状态

935
00:42:36,180 --> 00:42:40,270
如果它在那里找不到匹配的东西。 

936
00:42:40,270 --> 00:42:43,770
普通变量的另一个很好的例子

937
00:42:43,770 --> 00:42:47,250
假设是在模型的配对游戏中

938
00:42:47,250 --> 00:42:49,340
如果我有一个像这样的变量怎么办

939
00:42:49,340 --> 00:42:52,440
当前面朝上卡的索引？ 

940
00:42:52,440 --> 00:42:55,530
好的，当游戏开始时，没有面朝上的卡片。 

941
00:42:55,530 --> 00:42:56,750
那么那个索引是什么呢？ 

942
00:42:56,750 --> 00:42:58,360
就像，它没有设置。 

943
00:42:58,360 --> 00:43:01,660
因此，我们将使用Optional来存储它。 

944
00:43:01,660 --> 00:43:04,865
该var不会是索引的Int类型。 

945
00:43:04,865 --> 00:43:06,570
它的类型将为Optional。 

946
00:43:06,570 --> 00:43:08,160
现在关联的值将是一个Int 

947
00:43:08,160 --> 00:43:10,020
当然，如果已设置， 

948
00:43:10,020 --> 00:43:12,070
我们想知道Int是什么。 

949
00:43:12,070 --> 00:43:14,070
我要展示几个很好的例子

950
00:43:14,070 --> 00:43:15,653
在此之后的演示中。 

951
00:43:17,020 --> 00:43:18,620
因此，这种情况经常发生

952
00:43:18,620 --> 00:43:22,990
您需要一些有时未设置的变量， 

953
00:43:22,990 --> 00:43:24,350
未指定。 

954
00:43:24,350 --> 00:43:27,173
您想返回一个值，说我做不到， 

955
00:43:27,173 --> 00:43:28,850
这样的东西。 

956
00:43:28,850 --> 00:43:33,220
因此，Swift引入了很多语法糖， 

957
00:43:33,220 --> 00:43:37,280
基本上是特殊的语法，以便使其变得真正容易

958
00:43:37,280 --> 00:43:39,430
使用Optional，以至于您会认为

959
00:43:39,430 --> 00:43:42,990
在Swift中，Optionals只是一种魔术类型。 

960
00:43:42,990 --> 00:43:45,150
但是，所有这一切都只是这个枚举。 

961
00:43:45,150 --> 00:43:48,230
确实没有什么比这更多的了。 

962
00:43:48,230 --> 00:43:51,500
因此，让我们看一下所有这些语法糖。 

963
00:43:51,500 --> 00:43:55,660
第一个是我们如何声明或说

964
00:43:55,660 --> 00:43:57,220
我们想要这种类型？ 

965
00:43:57,220 --> 00:44:00,590
所以在这里以黄色显示，您看到的是String ？。 

966
00:44:00,590 --> 00:44:04,140
那就是说你好，这个var你好， 

967
00:44:04,140 --> 00:44:06,550
是Optional类型的

968
00:44:06,550 --> 00:44:09,770
一个可选的，其关联值为字符串。 

969
00:44:09,770 --> 00:44:12,360
我们将其称为Optional String。 

970
00:44:12,360 --> 00:44:14,580
当学生第一次接触到这一点时， 

971
00:44:14,580 --> 00:44:18,220
他们认为hello的类型是String 

972
00:44:18,220 --> 00:44:21,410
以某种方式修改为可选。 

973
00:44:21,410 --> 00:44:24,730
不，您好的类型是可选的。 

974
00:44:24,730 --> 00:44:27,560
它的关联值是一个字符串，但它是可选的。 

975
00:44:27,560 --> 00:44:29,120
这就是我们声明的方式。 

976
00:44:29,120 --> 00:44:32,010
这就是我们键入类型的方式， 

977
00:44:32,010 --> 00:44:36,083
我们如何用手指键入“可选字符串”类型。 

978
00:44:37,200 --> 00:44:38,880
现在如何设置值？ 

979
00:44:38,880 --> 00:44:41,480
很好记住，一个可选的字符串，它是一个可选的。 

980
00:44:41,480 --> 00:44:43,760
它只有两种情况，没有和一些。 

981
00:44:43,760 --> 00:44:47,490
因此，我们只说等于nil就设置了none。 

982
00:44:47,490 --> 00:44:52,240
因此，Swift中的关键字nil表示Optional.none。 

983
00:44:52,240 --> 00:44:55,983
这意味着未设置Optional的情况为nil。 

984
00:44:57,340 --> 00:45:00,320
同样，我们可以说，你好， 

985
00:45:00,320 --> 00:45:02,620
此Optional String等于String hello。 

986
00:45:02,620 --> 00:45:04,860
斯威夫特足够聪明，知道那意味着

987
00:45:04,860 --> 00:45:07,130
将此情况设置为Optional 

988
00:45:07,130 --> 00:45:10,023
并使用hello作为关联值。 

989
00:45:11,330 --> 00:45:14,500
这样就设置了String（在这种情况下，您好）， 

990
00:45:14,500 --> 00:45:17,923
并且它的关联值是hello。 

991
00:45:19,690 --> 00:45:23,150
请注意，Optionals总是开始

992
00:45:23,150 --> 00:45:25,920
隐式等于nil。 

993
00:45:25,920 --> 00:45:28,940
很好，因为请记住在结构和类中， 

994
00:45:28,940 --> 00:45:31,110
所有变量必须具有初始值。 

995
00:45:31,110 --> 00:45:32,390
我们跳了很多圈

996
00:45:32,390 --> 00:45:33,800
尝试获取我们所有的var 

997
00:45:33,800 --> 00:45:36,000
到目前为止具有初始值。 

998
00:45:36,000 --> 00:45:38,220
好吧，可选，没有任何障碍

999
00:45:38,220 --> 00:45:40,470
因为它得到一个隐式等于nil， 

1000
00:45:40,470 --> 00:45:45,350
或在枚举世界中，对于所有var来说，都为无。 

1001
00:45:45,350 --> 00:45:47,720
没错，对，因为这里有一个Optional。 

1002
00:45:47,720 --> 00:45:48,870
它已设置或未设置。 

1003
00:45:48,870 --> 00:45:50,890
好吧，它将开始没有设置。 

1004
00:45:50,890 --> 00:45:54,390
如果您愿意，可以将其初始化为“ hello”， 

1005
00:45:54,390 --> 00:45:56,550
但您可以不对其进行初始化， 

1006
00:45:56,550 --> 00:45:58,070
但是它并不是真正未初始化的。 

1007
00:45:58,070 --> 00:46:00,593
确实将其初始化为none。 

1008
00:46:01,510 --> 00:46:03,270
那么如何访问值呢？ 

1009
00:46:03,270 --> 00:46:06,070
假设我有一个像你好一样的变种， 

1010
00:46:06,070 --> 00:46:08,890
这是一个Optional，Optional String， 

1011
00:46:08,890 --> 00:46:10,680
我想要的字符串。 

1012
00:46:10,680 --> 00:46:12,690
如何获得字符串？ 

1013
00:46:12,690 --> 00:46:14,010
我如何获得相关的价值？ 

1014
00:46:14,010 --> 00:46:16,390
我要做什么，就像您在右边看到的那样， 

1015
00:46:16,390 --> 00:46:18,530
打开它，然后做这种情况？ 

1016
00:46:18,530 --> 00:46:19,670
当然不是。 

1017
00:46:19,670 --> 00:46:22,350
有一种简单的方法可以打开它。 

1018
00:46:22,350 --> 00:46:23,300
实际上有两种方式。 

1019
00:46:23,300 --> 00:46:25,070
一是感叹号。 

1020
00:46:25,070 --> 00:46:27,910
如果您在变数后面加上感叹号

1021
00:46:27,910 --> 00:46:31,000
这是一个可选的，它将假设

1022
00:46:31,000 --> 00:46:33,500
在某种情况下，固定的情况下， 

1023
00:46:33,500 --> 00:46:35,650
并获得相关的价值。 

1024
00:46:35,650 --> 00:46:38,630
但是，如果不是这样，它将导致程序崩溃。 

1025
00:46:38,630 --> 00:46:40,820
感叹号是真的，我们称之为

1026
00:46:40,820 --> 00:46:44,130
强制展开，因为您要强制展开

1027
00:46:44,130 --> 00:46:45,950
被解开，给我那个字符串。 

1028
00:46:45,950 --> 00:46:47,100
但是如果那个字符串不存在

1029
00:46:47,100 --> 00:46:49,010
因为在未设置的情况下是Optional， 

1030
00:46:49,010 --> 00:46:50,437
然后它会使您的程序崩溃。 

1031
00:46:50,437 --> 00:46:51,980
我们将在演示中看到

1032
00:46:51,980 --> 00:46:54,249
这听起来像啊，我永远都不会使用。 

1033
00:46:54,249 --> 00:46:55,820
我永远不会希望我的程序崩溃。 

1034
00:46:55,820 --> 00:46:57,210
但这实际上可能非常有用

1035
00:46:57,210 --> 00:46:59,040
如果您知道这是不应该的

1036
00:46:59,040 --> 00:47:00,180
确实如此。 

1037
00:47:00,180 --> 00:47:03,550
您可以轻松找到开发中的错误以及所有这些

1038
00:47:03,550 --> 00:47:05,040
通过使事情崩溃并说， 

1039
00:47:05,040 --> 00:47:07,350
“哇，那本不应该崩溃的。” 

1040
00:47:07,350 --> 00:47:09,930
但是有一种安全的方法

1041
00:47:09,930 --> 00:47:12,980
就是将其分配给另一个变量， 

1042
00:47:12,980 --> 00:47:14,090
一个安全的变量。 

1043
00:47:14,090 --> 00:47:16,040
如果允许，您可以这样做。 

1044
00:47:16,040 --> 00:47:18,320
所以你在这里的左下角看到

1045
00:47:18,320 --> 00:47:21,140
如果让路，所有黄色都围绕着。 

1046
00:47:21,140 --> 00:47:23,970
你说，如果允许的话，一些安全的版本， 

1047
00:47:23,970 --> 00:47:27,170
等于Optional，hello是Optional， 

1048
00:47:27,170 --> 00:47:31,160
那么那个safehello将是String类型的。 

1049
00:47:31,160 --> 00:47:34,020
如果可选，它将获得值

1050
00:47:34,020 --> 00:47:35,260
在某种情况下。 

1051
00:47:35,260 --> 00:47:37,610
然后在里面的花括号里面， 

1052
00:47:37,610 --> 00:47:39,870
如果让safehello等于打开花括号， 

1053
00:47:39,870 --> 00:47:43,090
在那个大括号中，safehello将存在于其中， 

1054
00:47:43,090 --> 00:47:44,580
这将是一个字符串。 

1055
00:47:44,580 --> 00:47:45,667
不是可选的。 

1056
00:47:45,667 --> 00:47:50,250
它安全地从Optional中获取了相关的值

1057
00:47:50,250 --> 00:47:51,320
并正在执行。 

1058
00:47:51,320 --> 00:47:54,430
现在，如果在未设置的情况下打个招呼， 

1059
00:47:54,430 --> 00:47:56,890
那么它甚至不会执行该代码

1060
00:47:56,890 --> 00:47:58,466
那说print（safehello）。 

1061
00:47:58,466 --> 00:47:59,600
甚至不会被执行。 

1062
00:47:59,600 --> 00:48:02,690
它会做一些其他的事情。 

1063
00:48:02,690 --> 00:48:05,370
就像在右下角， 

1064
00:48:05,370 --> 00:48:06,600
打个招呼。 

1065
00:48:06,600 --> 00:48:08,870
如果是在未设置的情况下， 

1066
00:48:08,870 --> 00:48:11,520
你会做那别的。 

1067
00:48:11,520 --> 00:48:13,000
否则，在某些情况下， 

1068
00:48:13,000 --> 00:48:15,360
那么你将要把字符串放到那边

1069
00:48:15,360 --> 00:48:17,963
并在那里进行打印（safehello）。 

1070
00:48:18,920 --> 00:48:22,260
这就是我们获取价值的方法，语法糖

1071
00:48:22,260 --> 00:48:23,790
用于获取Optional的值。 

1072
00:48:23,790 --> 00:48:25,510
要么强行从那里抓起

1073
00:48:25,510 --> 00:48:27,180
如果我们找不到它就会崩溃

1074
00:48:27,180 --> 00:48:30,170
或做一个安全变量

1075
00:48:30,170 --> 00:48:31,683
一个安全的着陆点。 

1076
00:48:32,610 --> 00:48:34,670
另一个很酷的小语法糖

1077
00:48:34,670 --> 00:48:36,780
是Optional默认值。 

1078
00:48:36,780 --> 00:48:40,900
因此，这可以让您真正简单地提供一个默认

1079
00:48:40,900 --> 00:48:43,300
当您访问可选项时

1080
00:48:43,300 --> 00:48:45,677
如果在未设置的情况下是Optional， 

1081
00:48:45,677 --> 00:48:47,630
所以等于零

1082
00:48:47,630 --> 00:48:50,610
这里我有一个叫做x的常数

1083
00:48:50,610 --> 00:48:54,570
类型为“可选字符串”，“可选字符串”。 

1084
00:48:54,570 --> 00:48:56,040
我可能已将其设置为某些内容。 

1085
00:48:56,040 --> 00:48:58,780
也许我将其设置为nil，也许我将其设置为某些东西。 

1086
00:48:58,780 --> 00:49:02,830
但是现在我要说的是y等于x。 

1087
00:49:02,830 --> 00:49:05,720
但是，如果x为零，请使用foo。 

1088
00:49:05,720 --> 00:49:07,340
那就是那个问号-问号

1089
00:49:07,340 --> 00:49:08,410
就是在那里

1090
00:49:08,410 --> 00:49:12,030
因此，在这种情况下，y始终为String类型。 

1091
00:49:12,030 --> 00:49:15,667
因为如果x是可选情况，则在设定的情况下

1092
00:49:15,667 --> 00:49:18,850
并且它具有关联的值，y会得到它。 

1093
00:49:18,850 --> 00:49:21,990
但是如果x在未设置的情况下， 

1094
00:49:21,990 --> 00:49:24,530
然后这个问号-问号会让你

1095
00:49:24,530 --> 00:49:25,743
获得foo的值。 

1096
00:49:26,680 --> 00:49:27,970
好吧，所以显示在右边

1097
00:49:27,970 --> 00:49:30,363
那里的枚举形式会是什么样子。 

1098
00:49:31,780 --> 00:49:35,660
好的，因此最好在实践中了解可选方案， 

1099
00:49:35,660 --> 00:49:38,010
所以我们要做两件事

1100
00:49:38,010 --> 00:49:39,183
在此演示中带有Optionals。 

1101
00:49:39,183 --> 00:49:41,570
一个，我们要修复匹配的firstIndex 

1102
00:49:41,570 --> 00:49:42,580
如我所说。 

1103
00:49:42,580 --> 00:49:44,740
第二，我们要创造自己的游戏， 

1104
00:49:44,740 --> 00:49:48,570
实际玩记忆游戏，开始匹配卡片。 

1105
00:49:48,570 --> 00:49:51,470
而要做到这一点， 

1106
00:49:51,470 --> 00:49:53,720
是要有一个跟踪变量

1107
00:49:53,720 --> 00:49:55,950
这张卡面朝上。 

1108
00:49:55,950 --> 00:49:57,120
因为当卡片正面朝上时， 

1109
00:49:57,120 --> 00:49:59,690
当有人拿起另一张卡时，我必须匹配它。 

1110
00:49:59,690 --> 00:50:02,253
因此，让我们深入研究该演示。 

1111
00:50:03,930 --> 00:50:06,740
好吧，既然我们知道什么是可选的， 

1112
00:50:06,740 --> 00:50:09,600
我们可以用它来修复这个假的东西

1113
00:50:09,600 --> 00:50:11,110
我们就在这里。 

1114
00:50:11,110 --> 00:50:12,940
这是什么假的？ 

1115
00:50:12,940 --> 00:50:16,350
好吧，我们有这个功能找到了第一个索引

1116
00:50:16,350 --> 00:50:19,570
与可识别数组中的某些元素匹配。 

1117
00:50:19,570 --> 00:50:20,403
它做到了。 

1118
00:50:20,403 --> 00:50:22,400
它通过并找到了第一个。 

1119
00:50:22,400 --> 00:50:26,320
但是，如果找不到它，它将返回零。 

1120
00:50:26,320 --> 00:50:29,830
零表示数组中第一件事的索引， 

1121
00:50:29,830 --> 00:50:32,840
如果此Array为空，则尤其假， 

1122
00:50:32,840 --> 00:50:34,290
可能是这样。 

1123
00:50:34,290 --> 00:50:35,770
那么我们该如何解决呢？ 

1124
00:50:35,770 --> 00:50:37,740
我们将通过返回类型来修复它， 

1125
00:50:37,740 --> 00:50:41,550
而不是Int，它将是可选的。 

1126
00:50:41,550 --> 00:50:45,243
注意，我说这个表达式是可选的。 

1127
00:50:45,243 --> 00:50:48,160
这是一个Optional，其关联值为Int， 

1128
00:50:48,160 --> 00:50:50,330
但这是可选的。 

1129
00:50:50,330 --> 00:50:52,390
人们一开始有时会感到困惑

1130
00:50:52,390 --> 00:50:54,490
认为这是一个Int 

1131
00:50:54,490 --> 00:50:56,100
加上一些修饰符。 

1132
00:50:56,100 --> 00:50:57,973
不，这是与Int不同的类型。 

1133
00:50:57,973 --> 00:51:00,550
这是一个名为Optional的类型。 

1134
00:51:00,550 --> 00:51:03,540
我们可以将其称为Optional Int， 

1135
00:51:03,540 --> 00:51:06,700
让我们在这里返回零， 

1136
00:51:06,700 --> 00:51:11,380
或在找不到时设置未设置的可选值。 

1137
00:51:11,380 --> 00:51:13,590
而且非常擅长与任何人交流

1138
00:51:13,590 --> 00:51:16,610
谁叫这个，“我找不到这个。” 

1139
00:51:16,610 --> 00:51:19,680
我们正常的回报是返回一个Int， 

1140
00:51:19,680 --> 00:51:21,810
Swift当然很聪明

1141
00:51:21,810 --> 00:51:25,240
如果您有一个可选的Int并返回一个Int， 

1142
00:51:25,240 --> 00:51:27,860
它将在设置状态下返回Optional 

1143
00:51:27,860 --> 00:51:29,980
关联值为Int， 

1144
00:51:29,980 --> 00:51:31,363
正是您想要的。 

1145
00:51:32,220 --> 00:51:33,053
就是这样。 

1146
00:51:33,053 --> 00:51:36,340
现在，无论如何它不再是虚假的功能， 

1147
00:51:36,340 --> 00:51:38,770
这是一个非常好的功能。 

1148
00:51:38,770 --> 00:51:42,600
我们可以在我们称之为的两个地方使用它。 

1149
00:51:42,600 --> 00:51:43,660
让我们转到网格。 

1150
00:51:43,660 --> 00:51:45,080
让我们从这个开始。 

1151
00:51:45,080 --> 00:51:47,270
所以这是使用firstIndex的Grid。 

1152
00:51:47,270 --> 00:51:48,680
正在获取索引。 

1153
00:51:48,680 --> 00:51:50,740
这个局部变量就在这里， 

1154
00:51:50,740 --> 00:51:52,700
如果我们现在选择单击它， 

1155
00:51:52,700 --> 00:51:55,450
现在为Optional Int类型。 

1156
00:51:55,450 --> 00:51:58,040
好吧，这将是一个问题

1157
00:51:58,040 --> 00:51:59,810
我们会看到一个错误出现在这里， 

1158
00:51:59,810 --> 00:52:03,357
这是“必须解开可选类型Int的值

1159
00:52:03,357 --> 00:52:04,960
“达到Int的值。” 

1160
00:52:04,960 --> 00:52:08,370
实际上，ItemAt的layout.location 

1161
00:52:08,370 --> 00:52:11,060
不以Optional作为其参数。 

1162
00:52:11,060 --> 00:52:12,690
它需要一个Int。 

1163
00:52:12,690 --> 00:52:15,350
现在我们可以接受这件事的建议

1164
00:52:15,350 --> 00:52:17,680
说好吧，让我们打开它。 

1165
00:52:17,680 --> 00:52:20,490
这就是我们解开Optional的方式。 

1166
00:52:20,490 --> 00:52:23,690
这需要一个处于设置状态的Optional， 

1167
00:52:23,690 --> 00:52:25,663
并获取其关联的值。 

1168
00:52:26,610 --> 00:52:30,540
但是，当Optional处于未设置状态时， 

1169
00:52:30,540 --> 00:52:32,820
这会使您的程序崩溃。 

1170
00:52:32,820 --> 00:52:33,957
现在有些人可能会说

1171
00:52:33,957 --> 00:52:37,487
“哇，我们为什么要使用感叹号？ 

1172
00:52:37,487 --> 00:52:40,990
“这太可怕了，有时会使我的程序崩溃。” 

1173
00:52:40,990 --> 00:52:44,050
是的，但是在这种情况下，可能实际上是很好的

1174
00:52:44,050 --> 00:52:46,230
离开这里的感叹号。 

1175
00:52:46,230 --> 00:52:48,370
因为永远不会这样

1176
00:52:48,370 --> 00:52:51,360
我们查找其中一项的第一个索引， 

1177
00:52:51,360 --> 00:52:55,070
我们只能通过项目数组通过ForEaching获得。 

1178
00:52:55,070 --> 00:52:56,660
这绝对不能为零。 

1179
00:52:56,660 --> 00:52:59,810
如果没有，那就出了什么问题了

1180
00:52:59,810 --> 00:53:03,200
我的代码中的某个地方，我有点希望它崩溃

1181
00:53:03,200 --> 00:53:04,783
所以我发现了这个问题。 

1182
00:53:05,800 --> 00:53:07,600
但是也许我真的很保守

1183
00:53:07,600 --> 00:53:09,870
当我将代码发送给客户时， 

1184
00:53:09,870 --> 00:53:12,080
我真的想确保，无论如何

1185
00:53:12,080 --> 00:53:15,670
它不会因为这些惊叹号之一而崩溃。 

1186
00:53:15,670 --> 00:53:18,590
所以，我可以保护客户

1187
00:53:18,590 --> 00:53:21,680
通过保护此代码，并说是否索引

1188
00:53:21,680 --> 00:53:25,410
不等于nil，则执行此操作。 

1189
00:53:25,410 --> 00:53:27,750
这将保护此代码

1190
00:53:27,750 --> 00:53:29,203
这样它就不会崩溃。 

1191
00:53:29,203 --> 00:53:33,880
因为如果index不为nil，则在此处展开​​它

1192
00:53:33,880 --> 00:53:36,000
总是会上班。 

1193
00:53:36,000 --> 00:53:38,053
但这没有建立。 

1194
00:53:39,160 --> 00:53:41,900
为什么不构建此代码？ 

1195
00:53:41,900 --> 00:53:44,077
它说：“缺少函数返回

1196
00:53:44,077 --> 00:53:47,210
“预期会返回“某些视图”。” 

1197
00:53:47,210 --> 00:53:50,890
确实，该函数应该返回“某些视图”。 

1198
00:53:50,890 --> 00:53:54,320
并且在索引的情况下确实返回“某些视图” 

1199
00:53:54,320 --> 00:53:56,960
不是nil，但是如果index为nil， 

1200
00:53:56,960 --> 00:53:58,853
当前，它什么也不返回。 

1201
00:53:59,800 --> 00:54:01,320
那是个问题。 

1202
00:54:01,320 --> 00:54:03,343
我什至不确定我们要返回什么

1203
00:54:03,343 --> 00:54:05,610
在这种情况下。 

1204
00:54:05,610 --> 00:54:07,980
所以，我们将不得不采取一些不同的策略

1205
00:54:07,980 --> 00:54:11,240
返回具有条件的“某些视图”。 

1206
00:54:11,240 --> 00:54:13,080
而且我们之前已经看过。 

1207
00:54:13,080 --> 00:54:17,730
在我们的视图ZStack中。 

1208
00:54:17,730 --> 00:54:19,200
ZStack有条件。 

1209
00:54:19,200 --> 00:54:21,760
如果该卡面朝上，它会做一件事。 

1210
00:54:21,760 --> 00:54:24,260
如果是面朝下的，那就做另一件事。 

1211
00:54:24,260 --> 00:54:27,920
ZStack在这里使用的这个功能，请记住， 

1212
00:54:27,920 --> 00:54:28,790
被称为ViewBiulder。 

1213
00:54:28,790 --> 00:54:33,040
这是我们的GeometryReader所做的事情， 

1214
00:54:33,040 --> 00:54:35,090
ForEach需要做的同样的事情，HStack， 

1215
00:54:35,090 --> 00:54:38,350
他们都使用ViewBuilder这个功能， 

1216
00:54:38,350 --> 00:54:39,670
但这是一种特殊的功能

1217
00:54:39,670 --> 00:54:40,917
您可以在其中放置这些if-thens 

1218
00:54:40,917 --> 00:54:42,890
您可以只列出视图。 

1219
00:54:42,890 --> 00:54:45,610
一切都变成了某种东西

1220
00:54:45,610 --> 00:54:48,090
那就是“某些视图”。 

1221
00:54:48,090 --> 00:54:51,770
因此，ZStack可以将“某些视图”作为其内容。 

1222
00:54:51,770 --> 00:54:55,390
好吧，我们可以在Grid上做同样的事情， 

1223
00:54:55,390 --> 00:54:57,050
但我们不需要进行任何布局。 

1224
00:54:57,050 --> 00:54:59,890
我们正在使用我们的框架和位置进行布局。 

1225
00:54:59,890 --> 00:55:02,190
所以我们想要一些需要ViewBuilder的东西

1226
00:55:02,190 --> 00:55:03,970
那有点什么都不做。 

1227
00:55:03,970 --> 00:55:05,510
而且有这样的事情。 

1228
00:55:05,510 --> 00:55:07,303
它称为组。 

1229
00:55:08,340 --> 00:55:12,550
因此，Group就像ZStack或其他任何事物

1230
00:55:12,550 --> 00:55:16,690
它的功能参数是一个“视图”构建器。 

1231
00:55:16,690 --> 00:55:20,730
但是，它对这里的内容没有任何作用。 

1232
00:55:20,730 --> 00:55:23,640
它允许您执行if if thens以及所有这些操作， 

1233
00:55:23,640 --> 00:55:26,210
您仍然可以列出这些内容， 

1234
00:55:26,210 --> 00:55:28,540
但这并没有把它们摆出来

1235
00:55:28,540 --> 00:55:30,920
或尝试以任何方式定位它们。 

1236
00:55:30,920 --> 00:55:33,863
因此，我们的定位将继续在这里进行。 

1237
00:55:35,030 --> 00:55:37,271
因此，我们将其转换为两行函数

1238
00:55:37,271 --> 00:55:40,270
而不是一个班轮，所以我们必须在这里放回程

1239
00:55:40,270 --> 00:55:41,780
以确保我们返回小组。 

1240
00:55:41,780 --> 00:55:45,290
但是现在我们要返回Group，这是一些视图。 

1241
00:55:45,290 --> 00:55:48,210
而Group只是使用View builder的东西

1242
00:55:48,210 --> 00:55:49,610
像这样去

1243
00:55:49,610 --> 00:55:53,530
现在，您可能会问：“如果索引为零，Group会做什么？” 

1244
00:55:53,530 --> 00:55:55,360
好吧，那会回来的

1245
00:55:55,360 --> 00:55:57,740
有某种空白的内容。 

1246
00:55:57,740 --> 00:55:59,300
它的身体将是一个空洞的视图。 

1247
00:55:59,300 --> 00:56:01,410
实际上有一个名为EmptyView的视图。 

1248
00:56:01,410 --> 00:56:04,180
可能会返回，但我们真的不在乎。 

1249
00:56:04,180 --> 00:56:06,374
我们只是在这里使用ViewBuilder功能

1250
00:56:06,374 --> 00:56:08,850
当我们知道我们可以做的时候。 

1251
00:56:08,850 --> 00:56:11,440
我们会发现该组很有用

1252
00:56:11,440 --> 00:56:14,170
在许多其他情况下也是如此。 

1253
00:56:14,170 --> 00:56:17,630
顾名思义，它对分组非常有用。 

1254
00:56:17,630 --> 00:56:20,760
这是因为集团，其观点在这里

1255
00:56:20,760 --> 00:56:22,480
是一个ViewBuilder视图。 

1256
00:56:22,480 --> 00:56:24,350
这就是为什么我们能够做到的

1257
00:56:24,350 --> 00:56:28,580
但这也是为什么我们能够列出一些视图的原因， 

1258
00:56:28,580 --> 00:56:30,290
然后将它们分组。 

1259
00:56:30,290 --> 00:56:33,760
因此，这实际上可能是Group存在的主要原因。 

1260
00:56:33,760 --> 00:56:36,010
这就是为什么将其称为“组”。 

1261
00:56:36,010 --> 00:56:39,050
但是说实话，我真的可能没有

1262
00:56:39,050 --> 00:56:41,740
经历了所有麻烦。 

1263
00:56:41,740 --> 00:56:43,710
我认为没有任何原因

1264
00:56:43,710 --> 00:56:45,860
检查该索引是否为零。 

1265
00:56:45,860 --> 00:56:48,393
正如我之前提到的，它永远不应为零。 

1266
00:56:49,260 --> 00:56:54,170
因此，我可能会删除所有这些内容。 

1267
00:56:54,170 --> 00:56:56,590
回到我们以前的地方。 

1268
00:56:56,590 --> 00:56:59,890
并让该索引强制展开。 

1269
00:56:59,890 --> 00:57:02,053
如果它使我的应用程序崩溃了，那么它也使我的应用程序崩溃了。 

1270
00:57:02,053 --> 00:57:05,310
它永远都不应该，所以我想在开发中找到， 

1271
00:57:05,310 --> 00:57:07,860
而没有所有这些代码，则代码更干净

1272
00:57:07,860 --> 00:57:10,453
还有ViewBuilder的东西。 

1273
00:57:11,470 --> 00:57:14,580
我可能要做的另一件事是移动此感叹号

1274
00:57:14,580 --> 00:57:17,460
从这里我经过这个变种

1275
00:57:17,460 --> 00:57:22,090
到这里我实际上得到了这个var的价值。 

1276
00:57:22,090 --> 00:57:23,890
因此，获取该firstIndex， 

1277
00:57:23,890 --> 00:57:25,920
并立即强行打开包装。 

1278
00:57:25,920 --> 00:57:28,280
这就是这个索引变量

1279
00:57:28,280 --> 00:57:30,723
转换为Int，我们可以直接将其传递。 

1280
00:57:32,280 --> 00:57:34,040
好吧，那里还有一个地方

1281
00:57:34,040 --> 00:57:35,675
我们使用firstIndex的地方。 

1282
00:57:35,675 --> 00:57:38,050
那是在我们的模型中，所以让我们来看一下

1283
00:57:38,050 --> 00:57:40,860
看看我们造成的损害

1284
00:57:40,860 --> 00:57:43,800
通过在此处切换到firstIndex。 

1285
00:57:43,800 --> 00:57:45,970
在这里，我们将使用一些不同的策略

1286
00:57:45,970 --> 00:57:48,740
避免必须解开Optional的错误

1287
00:57:48,740 --> 00:57:51,930
我要在我的租赁前使用if 

1288
00:57:51,930 --> 00:57:53,700
这是一个非常酷的功能。 

1289
00:57:53,700 --> 00:57:57,090
只需将if放在前面，然后再放大括号

1290
00:57:57,090 --> 00:57:59,350
做任何你想做的事。 

1291
00:57:59,350 --> 00:58:03,230
而您想要的任何东西只会实际发生

1292
00:58:03,230 --> 00:58:06,490
如果这个东西返回非零。 

1293
00:58:06,490 --> 00:58:09,980
如果返回nil，则该代码甚至都不会执行。 

1294
00:58:09,980 --> 00:58:14,770
在这里，请注意，如果让我们继续

1295
00:58:14,770 --> 00:58:17,380
冒号Int作为selectedIndex的类型。 

1296
00:58:17,380 --> 00:58:20,410
顺便说一下，我们并不需要它，因为它可以推断出它， 

1297
00:58:20,410 --> 00:58:22,740
但selectedIndex实际上是一个Int。 

1298
00:58:22,740 --> 00:58:26,730
只有在firstIndex的情况下它才会实际存在

1299
00:58:26,730 --> 00:58:29,300
返回非nil，这是唯一的时间

1300
00:58:29,300 --> 00:58:31,970
该代码也将被执行。 

1301
00:58:31,970 --> 00:58:33,400
但这正是我们想要的。 

1302
00:58:33,400 --> 00:58:35,160
它可以保护我们免受selectedIndex的影响。 

1303
00:58:35,160 --> 00:58:37,530
这意味着选择什么都不做。 

1304
00:58:37,530 --> 00:58:39,740
如果我们在卡中找不到该卡， 

1305
00:58:39,740 --> 00:58:40,600
那么这什么也没做。 

1306
00:58:40,600 --> 00:58:41,433
这正是我们想要的。 

1307
00:58:41,433 --> 00:58:43,040
我们希望它什么也不做。 

1308
00:58:43,040 --> 00:58:46,040
让我们运行并确保此可选业务

1309
00:58:46,040 --> 00:58:47,980
没有破坏任何东西。 

1310
00:58:47,980 --> 00:58:48,813
开始了。 

1311
00:58:48,813 --> 00:58:50,550
是的，我们仍然可以将卡片翻转过来。 

1312
00:58:50,550 --> 00:58:52,150
面朝上，面朝下。 

1313
00:58:52,150 --> 00:58:55,520
但是现在，该尝试玩游戏了。 

1314
00:58:55,520 --> 00:58:57,650
我们还需要Optional。 

1315
00:58:57,650 --> 00:59:00,030
我们将尽力使这些卡

1316
00:59:00,030 --> 00:59:02,200
实际上会匹配，也许匹配的卡

1317
00:59:02,200 --> 00:59:03,033
从游戏中消失。 

1318
00:59:03,033 --> 00:59:04,503
那也很酷。 

1319
00:59:05,770 --> 00:59:06,967
那么我们该怎么做呢？ 

1320
00:59:06,967 --> 00:59:11,620
我们如何玩我们的游戏，让它玩？ 

1321
00:59:11,620 --> 00:59:13,290
好吧，我们需要一些设计。 

1322
00:59:13,290 --> 00:59:15,040
我们是软件设计师。 

1323
00:59:15,040 --> 00:59:16,350
我们必须从概念上思考

1324
00:59:16,350 --> 00:59:18,300
我们如何做到这一点。 

1325
00:59:18,300 --> 00:59:22,080
因此，在我看来，我将经历各种情况。 

1326
00:59:22,080 --> 00:59:24,770
首先，我所有的卡都是正面朝下的。 

1327
00:59:24,770 --> 00:59:26,610
然后我点击卡片。 

1328
00:59:26,610 --> 00:59:28,210
然后没有匹配发生。 

1329
00:59:28,210 --> 00:59:30,570
卡只是面朝上翻转，这就是它的作用

1330
00:59:30,570 --> 00:59:32,610
现在就在我们的代码中。 

1331
00:59:32,610 --> 00:59:34,320
所以，好的。 

1332
00:59:34,320 --> 00:59:36,800
第二种状态是我拿到一张卡

1333
00:59:36,800 --> 00:59:38,750
然后我点击第二张卡片

1334
00:59:38,750 --> 00:59:40,880
好吧，那时候我真的很需要比赛。 

1335
00:59:40,880 --> 00:59:42,640
因此，如果有一张卡片正面朝上

1336
00:59:42,640 --> 00:59:44,250
然后点击了卡片

1337
00:59:44,250 --> 00:59:46,080
那就是我要玩游戏的时候。 

1338
00:59:46,080 --> 00:59:49,850
如果现在有两张卡片正面朝上，而我按了第三张卡片， 

1339
00:59:49,850 --> 00:59:51,760
现在我基本上需要转向

1340
00:59:51,760 --> 00:59:53,230
其他两张卡片正面朝下。 

1341
00:59:53,230 --> 00:59:54,250
无论他们是否匹配， 

1342
00:59:54,250 --> 00:59:55,960
他们需要面朝下。 

1343
00:59:55,960 --> 00:59:58,210
而我刚刚接触过的卡片

1344
00:59:58,210 --> 01:00:00,310
那将是面朝上的。 

1345
01:00:01,180 --> 01:00:02,420
在这三种情况下。 

1346
01:00:02,420 --> 01:00:04,390
这就是所有场景。 

1347
01:00:04,390 --> 01:00:06,830
在这三种情况下，我唯一一次玩过

1348
01:00:06,830 --> 01:00:11,580
一个匹配的游戏是如果有一张且只有一张卡片面朝上

1349
01:00:11,580 --> 01:00:14,210
当时我碰到一张新卡。 

1350
01:00:14,210 --> 01:00:16,030
所以我需要发现这种情况

1351
01:00:16,030 --> 01:00:17,210
当只有一个。 

1352
01:00:17,210 --> 01:00:19,580
所以我要去一个变种

1353
01:00:19,580 --> 01:00:21,470
跟踪索引

1354
01:00:21,470 --> 01:00:26,253
一张唯一的面朝上的卡片。 

1355
01:00:27,990 --> 01:00:30,380
这是我数组的索引， 

1356
01:00:30,380 --> 01:00:31,620
因此它将成为一个Int。 

1357
01:00:31,620 --> 01:00:34,620
但这可能是我比赛的开始

1358
01:00:34,620 --> 01:00:35,780
而且没有面朝上的卡， 

1359
01:00:35,780 --> 01:00:38,230
也许有两张面朝上的卡。 

1360
01:00:38,230 --> 01:00:41,410
因此，这确实需要是可选的。 

1361
01:00:41,410 --> 01:00:44,320
请注意，我在这里没有得到错误提示

1362
01:00:44,320 --> 01:00:45,830
我还没有初始化这个。 

1363
01:00:45,830 --> 01:00:49,260
没有错误，但是我还没有初始化。 

1364
01:00:49,260 --> 01:00:50,093
没有错误。 

1365
01:00:50,093 --> 01:00:53,010
那是因为所有可选项

1366
01:00:53,010 --> 01:00:56,200
自动初始化为零。 

1367
01:00:56,200 --> 01:00:57,430
因此等于nil。 

1368
01:00:57,430 --> 01:00:58,960
您可以根据需要输入。 

1369
01:00:58,960 --> 01:01:01,490
但是，如果您不把它放在那儿，它就会在那里。 

1370
01:01:01,490 --> 01:01:02,697
这很有道理，对吗？ 

1371
01:01:02,697 --> 01:01:05,203
可选值等于nil表示未设置。 

1372
01:01:06,248 --> 01:01:10,760
从总体上讲，此var开始时未设置游戏。 

1373
01:01:10,760 --> 01:01:11,690
因此，让我们继续前进。 

1374
01:01:11,690 --> 01:01:14,980
我得到了这个selectedIndex，我真的只想要

1375
01:01:14,980 --> 01:01:19,980
要注意显然在我的阵列中的卡片， 

1376
01:01:20,720 --> 01:01:25,300
而且还没有面朝上。 

1377
01:01:25,300 --> 01:01:28,130
如果卡已经面朝上并且我点击了它， 

1378
01:01:28,130 --> 01:01:29,850
我只是忽略它。 

1379
01:01:29,850 --> 01:01:31,890
现在，您会认为这可行，对吗？ 

1380
01:01:31,890 --> 01:01:33,430
在此处获取selectedIndex， 

1381
01:01:33,430 --> 01:01:35,990
并且selectedIndex不是朝上的。 

1382
01:01:35,990 --> 01:01:40,330
但它抱怨selectedIndex尚未解决。 

1383
01:01:40,330 --> 01:01:42,310
因此，如果您想这样做

1384
01:01:42,310 --> 01:01:44,860
你在说如果放手

1385
01:01:44,860 --> 01:01:47,490
然后你想做，在那件事上， 

1386
01:01:47,490 --> 01:01:50,550
而不是在这里，您将使用逗号。 

1387
01:01:50,550 --> 01:01:53,270
所以逗号就像顺序的

1388
01:01:53,270 --> 01:01:55,520
它首先在哪里做。 

1389
01:01:55,520 --> 01:01:59,870
然后，完成了它，可以做到这一点，并设置了selectedIndex。 

1390
01:01:59,870 --> 01:02:01,630
您甚至可以拥有更多这些， 

1391
01:02:01,630 --> 01:02:05,000
就像我可能也想忽略Cards 

1392
01:02:05,000 --> 01:02:09,190
这表明索引不匹配。 

1393
01:02:09,190 --> 01:02:11,310
所以我只会碰卡

1394
01:02:11,310 --> 01:02:12,940
面朝上，无与伦比。 

1395
01:02:12,940 --> 01:02:14,843
否则，我将忽略这些卡。 

1396
01:02:15,940 --> 01:02:19,363
如果让我们使用这些逗号表示，则相当多。 

1397
01:02:20,290 --> 01:02:22,630
在里面，我知道我已经选择了卡片

1398
01:02:22,630 --> 01:02:24,850
那是面朝下且尚未匹配的。 

1399
01:02:24,850 --> 01:02:28,500
所以我只想看看是否只有一个

1400
01:02:28,500 --> 01:02:30,280
卡片正面朝上，所以我要说

1401
01:02:30,280 --> 01:02:32,827
如果我可以让potentialMatchIndex 

1402
01:02:34,270 --> 01:02:38,040
等于indexOfTheOneAndOnlyFaceUpCard， 

1403
01:02:38,040 --> 01:02:40,690
现在我可能有一场比赛

1404
01:02:40,690 --> 01:02:42,380
因为只有一张面朝上的卡。 

1405
01:02:42,380 --> 01:02:44,420
我刚把另一张卡翻了过来。 

1406
01:02:44,420 --> 01:02:45,550
我们需要尝试并匹配它。 

1407
01:02:45,550 --> 01:02:49,600
没问题，如果在selectedIndex的Cards， 

1408
01:02:49,600 --> 01:02:53,100
如果有内容，请记住内容

1409
01:02:53,100 --> 01:02:55,940
在卡上，这就是卡上的内容， 

1410
01:02:55,940 --> 01:03:00,940
等于卡的潜在匹配数内容， 

1411
01:03:01,330 --> 01:03:04,300
然后woohoo，有一场比赛。 

1412
01:03:04,300 --> 01:03:06,510
现在，这使错误发生了。 

1413
01:03:06,510 --> 01:03:08,590
为什么会出错？ 

1414
01:03:08,590 --> 01:03:12,237
它说：“二元运算符等于-不能应用

1415
01:03:12,237 --> 01:03:15,790
“到两个CardContent操作数。” 

1416
01:03:15,790 --> 01:03:20,790
嗯，实际上这两个都是CardContent类型。 

1417
01:03:21,710 --> 01:03:24,700
那是我们不在乎。 

1418
01:03:24,700 --> 01:03:27,720
为什么我们不能在CardContent上做equals-equals？ 

1419
01:03:27,720 --> 01:03:30,090
这是一个字符串，对，表情符号字符串。 

1420
01:03:30,090 --> 01:03:31,900
等等

1421
01:03:31,900 --> 01:03:35,750
这是一种通用的记忆游戏玩法。 

1422
01:03:35,750 --> 01:03:37,850
这些里面没有表情符号。 

1423
01:03:37,850 --> 01:03:41,950
他们是CardContent，这对我们来说不在乎。 

1424
01:03:41,950 --> 01:03:45,880
可以是任何东西，图像，字符串，整数，等等。 

1425
01:03:45,880 --> 01:03:47,680
我们试图说等于。 

1426
01:03:47,680 --> 01:03:49,700
如果它是字符串，那么就可以了。 

1427
01:03:49,700 --> 01:03:50,910
如果是图片怎么办？ 

1428
01:03:50,910 --> 01:03:53,290
您能说一张图片等于另一张图片吗？ 

1429
01:03:53,290 --> 01:03:55,160
也许不是，我不知道。 

1430
01:03:55,160 --> 01:03:56,640
等于不是什么

1431
01:03:56,640 --> 01:03:58,992
那只适用于一切。 

1432
01:03:58,992 --> 01:04:02,830
实际上，平等在Swift中如何工作？ 

1433
01:04:02,830 --> 01:04:06,480
不管您信不信，Swift中的equals-equals并不是内置的

1434
01:04:06,480 --> 01:04:07,860
语言。 

1435
01:04:07,860 --> 01:04:10,630
它在Swift中使用了一种称为运算符的功能

1436
01:04:10,630 --> 01:04:13,310
这样您就可以关联一个运算符

1437
01:04:13,310 --> 01:04:15,200
具有功能。 

1438
01:04:15,200 --> 01:04:17,320
这正是平等所要做的。 

1439
01:04:17,320 --> 01:04:21,750
它将它与类型函数equals-equals关联。 

1440
01:04:21,750 --> 01:04:24,140
现在，等于等于看起来很有趣

1441
01:04:24,140 --> 01:04:27,300
Swift中的功能。 

1442
01:04:27,300 --> 01:04:29,400
这有点好笑，但也请记住

1443
01:04:29,400 --> 01:04:32,870
那张笑脸，表情符号笑脸， 

1444
01:04:32,870 --> 01:04:35,210
在Swift中是有效的函数名称。 

1445
01:04:35,210 --> 01:04:39,060
几乎所有Unicode字符都是有效的Swift。 

1446
01:04:39,060 --> 01:04:42,130
因此，等于笑脸和笑脸一样有效。 

1447
01:04:42,130 --> 01:04:44,730
所以这个等值函数是一个类型函数， 

1448
01:04:44,730 --> 01:04:46,460
它只需要两个参数， 

1449
01:04:46,460 --> 01:04:48,567
这是平等两边的两件事， 

1450
01:04:48,567 --> 01:04:52,330
无论是否相同，它都会返回布尔值。 

1451
01:04:52,330 --> 01:04:54,370
就是这样，这正是您所期望的。 

1452
01:04:54,370 --> 01:04:58,090
但是，并非每种类型都具有“等于”。 

1453
01:04:58,090 --> 01:05:00,000
实际上只有一些类型

1454
01:05:00,000 --> 01:05:02,130
检查是否相等。 

1455
01:05:02,130 --> 01:05:04,550
但幸运的是，等于函数

1456
01:05:04,550 --> 01:05:07,810
按照称为“等于表”的协议

1457
01:05:07,810 --> 01:05:11,030
所以我们可以在这里利用我们的约束和收获

1458
01:05:11,030 --> 01:05:15,990
说我们的CardContent在哪里实现Equatable。 

1459
01:05:15,990 --> 01:05:18,060
换句话说，我们只会工作， 

1460
01:05:18,060 --> 01:05:20,580
我们的MemoryGame仅在CardContent时有效

1461
01:05:21,470 --> 01:05:23,983
可以等于等于，可以等于。 

1462
01:05:25,020 --> 01:05:28,760
让我们在文档中查看该协议。 

1463
01:05:28,760 --> 01:05:31,050
所以我要做选项，单击。 

1464
01:05:31,050 --> 01:05:34,310
这是有关它的顶级文档， 

1465
01:05:34,310 --> 01:05:35,883
但让我们进入文档。 

1466
01:05:37,070 --> 01:05:39,360
平等是一个非常重要的协议。 

1467
01:05:39,360 --> 01:05:41,940
您可以看到很多解释

1468
01:05:41,940 --> 01:05:44,530
说某事物相等意味着什么

1469
01:05:44,530 --> 01:05:48,130
其他的东西，可转让财产，所有这一切。 

1470
01:05:48,130 --> 01:05:50,540
但是当您找到有关它的功能列表时， 

1471
01:05:50,540 --> 01:05:53,470
只有一个是必需的。 

1472
01:05:53,470 --> 01:05:54,600
您看到这个要求了吗？ 

1473
01:05:54,600 --> 01:05:56,950
这意味着它是协议的一部分， 

1474
01:05:56,950 --> 01:05:59,100
而且没有默认实现

1475
01:05:59,100 --> 01:06:03,200
扩展到任何地方，所以您必须实现它。 

1476
01:06:03,200 --> 01:06:06,970
这就是我所说的，静态的，类型函数

1477
01:06:06,970 --> 01:06:09,570
这需要其中两件事， 

1478
01:06:09,570 --> 01:06:12,070
记得在幻灯片中，我们拥有的比

1479
01:06:12,070 --> 01:06:15,400
而且你有自我，所以论点比

1480
01:06:15,400 --> 01:06:17,180
与一个int或它是总统。 

1481
01:06:17,180 --> 01:06:18,140
这里也是一样。 

1482
01:06:18,140 --> 01:06:20,950
如果您有equals-equals，如果我们使用String， 

1483
01:06:20,950 --> 01:06:23,620
那么Self和Self将是String和String， 

1484
01:06:23,620 --> 01:06:26,580
因此它需要两个String并进行比较。 

1485
01:06:26,580 --> 01:06:29,460
如果是Int，则需要两个Int，无论如何。 

1486
01:06:29,460 --> 01:06:31,180
这是您必须实现的唯一功能。 

1487
01:06:31,180 --> 01:06:34,480
真正简单的功能，简单易懂的功能， 

1488
01:06:34,480 --> 01:06:36,380
尽管您必须阅读所有这些内容以确保

1489
01:06:36,380 --> 01:06:37,710
你真的很明白

1490
01:06:37,710 --> 01:06:40,380
这是我们必须在Equatable中实施的唯一方法。 

1491
01:06:40,380 --> 01:06:42,020
所有其他这些都不是必需的

1492
01:06:42,020 --> 01:06:44,810
因为您可以通过扩展免费获得它们。 

1493
01:06:44,810 --> 01:06:48,320
Swift Foundation为您提供了这些东西

1494
01:06:48,320 --> 01:06:51,290
元组和其他东西自动在这里。 

1495
01:06:51,290 --> 01:06:53,610
不等于，它免费提供给您。 

1496
01:06:53,610 --> 01:06:55,983
它们全部基于此处的等值。 

1497
01:06:57,630 --> 01:07:00,550
这是一个协议，等于协议。 

1498
01:07:00,550 --> 01:07:04,180
因此，我们只是强迫或约束， 

1499
01:07:04,180 --> 01:07:07,620
我们的CardContent（我们不在乎）要平等。 

1500
01:07:07,620 --> 01:07:08,500
我们有点在意。 

1501
01:07:08,500 --> 01:07:11,540
我们关心它是等值的，因此我们可以对其进行比较。 

1502
01:07:11,540 --> 01:07:13,310
好吧，如果这两件事匹配， 

1503
01:07:13,310 --> 01:07:14,810
那我就说他们相配了

1504
01:07:14,810 --> 01:07:19,810
selectedIndex，isMatched处的纸牌等于true。 

1505
01:07:20,900 --> 01:07:24,000
当然，在potentialMatchIndex的卡片

1506
01:07:24,000 --> 01:07:25,170
事实证明这是一场比赛， 

1507
01:07:25,170 --> 01:07:28,463
因此它的isMatched也等于true。 

1508
01:07:29,400 --> 01:07:30,400
因此，这些卡是匹配的。 

1509
01:07:30,400 --> 01:07:31,370
棒极了。 

1510
01:07:31,370 --> 01:07:33,910
请注意，无论它们是否匹配， 

1511
01:07:33,910 --> 01:07:36,260
现在有两张卡片正面朝上。 

1512
01:07:36,260 --> 01:07:41,083
因此，一张唯一的朝上卡的索引为nil。 

1513
01:07:41,988 --> 01:07:44,040
没有一张，只有一张面朝上的卡。 

1514
01:07:44,040 --> 01:07:46,090
有两个，所以这意味着零。 

1515
01:07:47,040 --> 01:07:48,900
那其他情况呢？ 

1516
01:07:48,900 --> 01:07:52,220
因此，在这种情况下，没有一张，只有一张面朝上的卡。 

1517
01:07:52,220 --> 01:07:55,250
因此，要么为零，要么不止一个。 

1518
01:07:55,250 --> 01:07:58,220
在这种情况下，我们想将所有卡面朝下

1519
01:07:58,220 --> 01:08:00,470
除了我们当然选择的那个。 

1520
01:08:00,470 --> 01:08:01,910
所以我们要做一些循环

1521
01:08:01,910 --> 01:08:05,073
在我们的cards.indices中索引

1522
01:08:06,113 --> 01:08:08,970
而且我们只需要购买每张卡

1523
01:08:08,970 --> 01:08:12,900
isFaceUp等于false，我们将确保

1524
01:08:12,900 --> 01:08:17,900
我们将Card设为true，将其面朝上。 

1525
01:08:18,010 --> 01:08:19,530
在这种情况下也请注意

1526
01:08:19,530 --> 01:08:24,530
indexOfTheOneAndOnlyFaceUpCard是我们的selectedIndex。 

1527
01:08:24,714 --> 01:08:26,961
因为我只是把所有这些面朝下

1528
01:08:26,961 --> 01:08:29,446
我要把这个放回去

1529
01:08:29,446 --> 01:08:33,921
因此它将成为唯一的面朝上的卡片。 

1530
01:08:33,921 --> 01:08:35,090
就是这样了。 

1531
01:08:35,090 --> 01:08:36,010
这是我们的逻辑。 

1532
01:08:36,010 --> 01:08:38,947
我们不需要选择此卡就可以在那里打印。 

1533
01:08:38,947 --> 01:08:41,430
这就是完成这项工作的全部。 

1534
01:08:41,430 --> 01:08:44,803
因此，让我们运行，看看我们的游戏是否按照我们的意愿进行。 

1535
01:08:45,770 --> 01:08:47,920
好吧，这个游戏原来是最简单的游戏之一

1536
01:08:47,920 --> 01:08:51,870
进行记忆游戏，因为所有卡都面朝上。 

1537
01:08:51,870 --> 01:08:52,970
所以，那不好。 

1538
01:08:52,970 --> 01:08:54,690
让我们回到这里的模型

1539
01:08:54,690 --> 01:08:58,040
并进行更改，使所有卡面朝下开始。 

1540
01:08:58,040 --> 01:09:01,533
我认为这将使游戏更具挑战性。 

1541
01:09:02,960 --> 01:09:04,100
好吧，让我们尝试一下。 

1542
01:09:04,100 --> 01:09:05,800
鬼，是的。 

1543
01:09:05,800 --> 01:09:08,150
南瓜，哦，不，没有对手。 

1544
01:09:08,150 --> 01:09:11,640
鬼，是的，蜘蛛，不，不，不再。 

1545
01:09:11,640 --> 01:09:14,109
南瓜啊，我想我知道南瓜在哪里。 

1546
01:09:14,109 --> 01:09:15,410
就在这里

1547
01:09:15,410 --> 01:09:16,270
是。 

1548
01:09:16,270 --> 01:09:18,280
然后蜘蛛呢？ 

1549
01:09:18,280 --> 01:09:23,020
哦，现在请注意，它确实使我匹配的卡片面朝下， 

1550
01:09:23,020 --> 01:09:24,500
如果我尝试触及它们， 

1551
01:09:24,500 --> 01:09:27,280
我目前正在反复点击这些

1552
01:09:27,280 --> 01:09:29,940
他们不回头，因为他们已经匹配。 

1553
01:09:29,940 --> 01:09:32,140
我们将忽略已经匹配的卡。 

1554
01:09:32,140 --> 01:09:35,510
但是拥有这些正面朝下的卡片并不是一个很好的用户界面

1555
01:09:35,510 --> 01:09:37,923
您无法触摸，它什么也没做。 

1556
01:09:37,923 --> 01:09:40,520
我真的很想把这些拿走。 

1557
01:09:40,520 --> 01:09:43,250
因此，如果它们匹配，我将带走它们。 

1558
01:09:43,250 --> 01:09:46,340
因此，让我们回到我们的UI并执行此操作。 

1559
01:09:46,340 --> 01:09:48,200
这是我们的CardView。 

1560
01:09:48,200 --> 01:09:51,380
这是卡正面朝上的地方，那里没有问题。 

1561
01:09:51,380 --> 01:09:53,150
这是他们面朝下的地方。 

1562
01:09:53,150 --> 01:09:56,530
我要说的是如果卡片不匹配， 

1563
01:09:56,530 --> 01:09:58,720
那我画

1564
01:09:58,720 --> 01:10:00,910
但是如果它匹配并且面朝下， 

1565
01:10:00,910 --> 01:10:02,600
我什么也不会画。 

1566
01:10:02,600 --> 01:10:04,350
同样，这是ViewBuilder。 

1567
01:10:04,350 --> 01:10:05,570
这些简单的ifs。 

1568
01:10:05,570 --> 01:10:08,640
您甚至可以将这些if嵌套在else中

1569
01:10:08,640 --> 01:10:10,660
或其他if的if内。 

1570
01:10:10,660 --> 01:10:12,200
嵌套ifs可以。 

1571
01:10:12,200 --> 01:10:14,350
请注意，我们在这里甚至不需要其他。 

1572
01:10:14,350 --> 01:10:16,523
ViewBuilder知道如何处理事实

1573
01:10:16,523 --> 01:10:20,590
如果没有发生，那么这里什么也不会发生。 

1574
01:10:20,590 --> 01:10:21,980
本质上是一个空的视图。 

1575
01:10:21,980 --> 01:10:25,570
实际上，在SwiftUI中，有一个名为EmptyView的视图。 

1576
01:10:25,570 --> 01:10:27,930
这就是这个ViewBuilder要做的

1577
01:10:27,930 --> 01:10:30,280
如果卡片朝下，则为ZStack。 

1578
01:10:31,886 --> 01:10:33,183
看看是否可以解决该问题。 

1579
01:10:35,273 --> 01:10:38,757
然后我们得到南瓜，蜘蛛，鬼魂。 

1580
01:10:39,940 --> 01:10:41,690
哦，有比赛了，准备好了吗？ 

1581
01:10:41,690 --> 01:10:43,840
哇，这把他们带走了。 

1582
01:10:43,840 --> 01:10:46,520
另一场比赛，带走了那些。 

1583
01:10:46,520 --> 01:10:47,920
好的，这很好。 

1584
01:10:47,920 --> 01:10:51,197
我们的游戏基本上运行良好。 

1585
01:10:51,197 --> 01:10:54,370
因此，我想对模特做最后一件事。 

1586
01:10:54,370 --> 01:10:57,430
我有点担心我有这种状态， 

1587
01:10:57,430 --> 01:10:59,690
indexOfTheOneAndOnlyFaceUpCard， 

1588
01:10:59,690 --> 01:11:01,660
我必须保持同步

1589
01:11:01,660 --> 01:11:04,410
我对卡的更改。 

1590
01:11:04,410 --> 01:11:07,720
这是一种容易出错的编程方式

1591
01:11:07,720 --> 01:11:09,960
当您在两个地方拥有州时。 

1592
01:11:09,960 --> 01:11:13,000
indexOfTheOneAndOnlyFaceUpCard在这里， 

1593
01:11:13,000 --> 01:11:16,820
也可以从这些卡中确定

1594
01:11:16,820 --> 01:11:20,160
因此，让我们在这里使用计算的var 

1595
01:11:20,160 --> 01:11:25,160
并从卡中获取indexOfTheOneAndOnlyFaceUpCard。 

1596
01:11:25,270 --> 01:11:28,490
而且我们还将在这里进行一组

1597
01:11:28,490 --> 01:11:32,070
这样，如果有人设置indexOfTheOneAndOnlyFaceUpCard， 

1598
01:11:32,070 --> 01:11:35,030
我们将所有其他卡片正面朝下。 

1599
01:11:35,030 --> 01:11:37,220
这是您第一次看到计算属性

1600
01:11:37,220 --> 01:11:38,860
我们可以得到的价值， 

1601
01:11:38,860 --> 01:11:41,553
但我们也可以设置

1602
01:11:42,760 --> 01:11:45,230
让我们先设置一个。 

1603
01:11:45,230 --> 01:11:48,170
两者比较简单。 

1604
01:11:48,170 --> 01:11:51,060
当有人时我们将如何反应

1605
01:11:51,060 --> 01:11:56,060
设置indexOfTheOneAndOnlyFaceUpCard的值？ 

1606
01:11:56,160 --> 01:11:58,020
那么在这种情况下，我们需要经历

1607
01:11:58,020 --> 01:11:59,420
我们所有的卡。 

1608
01:11:59,420 --> 01:12:02,350
我将在这里浏览我们的索引。 

1609
01:12:02,350 --> 01:12:07,233
而且我要把所有卡片都朝下放置。 

1610
01:12:09,070 --> 01:12:11,550
除了我不想那样做

1611
01:12:11,550 --> 01:12:13,530
如果这是你说的

1612
01:12:13,530 --> 01:12:16,180
是indexOfTheOneAndOnlyFaceUpCard。 

1613
01:12:16,180 --> 01:12:20,670
在此集合内，有一个名为newValue的特殊变量。 

1614
01:12:20,670 --> 01:12:23,353
所以我可以告诉你索引是否等于newValue， 

1615
01:12:25,870 --> 01:12:28,730
这个人说这等于的价值， 

1616
01:12:28,730 --> 01:12:31,070
然后面朝上。 

1617
01:12:31,070 --> 01:12:33,300
所以newValue是特殊的var， 

1618
01:12:33,300 --> 01:12:37,850
仅在此集合内显示计算属性。 

1619
01:12:37,850 --> 01:12:40,200
这就是人们设定的目标。 

1620
01:12:40,200 --> 01:12:41,550
可能是零。 

1621
01:12:41,550 --> 01:12:44,770
此newValue是可选的，因此可以为nil。 

1622
01:12:44,770 --> 01:12:48,410
索引是一个整数，并且整数从不等于

1623
01:12:48,410 --> 01:12:50,140
未设置的可选

1624
01:12:50,140 --> 01:12:52,420
所以这等于是真的

1625
01:12:52,420 --> 01:12:54,140
如果这是可选的

1626
01:12:54,140 --> 01:12:57,563
及其关联的整数与此整数匹配

1627
01:12:59,040 --> 01:13:01,720
设置就这样，非常简单。 

1628
01:13:01,720 --> 01:13:03,720
怎么样呢？ 

1629
01:13:03,720 --> 01:13:06,520
好吧，要获得它，我真的需要查看所有卡片

1630
01:13:06,520 --> 01:13:08,030
看看哪些面朝上

1631
01:13:08,030 --> 01:13:09,620
看看是否只有一个。 

1632
01:13:09,620 --> 01:13:12,840
因此，让我们从获取所有面朝上的卡开始。 

1633
01:13:12,840 --> 01:13:15,820
所以我要说faceUpCardIndices。 

1634
01:13:15,820 --> 01:13:18,440
这将是一个整数数组。 

1635
01:13:18,440 --> 01:13:21,170
顺便说一句，我要在这里使用这种语法

1636
01:13:21,170 --> 01:13:22,670
表示整数数组。 

1637
01:13:22,670 --> 01:13:26,650
这与Int数组完全相同。 

1638
01:13:26,650 --> 01:13:28,900
我要说的是在现实世界中

1639
01:13:28,900 --> 01:13:33,000
实际上，这是首选语法。 

1640
01:13:33,000 --> 01:13:35,510
并非100％确信，但在我看来确实如此

1641
01:13:35,510 --> 01:13:37,950
人们更喜欢这种方法而不是Int数组。 

1642
01:13:37,950 --> 01:13:39,100
我喜欢整数数组。 

1643
01:13:39,100 --> 01:13:41,180
显然，这是通用的， 

1644
01:13:41,180 --> 01:13:43,880
不管是Int还是所有

1645
01:13:43,880 --> 01:13:47,340
但是使用数组非常普遍， 

1646
01:13:47,340 --> 01:13:49,853
所以我可以理解那里的速记。 

1647
01:13:50,740 --> 01:13:53,490
那么，现在我该如何获得这个faceUpCardIndices？ 

1648
01:13:53,490 --> 01:13:55,060
它从那里开始是空的， 

1649
01:13:55,060 --> 01:13:59,610
所以我要去找卡片索引。 

1650
01:13:59,610 --> 01:14:01,260
遍历我所有的卡。 

1651
01:14:01,260 --> 01:14:05,840
如果某个索引的卡面朝上， 

1652
01:14:05,840 --> 01:14:09,368
然后我将其放入faceUpCardIndices中， 

1653
01:14:09,368 --> 01:14:11,110
追加该索引。 

1654
01:14:11,110 --> 01:14:14,690
好吧，现在我有了所有面朝上的Card索引。 

1655
01:14:14,690 --> 01:14:19,470
我要说的是，如果faceUpCardIndices.count等于1， 

1656
01:14:19,470 --> 01:14:21,313
因此只有一张， 

1657
01:14:21,313 --> 01:14:26,313
然后我将那个faceUpCardIndices归零。 

1658
01:14:26,420 --> 01:14:28,550
顺便说一句，还有一个不错的小变种， 

1659
01:14:28,550 --> 01:14:30,340
首先。 

1660
01:14:30,340 --> 01:14:31,930
当我们先输入时

1661
01:14:31,930 --> 01:14:34,960
请注意，此变量的返回类型， 

1662
01:14:34,960 --> 01:14:38,560
或此var的类型是Int，问号， 

1663
01:14:38,560 --> 01:14:39,960
可选Int，为什么？ 

1664
01:14:39,960 --> 01:14:42,410
因为数组可能为空。 

1665
01:14:42,410 --> 01:14:44,740
因此，如果您说Array.first，而Array为空， 

1666
01:14:44,740 --> 01:14:46,840
这将返回nil。 

1667
01:14:46,840 --> 01:14:49,973
Swift使用Optionals进行交流。 

1668
01:14:51,220 --> 01:14:53,810
否则，我将返回零。 

1669
01:14:53,810 --> 01:14:57,210
因为如果没有一张卡

1670
01:14:57,210 --> 01:15:00,520
在面朝上的卡片列表中，那么显然， 

1671
01:15:00,520 --> 01:15:03,683
indexOfTheOneAndOnlyFaceUpCard为零，仅此而已。 

1672
01:15:05,500 --> 01:15:07,290
所以现在计算出来

1673
01:15:07,290 --> 01:15:10,750
我不必太努力地确保它保持同步。 

1674
01:15:10,750 --> 01:15:13,860
例如，在这里，我什至不必说

1675
01:15:13,860 --> 01:15:16,480
indexOfTheOneAndOnlyFaceUpCard为零。 

1676
01:15:16,480 --> 01:15:18,240
完全删除该代码

1677
01:15:18,240 --> 01:15:20,370
因为它总是会知道

1678
01:15:20,370 --> 01:15:22,040
当有两个面朝上的卡片时。 

1679
01:15:22,040 --> 01:15:23,700
它计算它。 

1680
01:15:23,700 --> 01:15:26,520
有点类似，因为我在这里

1681
01:15:26,520 --> 01:15:29,500
唯一的一张面朝上的卡片就是该索引， 

1682
01:15:29,500 --> 01:15:32,230
我不需要将所有其他部件正面朝下放置。 

1683
01:15:32,230 --> 01:15:35,333
这将由设置者自动完成。 

1684
01:15:36,250 --> 01:15:38,810
而且，将其面朝上的确如此， 

1685
01:15:38,810 --> 01:15:41,910
我们只需要在这里做，因为再次

1686
01:15:41,910 --> 01:15:44,048
设置indexOfTheOneAndOnlyFaceUpCard 

1687
01:15:44,048 --> 01:15:48,631
将确保此selectedIndex朝上。 

1688
01:15:49,469 --> 01:15:52,340
因此这使得该代码非常少

1689
01:15:52,340 --> 01:15:54,360
玩整个纸牌配对游戏。 

1690
01:15:54,360 --> 01:15:57,567
现在，这里要花很多代码。 

1691
01:15:57,567 --> 01:15:59,250
我们将在一秒钟内解决该问题， 

1692
01:15:59,250 --> 01:16:02,623
但请确保这没有破坏任何内容。 

1693
01:16:03,650 --> 01:16:04,520
开始了。 

1694
01:16:04,520 --> 01:16:08,840
南瓜，蜘蛛，蜘蛛，蜘蛛，南瓜，好吧。 

1695
01:16:08,840 --> 01:16:12,930
鬼，不，南瓜，鬼，鬼，鬼，南瓜。 

1696
01:16:12,930 --> 01:16:14,630
所以这是工作。 

1697
01:16:14,630 --> 01:16:16,980
漂亮的代码就在这里。 

1698
01:16:16,980 --> 01:16:20,500
这里的代码多于我们所需的代码。 

1699
01:16:20,500 --> 01:16:23,693
那么，如何才能减少此代码呢？ 

1700
01:16:24,600 --> 01:16:26,200
在这里，我只能想到一件事

1701
01:16:26,200 --> 01:16:28,700
使它更有效率， 

1702
01:16:28,700 --> 01:16:31,580
这是我在说的是真的

1703
01:16:31,580 --> 01:16:34,710
然后将其设置为true，否则将其设置为false。 

1704
01:16:34,710 --> 01:16:38,273
我可以把它放到这里。 

1705
01:16:39,249 --> 01:16:41,910
然后，我不需要所有其他开销

1706
01:16:41,910 --> 01:16:43,723
这一切的语法。 

1707
01:16:44,606 --> 01:16:45,860
所以我要设置每张卡。 

1708
01:16:45,860 --> 01:16:48,220
除非索引，否则我将其设置为false 

1709
01:16:48,220 --> 01:16:50,770
等于那个人所说的等于， 

1710
01:16:50,770 --> 01:16:52,070
就像我在这里做。 

1711
01:16:53,344 --> 01:16:54,177
很好。 

1712
01:16:54,177 --> 01:16:56,060
那是最少的代码。 

1713
01:16:56,060 --> 01:16:57,350
那怎么办

1714
01:16:57,350 --> 01:16:59,060
信不信由你，我要做到

1715
01:16:59,060 --> 01:17:00,690
所以这是一行代码。 

1716
01:17:00,690 --> 01:17:03,170
您知道我们喜欢此类中的一行代码。 

1717
01:17:03,170 --> 01:17:05,860
您的第一次家庭作业证明了这一点。 

1718
01:17:05,860 --> 01:17:08,230
那么我该如何编写这一行代码？ 

1719
01:17:08,230 --> 01:17:12,140
我将从这里拥有所有这些开始

1720
01:17:12,140 --> 01:17:13,930
成为一行，我要做

1721
01:17:13,930 --> 01:17:17,530
具有称为过滤器的范围内的功能。 

1722
01:17:17,530 --> 01:17:20,930
所以我要拿我的卡指数，这是一个范围

1723
01:17:20,930 --> 01:17:24,370
在零，点点之间，小于cards.count。 

1724
01:17:24,370 --> 01:17:26,700
并调用此函数过滤器。 

1725
01:17:26,700 --> 01:17:29,150
您会在此处看到过滤器。 

1726
01:17:29,150 --> 01:17:31,200
它返回一个整数数组。 

1727
01:17:31,200 --> 01:17:33,760
您在这里在左侧看到整数数组。 

1728
01:17:33,760 --> 01:17:37,580
这些整数就是这个范围内的所有整数

1729
01:17:37,580 --> 01:17:40,200
该函数需要一个Int 

1730
01:17:40,200 --> 01:17:42,293
并返回布尔值，则返回true。 

1731
01:17:43,610 --> 01:17:44,443
所以看起来像这样。 

1732
01:17:44,443 --> 01:17:45,910
让我们双击这个。 

1733
01:17:45,910 --> 01:17:46,743
这里是。 

1734
01:17:46,743 --> 01:17:48,630
我什至可以双击它。 

1735
01:17:48,630 --> 01:17:50,200
它为我填补了。 

1736
01:17:50,200 --> 01:17:52,880
这是一个函数，一个内联函数， 

1737
01:17:52,880 --> 01:17:55,880
需要一个Int并返回一个Bool。 

1738
01:17:55,880 --> 01:18:00,210
我们应该返回是否包含此Int， 

1739
01:18:00,210 --> 01:18:01,853
这是指数之一

1740
01:18:02,920 --> 01:18:05,480
在结果faceUpCardIndices中。 

1741
01:18:05,480 --> 01:18:09,080
我们通过过滤掉其他阵列来制作一个新的阵列。 

1742
01:18:09,080 --> 01:18:13,860
这就是索引，因此我们将其称为索引。 

1743
01:18:13,860 --> 01:18:14,860
我们想做什么？ 

1744
01:18:14,860 --> 01:18:19,460
我们想说该索引处的归还卡片， 

1745
01:18:19,460 --> 01:18:20,857
点是isFaceUp。 

1746
01:18:22,361 --> 01:18:24,440
这就是我们想要做的。 

1747
01:18:24,440 --> 01:18:27,820
当然，我们希望在Swift中减少代码量， 

1748
01:18:27,820 --> 01:18:31,053
这样我们就可以收回这个回报。 

1749
01:18:32,340 --> 01:18:35,113
也许我们会像这样把它放在这里。 

1750
01:18:36,990 --> 01:18:39,630
我们可以推断出此返回类型。 

1751
01:18:39,630 --> 01:18:42,913
不需要那个，也不需要这些括号。 

1752
01:18:43,770 --> 01:18:45,370
我上次没有给你看的另一件事

1753
01:18:45,370 --> 01:18:48,400
我们可以做得更小， 

1754
01:18:48,400 --> 01:18:51,130
这是参数在这里指定

1755
01:18:51,130 --> 01:18:52,150
带索引。 

1756
01:18:52,150 --> 01:18:55,630
您可以摆脱它，而只需使用零美元， 

1757
01:18:55,630 --> 01:18:58,330
每个参数分别为1美元和2美元。 

1758
01:18:58,330 --> 01:18:59,670
第一个参数为零美元， 

1759
01:18:59,670 --> 01:19:01,970
第二个论点一美元等等。 

1760
01:19:02,870 --> 01:19:04,120
所以我们快到了。 

1761
01:19:04,120 --> 01:19:07,210
这一切都就在这里。 

1762
01:19:07,210 --> 01:19:11,040
因为我们现在只需一口气计算一下， 

1763
01:19:11,040 --> 01:19:11,873
我们在这里得到这个警告

1764
01:19:11,873 --> 01:19:15,383
现在可以放手了。 

1765
01:19:16,240 --> 01:19:17,640
这个怎么样？ 

1766
01:19:17,640 --> 01:19:19,080
我们如何摆脱这一点？ 

1767
01:19:19,080 --> 01:19:20,030
这里发生了什么？ 

1768
01:19:20,030 --> 01:19:23,410
在这里，我们实际上只是对索引数组说， 

1769
01:19:23,410 --> 01:19:25,460
如果只有你们一个，把它给我。 

1770
01:19:25,460 --> 01:19:27,300
否则，请给我零。 

1771
01:19:27,300 --> 01:19:29,570
好吧，为什么我们不扩展Array， 

1772
01:19:29,570 --> 01:19:34,230
使用扩展数组，有一个这样做的var？ 

1773
01:19:34,230 --> 01:19:36,120
因为这似乎是一个合理的数组问题。 

1774
01:19:36,120 --> 01:19:39,180
嘿Array先生，只给我自己一件事， 

1775
01:19:39,180 --> 01:19:41,170
否则给我零。 

1776
01:19:41,170 --> 01:19:44,563
因此，让我们在这里为Array创建另一个扩展。 

1777
01:19:45,411 --> 01:19:46,750
做一个Swift文件。 

1778
01:19:46,750 --> 01:19:49,810
我们称其为Array + Only 

1779
01:19:49,810 --> 01:19:53,350
因为它返回数组中的唯一内容。 

1780
01:19:53,350 --> 01:19:58,350
而对Array的扩展将扩展所有Array。 

1781
01:19:58,630 --> 01:20:01,120
对Array的这种扩展不是这样的

1782
01:20:01,120 --> 01:20:03,300
元素可识别的位置。 

1783
01:20:03,300 --> 01:20:05,530
这个扩展到所有数组。 

1784
01:20:05,530 --> 01:20:07,890
它将添加此变量，我仅会调用。 

1785
01:20:07,890 --> 01:20:12,290
类型为元素，问号，可选元素。 

1786
01:20:12,290 --> 01:20:15,330
它是经过计算的，它只返回数组的计数

1787
01:20:15,330 --> 01:20:18,133
等于一个，第一个，冒号，零。 

1788
01:20:19,060 --> 01:20:22,680
因此这在Array中，因此count是Array的计数。 

1789
01:20:22,680 --> 01:20:23,820
如果那等于一， 

1790
01:20:23,820 --> 01:20:26,190
我们在这里使用这个三元运算符

1791
01:20:26,190 --> 01:20:28,800
返回数组中的第一项。 

1792
01:20:28,800 --> 01:20:29,823
否则为零。 

1793
01:20:32,140 --> 01:20:34,870
超级简单，那超级简单的代码

1794
01:20:34,870 --> 01:20:37,310
使一切都在这里消失。 

1795
01:20:37,310 --> 01:20:39,250
我们不需要任何这些。 

1796
01:20:39,250 --> 01:20:43,077
相反，我们可以在这里只说点

1797
01:20:43,077 --> 01:20:45,500
并摆脱所有这些。 

1798
01:20:45,500 --> 01:20:47,170
只需退货。 

1799
01:20:47,170 --> 01:20:50,770
但是，由于现在这是单线的，所以我们不需要退货。 

1800
01:20:50,770 --> 01:20:53,970
我们甚至可以在这里将其全部变成一行

1801
01:20:53,970 --> 01:20:55,077
也这样

1802
01:20:55,077 --> 01:20:59,690
这段代码突然变得紧凑了很多。 

1803
01:20:59,690 --> 01:21:02,123
因此，请确保我们没有在此处破坏任何内容。 

1804
01:21:03,860 --> 01:21:08,860
单击，是的，哦，是的，它有效。 

1805
01:21:09,450 --> 01:21:13,040
现在，这已经为您的作业设置了精美的外观。 

1806
01:21:13,040 --> 01:21:16,040
您现在要使用此工作游戏

1807
01:21:16,040 --> 01:21:18,670
并对其进行一些增强。 

1808
01:21:18,670 --> 01:21:20,490
因此，请查看相关内容。 

1809
01:21:20,490 --> 01:21:22,630
我们下次见。 

1810
01:21:22,630 --> 01:21:25,883
-[旁白]有关更多信息，请访问stanford.edu。 

