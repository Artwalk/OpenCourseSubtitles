1
00:00:04,940 --> 00:00:06,640
- 斯坦福大学。 

2
00:00:08,600 --> 00:00:10,270
-好的，欢迎参加第八讲

3
00:00:10,270 --> 00:00:14,580
斯坦福CS193p，2020年春季。 

4
00:00:14,580 --> 00:00:17,470
我今天要尽量减少幻灯片

5
00:00:17,470 --> 00:00:20,430
这样我们就可以进入另一个大型演示， 

6
00:00:20,430 --> 00:00:22,910
但我需要谈论概念性的东西

7
00:00:22,910 --> 00:00:25,470
我们将在演示中做几件事， 

8
00:00:25,470 --> 00:00:28,750
即UserDefaults，它非常轻巧， 

9
00:00:28,750 --> 00:00:30,890
我们将要使用的持久性存储

10
00:00:30,890 --> 00:00:32,440
用于演示目的。 

11
00:00:32,440 --> 00:00:36,510
然后，今天的主要话题是手势

12
00:00:36,510 --> 00:00:40,193
基本上是用用户的手指从用户那里获得输入。 

13
00:00:41,040 --> 00:00:43,130
因此，让我们谈谈UserDefaults这件事。 

14
00:00:43,130 --> 00:00:46,600
在此之前，我想先讨论一下持久性。 

15
00:00:46,600 --> 00:00:48,670
坚持不懈是我的意思

16
00:00:48,670 --> 00:00:52,273
使事情停留在您的iOS设备上

17
00:00:52,273 --> 00:00:55,340
即使您退出应用程序并重新启动它。 

18
00:00:55,340 --> 00:00:58,110
并且有许多方法可以使数据持久化。 

19
00:00:58,110 --> 00:01:01,107
您可以将其放在iOS的文件系统中。 

20
00:01:01,107 --> 00:01:04,670
基本上，下面都有一台Unix机器， 

21
00:01:04,670 --> 00:01:06,400
它具有Unix文件系统， 

22
00:01:06,400 --> 00:01:08,370
而且您当然可以将内容存储在文件系统中。 

23
00:01:08,370 --> 00:01:11,200
我希望在本季度晚些时候进行介绍。 

24
00:01:11,200 --> 00:01:13,090
您可以将内容放入SQL数据库

25
00:01:13,090 --> 00:01:14,480
或其他一些数据库。 

26
00:01:14,480 --> 00:01:18,200
iOS有一个很棒的框架，叫做CoreData 

27
00:01:18,200 --> 00:01:21,650
本质上是做一个面向对象的编程层

28
00:01:21,650 --> 00:01:23,950
在SQL数据库之上。 

29
00:01:23,950 --> 00:01:25,090
真的很棒。 

30
00:01:25,090 --> 00:01:26,859
别以为我们这个季度会做到这一点， 

31
00:01:26,859 --> 00:01:30,139
但是我至少要在本季度晚些时候谈论它。 

32
00:01:30,139 --> 00:01:32,306
当然，我们可以将内容存储在iCloud中。 

33
00:01:32,306 --> 00:01:33,390
那是好方法

34
00:01:33,390 --> 00:01:36,380
因为它在我们所有设备之间共享。 

35
00:01:36,380 --> 00:01:39,260
而且，实际上，有一个名为CloudKit的整个框架， 

36
00:01:39,260 --> 00:01:42,810
让我们从本质上进行数据库操作， 

37
00:01:42,810 --> 00:01:44,490
存储在云中。 

38
00:01:44,490 --> 00:01:46,540
所以这是一个很酷的方法。 

39
00:01:46,540 --> 00:01:48,772
并且还有许多第三方选项。 

40
00:01:48,772 --> 00:01:51,200
第三方提供的不同框架

41
00:01:51,200 --> 00:01:53,592
做同样的事情，网络数据库， 

42
00:01:53,592 --> 00:01:56,468
存放东西的地方，等等。 

43
00:01:56,468 --> 00:01:59,244
但最简单的存储方式之一

44
00:01:59,244 --> 00:02:01,520
使用的是UserDefaults 

45
00:02:01,520 --> 00:02:05,240
您可以将其视为持久性字典。 

46
00:02:05,240 --> 00:02:08,632
感觉很像只是粘贴在磁盘上的字典， 

47
00:02:08,632 --> 00:02:11,390
但实际上只能使用

48
00:02:11,390 --> 00:02:13,440
运送应用程式时， 

49
00:02:13,440 --> 00:02:15,420
您可能只想使用UserDefaults 

50
00:02:15,420 --> 00:02:18,832
根据用户的喜好，可以做一些小事情。 

51
00:02:18,832 --> 00:02:21,270
例如，您不想使用它来

52
00:02:21,270 --> 00:02:22,480
存储您的文件， 

53
00:02:22,480 --> 00:02:24,030
这就是我们在演示中要做的

54
00:02:24,030 --> 00:02:26,160
这就是为什么我告诉您有关UserDefaults的原因， 

55
00:02:26,160 --> 00:02:29,470
因此我们需要一种轻巧的方式来存储我们的文档， 

56
00:02:29,470 --> 00:02:30,303
所以我们要去做。 

57
00:02:30,303 --> 00:02:32,880
但是我的意思是，尽管UserDefaults很有价值， 

58
00:02:32,880 --> 00:02:34,720
用于存储这些轻巧的东西

59
00:02:34,720 --> 00:02:37,970
但您也会发现它也有些古怪。 

60
00:02:37,970 --> 00:02:39,922
现在UserDefaults非常有限

61
00:02:39,922 --> 00:02:42,000
可以存储的数据类型。 

62
00:02:42,000 --> 00:02:44,740
这不仅是完整的数据库或完整的词典， 

63
00:02:44,740 --> 00:02:46,790
您可以在其中放入任何想要的类型。 

64
00:02:46,790 --> 00:02:50,658
这是一个古老的API，已经存在了很长时间， 

65
00:02:50,658 --> 00:02:54,450
远远早于SwiftUI甚至Swift， 

66
00:02:54,450 --> 00:02:56,950
它的API有点奇怪

67
00:02:56,950 --> 00:02:58,570
给你们这个班的人

68
00:02:58,570 --> 00:03:01,610
现在真正习惯了函数式编程的人。 

69
00:03:01,610 --> 00:03:03,836
但是如果我们斜视这个API， 

70
00:03:03,836 --> 00:03:08,836
我们可以使其看起来足够接近Swift 

71
00:03:09,040 --> 00:03:11,579
并对其进行功能编程。 

72
00:03:11,579 --> 00:03:15,450
存储在UserDefaults中的数据

73
00:03:15,450 --> 00:03:17,040
称为属性列表。 

74
00:03:17,040 --> 00:03:21,030
现在，属性列表不是协议或结构， 

75
00:03:21,030 --> 00:03:24,630
或Swift的任何有形东西， 

76
00:03:24,630 --> 00:03:26,227
因为这一切都很漂亮。 

77
00:03:26,227 --> 00:03:29,140
但是财产清单实际上只是一个概念。 

78
00:03:29,140 --> 00:03:30,390
这是一个主意。 

79
00:03:30,390 --> 00:03:33,840
这个想法是它是字符串的任意组合， 

80
00:03:33,840 --> 00:03:37,530
整数，布尔值，浮点数（例如Float或Double）， 

81
00:03:37,530 --> 00:03:42,530
日期，数据，是一堆袋子，只是任意数据， 

82
00:03:42,540 --> 00:03:43,940
数组和字典。 

83
00:03:43,940 --> 00:03:46,171
因此，您将所有这些组合在一起

84
00:03:46,171 --> 00:03:50,891
像一个带有带字符串字典的数组

85
00:03:50,891 --> 00:03:53,260
作为键，将Ints作为值， 

86
00:03:53,260 --> 00:03:54,493
那将是一个属性列表。 

87
00:03:54,493 --> 00:03:56,930
有点愚蠢，但这将是一个属性列表

88
00:03:56,930 --> 00:04:00,120
因为其中所有的东西都是其中之一。 

89
00:04:00,120 --> 00:04:01,220
这就是我们可以存储的所有内容， 

90
00:04:01,220 --> 00:04:02,470
我们不能存储其他任何东西。 

91
00:04:02,470 --> 00:04:03,800
如果您想存储其他东西， 

92
00:04:03,800 --> 00:04:07,630
您必须以某种方式将其转换为属性列表。 

93
00:04:07,630 --> 00:04:10,200
现在，Swift中非常强大的方法

94
00:04:10,200 --> 00:04:14,190
将任意结构转换为属性列表

95
00:04:14,190 --> 00:04:16,580
正在使用此可编码协议， 

96
00:04:16,580 --> 00:04:19,410
我将推迟讲给你看

97
00:04:19,410 --> 00:04:22,420
在演示中，而不是一堆幻灯片。 

98
00:04:22,420 --> 00:04:24,893
您很快就会看到Codable的工作原理。 

99
00:04:24,893 --> 00:04:27,610
这是将结构转换为数据的好方法， 

100
00:04:27,610 --> 00:04:31,210
当然，数据（一小袋）是一个属性列表， 

101
00:04:31,210 --> 00:04:33,480
因此我们可以将其放入UserDefaults中。 

102
00:04:33,480 --> 00:04:35,230
我们将在演示中看到所有内容。 

103
00:04:36,860 --> 00:04:39,880
现在，为什么UserDefaults的API很奇怪？ 

104
00:04:39,880 --> 00:04:44,010
好吧，因为在该API中，Swift是一种类型， 

105
00:04:44,010 --> 00:04:47,780
我们没有谈论过的，有意地称为Any。 

106
00:04:47,780 --> 00:04:51,360
因此，Any基本上是一种意味着没有类型的类型。 

107
00:04:51,360 --> 00:04:52,570
如果是任何类型的东西， 

108
00:04:52,570 --> 00:04:54,780
就像它真的没有类型。 

109
00:04:54,780 --> 00:04:57,330
Swift是一种强类型语言， 

110
00:04:57,330 --> 00:04:59,300
它不喜欢任何。 

111
00:04:59,300 --> 00:05:02,003
任何都与Swift相反。 

112
00:05:02,003 --> 00:05:06,260
但是，它具有此类型Any只是为了向后兼容

113
00:05:06,260 --> 00:05:08,480
诸如UserDefaults之类的东西。 

114
00:05:08,480 --> 00:05:10,530
所以，我们真的不想与任何

115
00:05:10,530 --> 00:05:13,732
通常是SwiftUI和Swift程序员。 

116
00:05:13,732 --> 00:05:14,840
但是我们想使用UserDefaults， 

117
00:05:14,840 --> 00:05:19,550
因此我们将尝试在UserDefaults的API中忽略Any， 

118
00:05:19,550 --> 00:05:22,400
这是一个挑战，但您可以做到。 

119
00:05:22,400 --> 00:05:24,917
但是我们仍然想了解如何使用UserDefaults。 

120
00:05:24,917 --> 00:05:26,453
所以，让我们潜入这里。 

121
00:05:27,290 --> 00:05:29,190
您需要使用UserDefaults的第一件事是， 

122
00:05:29,190 --> 00:05:31,380
您需要一个UserDefaults实例， 

123
00:05:31,380 --> 00:05:33,908
您将要使用的所有方法功能

124
00:05:33,908 --> 00:05:36,500
UserDefaults中的实例方法。 

125
00:05:36,500 --> 00:05:39,950
所以，我们通常通过这个静态变量

126
00:05:39,950 --> 00:05:42,670
在UserDefaults上称为标准。 

127
00:05:42,670 --> 00:05:43,739
已经有点怪了吧？ 

128
00:05:43,739 --> 00:05:45,880
所以您说UserDefaults点标准， 

129
00:05:45,880 --> 00:05:47,730
然后您可以使用此共享实例

130
00:05:47,730 --> 00:05:48,563
在您的整个应用中。 

131
00:05:48,563 --> 00:05:52,700
现在，您可以创建其他实例，但这是99％的时间， 

132
00:05:52,700 --> 00:05:54,509
我们如何做到的。 

133
00:05:54,509 --> 00:05:55,933
然后，如果我们想存储数据， 

134
00:05:55,933 --> 00:05:59,572
我们将使用名为set forKey的此函数。 

135
00:05:59,572 --> 00:06:03,590
set在那里接受第一个参数，即object， 

136
00:06:03,590 --> 00:06:05,907
该对象必须是属性列表。 

137
00:06:05,907 --> 00:06:08,800
因此它必须是一个Int或字符串数​​组

138
00:06:08,800 --> 00:06:13,170
或只有我们谈论过的东西

139
00:06:13,170 --> 00:06:14,360
可能在属性列表中。 

140
00:06:14,360 --> 00:06:15,339
但这可以是任何东西

141
00:06:15,339 --> 00:06:18,010
只要那是全部。 

142
00:06:18,010 --> 00:06:21,610
然后forKey只是一些随机的String，再一次， 

143
00:06:21,610 --> 00:06:22,800
这就像一本字典， 

144
00:06:22,800 --> 00:06:26,040
因此，这是以后查找它的关键。 

145
00:06:26,040 --> 00:06:29,120
现在，为方便起见，还有诸如setDouble， 

146
00:06:29,120 --> 00:06:31,550
这需要一倍的forKey。 

147
00:06:31,550 --> 00:06:34,180
真的是语法糖

148
00:06:34,180 --> 00:06:38,260
就像说37.5一样， 

149
00:06:38,260 --> 00:06:39,783
forKey是同一回事。 

150
00:06:39,783 --> 00:06:42,230
但是您可以看到它看起来像一个字典，对吗？ 

151
00:06:42,230 --> 00:06:45,048
设置某个键的值。 

152
00:06:45,048 --> 00:06:47,740
现在如何获取数据？ 

153
00:06:47,740 --> 00:06:48,573
真的很容易

154
00:06:48,573 --> 00:06:51,260
有很多函数，例如integer forKey， 

155
00:06:51,260 --> 00:06:56,200
数据forKey，URL forKey甚至String Array forKey， 

156
00:06:56,200 --> 00:07:00,130
转到UserDefaults中的那个键， 

157
00:07:00,130 --> 00:07:02,320
看看以前有人在那里存储了什么， 

158
00:07:02,320 --> 00:07:05,000
如果能够将其变成您想要的类型， 

159
00:07:05,000 --> 00:07:08,010
如网址或字符串数​​组，它将返回它。 

160
00:07:08,010 --> 00:07:11,240
如果没有，它将返回nil。 

161
00:07:11,240 --> 00:07:13,840
因此，如果它是这些基本类型之一，那就太好了， 

162
00:07:13,840 --> 00:07:17,298
但是，如果您除了字符串以外还拥有其他数组，该怎么办？ 

163
00:07:17,298 --> 00:07:18,990
好吧，它开始变得复杂， 

164
00:07:18,990 --> 00:07:22,440
这就是Any开始出现的地方

165
00:07:22,440 --> 00:07:24,920
进来，一个怪物让我们。 

166
00:07:24,920 --> 00:07:29,060
因此，如果我尝试存储的数组，可以说， 

167
00:07:29,060 --> 00:07:33,860
字典，这是合法的，但是没有所谓的函数

168
00:07:33,860 --> 00:07:35,420
给我一本字典， 

169
00:07:35,420 --> 00:07:36,253
只有字符串数组， 

170
00:07:36,253 --> 00:07:38,370
那只是数组之一。 

171
00:07:38,370 --> 00:07:40,470
因此，如果您仅调用Array forKey， 

172
00:07:40,470 --> 00:07:42,660
您将获得任意阵列。 

173
00:07:42,660 --> 00:07:44,682
而且，我该如何处理这个Any？ 

174
00:07:44,682 --> 00:07:47,550
好吧，您将不得不在Swift中使用此运算符

175
00:07:47,550 --> 00:07:51,329
称为类型转换数组中的事物

176
00:07:51,329 --> 00:07:54,360
从任何人到成为您希望知道的类型

177
00:07:54,360 --> 00:07:55,750
它们是什么。 

178
00:07:55,750 --> 00:07:57,200
我们将在这里停下来。 

179
00:07:57,200 --> 00:07:59,960
我不想真正谈论类型转换， 

180
00:07:59,960 --> 00:08:02,860
您真的不需要在Swift中做那么多的事情。 

181
00:08:02,860 --> 00:08:04,430
现在，您本周的阅读作业

182
00:08:04,430 --> 00:08:05,790
将要谈论的是

183
00:08:05,790 --> 00:08:07,071
因此，如果您想知道这一点， 

184
00:08:07,071 --> 00:08:09,760
您会看到称为类型转换的部分， 

185
00:08:09,760 --> 00:08:11,319
它会告诉您所有相关信息。 

186
00:08:11,319 --> 00:08:15,043
但希望您可以避免整个事情

187
00:08:15,043 --> 00:08:19,800
通过某种方式弄清楚如何使用这些正常的之一

188
00:08:19,800 --> 00:08:21,720
从屏幕顶部开始

189
00:08:21,720 --> 00:08:23,490
而Codable可能真的可以帮助您， 

190
00:08:23,490 --> 00:08:25,791
因为这样您就可以将数据用于key。 

191
00:08:25,791 --> 00:08:28,030
而且Codable可以帮助您转换几乎所有结构， 

192
00:08:28,030 --> 00:08:31,823
甚至是一些古怪的东西数组，都变成了数据。 

193
00:08:33,810 --> 00:08:37,337
这就是我今天要说的UserDefaults。 

194
00:08:37,337 --> 00:08:39,630
我们将在这里进入我们的主要主题， 

195
00:08:39,630 --> 00:08:41,030
这是手势。 

196
00:08:41,030 --> 00:08:44,462
因此，手势实际上就是从用户那里获取输入。 

197
00:08:44,462 --> 00:08:47,720
我们之所以称为多点触控，是因为

198
00:08:47,720 --> 00:08:50,390
您可以同时放下多个手指， 

199
00:08:50,390 --> 00:08:54,430
并做手势，SwiftUI将识别它们。 

200
00:08:54,430 --> 00:08:58,230
斯威夫特几乎会注意识别这些手势

201
00:08:58,230 --> 00:08:59,840
当有人放下两根手指

202
00:08:59,840 --> 00:09:01,856
然后开始一起挤压他们的手指， 

203
00:09:01,856 --> 00:09:05,310
斯威夫特意识到，哇，这很关键，他们在捏， 

204
00:09:05,310 --> 00:09:06,520
我知道那个手势

205
00:09:06,520 --> 00:09:08,840
因此它可以识别它们，您所要做的就是说

206
00:09:08,840 --> 00:09:11,020
您想要识别哪些视图， 

207
00:09:11,020 --> 00:09:13,000
它将开始识别它们。 

208
00:09:13,000 --> 00:09:15,880
但是，重要的不只是认识他们， 

209
00:09:15,880 --> 00:09:17,935
一旦意识到发生这种情况， 

210
00:09:17,935 --> 00:09:21,490
您和您的代码必须处理手势。 

211
00:09:21,490 --> 00:09:23,423
因此，Swift做到了这一点， 

212
00:09:23,423 --> 00:09:26,270
SwiftUI会执行此操作，然后进行处理， 

213
00:09:26,270 --> 00:09:27,750
这是您必须要做的。 

214
00:09:27,750 --> 00:09:29,950
处理它只意味着决定要做什么

215
00:09:29,950 --> 00:09:32,433
当捏，拖或轻敲时。 

216
00:09:34,300 --> 00:09:37,940
因此，让我们先谈谈如何让您的“视图” 

217
00:09:37,940 --> 00:09:39,700
某种手势正在发生

218
00:09:39,700 --> 00:09:42,890
使用SwiftUI强大的手势识别功能。 

219
00:09:42,890 --> 00:09:46,040
很简单，View上只有一个ViewModifier 

220
00:09:46,040 --> 00:09:49,560
称为.gesture，您只需通过手势即可。 

221
00:09:49,560 --> 00:09:51,950
您通过的这个手势（手势） 

222
00:09:51,950 --> 00:09:53,430
只是需要什么

223
00:09:53,430 --> 00:09:55,340
实现了Gesture协议， 

224
00:09:55,340 --> 00:09:56,590
我们将谈论

225
00:09:56,590 --> 00:09:59,337
什么东西实现了Gesture协议，仅此而已。 

226
00:09:59,337 --> 00:10:02,230
然后，您的myView就在那里， 

227
00:10:02,230 --> 00:10:04,704
每当您的视图中开始发生该手势时， 

228
00:10:04,704 --> 00:10:06,823
您将被要求处理。 

229
00:10:08,350 --> 00:10:09,790
现在我们如何创建这个手势？ 

230
00:10:09,790 --> 00:10:12,260
我们如何在此处指定想要的手势？ 

231
00:10:12,260 --> 00:10:16,110
我们几乎总是使用View中的某个功能来做到这一点， 

232
00:10:16,110 --> 00:10:18,020
或可能是计算得出的var 

233
00:10:18,020 --> 00:10:21,279
甚至可能是我们身体var顶部的局部var， 

234
00:10:21,279 --> 00:10:22,960
就在我们这样做之前。 

235
00:10:22,960 --> 00:10:25,031
任何可以存储此东西的地方都可以， 

236
00:10:25,031 --> 00:10:27,900
而这台计算机var或func或其他

237
00:10:27,900 --> 00:10:30,680
只需要返回一些手势即可。 

238
00:10:30,680 --> 00:10:31,860
所以你知道一些意思， 

239
00:10:31,860 --> 00:10:34,200
这意味着您可以在其中退还任何物品

240
00:10:34,200 --> 00:10:37,420
只要实现该协议， 

241
00:10:37,420 --> 00:10:39,950
Swift会为您找出该返回类型。 

242
00:10:39,950 --> 00:10:42,033
所以在这里我有var theGesture， 

243
00:10:42,033 --> 00:10:45,290
我返回的TapGesture数为2。 

244
00:10:45,290 --> 00:10:48,390
Swift会知道其中有一些手势是TapGesture。 

245
00:10:48,390 --> 00:10:51,230
TapGesture是手势之一

246
00:10:51,230 --> 00:10:52,110
内置于SwiftUI中。 

247
00:10:52,110 --> 00:10:54,470
您非常了解，TapGesture。 

248
00:10:54,470 --> 00:10:57,380
我在这里特别数了两个。 

249
00:10:57,380 --> 00:10:58,959
因此，这实际上是双击。 

250
00:10:58,959 --> 00:11:02,270
TapGesture的初始化程序有一个参数， 

251
00:11:02,270 --> 00:11:04,640
这是多少次点击，我的默认值为一次， 

252
00:11:04,640 --> 00:11:05,913
但是我在这里说了两个。 

253
00:11:06,840 --> 00:11:09,480
结合您在此处看到的两段代码， 

254
00:11:09,480 --> 00:11:11,140
一个在顶部，一个在底部， 

255
00:11:11,140 --> 00:11:13,315
Swift将开始识别双击。 

256
00:11:13,315 --> 00:11:16,530
但是，双击时它什么也不会做， 

257
00:11:16,530 --> 00:11:18,530
因为我们没有告诉Swift如何处理

258
00:11:18,530 --> 00:11:20,310
双击发生。 

259
00:11:20,310 --> 00:11:25,060
所以我们下一步要做的就是向它解释

260
00:11:25,060 --> 00:11:28,930
如何处理，这取决于手势的种类， 

261
00:11:28,930 --> 00:11:30,170
这个怎么做。 

262
00:11:30,170 --> 00:11:33,250
因此，某些手势是离散的，例如TapGesture， 

263
00:11:33,250 --> 00:11:36,840
和LongPressGesture可以是离散的， 

264
00:11:36,840 --> 00:11:40,240
只是在发生轻拍的地方，然后再做点什么。 

265
00:11:40,240 --> 00:11:42,860
发生LongPressGesture，然后执行一些操作。 

266
00:11:42,860 --> 00:11:44,760
这与捏或拖动不同， 

267
00:11:44,760 --> 00:11:47,490
他们正在加班， 

268
00:11:47,490 --> 00:11:49,240
我们可能想参与其中。 

269
00:11:49,240 --> 00:11:50,970
因此，对于离散手势，这些操作很简单， 

270
00:11:50,970 --> 00:11:52,490
让我们将其清除。 

271
00:11:52,490 --> 00:11:55,317
您可以通过手势调用该功能

272
00:11:55,317 --> 00:11:58,260
.onEnded，需要关闭， 

273
00:11:58,260 --> 00:12:00,360
在那个关闭中，您可以做任何您想做的事

274
00:12:00,360 --> 00:12:02,370
TapGesture结束的时间。 

275
00:12:02,370 --> 00:12:04,930
这意味着当手指再次抬起敲击时， 

276
00:12:04,930 --> 00:12:06,430
或者，如果这是双击， 

277
00:12:06,430 --> 00:12:08,747
第二次手指再次抬起。 

278
00:12:08,747 --> 00:12:09,930
就是这样。 

279
00:12:09,930 --> 00:12:12,470
处理离散手势再简单不过了。 

280
00:12:12,470 --> 00:12:14,340
当然，离散手势

281
00:12:14,340 --> 00:12:15,880
非常简单易用， 

282
00:12:15,880 --> 00:12:18,780
他们有这些不错的便利功能， 

283
00:12:18,780 --> 00:12:21,240
您已经在TapGesture上看到了它。 

284
00:12:21,240 --> 00:12:22,370
我不知道你是否知道

285
00:12:22,370 --> 00:12:24,820
它也需要参数计数。 

286
00:12:24,820 --> 00:12:26,030
然后，您只需做一些事情即可。 

287
00:12:26,030 --> 00:12:28,510
这与我们所见完全相同

288
00:12:28,510 --> 00:12:29,650
在前两张幻灯片中。 

289
00:12:29,650 --> 00:12:32,340
在这里，我们将要处理TapGesture。 

290
00:12:32,340 --> 00:12:33,934
因此，离散手势很容易。 

291
00:12:33,934 --> 00:12:38,503
非离散手势，只需更多工作即可。 

292
00:12:39,360 --> 00:12:40,650
用非离散的姿势

293
00:12:40,650 --> 00:12:43,560
当它结束时，您一定会处理好

294
00:12:43,560 --> 00:12:44,720
我们将在稍后讨论

295
00:12:44,720 --> 00:12:46,320
就像一个离散的手势。 

296
00:12:46,320 --> 00:12:49,090
但是随着移动，您也可以应付， 

297
00:12:49,090 --> 00:12:51,600
当手指捏在一起时， 

298
00:12:51,600 --> 00:12:53,360
或者当他们旋转时， 

299
00:12:53,360 --> 00:12:56,870
或当手指在屏幕上拖动时， 

300
00:12:56,870 --> 00:12:58,260
你可以去做某事， 

301
00:12:58,260 --> 00:13:01,120
在您的“视图”中四处移动一整遍， 

302
00:13:01,120 --> 00:13:03,470
无论您想做什么，都可以做到。 

303
00:13:03,470 --> 00:13:05,522
现在，这些非离散手势的示例

304
00:13:05,522 --> 00:13:10,522
DragGesture，MagnificationGesture就像捏一样

305
00:13:10,750 --> 00:13:13,490
RotationGesture，就像您要转动表盘一样

306
00:13:13,490 --> 00:13:15,350
用两根手指，将两根手指放在屏幕上， 

307
00:13:15,350 --> 00:13:18,440
就像转动表盘，然后指定一些角度， 

308
00:13:18,440 --> 00:13:20,620
实际上，这种变化随您的操作而改变。 

309
00:13:20,620 --> 00:13:23,800
甚至LongPressGesture也可以是非离散的， 

310
00:13:23,800 --> 00:13:28,512
按住不放，所以它会说

311
00:13:28,512 --> 00:13:31,000
手指握住，然后重新抬起

312
00:13:31,000 --> 00:13:32,273
您会发现它出现了。 

313
00:13:32,273 --> 00:13:33,330
这与水龙头不同。 

314
00:13:33,330 --> 00:13:35,020
您不知道水龙头何时下降， 

315
00:13:35,020 --> 00:13:36,070
你只会发现它上升的时候， 

316
00:13:36,070 --> 00:13:37,833
但是长按一下，您就可以找到答案。 

317
00:13:38,680 --> 00:13:41,720
因此，让我们从谈论它们的结尾开始。 

318
00:13:41,720 --> 00:13:43,810
因此，就像离散一样，我们可以找出结局， 

319
00:13:43,810 --> 00:13:46,490
它与.onEnded完全相同。 

320
00:13:46,490 --> 00:13:49,630
唯一的区别是，您传递的功能

321
00:13:49,630 --> 00:13:52,284
闭包引起了争论。 

322
00:13:52,284 --> 00:13:55,390
因为，当DragGesture结束时， 

323
00:13:55,390 --> 00:13:58,765
您想知道，那次拖拽发生了什么？ 

324
00:13:58,765 --> 00:14:01,280
因此，您将在这里得到一点争论， 

325
00:14:01,280 --> 00:14:02,880
这个值参数

326
00:14:02,880 --> 00:14:05,945
每种手势都不同， 

327
00:14:05,945 --> 00:14:08,720
那会告诉你发生了什么。 

328
00:14:08,720 --> 00:14:10,930
对于DragGesture，该值为结构

329
00:14:10,930 --> 00:14:13,450
拖曳的起始位置

330
00:14:13,450 --> 00:14:15,510
和手指的结束位置。 

331
00:14:15,510 --> 00:14:18,620
对于放大倍数，它是放大倍数， 

332
00:14:18,620 --> 00:14:21,590
手指分开的距离

333
00:14:21,590 --> 00:14:23,850
当他们抬起屏幕。 

334
00:14:23,850 --> 00:14:25,810
和RotationGesture相似，对。 

335
00:14:25,810 --> 00:14:27,390
就像转动表盘，所以要说

336
00:14:27,390 --> 00:14:31,120
在手指抬起之前，它旋转了多少角度？ 

337
00:14:31,120 --> 00:14:33,510
仍然要结束，但您当然要找出答案， 

338
00:14:33,510 --> 00:14:35,113
那里发生了什么。 

339
00:14:36,300 --> 00:14:38,320
但更有趣的是

340
00:14:38,320 --> 00:14:39,725
在非离散手势时

341
00:14:39,725 --> 00:14:43,096
您想知道事情正在发生变化。 

342
00:14:43,096 --> 00:14:46,769
我们通过一些状态来做到这一点

343
00:14:46,769 --> 00:14:49,570
那只会生效

344
00:14:49,570 --> 00:14:51,894
当手势进行时。 

345
00:14:51,894 --> 00:14:54,990
此状态存储在您想要的任何var中， 

346
00:14:54,990 --> 00:14:55,960
您只需要标记它

347
00:14:55,960 --> 00:14:58,260
带有特殊标记@GestureState 

348
00:14:59,470 --> 00:15:02,080
而且您还必须给这个变量一个初始值

349
00:15:02,080 --> 00:15:03,450
某种形式。 

350
00:15:03,450 --> 00:15:05,210
该变量可以是您想要的任何类型。 

351
00:15:05,210 --> 00:15:07,470
可能是CGFloat，可能是结构

352
00:15:07,470 --> 00:15:09,540
里面有各种你自己的东西。 

353
00:15:09,540 --> 00:15:12,990
此var可以没有限制。 

354
00:15:12,990 --> 00:15:15,170
而这个var基本上要做的是

355
00:15:15,170 --> 00:15:18,220
告诉您的视图，这是您需要了解的所有内容

356
00:15:18,220 --> 00:15:20,450
在这个手势中吸引自己。 

357
00:15:20,450 --> 00:15:21,520
这就是这里发生的事情。 

358
00:15:21,520 --> 00:15:23,667
这就是这个变量的全部含义。 

359
00:15:23,667 --> 00:15:26,260
但这是特别标记的，我们将讨论

360
00:15:26,260 --> 00:15:27,460
有什么特别之处。 

361
00:15:28,330 --> 00:15:30,620
首先要了解的是这个变种很特别

362
00:15:30,620 --> 00:15:33,674
是它总是会回到那个初始值

363
00:15:33,674 --> 00:15:34,960
当手势结束时。 

364
00:15:34,960 --> 00:15:37,100
这就是为什么必须给它一个初始值的原因。 

365
00:15:37,100 --> 00:15:38,640
因此，当手势进行时， 

366
00:15:38,640 --> 00:15:42,080
您将要更新您的这个GestureState 

367
00:15:42,080 --> 00:15:43,450
反映手势中发生的事情

368
00:15:43,450 --> 00:15:46,010
每次手指移动。 

369
00:15:46,010 --> 00:15:48,320
但是，只要手指向上并结束， 

370
00:15:48,320 --> 00:15:50,580
这将重置为初始值。 

371
00:15:50,580 --> 00:15:52,870
因此，您必须了解这个@GestureState 

372
00:15:52,870 --> 00:15:55,890
仅在手势激活时的状态。 

373
00:15:55,890 --> 00:15:57,060
了解非常重要。 

374
00:15:57,060 --> 00:15:57,970
这就是为什么我把它涂成红色， 

375
00:15:57,970 --> 00:16:01,283
手势结束后，它将返回到初始值。 

376
00:16:02,510 --> 00:16:04,031
现在，当手势在发生时， 

377
00:16:04,031 --> 00:16:06,680
您当然有机会

378
00:16:06,680 --> 00:16:08,130
更改此状态。 

379
00:16:08,130 --> 00:16:09,670
这是你自己的状态，你自己的类型， 

380
00:16:09,670 --> 00:16:11,340
因此，您是必须更改它的人。 

381
00:16:11,340 --> 00:16:13,120
这就是您的操作方式。 

382
00:16:13,120 --> 00:16:16,270
就像您拥有.onEnded一样，您还有另一个功能

383
00:16:16,270 --> 00:16:18,140
在您的DragGesture上称为.updating。 

384
00:16:18,140 --> 00:16:20,200
现在屏幕上有很多颜色， 

385
00:16:20,200 --> 00:16:23,920
因此，让我们浏览一下所有这些不同的颜色。 

386
00:16:23,920 --> 00:16:27,110
更新函数带有两个参数， 

387
00:16:27,110 --> 00:16:30,300
括号中的第一个是

388
00:16:30,300 --> 00:16:32,050
您的GestureState变量。 

389
00:16:32,050 --> 00:16:35,550
因此，您要将GestureState变量传递给.updating。 

390
00:16:35,550 --> 00:16:37,590
请注意，您必须在其前面放一美元， 

391
00:16:37,590 --> 00:16:40,350
我将在演示中对此稍作讨论，这是为什么， 

392
00:16:40,350 --> 00:16:43,200
但实际上，我们要等到下周再谈。 

393
00:16:43,200 --> 00:16:44,657
但是只要放一美元

394
00:16:44,657 --> 00:16:46,883
在您的@GestureState变量前面。 

395
00:16:47,870 --> 00:16:50,860
就像.onEnded一样，.updating需要关闭

396
00:16:50,860 --> 00:16:51,693
它会打电话。 

397
00:16:51,693 --> 00:16:53,420
现在，要反复叫那个东西

398
00:16:53,420 --> 00:16:55,420
当手指靠近时， 

399
00:16:55,420 --> 00:16:58,030
或手指在屏幕上拖动，等等

400
00:16:58,030 --> 00:17:00,550
它会被一遍又一遍地称为这种关闭。 

401
00:17:00,550 --> 00:17:02,800
那么我们在那里的三个论点是什么

402
00:17:02,800 --> 00:17:03,871
到关闭？ 

403
00:17:03,871 --> 00:17:07,120
第一个是蓝色值参数， 

404
00:17:07,120 --> 00:17:08,930
相同的是.onEnded。 

405
00:17:08,930 --> 00:17:10,960
也就是说，此手势的状态。 

406
00:17:10,960 --> 00:17:13,294
手指合在一起有多近以进行挤压， 

407
00:17:13,294 --> 00:17:16,800
如果我们拖动，手指会移动多远，无论如何。 

408
00:17:16,800 --> 00:17:17,633
这是一个结构。 

409
00:17:17,633 --> 00:17:21,050
这取决于我们在这里谈论的手势

410
00:17:21,050 --> 00:17:22,350
至于里面有什么

411
00:17:22,350 --> 00:17:24,050
可能不是结构，如放大倍数

412
00:17:24,050 --> 00:17:26,240
我认为这只是具有规模的CGFloat。 

413
00:17:26,240 --> 00:17:27,640
但是对于DragGestures来说，这是一个结构

414
00:17:27,640 --> 00:17:29,990
带有开始位置，结束位置，时间戳， 

415
00:17:29,990 --> 00:17:31,620
还有其他东西。 

416
00:17:31,620 --> 00:17:32,760
这就是价值所在。 

417
00:17:32,760 --> 00:17:35,540
您已经习惯了.onEnded。 

418
00:17:35,540 --> 00:17:38,440
那里是myGestureState紫色参数， 

419
00:17:38,440 --> 00:17:42,010
本质上又是您的@GestureState。 

420
00:17:42,010 --> 00:17:43,090
不仅在那里

421
00:17:43,090 --> 00:17:46,390
它也在这个小封闭中。 

422
00:17:46,390 --> 00:17:48,270
您可以在那里为其指定一个值。 

423
00:17:48,270 --> 00:17:52,130
所以，我将在演示中简要介绍一下

424
00:17:52,130 --> 00:17:55,480
这里发生的事情本质上是一个inout参数， 

425
00:17:55,480 --> 00:17:57,180
但是你真正需要知道的

426
00:17:57,180 --> 00:17:59,040
为了使这项工作， 

427
00:17:59,040 --> 00:18:02,830
是你的@GestureState变量

428
00:18:02,830 --> 00:18:06,213
在这三个地方出现作为.updating的参数， 

429
00:18:06,213 --> 00:18:08,550
作为关闭的第二个参数， 

430
00:18:08,550 --> 00:18:12,250
然后在里面作为一个可变的可写变量

431
00:18:12,250 --> 00:18:13,640
你可以改变。 

432
00:18:13,640 --> 00:18:16,011
现在，如果您想把手放在眼睛上

433
00:18:16,011 --> 00:18:18,040
不用考虑

434
00:18:18,040 --> 00:18:20,090
您可以认为在此关闭内

435
00:18:20,090 --> 00:18:22,797
您可以更改@GestureState变量。 

436
00:18:22,797 --> 00:18:26,489
这实际上不是正在发生的事情，但是感觉就像是。 

437
00:18:26,489 --> 00:18:29,470
但是这里发生的概念性语义问题， 

438
00:18:29,470 --> 00:18:31,800
实际上，这是唯一的方法

439
00:18:31,800 --> 00:18:34,324
您应该更改您的@GestureState。 

440
00:18:34,324 --> 00:18:38,270
您无法在其他任何地方更改myGestureState 

441
00:18:38,270 --> 00:18:40,307
除了此封包内部的内容。 

442
00:18:40,307 --> 00:18:43,530
这很有意义，因为此@GestureState 

443
00:18:43,530 --> 00:18:47,420
仅在手势进行时才处于活动状态。 

444
00:18:47,420 --> 00:18:49,700
因此，您再也不想设置它了。 

445
00:18:49,700 --> 00:18:51,690
实际上没有任何其他时间设置它

446
00:18:51,690 --> 00:18:53,140
然后当这件事进行的时候， 

447
00:18:53,140 --> 00:18:55,303
因为这就是@GestureState的全部。 

448
00:18:56,600 --> 00:18:57,610
非常重要的一点是要了解

449
00:18:57,610 --> 00:19:00,187
这是您更改@GestureState变量的唯一位置。 

450
00:19:00,187 --> 00:19:01,760
您可以将其更改为所需的任何内容， 

451
00:19:01,760 --> 00:19:03,980
而且您几乎总是要将其更改为某些内容

452
00:19:03,980 --> 00:19:06,010
基于那个蓝色值是正确的。 

453
00:19:06,010 --> 00:19:08,160
根据手指并拢的距离， 

454
00:19:08,160 --> 00:19:09,370
他们搬了多少。 

455
00:19:09,370 --> 00:19:12,232
您将更新您的小@GestureState结构

456
00:19:12,232 --> 00:19:14,830
这样您的视图才能正确绘制自己

457
00:19:14,830 --> 00:19:17,273
在拖动或挤压的中间。 

458
00:19:18,420 --> 00:19:20,420
现在，这里的第三个论点是交易， 

459
00:19:20,420 --> 00:19:21,726
与动画有关。 

460
00:19:21,726 --> 00:19:23,640
在本课程中，我们不会谈论这一点。 

461
00:19:23,640 --> 00:19:24,830
有一些限制， 

462
00:19:24,830 --> 00:19:26,570
我们只是没有时间谈论所有事情。 

463
00:19:26,570 --> 00:19:27,920
你可以看一下文档

464
00:19:27,920 --> 00:19:29,850
如果您想尝试找出交易。 

465
00:19:29,850 --> 00:19:33,040
用于视图之间的高级动画交互， 

466
00:19:33,040 --> 00:19:36,083
我们只需要在某处画线。 

467
00:19:37,180 --> 00:19:40,840
现在，实际上有一个更简单的.updating版本， 

468
00:19:40,840 --> 00:19:41,990
它称为.onChanged。 

469
00:19:43,090 --> 00:19:45,760
而且，当您第一次看到此内容时，您可能会喜欢， 

470
00:19:45,760 --> 00:19:47,630
哦，这比较简单，我要用这个， 

471
00:19:47,630 --> 00:19:50,250
但这仅适用于某些类型的更改。 

472
00:19:50,250 --> 00:19:51,937
我会在稍后解释。 

473
00:19:51,937 --> 00:19:55,000
因此，.onChanged看起来就像.updating， 

474
00:19:55,000 --> 00:19:57,440
除了，没有@GestureState。 

475
00:19:57,440 --> 00:19:58,788
因为在.onChanged中， 

476
00:19:58,788 --> 00:20:01,710
您不会更新任何@GestureState。 

477
00:20:01,710 --> 00:20:03,342
此值传递给您， 

478
00:20:03,342 --> 00:20:05,610
而您只需要基于它做一些事情。 

479
00:20:05,610 --> 00:20:07,883
这就是为什么这样做的局限性。 

480
00:20:07,883 --> 00:20:10,703
但是，您可以做一些事情， 

481
00:20:10,703 --> 00:20:12,560
那是什么东西？ 

482
00:20:12,560 --> 00:20:14,660
好吧，如果你在做某事

483
00:20:14,660 --> 00:20:18,280
您实际上对实际的手指位置感兴趣， 

484
00:20:18,280 --> 00:20:20,440
就像您所做的一样，拖动以选择右侧

485
00:20:20,440 --> 00:20:22,120
您在屏幕上拖动手指

486
00:20:22,120 --> 00:20:24,400
选择对象或类似的东西， 

487
00:20:24,400 --> 00:20:29,003
那么您只想知道当前拖出的位置。 

488
00:20:29,900 --> 00:20:32,200
那不就是你捏

489
00:20:32,200 --> 00:20:35,530
放大或缩小某物，或四处移动， 

490
00:20:35,530 --> 00:20:38,530
或相对于以前的位置。 

491
00:20:38,530 --> 00:20:40,340
就像绝对的手指位置，或者

492
00:20:40,340 --> 00:20:43,263
你会跟着手指转，像笔一样画

493
00:20:43,263 --> 00:20:45,170
在您的应用中

494
00:20:45,170 --> 00:20:46,820
然后，您可能想要这个。 

495
00:20:46,820 --> 00:20:48,150
但是，大多数时候您对

496
00:20:48,150 --> 00:20:49,450
在相对的变化。 

497
00:20:49,450 --> 00:20:51,390
你捏了多少？ 

498
00:20:51,390 --> 00:20:53,630
您跨屏幕拖了多远？ 

499
00:20:53,630 --> 00:20:55,283
当您对相对变化感兴趣时， 

500
00:20:55,283 --> 00:20:57,693
那就是您需要更新的时候。 

501
00:20:59,410 --> 00:21:02,210
好吧，我要总结一下

502
00:21:02,210 --> 00:21:04,600
我在一张幻灯片中刚才说的所有内容。 

503
00:21:04,600 --> 00:21:06,580
所以这是一个让您回顾的机会

504
00:21:06,580 --> 00:21:07,630
并立即获得所有信息。 

505
00:21:07,630 --> 00:21:10,900
这就是我们处理非离散手势的方法

506
00:21:10,900 --> 00:21:12,510
当手指移动时。 

507
00:21:12,510 --> 00:21:14,950
首先，我们将收集所需的任何信息

508
00:21:14,950 --> 00:21:17,223
在手势发生时绘制视图

509
00:21:17,223 --> 00:21:19,130
转换为@GestureState变量。 

510
00:21:19,130 --> 00:21:22,397
可能仅是CGFloat，可能是整个结构。 

511
00:21:22,397 --> 00:21:25,208
然后，我们将.updating添加到我们的手势中。 

512
00:21:25,208 --> 00:21:28,160
无论我们是捏还是拖。 

513
00:21:28,160 --> 00:21:31,420
在我们通过的.updating闭包中， 

514
00:21:31,420 --> 00:21:32,660
我们将获得价值

515
00:21:32,660 --> 00:21:35,350
不断重复手势的变化。 

516
00:21:35,350 --> 00:21:37,450
它会不断给我们带来最新的价值

517
00:21:37,450 --> 00:21:39,080
发生了什么。 

518
00:21:39,080 --> 00:21:42,030
我们将更新我们的@GestureState， 

519
00:21:42,030 --> 00:21:44,100
但是我们会明白@GestureState 

520
00:21:44,100 --> 00:21:46,800
当事情结束时，会消失。 

521
00:21:46,800 --> 00:21:48,540
并返回其初始值。 

522
00:21:48,540 --> 00:21:51,770
因此，在非离散手势的.onEnded中， 

523
00:21:51,770 --> 00:21:54,210
我们将确保更新我们需要做的一切， 

524
00:21:54,210 --> 00:21:56,520
这样，当事情回到最初的价值时， 

525
00:21:56,520 --> 00:21:58,253
我们的视图仍然可以正确绘制。 

526
00:22:00,080 --> 00:22:02,980
好的，让我们进入演示。 

527
00:22:02,980 --> 00:22:04,870
我要告诉你我谈论的有关Codable的内容。 

528
00:22:04,870 --> 00:22:07,070
我们将使用UserDefaults存储我们的文档， 

529
00:22:07,070 --> 00:22:09,470
因为我到目前为止没有时间

530
00:22:09,470 --> 00:22:11,350
教您有关文件系统的知识。 

531
00:22:11,350 --> 00:22:12,920
那里涉及很多

532
00:22:12,920 --> 00:22:14,090
所以我们稍后再做。 

533
00:22:14,090 --> 00:22:16,855
我还要做一些其他有趣的事情，为字体设置动画， 

534
00:22:16,855 --> 00:22:20,025
但是我们今天要做的主要是做一些手势

535
00:22:20,025 --> 00:22:21,290
在我们的EmojiArt中

536
00:22:21,290 --> 00:22:23,650
做到这一点，以便我们可以使文档越来越大， 

537
00:22:23,650 --> 00:22:25,693
然后在里面平移一下

538
00:22:27,560 --> 00:22:30,860
好吧，让我们继续改进我们的EmojiArt。 

539
00:22:30,860 --> 00:22:34,300
当前，它有一个大问题。 

540
00:22:34,300 --> 00:22:39,300
举例来说，如果您开始制作一本非常漂亮的EmojiArt， 

541
00:22:39,444 --> 00:22:43,243
我们树底的一些苹果， 

542
00:22:43,243 --> 00:22:47,227
然后，当我回来时，我退出了我的应用， 

543
00:22:47,227 --> 00:22:49,800
我已经失去了所做的所有工作。 

544
00:22:49,800 --> 00:22:52,000
所以，那不是很好。 

545
00:22:52,000 --> 00:22:53,380
下周或下周， 

546
00:22:53,380 --> 00:22:55,720
我们实际上将处理多个文档， 

547
00:22:55,720 --> 00:22:58,850
和文档选择器等等。 

548
00:22:58,850 --> 00:23:00,685
但是今天，让我们尝试

549
00:23:00,685 --> 00:23:03,560
使我们的文档持久化。 

550
00:23:03,560 --> 00:23:07,080
当我们坚持某件事时，我们需要什么？ 

551
00:23:07,080 --> 00:23:08,330
Kinda需要两件事。 

552
00:23:08,330 --> 00:23:12,210
一，需要某种文件格式来存储它。 

553
00:23:12,210 --> 00:23:13,951
然后我们需要一个放置它的地方。 

554
00:23:13,951 --> 00:23:16,380
可能是我们想要放的地方

555
00:23:16,380 --> 00:23:17,800
在文件系统中， 

556
00:23:17,800 --> 00:23:20,370
我希望能向您展示

557
00:23:20,370 --> 00:23:21,870
在几个星期内。 

558
00:23:21,870 --> 00:23:23,000
但是与此同时

559
00:23:23,000 --> 00:23:25,270
我们只是将其放在UserDefaults中， 

560
00:23:25,270 --> 00:23:27,440
我们今天在幻灯片中谈到了这一点。 

561
00:23:27,440 --> 00:23:29,430
现在，UserDefaults完全是错误的地方

562
00:23:29,430 --> 00:23:32,130
放置文档，但这非常简单， 

563
00:23:32,130 --> 00:23:35,060
一行代码bam，位于UserDefaults中。 

564
00:23:35,060 --> 00:23:36,960
实际上，我们在这里专注于什么， 

565
00:23:36,960 --> 00:23:39,570
不是我们存储它的地方，而是更多， 

566
00:23:39,570 --> 00:23:41,510
我们将使用哪种文件格式， 

567
00:23:41,510 --> 00:23:44,270
以及我们如何生成该文件格式。 

568
00:23:44,270 --> 00:23:47,100
我们将使用的文件格式是JSON。 

569
00:23:47,100 --> 00:23:50,649
因此，你们大多数人以前可能都听说过JSON。 

570
00:23:50,649 --> 00:23:52,622
这是使用的文件格式， 

571
00:23:52,622 --> 00:23:55,910
主要是为了在Internet上传播事物。 

572
00:23:55,910 --> 00:23:57,965
这是一种公共文件格式。 

573
00:23:57,965 --> 00:24:01,460
iOS内置了很棒的功能

574
00:24:01,460 --> 00:24:03,715
它将在哪里生成JSON 

575
00:24:03,715 --> 00:24:08,715
几乎可以想象到的任何结构。 

576
00:24:08,740 --> 00:24:12,800
因此，我们将EmojiArtDocument作为模型中的结构， 

577
00:24:12,800 --> 00:24:15,288
我们可以使用这个很棒的iOS功能

578
00:24:15,288 --> 00:24:18,750
生成它的JSON版本。 

579
00:24:18,750 --> 00:24:19,640
因此，让我们这样做。 

580
00:24:19,640 --> 00:24:23,340
让我们跳回到这里，转到我们的模型，这是我们的模型。 

581
00:24:23,340 --> 00:24:26,333
我们只想把这整个事情转过来

582
00:24:26,333 --> 00:24:28,580
到一团JSON中。 

583
00:24:28,580 --> 00:24:29,730
那么我们该怎么做呢？ 

584
00:24:29,730 --> 00:24:32,870
我将有一个名为json的变量。 

585
00:24:32,870 --> 00:24:34,448
它会返回一个数据。 

586
00:24:34,448 --> 00:24:38,848
现在，此数据只是一小袋。 

587
00:24:38,848 --> 00:24:42,599
在我们的例子中，它将有JSON。 

588
00:24:42,599 --> 00:24:47,130
所以我只是返回尝试使用JSONEncoder 

589
00:24:48,879 --> 00:24:53,280
编码自己。 

590
00:24:53,280 --> 00:24:55,930
这是我们真正需要的唯一一行代码

591
00:24:55,930 --> 00:24:59,320
生成我们自己的JSON版本。 

592
00:24:59,320 --> 00:25:01,230
但是您可以看到我们在这里有一个错误。 

593
00:25:01,230 --> 00:25:03,910
它说实例方法编码

594
00:25:03,910 --> 00:25:08,020
要求EmojiArt符合Encodable。 

595
00:25:08,020 --> 00:25:10,830
好吧，这就是函数式编程， 

596
00:25:10,830 --> 00:25:14,260
当然，其中包含一个可编码的协议。 

597
00:25:14,260 --> 00:25:16,210
因此，我们的EmojiArt本质上是

598
00:25:16,210 --> 00:25:19,862
可编码必须符合它的要求。 

599
00:25:19,862 --> 00:25:23,370
而且，令人惊讶的是，由于扩展， 

600
00:25:23,370 --> 00:25:26,830
在Swift中，通常您可以将Encodable 

601
00:25:26,830 --> 00:25:29,370
在结构上，它将正常工作。 

602
00:25:29,370 --> 00:25:31,690
但是，这一功能不太有效。 

603
00:25:31,690 --> 00:25:35,640
而且，它是否有效，取决于每个变量

604
00:25:35,640 --> 00:25:39,640
在您的结构中本身就是可编码的。 

605
00:25:39,640 --> 00:25:40,710
因此，让我们看一下我们的var。 

606
00:25:40,710 --> 00:25:42,327
我们得到了背景URL。 

607
00:25:42,327 --> 00:25:46,348
URL，绝对是可编码的，我可以保证。 

608
00:25:46,348 --> 00:25:48,470
表情符号，是什么类型？ 

609
00:25:48,470 --> 00:25:49,670
这是一个数组。 

610
00:25:49,670 --> 00:25:51,890
数组，绝对可编码。 

611
00:25:51,890 --> 00:25:53,033
但是数组中有什么？ 

612
00:25:53,033 --> 00:25:54,470
表情符号

613
00:25:54,470 --> 00:25:55,809
哦，就是这个结构。 

614
00:25:55,809 --> 00:25:59,170
嗯，好的，此结构不可编码。 

615
00:25:59,170 --> 00:26:03,640
没问题，我们只说可可的， 

616
00:26:03,640 --> 00:26:05,290
使用相同的机制， 

617
00:26:05,290 --> 00:26:08,010
Swift已自动将其设为可编码， 

618
00:26:08,010 --> 00:26:10,770
现在我的EmojiArt中的所有内容都是可编码的。 

619
00:26:10,770 --> 00:26:14,490
因此，它是可编码的，并且此表情符号结构中的所有内容

620
00:26:14,490 --> 00:26:15,760
也是可编码的。 

621
00:26:15,760 --> 00:26:17,689
字符串，整数，这些都是可编码的。 

622
00:26:17,689 --> 00:26:20,172
因此，这是可编码的。 

623
00:26:20,172 --> 00:26:24,270
现在，我们几乎从来没有使一个可编码的结构

624
00:26:24,270 --> 00:26:26,717
而不是可腐烂的。 

625
00:26:27,622 --> 00:26:30,020
把东西变成JSON没有用

626
00:26:30,020 --> 00:26:33,740
如果您无法将其转换为这些事情之一。 

627
00:26:33,740 --> 00:26:36,693
当然，我们将使这两者都可解码。 

628
00:26:37,530 --> 00:26:39,220
实际上，它是如此普遍

629
00:26:39,220 --> 00:26:41,650
同时具有可编码和可解码。 

630
00:26:41,650 --> 00:26:44,760
现在有另一个协议可以继承它们

631
00:26:44,760 --> 00:26:46,820
这是可编码的。 

632
00:26:46,820 --> 00:26:49,715
这就是我们要指定的协议

633
00:26:49,715 --> 00:26:54,715
当我们想将某些东西变成JSON时。 

634
00:26:56,510 --> 00:26:59,687
因此，使此Codable不再需要。 

635
00:26:59,687 --> 00:27:01,264
如果你有一个结构

636
00:27:01,264 --> 00:27:05,460
没有这样的标准类型

637
00:27:05,460 --> 00:27:07,912
或可以标记为可编码的子结构， 

638
00:27:07,912 --> 00:27:09,980
可编码是一种协议， 

639
00:27:09,980 --> 00:27:12,320
那里有可以使用的功能

640
00:27:12,320 --> 00:27:16,180
把任何东西变成编码的东西

641
00:27:16,180 --> 00:27:18,220
可以JSON化。 

642
00:27:18,220 --> 00:27:21,970
但是，大多数时候，我们尝试使用简单类型

643
00:27:21,970 --> 00:27:23,330
我们可以做到的。 

644
00:27:23,330 --> 00:27:26,860
因此，这不是真正的领域， 

645
00:27:26,860 --> 00:27:28,810
我们才是本课程的第四周， 

646
00:27:28,810 --> 00:27:31,640
还不是我们的知识库

647
00:27:31,640 --> 00:27:33,790
去做一些可编码的东西

648
00:27:33,790 --> 00:27:35,070
不使用标准类型

649
00:27:35,070 --> 00:27:36,300
但是你知道从哪里开始。 

650
00:27:36,300 --> 00:27:37,640
你可以看一下这个协议， 

651
00:27:37,640 --> 00:27:40,070
看看它的描述， 

652
00:27:40,070 --> 00:27:41,893
并且，如果您需要， 

653
00:27:41,893 --> 00:27:45,150
您可以制作自己的结构Codable， 

654
00:27:45,150 --> 00:27:47,633
即使他们没有使用这些标准类型。 

655
00:27:48,622 --> 00:27:51,970
现在我们有了JSON，我想看看

656
00:27:51,970 --> 00:27:53,390
我想看这个JSON。 

657
00:27:53,390 --> 00:27:56,270
所以我要做的实际上是回到我的文档， 

658
00:27:56,270 --> 00:27:58,520
每次我更改EmojiArt时， 

659
00:27:58,520 --> 00:28:00,527
我要在控制台上打印

660
00:28:00,527 --> 00:28:03,490
它的JSON表示形式。 

661
00:28:03,490 --> 00:28:05,410
每当我说这改变时， 

662
00:28:05,410 --> 00:28:09,344
你们当中有些人在想，是的，我们知道该怎么做， 

663
00:28:09,344 --> 00:28:13,690
didSet对，这是一个属性观察器。 

664
00:28:13,690 --> 00:28:18,240
每当EmojiArt更改时，都会调用此名称。 

665
00:28:18,240 --> 00:28:21,650
不幸的是，Swift现在有一个错误， 

666
00:28:21,650 --> 00:28:23,740
如果你在看这个

667
00:28:23,740 --> 00:28:25,470
斯坦福大学季度结束后， 

668
00:28:25,470 --> 00:28:28,830
很可能该错误已在Swift中修复。 

669
00:28:28,830 --> 00:28:31,506
但是在斯坦福季度，它尚未修复。 

670
00:28:31,506 --> 00:28:34,223
问题是属性包装器

671
00:28:34,223 --> 00:28:37,417
这就是@Published的意思

672
00:28:37,417 --> 00:28:41,010
@State还是属性包装器等等。 

673
00:28:41,010 --> 00:28:45,820
目前，这些功能在房地产观察家中表现不佳。 

674
00:28:45,820 --> 00:28:49,440
这是一个已知问题，很快就会解决， 

675
00:28:49,440 --> 00:28:50,730
至少我希望。 

676
00:28:50,730 --> 00:28:53,330
但这使我们无法做到这一点， 

677
00:28:53,330 --> 00:28:56,000
在这里我们可以说打印

678
00:28:56,000 --> 00:29:00,000
我的EmojiArt的JSON版本等于

679
00:29:00,000 --> 00:29:03,930
这里我只说emojiArt.json。 

680
00:29:03,930 --> 00:29:07,930
这个JSON是一个数据，当然是一个Optional数据， 

681
00:29:07,930 --> 00:29:10,630
我想将其转换为UTF-8字符串。 

682
00:29:10,630 --> 00:29:15,630
因此，UTF-8是JSON始终使用的编码字符串。 

683
00:29:16,370 --> 00:29:18,840
由于这可能为零，如果为零， 

684
00:29:18,840 --> 00:29:21,430
然后返回String nil。 

685
00:29:21,430 --> 00:29:24,840
这个utf8 var是我添加到数据中的东西

686
00:29:24,840 --> 00:29:28,410
在EmojiArt扩展程序中，因此您可以进行检查。 

687
00:29:28,410 --> 00:29:31,810
所以，如果我们能把这张照片打印出来，那就太好了

688
00:29:31,810 --> 00:29:33,350
每次改变。 

689
00:29:33,350 --> 00:29:35,950
由于这两个不兼容，我们该怎么做

690
00:29:35,950 --> 00:29:39,470
不再将其发布为@Publish， 

691
00:29:39,470 --> 00:29:41,203
我们将从那里带走。 

692
00:29:41,203 --> 00:29:43,030
而且我们甚至会在这里标记为

693
00:29:43,030 --> 00:29:48,030
财产观察员问题的解决方法

694
00:29:49,820 --> 00:29:53,160
与属性包装。 

695
00:29:53,160 --> 00:29:56,830
相反，我们仍然需要这个EmojiArt 

696
00:29:56,830 --> 00:30:00,030
当要更改以执行ObservableObject事情时。 

697
00:30:00,030 --> 00:30:02,890
这很好地提醒了我们正在做什么， 

698
00:30:02,890 --> 00:30:04,838
我将在我的willSet中做到这一点， 

699
00:30:04,838 --> 00:30:07,853
objectWillChange.send。 

700
00:30:09,300 --> 00:30:12,730
这就是ObservableObject所做的事情

701
00:30:12,730 --> 00:30:15,130
当我们发布时，它会发布

702
00:30:15,130 --> 00:30:17,730
消息已更改。 

703
00:30:17,730 --> 00:30:19,560
所以我们回想起当

704
00:30:19,560 --> 00:30:22,150
我们首先谈到ObervableObject， 

705
00:30:22,150 --> 00:30:23,690
但提醒一下。 

706
00:30:23,690 --> 00:30:24,840
所以我自己做

707
00:30:24,840 --> 00:30:26,777
现在这还不太好

708
00:30:26,777 --> 00:30:29,520
因为已经发布了

709
00:30:29,520 --> 00:30:32,540
我们真的对@Publish的了解还不够

710
00:30:32,540 --> 00:30:34,580
以及它在做什么以了解

711
00:30:34,580 --> 00:30:36,390
为什么这不是那么好。 

712
00:30:36,390 --> 00:30:38,970
它会为我们的目的工作， 

713
00:30:38,970 --> 00:30:41,450
但是@Publish实际上提供了一些东西

714
00:30:41,450 --> 00:30:44,220
叫发布者来改变这件事， 

715
00:30:44,220 --> 00:30:45,180
我们可以使用它。 

716
00:30:45,180 --> 00:30:47,147
实际上，如果我们对发布有更多了解

717
00:30:47,147 --> 00:30:48,660
在本季度的这一点， 

718
00:30:48,660 --> 00:30:51,450
我们可以用它来以其他方式解决此问题

719
00:30:51,450 --> 00:30:53,620
那可能会好一点。 

720
00:30:53,620 --> 00:30:56,130
但这很好，这使其对我们有用。 

721
00:30:56,130 --> 00:30:57,080
我们仍然会有

722
00:30:57,080 --> 00:30:59,580
我们的ObservableObject通知发生了变化， 

723
00:30:59,580 --> 00:31:01,790
而且我们每次都会打印出JSON 

724
00:31:01,790 --> 00:31:04,340
我们的EmojiArt发生了变化。 

725
00:31:04,340 --> 00:31:06,393
让我们看一下，看看是否可行。 

726
00:31:10,800 --> 00:31:14,380
现在，我要拖下东西， 

727
00:31:14,380 --> 00:31:17,590
我相信我的EmojiArt应该更改，并且我应该看到JSON。 

728
00:31:17,590 --> 00:31:18,530
准备？ 

729
00:31:18,530 --> 00:31:20,370
oom，呜呜，我们做到了。 

730
00:31:20,370 --> 00:31:21,410
实际上，让我们将其缩小， 

731
00:31:21,410 --> 00:31:23,070
我们可以看到它同时进行。 

732
00:31:23,070 --> 00:31:25,864
这里是我们的JSON，上面有背景图片。 

733
00:31:25,864 --> 00:31:27,300
让我们看看表情符号。 

734
00:31:27,300 --> 00:31:29,471
没有表情符号，因为我没有放入任何表情符号。 

735
00:31:29,471 --> 00:31:31,189
我们去放一个表情符号。 

736
00:31:31,189 --> 00:31:33,590
也许是树下的苹果又来了。 

737
00:31:33,590 --> 00:31:34,730
有一个苹果。 

738
00:31:34,730 --> 00:31:38,880
也许地球上空的地球怎么样？ 

739
00:31:38,880 --> 00:31:40,560
还是火星或这里的东西？ 

740
00:31:40,560 --> 00:31:43,560
您会看到它正在生成JSON 

741
00:31:43,560 --> 00:31:45,379
代表了我们的整个文件。 

742
00:31:45,379 --> 00:31:47,345
所以那非常容易

743
00:31:47,345 --> 00:31:50,213
就能像这样生成JSON。 

744
00:31:50,213 --> 00:31:53,580
而现在，我们要做的另一件事是， 

745
00:31:53,580 --> 00:31:57,250
我们将把JSON放入UserDefaults 

746
00:31:57,250 --> 00:32:00,310
作为使我们的文档永久保存的一种方式。 

747
00:32:00,310 --> 00:32:03,050
再一次，我们还没有多个文档， 

748
00:32:03,050 --> 00:32:04,305
我们无法命名文件， 

749
00:32:04,305 --> 00:32:07,040
我们真的应该将它们放在文件系统中

750
00:32:07,040 --> 00:32:09,960
甚至在iCloud或类似的软件中，但就目前而言， 

751
00:32:09,960 --> 00:32:12,883
让我们坚持下去，以便当我们退出时， 

752
00:32:12,883 --> 00:32:17,883
然后我们回去，我们不会丢失美丽的图像。 

753
00:32:19,130 --> 00:32:19,963
现在我们该怎么做？ 

754
00:32:19,963 --> 00:32:21,370
所以我要在这里停止打印

755
00:32:21,370 --> 00:32:24,660
我只是说UserDefault.standard， 

756
00:32:24,660 --> 00:32:28,260
这是标准的UserDefaults数据库。 

757
00:32:28,260 --> 00:32:30,210
您可以有其他人，但这是标准的， 

758
00:32:30,210 --> 00:32:32,652
我们使用了99％的时间。 

759
00:32:32,652 --> 00:32:37,652
为特定密钥设置此EmojiArt JSON值， 

760
00:32:39,950 --> 00:32:41,300
您会记得幻灯片中的内容

761
00:32:41,300 --> 00:32:43,480
UserDefaults就像一个字典， 

762
00:32:43,480 --> 00:32:45,220
感觉就像一本字典。 

763
00:32:45,220 --> 00:32:46,620
现在，您只需要指定一个密钥， 

764
00:32:46,620 --> 00:32:49,630
我会说EmojiArtDocument点， 

765
00:32:49,630 --> 00:32:53,440
这就像无标题的文件之类的。 

766
00:32:53,440 --> 00:32:54,639
这个钥匙可以是任何东西， 

767
00:32:54,639 --> 00:32:57,990
我们倾向于把像类名这样的东西

768
00:32:57,990 --> 00:33:00,130
或开头的结构名称， 

769
00:33:00,130 --> 00:33:02,620
仅因为此UserDefaults标准

770
00:33:02,620 --> 00:33:03,830
用于整个应用， 

771
00:33:03,830 --> 00:33:07,020
我们可能还有其他想要存储东西的结构

772
00:33:07,020 --> 00:33:09,880
在UserDefaults中，我们不需要它们的密钥

773
00:33:09,880 --> 00:33:12,193
与我们的相撞。 

774
00:33:13,170 --> 00:33:16,380
就是这样，将要在其中编写此内容。 

775
00:33:16,380 --> 00:33:17,958
请注意，这是一个数据， 

776
00:33:17,958 --> 00:33:20,970
它知道，这个UserDefaults 

777
00:33:20,970 --> 00:33:22,360
知道如何放入数据， 

778
00:33:22,360 --> 00:33:24,900
和字符串，日期，整数和浮点数， 

779
00:33:24,900 --> 00:33:26,900
和这些东西的数组， 

780
00:33:26,900 --> 00:33:27,753
和字典这些东西。 

781
00:33:27,753 --> 00:33:28,605
就是这样。 

782
00:33:28,605 --> 00:33:30,610
它还知道如何处理Optional， 

783
00:33:30,610 --> 00:33:31,640
因为这是可选的。 

784
00:33:31,640 --> 00:33:33,600
如果我说set，这是零， 

785
00:33:33,600 --> 00:33:36,610
它只会清除此键的所有内容。 

786
00:33:36,610 --> 00:33:38,500
现在，我们想把它弄出来。 

787
00:33:38,500 --> 00:33:40,790
我们如何把那东西弄出来？ 

788
00:33:40,790 --> 00:33:42,440
好吧，回到我们的EmojiArt 

789
00:33:42,440 --> 00:33:45,028
我们知道如何将自己编码为JSON。 

790
00:33:45,028 --> 00:33:48,714
但是我们这里需要一些代码来解码自己。 

791
00:33:48,714 --> 00:33:51,090
让我用一个init来做。 

792
00:33:51,090 --> 00:33:51,923
我要去初始化

793
00:33:51,923 --> 00:33:55,024
以JSON数据作为参数， 

794
00:33:55,024 --> 00:33:59,012
并尝试查看此数据并将其解码

795
00:33:59,012 --> 00:34:00,873
成为EmojiArt。 

796
00:34:01,850 --> 00:34:03,410
那么，我们将如何做呢？ 

797
00:34:03,410 --> 00:34:07,110
我只想说说这个JSON数据不等于nil， 

798
00:34:07,110 --> 00:34:09,337
我显然无法解码nil， 

799
00:34:09,337 --> 00:34:14,042
然后我要让我创建一个新的EmojiArt 

800
00:34:14,042 --> 00:34:19,042
等于尝试使用JSONDecoder解码EmojiArt。 

801
00:34:24,020 --> 00:34:28,190
在这里，我指定了我想解码的东西的类型， 

802
00:34:28,190 --> 00:34:29,680
当我们指定类型时，请记住， 

803
00:34:29,680 --> 00:34:34,552
我们将.self像URL.self一样放置上次删除操作。 

804
00:34:34,552 --> 00:34:38,063
我将通过传入的JSON执行此操作。 

805
00:34:38,063 --> 00:34:40,840
这要么行得通，要么行不通。 

806
00:34:40,840 --> 00:34:43,599
也可以尝试一下，就像这样尝试一下， 

807
00:34:43,599 --> 00:34:46,680
并尝试了data contentsOf。 

808
00:34:46,680 --> 00:34:48,560
如果失败，它将返回nil。 

809
00:34:48,560 --> 00:34:50,800
所以，如果让它什么都不做， 

810
00:34:50,800 --> 00:34:52,340
否则我们不会进来。 

811
00:34:52,340 --> 00:34:56,340
但是，如果这没有失败，那么我现在有了新的EmojiArt。 

812
00:34:56,340 --> 00:34:59,580
所以现在我有点想取代我的整个自我

813
00:34:59,580 --> 00:35:02,364
有了这个新的EmojiArt，因为我正在初始化自己， 

814
00:35:02,364 --> 00:35:05,240
信不信由你，对于一个价值类型，你可以说， 

815
00:35:05,240 --> 00:35:07,430
自我等于某事。 

816
00:35:07,430 --> 00:35:09,790
您可以使用值类型， 

817
00:35:09,790 --> 00:35:11,980
给自己分配一些东西

818
00:35:11,980 --> 00:35:14,670
它将取代整个东西。 

819
00:35:14,670 --> 00:35:16,770
也可以用枚举来实现。 

820
00:35:16,770 --> 00:35:18,550
太好了，这正是我想要的。 

821
00:35:18,550 --> 00:35:19,383
我正在初始化。 

822
00:35:19,383 --> 00:35:22,250
我会让自己等于任何表情符号艺术

823
00:35:22,250 --> 00:35:25,563
我能够根据您提供给我的JSON进行解码。 

824
00:35:26,500 --> 00:35:29,156
但是，如果我不能解码怎么办？ 

825
00:35:29,156 --> 00:35:31,099
如果我在这里什么都不做， 

826
00:35:31,099 --> 00:35:34,240
我要得到一个空白的EmojiArtDocument。 

827
00:35:34,240 --> 00:35:36,640
因为我不会初始化任何一个

828
00:35:36,640 --> 00:35:38,650
不同于默认值， 

829
00:35:38,650 --> 00:35:40,920
这个是nil，这是一个空数组， 

830
00:35:40,920 --> 00:35:43,219
所以我会得到一个空白的EmojiArtDocument。 

831
00:35:43,219 --> 00:35:45,890
但是，我认为这不是我想要的。 

832
00:35:45,890 --> 00:35:47,600
如果有人要我创建

833
00:35:47,600 --> 00:35:50,080
一个带有JSON的EmojiArtDocument， 

834
00:35:50,080 --> 00:35:53,550
由于某种原因，我无法做到这一点， 

835
00:35:53,550 --> 00:35:56,730
我真的需要让他们知道。 

836
00:35:56,730 --> 00:35:57,860
而且，我要这样做的方式

837
00:35:57,860 --> 00:36:00,550
与失败的初始化程序一起使用。 

838
00:36:00,550 --> 00:36:03,630
如果您在初始化后立即问号， 

839
00:36:03,630 --> 00:36:05,870
然后当人们调用此初始化程序时， 

840
00:36:05,870 --> 00:36:08,228
如果此初始值设定项返回nil， 

841
00:36:08,228 --> 00:36:11,980
然后他们会得到零作为对象

842
00:36:11,980 --> 00:36:14,110
他们试图创造。 

843
00:36:14,110 --> 00:36:16,220
那真的是要发送信息， 

844
00:36:16,220 --> 00:36:19,700
我试图用JSON创建EmojiArt，但我做不到。 

845
00:36:19,700 --> 00:36:21,610
所以一个失败的初始化器，真的很简单， 

846
00:36:21,610 --> 00:36:25,350
您只是提出问题，每失败一次返回nil， 

847
00:36:25,350 --> 00:36:26,930
然后人们在创造你， 

848
00:36:26,930 --> 00:36:28,600
他们必须检查零， 

849
00:36:28,600 --> 00:36:30,020
因为本质上你是要回来的

850
00:36:30,020 --> 00:36:32,483
这里是EmojiArt的可选版本。 

851
00:36:33,427 --> 00:36:35,440
现在我们在这里添加了一个init， 

852
00:36:35,440 --> 00:36:37,054
我不知道您是否记得规则？ 

853
00:36:37,054 --> 00:36:40,840
但是，如果您添加一个init，那么您将失去免费的init， 

854
00:36:40,840 --> 00:36:44,090
指定每个参数的免费初始化。 

855
00:36:44,090 --> 00:36:45,270
这些都有默认值， 

856
00:36:45,270 --> 00:36:47,240
所以你可以说不带参数的初始化， 

857
00:36:47,240 --> 00:36:49,170
实际上，这就是我们要做的

858
00:36:49,170 --> 00:36:51,950
我们创建了一个无参数的EmojiArt空。 

859
00:36:51,950 --> 00:36:54,551
我们丢失了该init，因此我们必须将其添加回去。 

860
00:36:54,551 --> 00:36:57,620
因此，没有参数的初始化对我们的结构没有任何作用， 

861
00:36:57,620 --> 00:37:00,943
它只是采用这些默认值并使用它们。 

862
00:37:02,920 --> 00:37:06,644
所以现在我们有了创建EmojiArtDocument的方法

863
00:37:06,644 --> 00:37:10,660
从此JSON数据中获取，因此让我们在这里使用它。 

864
00:37:10,660 --> 00:37:13,738
而不是这样做，我们创建一个空的， 

865
00:37:13,738 --> 00:37:16,307
我将为我的文档创建一个init。 

866
00:37:16,307 --> 00:37:20,390
在我的初始化中，我要设置我的EmojiArt等于

867
00:37:20,390 --> 00:37:23,423
我通过传递JSON获得的EmojiArt 

868
00:37:23,423 --> 00:37:26,220
我脱离了UserDefaults。 

869
00:37:26,220 --> 00:37:28,649
所以我要使用我的标准UserDefaults， 

870
00:37:28,649 --> 00:37:33,630
这次我要索要相同密钥的数据。 

871
00:37:33,630 --> 00:37:38,630
现在，我可以将其复制并粘贴到此处， 

872
00:37:39,000 --> 00:37:40,560
但这是一个危险的举动， 

873
00:37:40,560 --> 00:37:43,850
如果我错过一个角色或其他任何角色，那么这些将不匹配。 

874
00:37:43,850 --> 00:37:46,000
因此，让我们成为优秀的程序员吧， 

875
00:37:46,000 --> 00:37:47,890
创建一个小的静态变量。 

876
00:37:47,890 --> 00:37:50,203
我将其称为无标题。 

877
00:37:51,610 --> 00:37:56,610
让我们将其设为私有静态，让无标题等于该字符串， 

878
00:37:59,890 --> 00:38:02,514
然后我将在这里使用它， 

879
00:38:02,514 --> 00:38:05,333
EmojiArtDocument.untitled。 

880
00:38:06,250 --> 00:38:09,260
这样，我保证无论我存多少钱

881
00:38:09,260 --> 00:38:11,623
是我用来找回它的钥匙。 

882
00:38:12,720 --> 00:38:16,410
顺便说一句，一旦我们备份了这个EmojiArt， 

883
00:38:16,410 --> 00:38:20,079
我们确定要获取我们的背景图片， 

884
00:38:20,079 --> 00:38:22,760
因为您的EmojiArtDocument不存储图像， 

885
00:38:22,760 --> 00:38:23,920
仅URL。 

886
00:38:23,920 --> 00:38:26,210
所以我们必须回到互联网上

887
00:38:26,210 --> 00:38:29,330
并在加载时获取图像数据。 

888
00:38:29,330 --> 00:38:30,480
现在我们这里仍然有错误， 

889
00:38:30,480 --> 00:38:33,600
可选类型EmojiArt的值， 

890
00:38:33,600 --> 00:38:38,600
EmojiArt可选必须解压缩为EmojiArt类型。 

891
00:38:39,379 --> 00:38:40,320
这很有道理，对吗？ 

892
00:38:40,320 --> 00:38:44,957
因为这是一个失败的初始化程序，所以它可能返回nil。 

893
00:38:44,957 --> 00:38:47,320
这里的EmojiArt不能取零， 

894
00:38:47,320 --> 00:38:49,700
它不是可选的EmojiArt。 

895
00:38:49,700 --> 00:38:52,220
所以我要在这里做的是，如果返回nil， 

896
00:38:52,220 --> 00:38:54,470
我要创建一个空白文档。 

897
00:38:54,470 --> 00:38:56,170
所以至少我们有一些文件。 

898
00:38:57,340 --> 00:38:59,313
好吧，让我们把这个东西放起来。 

899
00:39:00,236 --> 00:39:01,069
让我们看看它是否有效。 

900
00:39:01,069 --> 00:39:03,470
好的，我们首先要有一个空白文档， 

901
00:39:03,470 --> 00:39:06,170
这是问号问号空白文档

902
00:39:06,170 --> 00:39:09,421
因为我们无法从UserDefaults加载任何内容

903
00:39:09,421 --> 00:39:11,820
一开始，那里什么都没有。 

904
00:39:11,820 --> 00:39:15,357
但是，如果我们在这里开始构建自己的东西，那就开始吧。 

905
00:39:15,357 --> 00:39:18,280
把苹果放回这里。 

906
00:39:18,280 --> 00:39:22,174
将我们的地球放在这里的天空中。 

907
00:39:22,174 --> 00:39:26,610
希望在我们讲话时写出JSON 

908
00:39:26,610 --> 00:39:28,270
到我们的UserDefaults。 

909
00:39:28,270 --> 00:39:32,743
让我们退出，然后再次运行它，看看会发生什么。 

910
00:39:32,743 --> 00:39:34,930
哇，有我们的文件。 

911
00:39:34,930 --> 00:39:36,791
现在，有时您必须要小心一点。 

912
00:39:36,791 --> 00:39:40,490
如果我们不知道将棒球丢在前院， 

913
00:39:40,490 --> 00:39:44,363
在那里，现在我们按停止，然后再次运行， 

914
00:39:45,950 --> 00:39:47,640
哦，我们丢了她的棒球。 

915
00:39:47,640 --> 00:39:49,421
棒球为什么不工作？ 

916
00:39:49,421 --> 00:39:52,950
好吧，UserDefaults，当您将内容放入UserDefaults中时， 

917
00:39:52,950 --> 00:39:55,890
它不会立即耗尽并写入磁盘， 

918
00:39:55,890 --> 00:39:58,290
它缓冲它们并写出

919
00:39:58,290 --> 00:40:01,015
在方便的时候在适当的时候。 

920
00:40:01,015 --> 00:40:04,180
而且，我们没有机会这样做

921
00:40:04,180 --> 00:40:07,970
因为我们捡起了这个棒球，所以把它放在这里， 

922
00:40:07,970 --> 00:40:11,390
然后我们停下来，这扼杀了我们的应用程序。 

923
00:40:11,390 --> 00:40:12,670
它只是杀死了它。 

924
00:40:12,670 --> 00:40:15,390
没有机会去做这样的事情。 

925
00:40:15,390 --> 00:40:18,020
因此，当您进行调试并使用时， 

926
00:40:18,020 --> 00:40:19,746
那个时候我们很幸运，它写出来了。 

927
00:40:19,746 --> 00:40:22,830
当您这样做时，您想做的一件事就是， 

928
00:40:22,830 --> 00:40:25,540
当您进行更改并需要UserDefaults时

929
00:40:25,540 --> 00:40:29,110
写下来，只需切换到另一个应用程序即可。 

930
00:40:29,110 --> 00:40:31,240
在这里，我将切换到文件应用程序。 

931
00:40:31,240 --> 00:40:33,110
没关系，然后切换回去。 

932
00:40:33,110 --> 00:40:34,600
因为当您切换到另一个应用程序时， 

933
00:40:34,600 --> 00:40:37,740
UserDefaults总是会写出数据库。 

934
00:40:37,740 --> 00:40:42,263
这样，当您退出并返回时，它就在那里。 

935
00:40:43,750 --> 00:40:45,530
那就是我真正想要谈论的

936
00:40:45,530 --> 00:40:47,611
就目前的存储量而言， 

937
00:40:47,611 --> 00:40:49,600
我们将继续努力

938
00:40:49,600 --> 00:40:50,960
随着季度的进行。 

939
00:40:50,960 --> 00:40:54,690
但是我接下来要谈的是手势。 

940
00:40:54,690 --> 00:40:59,004
我想在这里做的就是放大和缩小

941
00:40:59,004 --> 00:41:00,950
在我的文件上。 

942
00:41:00,950 --> 00:41:01,783
我会告诉你为什么。 

943
00:41:01,783 --> 00:41:03,840
这是下面的另一张图片。 

944
00:41:03,840 --> 00:41:08,840
让我们继续将该图像拖放到此处

945
00:41:09,110 --> 00:41:10,193
看看会发生什么。 

946
00:41:11,280 --> 00:41:12,950
哇

947
00:41:12,950 --> 00:41:16,620
好的，它肯定在其中放置了该图像，但是它很大。 

948
00:41:16,620 --> 00:41:18,600
这只是一个巨大的形象。 

949
00:41:18,600 --> 00:41:22,270
所以，我真的很想能够在这里放大。 

950
00:41:22,270 --> 00:41:24,610
顺便说一下，我在模拟器中不放选项， 

951
00:41:24,610 --> 00:41:28,350
这就是您如何模拟两个手指下垂的方式。 

952
00:41:28,350 --> 00:41:31,493
我真的想放大并在此处看到整个图片。 

953
00:41:31,493 --> 00:41:33,870
还有另一匹马，一整堆其他动物， 

954
00:41:33,870 --> 00:41:36,343
我想看这些东西。 

955
00:41:37,370 --> 00:41:38,330
现在，我不知道你是否知道这一点， 

956
00:41:38,330 --> 00:41:40,532
这个巨大的形象还有一个可怕的问题， 

957
00:41:40,532 --> 00:41:44,240
它炸毁了我们的表情符号调色板。 

958
00:41:44,240 --> 00:41:46,290
我们甚至无法添加更多表情符号， 

959
00:41:46,290 --> 00:41:48,650
他们都在这里被消灭了。 

960
00:41:48,650 --> 00:41:50,862
这是以某种方式画在外面

961
00:41:50,862 --> 00:41:52,908
应该绘制的位置。 

962
00:41:52,908 --> 00:41:55,200
这实际上在SwiftUI中是正常的。 

963
00:41:55,200 --> 00:41:57,760
SwiftUI中的默认设置为Views 

964
00:41:57,760 --> 00:42:00,985
能够画出自己的界限。 

965
00:42:00,985 --> 00:42:03,884
因此，如果我们想将View保留在其边界之内， 

966
00:42:03,884 --> 00:42:06,590
我们必须对其进行修改。 

967
00:42:06,590 --> 00:42:09,087
因此，让我们开始吧，让我们把货盘取回来

968
00:42:09,087 --> 00:42:10,563
在我们做任何事情之前。 

969
00:42:11,450 --> 00:42:13,918
我们使用的修饰符确实非常简单。 

970
00:42:13,918 --> 00:42:18,760
要放它，让我们在这里放到ZStack上。 

971
00:42:18,760 --> 00:42:20,879
这是我们ZStack的东西。 

972
00:42:20,879 --> 00:42:23,917
叫做.clipped 

973
00:42:23,917 --> 00:42:26,060
.clipped只是意味着它所做的所有绘图

974
00:42:26,060 --> 00:42:29,500
将被剪裁到视图的边界。 

975
00:42:29,500 --> 00:42:32,280
顺便说一句，当我在这里的时候，让我们移动这些东西， 

976
00:42:32,280 --> 00:42:34,555
边缘的东西，下降的东西， 

977
00:42:34,555 --> 00:42:37,453
让我们也将其移至此处。 

978
00:42:38,452 --> 00:42:40,810
我将其移出此处的原因是， 

979
00:42:40,810 --> 00:42:43,610
这些确实在语义上适用于ZStack， 

980
00:42:43,610 --> 00:42:45,940
我们确实希望ZStack一直到边缘， 

981
00:42:45,940 --> 00:42:48,187
我们希望能够将其放置在ZStack中的任何位置。 

982
00:42:48,187 --> 00:42:49,942
它在这里清理

983
00:42:49,942 --> 00:42:53,807
因此，这里发生的事情要干净得多。 

984
00:42:53,807 --> 00:42:56,661
虽然，这不是很干净。 

985
00:42:56,661 --> 00:42:59,350
让我们确保此剪辑工作正常， 

986
00:42:59,350 --> 00:43:00,390
然后我们要回到这里

987
00:43:00,390 --> 00:43:02,623
并在那里修复这个不太干净的代码。 

988
00:43:07,860 --> 00:43:09,460
好吧，这是我们的大事。 

989
00:43:09,460 --> 00:43:12,160
而且它仍然很大，所以我们仍然需要手势， 

990
00:43:12,160 --> 00:43:15,897
但是，宇，我们仍然有各种表情符号

991
00:43:15,897 --> 00:43:18,180
而且我们仍然可以将它们放在那里。 

992
00:43:18,180 --> 00:43:19,660
好吧，让我们返回并清理该代码

993
00:43:19,660 --> 00:43:20,580
我在说

994
00:43:20,580 --> 00:43:24,000
这段代码，为什么这不是很干净？ 

995
00:43:24,000 --> 00:43:27,900
在SwiftUI中，真正的目的就是分解这些视图

996
00:43:27,900 --> 00:43:30,490
变成小小的意见。 

997
00:43:30,490 --> 00:43:34,230
尤其是当您具有视图的语义边界时

998
00:43:34,230 --> 00:43:35,812
就像我们在这里。 

999
00:43:35,812 --> 00:43:38,220
这段代码是关于什么的？ 

1000
00:43:38,220 --> 00:43:40,864
该代码仅用于显示此背景图片， 

1001
00:43:40,864 --> 00:43:43,548
但不幸的是，它可能为零， 

1002
00:43:43,548 --> 00:43:45,460
所以我们必须检查一下。 

1003
00:43:45,460 --> 00:43:47,230
这就是我们在这里所做的一切。 

1004
00:43:47,230 --> 00:43:49,730
而且，如果有人正在阅读我们的代码， 

1005
00:43:49,730 --> 00:43:51,560
他们必须在这里传递很多代码

1006
00:43:51,560 --> 00:43:53,960
只是意识到我们正在显示图像

1007
00:43:53,960 --> 00:43:55,173
那可能是可选的。 

1008
00:43:56,040 --> 00:43:57,835
我们不应该问我们的代码读者

1009
00:43:57,835 --> 00:44:02,450
难以理解正在发生的事情。 

1010
00:44:02,450 --> 00:44:04,810
我要再做一个子视图

1011
00:44:04,810 --> 00:44:06,710
这就是我们将其分解的方式。 

1012
00:44:06,710 --> 00:44:09,410
我们只是制作，称为函数和变量

1013
00:44:09,410 --> 00:44:11,460
把我们的观点放在其他地方， 

1014
00:44:11,460 --> 00:44:15,480
或者我们可以制作新的视图，就像制作CardView一样。 

1015
00:44:15,480 --> 00:44:18,387
所以我要在这里做另外一个观点，我要说

1016
00:44:18,387 --> 00:44:20,710
结构。我将其称为OptionalImage。 

1017
00:44:20,710 --> 00:44:25,630
这将是一个带变量的View， 

1018
00:44:25,630 --> 00:44:29,900
这是一个UIImage，可选的UIImage。 

1019
00:44:29,900 --> 00:44:33,570
然后我的var身体将像往常一样返回一些View。 

1020
00:44:33,570 --> 00:44:35,110
我要把这段代码放在那里

1021
00:44:35,110 --> 00:44:38,150
所以我要去获取这段代码，让我们离开这里。 

1022
00:44:38,150 --> 00:44:41,860
剪下，就在这里粘贴。 

1023
00:44:41,860 --> 00:44:43,289
当然，我正在使用这个uiImage 

1024
00:44:43,289 --> 00:44:45,737
而不是此backgroundImage。 

1025
00:44:51,753 --> 00:44:52,586
而已。 

1026
00:44:52,586 --> 00:44:56,112
所以我刚刚在这里创建了这个小实用程序， 

1027
00:44:56,112 --> 00:45:01,112
它所做的就是处理可能为nil的UIImage。 

1028
00:45:01,460 --> 00:45:04,620
现在，我在这里编写的代码摆脱了所有混乱

1029
00:45:04,620 --> 00:45:09,620
只是self.document.backgroundImage的OptionalImage。 

1030
00:45:12,580 --> 00:45:15,890
这里要干净得多，以了解发生了什么。 

1031
00:45:15,890 --> 00:45:19,840
特别是在这里看这个ZStack， 

1032
00:45:19,840 --> 00:45:21,830
很明显，这是我的背景图片

1033
00:45:21,830 --> 00:45:23,550
这些是我的表情符号

1034
00:45:23,550 --> 00:45:25,510
简单得多。 

1035
00:45:25,510 --> 00:45:26,674
现在，这个OptionalImage 

1036
00:45:26,674 --> 00:45:30,890
但这与EmojiArt无关。 

1037
00:45:30,890 --> 00:45:32,117
所以我要把它带走

1038
00:45:32,117 --> 00:45:34,400
并将其放在自己的文件中。 

1039
00:45:34,400 --> 00:45:36,090
您真的想这样做， 

1040
00:45:36,090 --> 00:45:37,750
当你有不相关的东西时， 

1041
00:45:37,750 --> 00:45:41,880
不要将那些东西埋在无关的代码中。 

1042
00:45:41,880 --> 00:45:46,180
因此，这称为OptionalImage，放在其自己的文件中。 

1043
00:45:46,180 --> 00:45:49,560
我在这里创建的这个文件

1044
00:45:49,560 --> 00:45:51,263
我可能会用这个

1045
00:45:51,263 --> 00:45:54,560
拿起并将其拖到我正在编写的其他应用中， 

1046
00:45:54,560 --> 00:45:57,980
这是一个非常有用的小视图， 

1047
00:45:57,980 --> 00:46:00,333
并且在这种意义上非常可重用。 

1048
00:46:02,148 --> 00:46:03,740
想绕道走， 

1049
00:46:03,740 --> 00:46:07,760
只是因为我不希望您创建这些视图

1050
00:46:07,760 --> 00:46:10,020
这里只有几百行代码， 

1051
00:46:10,020 --> 00:46:12,970
然后完全无法理解。 

1052
00:46:12,970 --> 00:46:15,770
好，回到我们想做的是， 

1053
00:46:15,770 --> 00:46:20,707
我们希望能够在这里的EmojiArt中

1054
00:46:20,707 --> 00:46:24,560
放大这些巨大的图像，以便我们可以看到

1055
00:46:24,560 --> 00:46:25,763
那里发生了什么。 

1056
00:46:26,600 --> 00:46:31,356
我们将通过引入新的@State来做到这一点

1057
00:46:31,356 --> 00:46:36,356
进入我们的视图，我将其称为zoomScale。 

1058
00:46:36,750 --> 00:46:39,920
这只是@State，因为它只会影响

1059
00:46:39,920 --> 00:46:41,260
视图的外观。 

1060
00:46:41,260 --> 00:46:45,150
这与我们的EmojiArt文档本身无关， 

1061
00:46:45,150 --> 00:46:49,530
这纯粹是UI可视化的东西，只是暂时的。 

1062
00:46:49,530 --> 00:46:50,580
当我们放大和缩小时， 

1063
00:46:50,580 --> 00:46:54,147
它只是向我们显示了缩放比例。 

1064
00:46:54,147 --> 00:46:56,031
只会成为CGFloat。 

1065
00:46:56,031 --> 00:46:57,481
我将以等于1.0开始。 

1066
00:46:58,550 --> 00:47:00,410
这是房间规模

1067
00:47:00,410 --> 00:47:04,704
在整个文档中放大或缩小了多少。 

1068
00:47:04,704 --> 00:47:07,300
zoomScale 1.0意味着我们的文档是

1069
00:47:07,300 --> 00:47:11,530
不论其背景URL图像的大小如何。 

1070
00:47:11,530 --> 00:47:14,410
但是2.0意味着它的大小是它的两倍。 

1071
00:47:14,410 --> 00:47:16,993
.5表示它的大小是它的一半。 

1072
00:47:17,930 --> 00:47:19,940
我要用这个zoomScale做的第一件事

1073
00:47:19,940 --> 00:47:22,730
是将其应用于我视图中的所有位置

1074
00:47:22,730 --> 00:47:24,119
在什么地方重要。 

1075
00:47:24,119 --> 00:47:29,100
因此，例如，我的背景图片显然很重要， 

1076
00:47:29,100 --> 00:47:33,947
我想将scaleEffect设为我们的zoomScale。 

1077
00:47:35,240 --> 00:47:37,750
这样就可以使我的背景图像尺寸合适。 

1078
00:47:37,750 --> 00:47:41,570
当然，我的表情符号也需要变大

1079
00:47:41,570 --> 00:47:43,030
当我放大时。 

1080
00:47:43,030 --> 00:47:44,120
这就是他们的字体。 

1081
00:47:44,120 --> 00:47:45,910
因此，让我们来看一下它们的字体，就在这里。 

1082
00:47:45,910 --> 00:47:47,810
我们看到他们的字体是这种字体大小， 

1083
00:47:47,810 --> 00:47:52,800
我们必须通过zoomScale将其放大。 

1084
00:47:52,800 --> 00:47:54,120
我们要做的另一件事是

1085
00:47:54,120 --> 00:47:57,704
每次我们从这个iOS坐标系转换时， 

1086
00:47:57,704 --> 00:48:00,090
在左上角是（0，0）， 

1087
00:48:00,090 --> 00:48:02,060
到EmojiArt坐标系， 

1088
00:48:02,060 --> 00:48:03,920
中间是（0，0）， 

1089
00:48:03,920 --> 00:48:05,580
我们必须小心，因为

1090
00:48:05,580 --> 00:48:07,240
当事物远离中间时， 

1091
00:48:07,240 --> 00:48:09,760
当它们放大时，它们离中间很远， 

1092
00:48:09,760 --> 00:48:11,000
所以会影响到它。 

1093
00:48:11,000 --> 00:48:13,389
那么我们转换的两个地方在哪里

1094
00:48:13,389 --> 00:48:14,969
那些坐标系？ 

1095
00:48:14,969 --> 00:48:17,710
当我们下降时，一个在这里。 

1096
00:48:17,710 --> 00:48:20,330
而且在这里我们要放置表情符号

1097
00:48:20,330 --> 00:48:22,560
我们正在通过表情符号的地方

1098
00:48:22,560 --> 00:48:23,820
然后放下

1099
00:48:23,820 --> 00:48:26,020
好吧，显然我们被告知他们在哪里

1100
00:48:26,020 --> 00:48:29,500
在EmojiArt的（0，0）中心坐标系中， 

1101
00:48:29,500 --> 00:48:30,950
我们需要转换它们。 

1102
00:48:30,950 --> 00:48:33,261
因此，我们需要修复这两种情况。 

1103
00:48:33,261 --> 00:48:37,410
现在我们下落的位置将是

1104
00:48:37,410 --> 00:48:42,410
原来的位置，但除以zoomScale。 

1105
00:48:43,790 --> 00:48:44,920
与y相同。 

1106
00:48:44,920 --> 00:48:46,120
这样就可以修复

1107
00:48:46,120 --> 00:48:49,720
液滴的坐标系转换。 

1108
00:48:49,720 --> 00:48:52,290
对于位置，还可以将其嵌入此处

1109
00:48:52,290 --> 00:48:53,580
让我们清理一下

1110
00:48:53,580 --> 00:48:57,177
我要说的是我的表情符号所在的位置， 

1111
00:48:57,177 --> 00:49:02,177
我将本质上将位置修改为

1112
00:49:03,530 --> 00:49:04,900
除此之外。 

1113
00:49:04,900 --> 00:49:07,083
现在，我将其放置在位置中。 

1114
00:49:10,170 --> 00:49:11,790
我要去那个地方

1115
00:49:11,790 --> 00:49:12,920
通过拆分

1116
00:49:12,920 --> 00:49:15,621
这使我们添加它变得非常容易

1117
00:49:15,621 --> 00:49:19,210
之前对其进行了少许zoomScale修改。 

1118
00:49:19,210 --> 00:49:20,043
所以我要说

1119
00:49:20,043 --> 00:49:24,710
location等于CGPoint location.x乘我们的zoomScale， 

1120
00:49:26,615 --> 00:49:31,615
y是location.y乘以我们的zoomScale。 

1121
00:49:31,730 --> 00:49:33,940
我想这就是所有的地方

1122
00:49:33,940 --> 00:49:36,350
我们的zoomScale将适用。 

1123
00:49:36,350 --> 00:49:39,790
我们正在很好地放大文档。 

1124
00:49:39,790 --> 00:49:42,060
我们将使用什么手势？ 

1125
00:49:42,060 --> 00:49:43,820
好吧，我们想捏。 

1126
00:49:43,820 --> 00:49:46,204
但我要再换一个有趣的手势

1127
00:49:46,204 --> 00:49:48,290
这是双击。 

1128
00:49:48,290 --> 00:49:51,214
双击将放大我的整个文档

1129
00:49:51,214 --> 00:49:54,365
以完全适合可用空间。 

1130
00:49:54,365 --> 00:49:56,630
我们为文档留出了一定的空间， 

1131
00:49:56,630 --> 00:50:00,560
根据我们的应用在用户界面中的位置， 

1132
00:50:00,560 --> 00:50:03,170
然后我将其缩放以适合该尺寸。 

1133
00:50:03,170 --> 00:50:06,420
因此，让我们在这里创建一个新的私人功能， 

1134
00:50:06,420 --> 00:50:08,887
我将其称为zoomToFit。 

1135
00:50:08,887 --> 00:50:12,453
它将采用合适的图像。 

1136
00:50:14,060 --> 00:50:16,580
可能为零，因为我们的背景图片可能为零， 

1137
00:50:16,580 --> 00:50:17,973
在一些大小。 

1138
00:50:19,280 --> 00:50:22,113
而且这将设置我们的zoomScale。 

1139
00:50:22,113 --> 00:50:24,393
它将zoomScale设置为合适。 

1140
00:50:25,240 --> 00:50:28,010
现在，如果我们有图像，我只会这样做。 

1141
00:50:28,010 --> 00:50:30,540
我们有一张图片，我不会触摸zoomScale， 

1142
00:50:30,540 --> 00:50:33,940
而且我也只会在图像有一定尺寸的情况下执行此操作

1143
00:50:33,940 --> 00:50:35,520
所以我要检查以确保

1144
00:50:35,520 --> 00:50:38,370
image.size.width大于零， 

1145
00:50:38,370 --> 00:50:42,100
并且image.size.height大于零。 

1146
00:50:42,100 --> 00:50:44,480
所以，我们有一些大小的图像

1147
00:50:44,480 --> 00:50:46,530
现在我们将zoomToFit。 

1148
00:50:46,530 --> 00:50:50,760
现在我们可以根据水平缩放来缩放它

1149
00:50:50,760 --> 00:50:55,160
说出size.width除以images.size.width。 

1150
00:50:55,160 --> 00:50:57,900
或者我们可以通过垂直缩放来实现

1151
00:50:57,900 --> 00:51:00,080
这将是size.height除以

1152
00:51:00,080 --> 00:51:02,760
image.size.height。 

1153
00:51:02,760 --> 00:51:04,610
所以我们应该使用这两个中的哪一个， 

1154
00:51:04,610 --> 00:51:06,560
水平还是垂直？ 

1155
00:51:06,560 --> 00:51:09,200
我认为我们将使用两者中较小的一个。 

1156
00:51:09,200 --> 00:51:12,042
所以我要设置我的zoomScale 

1157
00:51:12,042 --> 00:51:15,930
等于水平缩放的最小值

1158
00:51:15,930 --> 00:51:18,020
或垂直缩放。 

1159
00:51:18,020 --> 00:51:19,250
因此，无论哪一种都会使它变小。 

1160
00:51:19,250 --> 00:51:22,210
这样，图像将始终在屏幕上完全显示

1161
00:51:22,210 --> 00:51:23,043
无论。 

1162
00:51:24,180 --> 00:51:25,420
差不多好了。 

1163
00:51:25,420 --> 00:51:28,430
现在，我们只需要在“视图”中添加手势即可。 

1164
00:51:28,430 --> 00:51:30,280
我们只需要标记任何视图

1165
00:51:30,280 --> 00:51:32,720
我们希望双击可以继续工作， 

1166
00:51:32,720 --> 00:51:34,330
能够做到这一点。 

1167
00:51:34,330 --> 00:51:35,560
所以我要做到

1168
00:51:35,560 --> 00:51:39,810
这样双击背景就可以了。 

1169
00:51:39,810 --> 00:51:42,132
因此，让我们在这里添加一个手势。 

1170
00:51:42,132 --> 00:51:45,302
我们使用手势ViewModifier来做到这一点， 

1171
00:51:45,302 --> 00:51:48,167
我们只需要指定手势即可

1172
00:51:48,167 --> 00:51:50,260
现在我要做一些功能

1173
00:51:50,260 --> 00:51:51,620
做那个手势

1174
00:51:51,620 --> 00:51:56,620
在geometry.size中称为doubleTapToZoom。 

1175
00:51:57,970 --> 00:51:59,316
这个函数必须返回

1176
00:51:59,316 --> 00:52:01,702
一些手势。 

1177
00:52:01,702 --> 00:52:05,980
此手势仅将手势作为其参数。 

1178
00:52:05,980 --> 00:52:10,780
所以我要去这里创建一个私人功能

1179
00:52:10,780 --> 00:52:15,713
在大小上称为doubleTapToZoom。 

1180
00:52:15,713 --> 00:52:18,973
而且它必须返回一些手势。 

1181
00:52:19,910 --> 00:52:24,480
这就是ViewModifier所需要的，它需要一些手势。 

1182
00:52:24,480 --> 00:52:27,330
因此，我们必须返回一些手势。 

1183
00:52:27,330 --> 00:52:29,090
我们将返回什么手势？ 

1184
00:52:29,090 --> 00:52:30,540
好吧，我们正在双击

1185
00:52:30,540 --> 00:52:32,350
这就是TapGesture。 

1186
00:52:33,240 --> 00:52:34,600
有很多手势， 

1187
00:52:34,600 --> 00:52:36,000
我们在幻灯片中谈到了这一点。 

1188
00:52:36,000 --> 00:52:39,286
TapGesture是一款出色的双击软件。 

1189
00:52:39,286 --> 00:52:43,583
实际上，我想要一个数量为2的TapGesture。 

1190
00:52:44,970 --> 00:52:46,370
我要退货。 

1191
00:52:46,370 --> 00:52:48,291
但是，当然，我必须指定

1192
00:52:48,291 --> 00:52:51,640
当TapGesture发生时，我该怎么办？ 

1193
00:52:51,640 --> 00:52:54,592
在这种情况下，我想调用zoomToFit。 

1194
00:52:54,592 --> 00:52:58,509
我们通过Gesture中的.onEnded函数来做到这一点。 

1195
00:53:00,880 --> 00:53:04,175
现在.onEnded需要一个函数来执行

1196
00:53:04,175 --> 00:53:07,410
无论这个手势是什么， 

1197
00:53:07,410 --> 00:53:09,970
在这种情况下，双击结束。 

1198
00:53:09,970 --> 00:53:13,520
因此，当第二个点击手指抬起时，双击

1199
00:53:13,520 --> 00:53:16,563
它结束了，我们可以在这里做.onEnded。 

1200
00:53:17,710 --> 00:53:19,060
我们在这里要做什么？ 

1201
00:53:19,060 --> 00:53:20,777
self.zoomToFit。 

1202
00:53:23,220 --> 00:53:24,190
而我们适合什么呢？ 

1203
00:53:24,190 --> 00:53:27,527
我们将适合文档的backgroundImage。 

1204
00:53:29,460 --> 00:53:32,543
大小是传入的大小。 

1205
00:53:33,790 --> 00:53:34,840
因此，让我们来看看。 

1206
00:53:39,170 --> 00:53:40,320
这是我们的巨大形象。 

1207
00:53:40,320 --> 00:53:41,760
我要双击。 

1208
00:53:41,760 --> 00:53:43,410
哇，我们把它缩小了。 

1209
00:53:43,410 --> 00:53:46,430
让我们来看看较小的图像，这个小家伙。 

1210
00:53:46,430 --> 00:53:49,248
这是一个非常小的图像，因为我们现在被放大了。 

1211
00:53:49,248 --> 00:53:50,550
（发声） 

1212
00:53:50,550 --> 00:53:52,320
现在我唯一不喜欢的是

1213
00:53:52,320 --> 00:53:56,430
我在这里所做的是震撼。 

1214
00:53:56,430 --> 00:54:01,430
而且我们知道，在移动应用中，我们需要东西

1215
00:54:01,560 --> 00:54:02,840
不要那样跳

1216
00:54:02,840 --> 00:54:04,920
我们想要一些动画。 

1217
00:54:04,920 --> 00:54:06,110
因此，让我们在此处添加一些动画。 

1218
00:54:06,110 --> 00:54:07,830
你知道怎么做

1219
00:54:07,830 --> 00:54:10,543
与动画，显式动画。 

1220
00:54:11,532 --> 00:54:13,220
有了zoomToFit。 

1221
00:54:13,220 --> 00:54:14,470
让我们看看它是如何工作的。 

1222
00:54:19,780 --> 00:54:22,283
哇，看起来好多了。 

1223
00:54:23,450 --> 00:54:26,163
但是，我实际上认为我发现了一些奇怪的东西

1224
00:54:26,163 --> 00:54:31,016
那里的表情符号。 

1225
00:54:31,016 --> 00:54:33,053
因此，让我们在这里获取小包装。 

1226
00:54:34,854 --> 00:54:36,093
并观看这些表情符号。 

1227
00:54:37,090 --> 00:54:39,107
哦，他们有点生涩。 

1228
00:54:39,107 --> 00:54:41,110
每当我看到动画时

1229
00:54:41,110 --> 00:54:42,512
我真的不喜欢我所看到的

1230
00:54:42,512 --> 00:54:45,300
我要去这里，慢下来。 

1231
00:54:45,300 --> 00:54:49,110
让我们在这里使用线性动画。 

1232
00:54:49,110 --> 00:54:51,363
持续时间，例如4秒。 

1233
00:54:52,260 --> 00:54:54,413
让我们来看看实际情况。 

1234
00:54:56,291 --> 00:54:59,663
好吧，让我们再次捡起更大的一个，就在这里。 

1235
00:55:01,750 --> 00:55:03,330
对，现在我要双击。 

1236
00:55:03,330 --> 00:55:05,830
我们将观看这些表情符号。 

1237
00:55:05,830 --> 00:55:10,120
哦，哇！表情符号不是动画的， 

1238
00:55:10,120 --> 00:55:13,110
他们只是跳到了应该的大小。 

1239
00:55:13,110 --> 00:55:14,920
实际上，我认为这甚至更糟。 

1240
00:55:14,920 --> 00:55:17,380
我们去看看它们现在变大了， 

1241
00:55:17,380 --> 00:55:19,290
准备好，准备好，在这里观看。 

1242
00:55:19,290 --> 00:55:20,240
哦，看到了吗？ 

1243
00:55:20,240 --> 00:55:22,130
他们变大然后被切断

1244
00:55:22,130 --> 00:55:25,600
因为视图的大小是动画的， 

1245
00:55:25,600 --> 00:55:27,800
但是还没有赶上他们有多大。 

1246
00:55:28,810 --> 00:55:30,420
这是个问题。 

1247
00:55:30,420 --> 00:55:34,940
我们必须以某种方式为该字体的大小设置动画

1248
00:55:34,940 --> 00:55:36,820
被使用。 

1249
00:55:36,820 --> 00:55:38,520
好吧，我们知道该怎么做。 

1250
00:55:38,520 --> 00:55:41,410
实际上，这是对您的一点评论。 

1251
00:55:41,410 --> 00:55:44,250
动画如何在SwiftUI中工作？ 

1252
00:55:44,250 --> 00:55:47,480
它发生在ViewModifiers中。 

1253
00:55:47,480 --> 00:55:49,150
现在，我不会经历， 

1254
00:55:49,150 --> 00:55:50,920
我们已经在这个演示中花了很多时间

1255
00:55:50,920 --> 00:55:52,850
所以我不会讲所有细节

1256
00:55:52,850 --> 00:55:56,912
制作自己的Animatable字体大小ViewModifier的方法， 

1257
00:55:56,912 --> 00:55:58,220
但是我做到了

1258
00:55:58,220 --> 00:56:01,450
因此，让我们转到此处并将其拖入。 

1259
00:56:01,450 --> 00:56:05,913
这是我的Animatable修改器。 

1260
00:56:06,960 --> 00:56:08,810
我将简要介绍一下此代码。 

1261
00:56:08,810 --> 00:56:11,690
您可以稍后在闲暇时看看。 

1262
00:56:11,690 --> 00:56:14,750
但实际上它只是在制作animatableData 

1263
00:56:14,750 --> 00:56:16,350
那是字体大小。 

1264
00:56:16,350 --> 00:56:19,087
所以我有这个字体大小，是animatableData， 

1265
00:56:19,087 --> 00:56:24,087
而我的内容只是一个字体，即该大小的系统字体。 

1266
00:56:24,288 --> 00:56:26,280
再简单不过了。 

1267
00:56:26,280 --> 00:56:28,297
我什至在View上做了一个很好的扩展

1268
00:56:28,297 --> 00:56:31,660
那我就可以说.font animatableWithSize 

1269
00:56:32,530 --> 00:56:36,780
并为其指定大小，它将自动对其进行修改。 

1270
00:56:36,780 --> 00:56:38,820
这真的很容易应用。 

1271
00:56:38,820 --> 00:56:41,060
无论我们在哪里设置字体，都在这里， 

1272
00:56:41,060 --> 00:56:45,050
而不是将这种自定义字体称为表情符号， 

1273
00:56:45,050 --> 00:56:45,883
在这里

1274
00:56:45,883 --> 00:56:49,338
我要把这个大小，从那里剪下来， 

1275
00:56:49,338 --> 00:56:53,370
不再需要这个了，把它放在这里

1276
00:56:53,370 --> 00:56:58,030
在我的新字体animatableWithSize中。 

1277
00:56:58,030 --> 00:56:58,863
在那里。 

1278
00:57:00,330 --> 00:57:01,703
那是我想要的大小。 

1279
00:57:06,923 --> 00:57:08,390
我们需要自我。 

1280
00:57:08,390 --> 00:57:12,501
这将以动画方式修改此文本

1281
00:57:12,501 --> 00:57:15,120
到这个新的字体大小。 

1282
00:57:15,120 --> 00:57:17,903
再一次，可以在这里双击。 

1283
00:57:19,160 --> 00:57:21,810
好的，有点慢，看起来好像在那儿工作。 

1284
00:57:21,810 --> 00:57:24,083
让我们在这里做一个真正的大人物。 

1285
00:57:29,470 --> 00:57:32,320
好吧，现在仔细看，我们走了。 

1286
00:57:32,320 --> 00:57:34,700
哦，不错。 

1287
00:57:34,700 --> 00:57:37,260
那里的动画更加流畅。 

1288
00:57:37,260 --> 00:57:40,653
并且，实际测试请尝试较小的测试。 

1289
00:57:42,470 --> 00:57:47,470
哦，好的，看起来就像我们的动画

1290
00:57:47,730 --> 00:57:49,784
在这里工作得很好。 

1291
00:57:49,784 --> 00:57:52,233
让我们继续并加快速度。 

1292
00:57:54,850 --> 00:57:57,123
然后继续努力。 

1293
00:57:58,150 --> 00:58:02,020
所以捏只是一种不同的手势。 

1294
00:58:02,020 --> 00:58:04,820
您会记得我们今天所做的幻灯片， 

1295
00:58:04,820 --> 00:58:08,200
这些非离散手势的工作方式， 

1296
00:58:08,200 --> 00:58:13,200
就像是拖拉一样，是在手势处于活动状态时， 

1297
00:58:14,450 --> 00:58:16,467
我们将修改某些状态， 

1298
00:58:16,467 --> 00:58:19,930
这种状态将影响事物的外观

1299
00:58:19,930 --> 00:58:22,840
当我们捏或拖动时。 

1300
00:58:22,840 --> 00:58:25,850
然后，当拖动结束时，无论结束状态是什么， 

1301
00:58:25,850 --> 00:58:29,790
我们将更新我们的稳态值

1302
00:58:29,790 --> 00:58:32,443
无论如何，修改我们的视图。 

1303
00:58:33,430 --> 00:58:35,510
它保持在该状态。 

1304
00:58:35,510 --> 00:58:39,090
了解这些手势如何工作的关键， 

1305
00:58:39,090 --> 00:58:40,940
这些非离散的手势是

1306
00:58:40,940 --> 00:58:44,620
您将拥有两种不同的状态。 

1307
00:58:44,620 --> 00:58:46,150
所以我们要有状态

1308
00:58:46,150 --> 00:58:48,080
通常是我们的zoomScale， 

1309
00:58:48,080 --> 00:58:52,517
我将其重命名为stableStateZoomScale。 

1310
00:58:52,517 --> 00:58:54,900
这就是我们拥有的zoomScale 

1311
00:58:54,900 --> 00:58:58,230
只是处于稳定状态，而不是在进行手势时。 

1312
00:58:58,230 --> 00:59:00,980
然后我们将有一个新的状态， 

1313
00:59:00,980 --> 00:59:03,020
这将是@GestureState， 

1314
00:59:03,020 --> 00:59:05,660
与@State不同，但略有不同， 

1315
00:59:05,660 --> 00:59:08,844
这将是gestureZoomScale。 

1316
00:59:08,844 --> 00:59:11,128
这就是我们要使用的zoomScale 

1317
00:59:11,128 --> 00:59:13,490
手势正在进行时。 

1318
00:59:13,490 --> 00:59:16,110
现在，重要的是要知道这个@GestureState 

1319
00:59:16,110 --> 00:59:17,340
可以是任何类型。 

1320
00:59:17,340 --> 00:59:20,720
实际上甚至不必是同一类型的东西

1321
00:59:20,720 --> 00:59:22,590
你的稳定状态正在做什么。 

1322
00:59:22,590 --> 00:59:26,190
这只不过是要更改的任何信息

1323
00:59:26,190 --> 00:59:29,680
每次捏移动，拖动移动等等

1324
00:59:29,680 --> 00:59:32,100
让您跟踪它。 

1325
00:59:32,100 --> 00:59:34,010
现在，就我们而言，当我们捏捏时， 

1326
00:59:34,010 --> 00:59:37,920
我们只是想跟踪规模是多少。 

1327
00:59:37,920 --> 00:59:41,333
因此，这使得我们之前拥有的zoomScale， 

1328
00:59:41,333 --> 00:59:45,120
我们仍然会拥有它，它将被计算

1329
00:59:45,120 --> 00:59:46,340
刚回来

1330
00:59:46,340 --> 00:59:51,340
稳定状态缩放比例乘以手势缩放比例。 

1331
00:59:53,290 --> 00:59:56,100
现在这个手势缩放比例是1.0， 

1332
00:59:56,100 --> 00:59:57,940
所以当手势不进行时， 

1333
00:59:57,940 --> 01:00:00,138
只是，这将是平等的吧？ 

1334
01:00:00,138 --> 01:00:02,404
stableStateZoomScale乘以1.0 

1335
01:00:02,404 --> 01:00:04,810
将与steadyStateZoomScale相同。 

1336
01:00:04,810 --> 01:00:06,580
但是当我们的手势起作用时， 

1337
01:00:06,580 --> 01:00:08,820
捏一点点移开

1338
01:00:08,820 --> 01:00:10,390
它开始大于一

1339
01:00:10,390 --> 01:00:12,170
然后我们的zoomScale会上升。 

1340
01:00:12,170 --> 01:00:15,950
当这种情况再次出现时，它会往回降低。 

1341
01:00:15,950 --> 01:00:20,550
所以我们的工作是做出手势，捏手势， 

1342
01:00:20,550 --> 01:00:23,260
修改此手势的缩放比例

1343
01:00:23,260 --> 01:00:25,990
只有在我们捏的时候。 

1344
01:00:25,990 --> 01:00:28,010
然后，在手势结束时， 

1345
01:00:28,010 --> 01:00:31,290
它将更新为我们的稳态值。 

1346
01:00:31,290 --> 01:00:33,830
这就是我们做手势的方式。 

1347
01:00:33,830 --> 01:00:35,550
现在，注意这里，我们遇到了一个错误， 

1348
01:00:35,550 --> 01:00:37,720
那是因为恢复正常， 

1349
01:00:37,720 --> 01:00:39,640
我们显然正在尝试zoomToFit 

1350
01:00:39,640 --> 01:00:41,753
我们的stableStateZoomScale。 

1351
01:00:43,690 --> 01:00:47,100
我们以完全相同的方式做出手势

1352
01:00:47,100 --> 01:00:49,699
因为我们对doubleTapToZoom做了这个手势。 

1353
01:00:49,699 --> 01:00:51,810
我们只会有.gesture 

1354
01:00:51,810 --> 01:00:53,420
我们将拥有不同的功能。 

1355
01:00:53,420 --> 01:00:55,483
我将其称为我的zoomGesture。 

1356
01:00:56,407 --> 01:00:59,000
而且我的zoomGesture实际上不需要尺寸， 

1357
01:00:59,000 --> 01:01:01,810
它不像双击需要尺寸的地方。 

1358
01:01:01,810 --> 01:01:03,111
所以我有这个zoomGesture。 

1359
01:01:03,111 --> 01:01:04,890
顺便说一句，这可能是一个变种， 

1360
01:01:04,890 --> 01:01:06,080
这不必是一个功能

1361
01:01:06,080 --> 01:01:08,090
因为它不需要任何参数。 

1362
01:01:08,090 --> 01:01:10,780
让我们继续，将我们的zoomGesture放在这里。 

1363
01:01:10,780 --> 01:01:15,333
让我们将其放到这里，私人功能zoomGesture。 

1364
01:01:17,339 --> 01:01:20,117
而且还会返回一些手势。 

1365
01:01:21,660 --> 01:01:25,670
因为我们将其传递给此手势功能， 

1366
01:01:25,670 --> 01:01:27,680
它必须进行一些缩放手势。 

1367
01:01:27,680 --> 01:01:30,080
另外，顺便说一句，我想我要把我的zoomGesture 

1368
01:01:30,080 --> 01:01:31,420
在整个文件上。 

1369
01:01:31,420 --> 01:01:34,560
所以我将把它放在整个文档中， 

1370
01:01:34,560 --> 01:01:36,210
不只是我们的背景

1371
01:01:36,210 --> 01:01:37,390
我认为没有区别

1372
01:01:37,390 --> 01:01:40,970
因为我们的背景，它充满了我们的整个文档。 

1373
01:01:40,970 --> 01:01:43,980
但是，再次，仅仅是为了代码清晰， 

1374
01:01:43,980 --> 01:01:47,150
我将把这些东西分开。 

1375
01:01:47,150 --> 01:01:48,940
zoomGesture返回一些手势。 

1376
01:01:48,940 --> 01:01:49,910
什么样的手势？ 

1377
01:01:49,910 --> 01:01:52,930
它会返回所谓的放大手势， 

1378
01:01:52,930 --> 01:01:55,280
这就是我们要做的事。 

1379
01:01:55,280 --> 01:01:56,480
因此，它将归还。 

1380
01:01:56,480 --> 01:01:58,450
实际上，它与双击相同

1381
01:01:58,450 --> 01:02:00,810
在其中有一个.onEnded。 

1382
01:02:00,810 --> 01:02:01,750
与.onEnded的唯一区别

1383
01:02:01,750 --> 01:02:05,550
MagenificationGesture的好处是它可以为您提供

1384
01:02:05,550 --> 01:02:09,473
作为参数，finalGestureScale。 

1385
01:02:10,570 --> 01:02:13,560
所以这是最后的gestureScale 

1386
01:02:13,560 --> 01:02:16,680
当用户的手指从捏合处抬起时。 

1387
01:02:16,680 --> 01:02:18,320
现在有了这个finalGestureScale， 

1388
01:02:18,320 --> 01:02:23,320
我可以将我的stableStateZoomScale重置为等于

1389
01:02:24,100 --> 01:02:26,390
我的finalGestureScale。 

1390
01:02:26,390 --> 01:02:28,700
因此，如果手势变大两倍， 

1391
01:02:28,700 --> 01:02:31,610
现在我的手指处于稳定状态， 

1392
01:02:31,610 --> 01:02:33,450
我要大一倍。 

1393
01:02:33,450 --> 01:02:37,343
如果下降到一半的话，也是一样。 

1394
01:02:37,343 --> 01:02:40,390
因此，.onEnded就像这里的.onEnded 

1395
01:02:40,390 --> 01:02:42,523
双击很容易实现。 

1396
01:02:43,410 --> 01:02:45,350
技巧或关键部分

1397
01:02:45,350 --> 01:02:47,741
做这些非离散的手势， 

1398
01:02:47,741 --> 01:02:49,732
正在改变。 

1399
01:02:49,732 --> 01:02:51,670
这就是它的样子。 

1400
01:02:51,670 --> 01:02:53,448
称为.updating。 

1401
01:02:53,448 --> 01:02:57,699
.updating需要一个参数，即您

1402
01:02:57,699 --> 01:03:01,069
无论您的@GestureState用于此手势。 

1403
01:03:01,069 --> 01:03:03,870
因此，我们将说出手势缩放比例。 

1404
01:03:05,000 --> 01:03:08,330
但是，您必须在前面加一个美元符号， 

1405
01:03:08,330 --> 01:03:09,470
我们将谈论

1406
01:03:09,470 --> 01:03:11,500
这个美元符号下周意味着什么。 

1407
01:03:11,500 --> 01:03:13,890
它将其转换为所谓的绑定。 

1408
01:03:13,890 --> 01:03:16,296
因此它绑定到另一个变量。 

1409
01:03:16,296 --> 01:03:18,153
但是，您真的不需要知道

1410
01:03:18,153 --> 01:03:21,660
使这个手势工作正常。 

1411
01:03:21,660 --> 01:03:24,010
了解它本质上只是链接

1412
01:03:24,010 --> 01:03:25,679
到您的@GestureState。 

1413
01:03:25,679 --> 01:03:28,630
当然，这也需要一个论点， 

1414
01:03:28,630 --> 01:03:29,550
这是一个功能。 

1415
01:03:29,550 --> 01:03:31,200
这个功能叫做

1416
01:03:31,200 --> 01:03:34,310
每次捏手势改变时。 

1417
01:03:34,310 --> 01:03:36,160
因此，这是不断被称为， 

1418
01:03:36,160 --> 01:03:38,020
这个小功能经常被调用

1419
01:03:38,020 --> 01:03:40,490
当捏进出时。 

1420
01:03:40,490 --> 01:03:43,140
这件事有三个论点。 

1421
01:03:43,140 --> 01:03:45,470
第一个，很容易理解， 

1422
01:03:45,470 --> 01:03:47,667
这是最新的GestureScale。 

1423
01:03:49,169 --> 01:03:53,822
这只是告诉您最新的捏样。 

1424
01:03:53,822 --> 01:03:56,041
第二个论点真的很奇怪。 

1425
01:03:56,041 --> 01:04:00,260
这是我们的@GestureState作为inout参数， 

1426
01:04:00,260 --> 01:04:01,940
我们将在稍后讨论。 

1427
01:04:01,940 --> 01:04:05,482
最后一个参数是交易。 

1428
01:04:05,482 --> 01:04:07,616
我不会谈论交易。 

1429
01:04:07,616 --> 01:04:09,784
交易本质上是捕获

1430
01:04:09,784 --> 01:04:13,470
所有发生的动画环境。 

1431
01:04:13,470 --> 01:04:17,550
这是动画的高级用法

1432
01:04:17,550 --> 01:04:20,130
在这堂课中我们几乎会忽略。 

1433
01:04:20,130 --> 01:04:23,470
因此，我们也将忽略该论点。 

1434
01:04:23,470 --> 01:04:26,480
但是我们将专注于我们的GestureStateInOut。 

1435
01:04:26,480 --> 01:04:29,150
所以，一个inout参数，希望你从

1436
01:04:29,150 --> 01:04:31,289
您上周的阅读作业。 

1437
01:04:31,289 --> 01:04:34,990
但是，通常情况下， 

1438
01:04:34,990 --> 01:04:36,610
因此，当有人调用此函数时， 

1439
01:04:36,610 --> 01:04:38,470
该论点通常会出现。 

1440
01:04:38,470 --> 01:04:43,118
但是，如果您实际上为此分配了一个值， 

1441
01:04:43,118 --> 01:04:47,540
然后将其复制出来。 

1442
01:04:47,540 --> 01:04:50,640
所以这个手势本质上已经超越了您， 

1443
01:04:50,640 --> 01:04:54,520
您自己的@GestureState var， 

1444
01:04:54,520 --> 01:04:56,770
让您在这里进行修改。 

1445
01:04:56,770 --> 01:04:58,190
然后当你把它传出去时， 

1446
01:04:58,190 --> 01:05:00,870
它在这里打开并更改它。 

1447
01:05:00,870 --> 01:05:02,690
那么为什么会这样呢？ 

1448
01:05:02,690 --> 01:05:06,650
为什么我们不仅仅改变手势

1449
01:05:06,650 --> 01:05:07,510
直接在这里

1450
01:05:07,510 --> 01:05:10,380
为什么我不说gestureZoomScale等于某个值？ 

1451
01:05:10,380 --> 01:05:13,070
为什么要通过此变量来完成？ 

1452
01:05:13,070 --> 01:05:15,930
那么答案就是这个@GestureState var， 

1453
01:05:15,930 --> 01:05:20,380
虽然它在您的视图中，但实际上归此手势所有。 

1454
01:05:20,380 --> 01:05:22,570
除了您提供的初始值之外， 

1455
01:05:22,570 --> 01:05:25,590
您永远不要直接为其分配值。 

1456
01:05:25,590 --> 01:05:28,370
始终让手势进行处理。 

1457
01:05:28,370 --> 01:05:30,540
顺便说一下，手势有什么作用？ 

1458
01:05:30,540 --> 01:05:32,500
好吧，当手势没有发生时， 

1459
01:05:32,500 --> 01:05:34,190
它将其保留为1.0。 

1460
01:05:34,190 --> 01:05:36,110
然后，当手势发生时， 

1461
01:05:36,110 --> 01:05:39,100
它传递给您，您可以在此处进行修改。 

1462
01:05:39,100 --> 01:05:42,060
然后结束时，它会回到1.0。 

1463
01:05:42,060 --> 01:05:45,770
因此，手势想拥有该变量， 

1464
01:05:45,770 --> 01:05:47,620
因此您不可以拥有它。 

1465
01:05:47,620 --> 01:05:49,190
这项业务

1466
01:05:49,190 --> 01:05:50,640
如果你真的不明白我在说什么

1467
01:05:50,640 --> 01:05:52,980
关于输入参数，不理解读数， 

1468
01:05:52,980 --> 01:05:54,580
也许回去做阅读。 

1469
01:05:54,580 --> 01:05:56,560
但是即使那样你还是不懂

1470
01:05:56,560 --> 01:05:59,790
然后就知道这里的手势， 

1471
01:05:59,790 --> 01:06:00,890
这个放大手势

1472
01:06:00,890 --> 01:06:04,420
只希望您修改@GestureState 

1473
01:06:04,420 --> 01:06:07,140
在此函数中被反复调用

1474
01:06:07,140 --> 01:06:09,060
当发生happens缩时。 

1475
01:06:09,060 --> 01:06:11,920
现在，因为这就是这样做的原因， 

1476
01:06:11,920 --> 01:06:16,372
很多人会将其重命名为完全相同的名称

1477
01:06:16,372 --> 01:06:20,301
作为其@GestureState变量。 

1478
01:06:20,301 --> 01:06:23,732
当他们这样做时，将其称为完全相同的事情， 

1479
01:06:23,732 --> 01:06:27,183
现在看来您正在这里更改此设置。 

1480
01:06:28,160 --> 01:06:29,360
我实际上是那个的粉丝

1481
01:06:29,360 --> 01:06:31,320
一开始我不是这样说的

1482
01:06:31,320 --> 01:06:34,040
因为我希望您了解这里发生的事情。 

1483
01:06:34,040 --> 01:06:37,853
但是，我认为将其命名为一个好主意。 

1484
01:06:38,980 --> 01:06:40,200
所以，我们想做什么

1485
01:06:40,200 --> 01:06:42,500
每次捏进出

1486
01:06:42,500 --> 01:06:44,332
或有一点变化？ 

1487
01:06:44,332 --> 01:06:47,727
好吧，这里我们只想获取最新的GestureScale。 

1488
01:06:47,727 --> 01:06:51,766
因此，无论这是什么，最后一次捏动时， 

1489
01:06:51,766 --> 01:06:54,528
我们想将其设置为我们的poseZoomScale。 

1490
01:06:54,528 --> 01:06:59,360
因此，这是更新时最简单的操作。 

1491
01:06:59,360 --> 01:07:00,780
我们要做一些更复杂的事情

1492
01:07:00,780 --> 01:07:04,333
当我们执行DragGesture并平移事物时。 

1493
01:07:04,333 --> 01:07:08,870
这就是支持此缩放手势所需的全部。 

1494
01:07:08,870 --> 01:07:11,700
我们创建了一个缩放手势，一个“放大手势”， 

1495
01:07:11,700 --> 01:07:14,230
它在结束时会更新我们的稳态。 

1496
01:07:14,230 --> 01:07:17,052
进行时，它会更新此@GestureState， 

1497
01:07:17,052 --> 01:07:18,689
这是暂时的，我们只能这样做

1498
01:07:18,689 --> 01:07:19,973
当手势发生时。 

1499
01:07:19,973 --> 01:07:23,984
我们要做的就是将此缩放手势附加到我们的ZStack上， 

1500
01:07:23,984 --> 01:07:27,151
这样当我们的ZStack中发生该手势时， 

1501
01:07:27,151 --> 01:07:29,520
我们认识到这一点。 

1502
01:07:29,520 --> 01:07:31,720
好的，这是我们的小文件。 

1503
01:07:31,720 --> 01:07:34,257
按住选项获得两根手指， 

1504
01:07:34,257 --> 01:07:37,493
我们可以放大和缩小。 

1505
01:07:38,414 --> 01:07:41,970
而且我们仍然可以双击以显示整个图像。 

1506
01:07:41,970 --> 01:07:46,083
我们也可以在这里获得我们的广泛背景。 

1507
01:07:46,970 --> 01:07:50,887
我们可以放大和缩小，双击。 

1508
01:07:53,210 --> 01:07:55,890
我们可以为平移做同样的事情， 

1509
01:07:55,890 --> 01:07:57,570
因为如果我在这里放大

1510
01:07:57,570 --> 01:07:59,110
我想看另一匹马， 

1511
01:07:59,110 --> 01:08:02,490
我希望能够将其拖动。 

1512
01:08:02,490 --> 01:08:05,540
对于潘，我不会详细介绍所有细节

1513
01:08:05,540 --> 01:08:07,770
再次输入代码，全部输入， 

1514
01:08:07,770 --> 01:08:12,110
因为这与做同一件事非常相似

1515
01:08:12,110 --> 01:08:14,040
我们在这里使用缩放手势

1516
01:08:14,040 --> 01:08:17,812
但我将与您一起检查代码。 

1517
01:08:17,812 --> 01:08:21,620
对于平底锅，这是我刚刚添加的代码。 

1518
01:08:21,620 --> 01:08:24,490
我们将仍然有stableStatePanOffset， 

1519
01:08:24,490 --> 01:08:26,590
仍然会有手势PanOffset， 

1520
01:08:26,590 --> 01:08:29,310
当我们拖动时，它只会是平底锅

1521
01:08:29,310 --> 01:08:31,070
然后将使平移偏移

1522
01:08:31,070 --> 01:08:33,350
通过将两者加在一起

1523
01:08:33,350 --> 01:08:35,860
然后乘以zoomScale。 

1524
01:08:35,860 --> 01:08:37,770
顺便说一句，我在这里做一些事情

1525
01:08:37,770 --> 01:08:39,330
就像加点， 

1526
01:08:39,330 --> 01:08:41,079
通常您无法在Swift中做到这一点， 

1527
01:08:41,079 --> 01:08:44,600
但是我在这里添加了一些EmojiArt扩展

1528
01:08:44,600 --> 01:08:48,070
有关点和大小的信息，以便可以在此处编写此代码

1529
01:08:48,070 --> 01:08:49,260
看起来简单得多。 

1530
01:08:49,260 --> 01:08:51,940
因此，您也可以根据需要查看这些内容。 

1531
01:08:51,940 --> 01:08:53,327
感觉完全一样，对， 

1532
01:08:53,327 --> 01:08:54,480
panOffset就像zoomScale。 

1533
01:08:54,480 --> 01:08:58,541
它只是保持稳定状态并添加手势的

1534
01:08:58,541 --> 01:09:01,990
运动中的价值。 

1535
01:09:01,990 --> 01:09:04,260
让我们看一下panGesture，看起来有些不同

1536
01:09:04,260 --> 01:09:05,870
而不是放大手势。 

1537
01:09:05,870 --> 01:09:07,010
这是一个DragGesture。 

1538
01:09:07,010 --> 01:09:09,480
最后，几乎是一样的， 

1539
01:09:09,480 --> 01:09:12,300
我们得到了最终的阻力值。 

1540
01:09:12,300 --> 01:09:13,950
唯一的问题是

1541
01:09:13,950 --> 01:09:16,790
传递给我们的阻力值

1542
01:09:16,790 --> 01:09:21,370
比放大要复杂一些。 

1543
01:09:21,370 --> 01:09:23,730
放大只是一个简单的比例， 

1544
01:09:23,730 --> 01:09:27,130
这就是我们更新时传递的值

1545
01:09:27,130 --> 01:09:28,600
以及何时结束。 

1546
01:09:28,600 --> 01:09:30,500
但是阻力有更多信息。 

1547
01:09:30,500 --> 01:09:32,930
所以我们要去看看这个

1548
01:09:32,930 --> 01:09:34,980
在文档中。 

1549
01:09:34,980 --> 01:09:36,490
打开它。 

1550
01:09:36,490 --> 01:09:38,230
这是DragGesture。 

1551
01:09:38,230 --> 01:09:40,843
它在这里解释了这一点。 

1552
01:09:40,843 --> 01:09:42,970
但是在这里，您可以看到， 

1553
01:09:42,970 --> 01:09:45,269
当我们有.updating和.onEnded时， 

1554
01:09:45,269 --> 01:09:47,690
这种价值传递给我们， 

1555
01:09:47,690 --> 01:09:50,760
当我们处理手势中发生的事情时， 

1556
01:09:50,760 --> 01:09:54,630
实际上是这里的DragGesture.Value类型。 

1557
01:09:54,630 --> 01:09:56,850
所以我要点击这个.Value 

1558
01:09:56,850 --> 01:09:58,730
我们将看到它的外观。 

1559
01:09:58,730 --> 01:10:01,350
您可以看到此值不是简单的Float 

1560
01:10:01,350 --> 01:10:03,850
就像比例尺在“放大手势”中一样。 

1561
01:10:03,850 --> 01:10:06,888
它实际上是一个结构，并且具有位置

1562
01:10:06,888 --> 01:10:11,240
手指当前所在的位置

1563
01:10:11,240 --> 01:10:14,080
以及您开始的起始位置。 

1564
01:10:14,080 --> 01:10:15,626
甚至是时间。 

1565
01:10:15,626 --> 01:10:18,870
因此，它每次更新都带有时间戳记， 

1566
01:10:18,870 --> 01:10:21,740
这样您就可以知道它的移动速度有多快。 

1567
01:10:21,740 --> 01:10:25,080
这是CGSize的翻译， 

1568
01:10:25,080 --> 01:10:28,050
宽度和高度，自开始以来走了多远

1569
01:10:28,050 --> 01:10:28,883
平底锅。 

1570
01:10:28,883 --> 01:10:33,487
我们将使用此翻译来更新我们的偏移量。 

1571
01:10:34,362 --> 01:10:37,889
所以就在这里，我们要说翻译， 

1572
01:10:37,889 --> 01:10:40,361
只需将值转换拖入此处即可。 

1573
01:10:40,361 --> 01:10:42,390
我们要做的就是翻译， 

1574
01:10:42,390 --> 01:10:45,060
我们必须除以zoomScale， 

1575
01:10:45,060 --> 01:10:49,040
最后我们将其添加到稳定状态， 

1576
01:10:49,040 --> 01:10:50,550
在更新的同时， 

1577
01:10:50,550 --> 01:10:52,960
这将是我们的手势平移状态。 

1578
01:10:52,960 --> 01:10:55,100
然后我们将这两个加在一起。 

1579
01:10:55,100 --> 01:10:55,933
然后我们走。 

1580
01:10:55,933 --> 01:10:58,040
否则，它非常相似。 

1581
01:10:58,040 --> 01:10:59,710
现在我们有了PanOffset 

1582
01:10:59,710 --> 01:11:02,030
我们只需要在任何地方使用它

1583
01:11:02,030 --> 01:11:04,710
平底锅很有意义。 

1584
01:11:04,710 --> 01:11:06,440
这很容易，很多地方都一样

1585
01:11:06,440 --> 01:11:07,780
我们做了zoomScale。 

1586
01:11:07,780 --> 01:11:10,570
当然，我们在这里进行scaleEffect 

1587
01:11:10,570 --> 01:11:12,720
我们想抵消我们的观点。 

1588
01:11:12,720 --> 01:11:14,995
每个人都记得偏移量

1589
01:11:14,995 --> 01:11:18,390
您可能在作业中使用了很多3 

1590
01:11:18,390 --> 01:11:19,570
或通过动画， 

1591
01:11:19,570 --> 01:11:23,490
但是这是背景图片的偏移量。 

1592
01:11:23,490 --> 01:11:25,040
表情符号的偏移量如何？ 

1593
01:11:25,040 --> 01:11:27,071
这就是这里的位置。 

1594
01:11:27,071 --> 01:11:29,050
而且，请记住， 

1595
01:11:29,050 --> 01:11:31,690
正在进行坐标系转换

1596
01:11:31,690 --> 01:11:34,360
从中心的（0，0）开始，因此也是drop。 

1597
01:11:34,360 --> 01:11:37,210
所以这两个都需要调整， 

1598
01:11:37,210 --> 01:11:38,540
位置和这个。 

1599
01:11:38,540 --> 01:11:40,880
我们在这里时先做一个。 

1600
01:11:40,880 --> 01:11:43,080
只是要把这个扔在这里， 

1601
01:11:43,080 --> 01:11:47,810
位置等于CGPoint，即x位置， 

1602
01:11:47,810 --> 01:11:52,810
但减去panOffset的宽度， 

1603
01:11:53,550 --> 01:11:58,550
y是location.y减去panOffset的高度。 

1604
01:12:00,970 --> 01:12:03,080
然后这个位置

1605
01:12:03,080 --> 01:12:04,554
让我们来解决这个问题。 

1606
01:12:04,554 --> 01:12:06,380
它在做同样的过渡

1607
01:12:06,380 --> 01:12:08,740
实际上是相反的方向。 

1608
01:12:08,740 --> 01:12:10,620
就在这里

1609
01:12:10,620 --> 01:12:15,620
我们说位置等于CGPoint，等于x。 

1610
01:12:16,037 --> 01:12:19,640
x加上panOffset.width， 

1611
01:12:19,640 --> 01:12:24,360
y是location.y加上panOffset.height。 

1612
01:12:26,090 --> 01:12:30,660
除此之外，还有我想做的唯一一件事

1613
01:12:30,660 --> 01:12:33,470
panOffset是当我双击zoomToFit时， 

1614
01:12:33,470 --> 01:12:36,390
我想我们想将其重置为中心。 

1615
01:12:36,390 --> 01:12:41,390
假设稳定，我们的stableStatePanOffset等于.zero， 

1616
01:12:42,800 --> 01:12:46,080
顺便说一下，它与CGSize.zero相同。 

1617
01:12:46,080 --> 01:12:49,970
但是，Swift可以为我们推断CGSize。 

1618
01:12:49,970 --> 01:12:51,870
我认为这就是我们需要做的。 

1619
01:12:51,870 --> 01:12:54,450
那是锅唯一重要的地方。 

1620
01:12:54,450 --> 01:12:56,010
只是移动背景， 

1621
01:12:56,010 --> 01:12:56,843
然后确保

1622
01:12:56,843 --> 01:12:59,560
我们正在做正确的坐标系转换

1623
01:12:59,560 --> 01:13:01,580
在表情符号的位置。 

1624
01:13:01,580 --> 01:13:04,840
就像我们为zoomGesture添加了手势一样， 

1625
01:13:04,840 --> 01:13:08,983
让我们为panGesture添加手势。 

1626
01:13:10,777 --> 01:13:13,719
您可以在此处添加多个手势。 

1627
01:13:13,719 --> 01:13:17,250
如果他们可能在某些方面互相冲突， 

1628
01:13:17,250 --> 01:13:20,997
然后您可以在手势中找到一些方法

1629
01:13:20,997 --> 01:13:24,750
同时或什至只做手势

1630
01:13:24,750 --> 01:13:27,410
一旦一个手势获胜， 

1631
01:13:27,410 --> 01:13:28,440
不会允许另一个。 

1632
01:13:28,440 --> 01:13:31,963
您可以在Gesture文档中进行查看。 

1633
01:13:35,330 --> 01:13:36,910
好吧，让我们看看。 

1634
01:13:36,910 --> 01:13:38,370
呜，我们走了。 

1635
01:13:38,370 --> 01:13:42,460
我们可以做到，我们可以放大，环顾四周， 

1636
01:13:42,460 --> 01:13:43,947
并缩小。 

1637
01:13:45,570 --> 01:13:48,714
所以我们现在是缩放和平移的完美结合

1638
01:13:48,714 --> 01:13:50,683
在整个文档中。 

1639
01:13:51,550 --> 01:13:54,780
现在，您要做的作业是

1640
01:13:54,780 --> 01:13:57,146
做同样的事情，缩放和平移， 

1641
01:13:57,146 --> 01:14:00,150
但是有了这些小的表情符号。 

1642
01:14:00,150 --> 01:14:03,360
在这种情况下，移动表情符号， 

1643
01:14:03,360 --> 01:14:06,870
并调整表情符号的大小，使其更大

1644
01:14:06,870 --> 01:14:08,830
与背景相比。 

1645
01:14:08,830 --> 01:14:12,790
那真的会让我们建立真正美丽的EmojiArt 

1646
01:14:12,790 --> 01:14:15,340
因为我们实际上可以控制尺寸

1647
01:14:15,340 --> 01:14:16,580
和事物的定位。 

1648
01:14:16,580 --> 01:14:18,680
所以您将不得不管理选择

1649
01:14:18,680 --> 01:14:20,740
这些东西中，选择它们。 

1650
01:14:20,740 --> 01:14:21,925
顺便说一下，那个作业是下周。 

1651
01:14:21,925 --> 01:14:24,610
在作业A3中，您不必

1652
01:14:24,610 --> 01:14:27,010
您在作业A3中没有使用任何手势， 

1653
01:14:27,010 --> 01:14:28,920
这是我正在谈论的下周作业。 

1654
01:14:28,920 --> 01:14:30,420
正如我之前提到的

1655
01:14:30,420 --> 01:14:32,290
您可能要使用的一种数据结构

1656
01:14:32,290 --> 01:14:34,915
保持您的选择，是一套。 

1657
01:14:34,915 --> 01:14:39,620
因此，如果您要将您的小表情符号放入集合中， 

1658
01:14:39,620 --> 01:14:41,370
他们需要是可哈希的。 

1659
01:14:41,370 --> 01:14:43,200
因此，让我们谈谈它是如何工作的。 

1660
01:14:43,200 --> 01:14:47,034
回到此处，在EmojiArt中，我们的表情符号就在这里。 

1661
01:14:47,034 --> 01:14:49,740
而且，它们是可识别的，并且是可编码的， 

1662
01:14:49,740 --> 01:14:51,833
您还可以使其成为可哈希的。 

1663
01:14:52,810 --> 01:14:54,440
而且，如果您将其标记为可哈希， 

1664
01:14:54,440 --> 01:14:56,180
这意味着它们可以放在集合中。 

1665
01:14:56,180 --> 01:14:59,710
请注意，您无需执行任何操作，就可以了。 

1666
01:14:59,710 --> 01:15:01,630
这又是因为

1667
01:15:01,630 --> 01:15:04,200
这种结构中的类型使得Swift 

1668
01:15:04,200 --> 01:15:06,970
可以自动为您完成此哈希处理。 

1669
01:15:06,970 --> 01:15:08,861
因此，您不仅可以将其放在集合中， 

1670
01:15:08,861 --> 01:15:12,200
但如果密钥在字典中，表情符号也可能是

1671
01:15:12,200 --> 01:15:13,033
如果您想要的话。 

1672
01:15:13,033 --> 01:15:14,916
我认为您不需要功课。 

1673
01:15:14,916 --> 01:15:17,990
但是，我只是想向您展示

1674
01:15:17,990 --> 01:15:20,400
万一你想这样做。 

1675
01:15:20,400 --> 01:15:22,431
今天就这样。 

1676
01:15:22,431 --> 01:15:26,400
我们为EmojiArt添加了许多很酷的功能。 

1677
01:15:26,400 --> 01:15:31,400
我们可以保存它，当我们离开并回来时， 

1678
01:15:33,200 --> 01:15:36,070
我们不会失去我们所做的所有出色的工作。 

1679
01:15:36,070 --> 01:15:38,300
当然，我们有双击

1680
01:15:38,300 --> 01:15:40,533
我们可以调整大小和平移。 

1681
01:15:42,290 --> 01:15:43,830
所以我们还有很多事情可以做

1682
01:15:43,830 --> 01:15:45,740
为了使我们的EmojiArt更好

1683
01:15:45,740 --> 01:15:48,323
我们将在下周深入探讨所有这些。 

1684
01:15:49,670 --> 01:15:53,133
-有关更多信息，请访问standford.edu。 

