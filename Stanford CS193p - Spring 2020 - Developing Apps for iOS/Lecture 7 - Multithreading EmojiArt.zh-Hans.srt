1
00:00:00,740 --> 00:00:03,490
（和平音乐） 

2
00:00:04,930 --> 00:00:06,630
-[主持人]斯坦福大学。 

3
00:00:08,520 --> 00:00:13,290
-[Paul]好的，第7讲，斯坦福CS193p， 

4
00:00:13,290 --> 00:00:15,870
2020年春季。 

5
00:00:15,870 --> 00:00:18,950
今天我们将简要讨论颜色和图像， 

6
00:00:18,950 --> 00:00:20,423
只需几分钟。 

7
00:00:20,423 --> 00:00:22,780
那我们今天就进入我们的主要话题

8
00:00:22,780 --> 00:00:26,020
这是多线程编程。 

9
00:00:26,020 --> 00:00:28,620
然后我们要进行一个巨大的演示

10
00:00:28,620 --> 00:00:30,520
这个演示将覆盖很多领域。 

11
00:00:30,520 --> 00:00:34,810
我们将通过开发一些MVVM 

12
00:00:34,810 --> 00:00:36,973
从头开始完全独立的应用程序

13
00:00:36,973 --> 00:00:39,710
通过这种方式，您可以比较和对比该应用

14
00:00:39,710 --> 00:00:43,990
使用Memorize，它可以帮助您更好地了解MVVM。 

15
00:00:43,990 --> 00:00:45,131
然后我们要谈谈

16
00:00:45,131 --> 00:00:47,110
关于一堆杂项

17
00:00:47,110 --> 00:00:50,327
当然，我们将演示多线程

18
00:00:50,327 --> 00:00:52,513
因为那是我们今天的主题。 

19
00:00:53,890 --> 00:00:56,630
所以颜色和图像，让我们先谈谈颜色。 

20
00:00:56,630 --> 00:00:59,590
如您所知，有一个名为Color的结构。 

21
00:00:59,590 --> 00:01:01,140
到目前为止，我们一直在使用它。 

22
00:01:01,140 --> 00:01:03,890
还有另一种叫做UIColor的东西。 

23
00:01:03,890 --> 00:01:05,850
您可能想知道为什么这两件事

24
00:01:05,850 --> 00:01:08,140
只是这样命名？ 

25
00:01:08,140 --> 00:01:10,720
嗯，随着我们的学习，我们谈论了一个颜色

26
00:01:10,720 --> 00:01:15,470
实际上，在论坛中，可以扮演不同的角色。 

27
00:01:15,470 --> 00:01:17,220
它可以是颜色说明符， 

28
00:01:17,220 --> 00:01:19,190
像前景色Color.green 

29
00:01:19,190 --> 00:01:23,360
或者也可以是ShapeStyle，填充Color.blue。 

30
00:01:23,360 --> 00:01:25,387
它甚至可能是一个View，我们还没有看到

31
00:01:25,387 --> 00:01:27,120
到目前为止，在我们的任何演示中， 

32
00:01:27,120 --> 00:01:29,700
但它可以是View，Color.white。 

33
00:01:29,700 --> 00:01:31,830
您可以在出现视图的任何地方显示该内容。 

34
00:01:31,830 --> 00:01:33,740
这很奇怪，就像这样， 

35
00:01:33,740 --> 00:01:37,620
这样做时，您会得到一个用白色填充的矩形。 

36
00:01:37,620 --> 00:01:40,760
现在由于色彩的多面性

37
00:01:40,760 --> 00:01:42,650
它可以做所有这些不同的事情， 

38
00:01:42,650 --> 00:01:44,750
它的API有所限制。 

39
00:01:44,750 --> 00:01:48,310
通常只是创建颜色，我认为有些东西

40
00:01:48,310 --> 00:01:51,643
您可以在其中比较颜色，但功能非常有限。 

41
00:01:52,650 --> 00:01:55,110
所以还有另一件事，UIColor。 

42
00:01:55,110 --> 00:01:56,610
这就是你实际所在的地方

43
00:01:56,610 --> 00:01:58,780
要操纵颜色， 

44
00:01:58,780 --> 00:02:00,610
您将要询问颜色， 

45
00:02:00,610 --> 00:02:05,610
您的RGB值是多少，并且系统颜色更多

46
00:02:05,710 --> 00:02:07,380
和预先内置的颜色。 

47
00:02:07,380 --> 00:02:09,700
这是一个更强大的颜色等级

48
00:02:09,700 --> 00:02:10,600
比这个颜色的东西。 

49
00:02:10,600 --> 00:02:12,100
现在不是变色龙了。 

50
00:02:12,100 --> 00:02:15,310
只是一个代表颜色的小容器

51
00:02:15,310 --> 00:02:17,710
它以非常特殊的方式代表它

52
00:02:17,710 --> 00:02:18,760
但这就是事实。 

53
00:02:18,760 --> 00:02:20,890
如果我要进行任何颜色处理， 

54
00:02:20,890 --> 00:02:24,400
顺便说一句，您将在作业五中执行该操作。 

55
00:02:24,400 --> 00:02:26,500
不是下周，而是下周， 

56
00:02:26,500 --> 00:02:29,020
您将要使用UIColor。 

57
00:02:29,020 --> 00:02:31,420
但很棒的是，一旦您构建了UIColor 

58
00:02:31,420 --> 00:02:33,810
并对其进行改造，或者做任何您想做的事

59
00:02:33,810 --> 00:02:36,170
使其成为您想要的方式，现在您可以说

60
00:02:36,170 --> 00:02:39,350
颜色uiColor：并指定该颜色

61
00:02:39,350 --> 00:02:41,560
您可以通过以上所有方式使用它， 

62
00:02:41,560 --> 00:02:44,459
作为说明符，一个View，等等。 

63
00:02:44,459 --> 00:02:46,550
UIColor以UI开头。 

64
00:02:46,550 --> 00:02:50,650
那是因为它来自旧的SwiftSwift之前的世界。 

65
00:02:50,650 --> 00:02:53,400
以UI开头的东西来自UIKit。 

66
00:02:53,400 --> 00:02:56,200
但是它擅长操纵色彩， 

67
00:02:56,200 --> 00:03:00,120
是的，他们就像把它一样带到SwiftUI中。 

68
00:03:00,120 --> 00:03:02,720
现在发生了类似的二分法

69
00:03:02,720 --> 00:03:05,034
使用Image和UIImage。 

70
00:03:05,034 --> 00:03:08,323
因此，SwiftUI中的Image主要是一个View， 

71
00:03:09,460 --> 00:03:11,490
它是一个显示图像的视图。 

72
00:03:11,490 --> 00:03:14,930
您可以制作一个Image类型的变量

73
00:03:14,930 --> 00:03:16,240
并保存图像。 

74
00:03:16,240 --> 00:03:17,550
这是一个视图。 

75
00:03:17,550 --> 00:03:20,490
因此，此图像视图可以指定什么图像

76
00:03:20,490 --> 00:03:23,710
您希望它以多种方式显示。 

77
00:03:23,710 --> 00:03:26,340
一种方法是只给它一个字符串， 

78
00:03:26,340 --> 00:03:29,280
并将其用作图像的名称

79
00:03:29,280 --> 00:03:33,290
它可以在您的Assets.xcassets文件中找到。 

80
00:03:33,290 --> 00:03:36,090
如果您在Xcode中查看所有文件所在的位置， 

81
00:03:36,090 --> 00:03:37,750
那里有一个我们没有谈论过的文件， 

82
00:03:37,750 --> 00:03:40,810
Assets.xcassets，Xcode资产。 

83
00:03:40,810 --> 00:03:43,240
如果您查看它，您会发现它只是一个地方

84
00:03:43,240 --> 00:03:45,690
以多种不同格式存储图像

85
00:03:45,690 --> 00:03:48,650
然后您可以通过说出名称的图片来按名称获取它们。 

86
00:03:48,650 --> 00:03:52,500
这是访问图像的最基本方法。 

87
00:03:52,500 --> 00:03:55,760
尽管还有大量的系统映像。 

88
00:03:55,760 --> 00:03:58,850
然后通过说Image systemName得到这个： 

89
00:03:58,850 --> 00:04:00,250
然后是名字。 

90
00:04:00,250 --> 00:04:02,010
现在，您如何找出所有这些？ 

91
00:04:02,010 --> 00:04:04,120
好吧，您需要下载一个应用程序

92
00:04:04,120 --> 00:04:07,140
来自developer.apple.com/design 

93
00:04:07,140 --> 00:04:10,470
称为SF符号，并列出了所有符号。 

94
00:04:10,470 --> 00:04:12,920
您可以按名称搜索它们， 

95
00:04:12,920 --> 00:04:15,693
名称几乎封装了它们的含义。 

96
00:04:16,600 --> 00:04:17,720
顺便说一句，当您在那里时， 

97
00:04:17,720 --> 00:04:19,800
在developer.apple.com/design上， 

98
00:04:19,800 --> 00:04:21,810
您会在该页面上看到一个文档

99
00:04:21,810 --> 00:04:23,880
称为人机界面指南。 

100
00:04:23,880 --> 00:04:25,810
您真的想阅读该文档。 

101
00:04:25,810 --> 00:04:27,180
我真的（笑）应该做到了

102
00:04:27,180 --> 00:04:29,100
阅读第四号作业。 

103
00:04:29,100 --> 00:04:31,750
我可能会回去仍然这样做，但是您应该阅读它。 

104
00:04:31,750 --> 00:04:34,240
如果您想绝对阅读

105
00:04:34,240 --> 00:04:35,720
进行App Store提交。 

106
00:04:35,720 --> 00:04:39,600
它讨论了您的UI应该如何执行某些操作

107
00:04:39,600 --> 00:04:42,720
这样所有应用程序中的所有UI都会执行这些操作

108
00:04:42,720 --> 00:04:45,830
以相同的方式，用户将获得一致的体验。 

109
00:04:45,830 --> 00:04:48,190
非常重要，不仅要阅读该文档， 

110
00:04:48,190 --> 00:04:50,850
真正了解其中的所有事物

111
00:04:50,850 --> 00:04:52,160
所以当你去写你的应用程序时

112
00:04:52,160 --> 00:04:54,760
并提交到App Store，不会被拒绝

113
00:04:54,760 --> 00:04:57,940
违反了这些人机界面指南。 

114
00:04:57,940 --> 00:05:00,930
顺便说一下，如果您使用系统名称图片， 

115
00:05:00,930 --> 00:05:02,770
您可以控制它们的大小

116
00:05:02,770 --> 00:05:05,230
使用.imageScale View修改器。 

117
00:05:05,230 --> 00:05:06,800
有点藏在那里

118
00:05:06,800 --> 00:05:09,385
因为您没有在图像中的某处执行此操作。 

119
00:05:09,385 --> 00:05:11,220
因此实际上有一个View修改器。 

120
00:05:11,220 --> 00:05:12,760
所以去看看。 

121
00:05:12,760 --> 00:05:14,870
还有一个简短的提示，系统映像

122
00:05:14,870 --> 00:05:16,970
用作口罩真的很好。 

123
00:05:16,970 --> 00:05:18,730
就像有渐变一样

124
00:05:18,730 --> 00:05:22,060
您可以通过系统映像使它发光

125
00:05:22,060 --> 00:05:24,410
那会给你一些很酷的效果。 

126
00:05:25,940 --> 00:05:28,680
因此，UIImage就是如果您有一个var 

127
00:05:28,680 --> 00:05:31,360
那会在其中保留图像，例如JPEG图像， 

128
00:05:31,360 --> 00:05:33,120
它将是UIImage类型。 

129
00:05:33,120 --> 00:05:36,430
再次，来自UIKit，它是如此的好（笑） 

130
00:05:36,430 --> 00:05:38,820
在处理图像时，没有任何理由

131
00:05:38,820 --> 00:05:42,470
尝试在“图像视图”中全部复制。 

132
00:05:42,470 --> 00:05:44,120
所以他们刚把它带进来

133
00:05:44,120 --> 00:05:47,201
UIImage可以执行多种文件格式， 

134
00:05:47,201 --> 00:05:48,710
JPEG，GIF，PNG。 

135
00:05:48,710 --> 00:05:52,010
它具有转换原语，缩放比例，所有这些， 

136
00:05:52,010 --> 00:05:54,970
它可以做动画图像。 

137
00:05:54,970 --> 00:05:57,920
而一旦您建立了一个UIImage达到您想要的

138
00:05:57,920 --> 00:06:02,920
从任何JPEG文件或从中构建的文件中， 

139
00:06:03,070 --> 00:06:06,234
那么您可以说Image uiImage :, 

140
00:06:06,234 --> 00:06:09,940
UIImage并将其显示为View。 

141
00:06:09,940 --> 00:06:12,930
类似于Color和UIColor， 

142
00:06:12,930 --> 00:06:14,190
图像和UIImage。 

143
00:06:16,110 --> 00:06:18,603
好的，今天的主要事情是多线程。 

144
00:06:19,673 --> 00:06:24,673
现在可以使用多线程来构建系统

145
00:06:25,250 --> 00:06:28,090
拥有应用程序的并行计算

146
00:06:28,090 --> 00:06:29,810
并且同时执行多项操作。 

147
00:06:29,810 --> 00:06:31,240
也许他们互相依赖

148
00:06:31,240 --> 00:06:34,710
您想要管理所有这些东西的依赖性。 

149
00:06:34,710 --> 00:06:36,710
但是我们只会谈论多线程

150
00:06:36,710 --> 00:06:40,610
在这个班上一个非常重要的利基市场

151
00:06:40,610 --> 00:06:45,123
它可以满足的要求，这不会阻止UI。 

152
00:06:46,110 --> 00:06:48,290
而且我们不会阻塞UI 

153
00:06:48,290 --> 00:06:50,940
通过拥有所有会阻塞用户界面的内容

154
00:06:50,940 --> 00:06:53,390
在不同的执行线程上。 

155
00:06:53,390 --> 00:06:56,950
现在，永远无法阻止您的UI。 

156
00:06:56,950 --> 00:06:59,050
如果有人用手指伸手

157
00:06:59,050 --> 00:07:02,030
滚动内容或点击按钮， 

158
00:07:02,030 --> 00:07:03,730
您的UI必须已准备就绪。 

159
00:07:03,730 --> 00:07:05,247
不能说：“哦，对不起。 

160
00:07:05,247 --> 00:07:07,387
“我打算再做一秒钟

161
00:07:07,387 --> 00:07:08,820
“或者，我马上回来。” 

162
00:07:08,820 --> 00:07:10,183
它必须立即做到。 

163
00:07:11,730 --> 00:07:14,090
但是有时候您需要做那些缓慢的事情。 

164
00:07:14,090 --> 00:07:16,850
您需要做一些庞大的机器学习计算

165
00:07:16,850 --> 00:07:19,300
之类的东西，或者您需要通过网络外出

166
00:07:19,300 --> 00:07:20,690
这将需要时间。 

167
00:07:20,690 --> 00:07:22,430
只是没有避免的时间。 

168
00:07:22,430 --> 00:07:25,413
那么在那段时间内您将如何不阻塞UI？ 

169
00:07:26,280 --> 00:07:27,113
好吧，我们要做

170
00:07:27,113 --> 00:07:29,190
通过使用不同的执行线程。 

171
00:07:29,190 --> 00:07:32,700
现在我要假设你们大多数人都知道线程是什么

172
00:07:32,700 --> 00:07:35,110
但我将快速讨论。 

173
00:07:35,110 --> 00:07:37,590
大多数现代操作系统都具有此功能

174
00:07:37,590 --> 00:07:40,280
说这段代码应该执行

175
00:07:40,280 --> 00:07:42,750
在自己的执行线程上。 

176
00:07:42,750 --> 00:07:45,380
然后您可以有多个执行线程

177
00:07:45,380 --> 00:07:47,320
全部同时执行。 

178
00:07:47,320 --> 00:07:50,760
现在他们可能实际上并没有同时执行。 

179
00:07:50,760 --> 00:07:54,200
你知道，如果你有多个核心处理器

180
00:07:54,200 --> 00:07:56,890
或多处理器之类的东西。 

181
00:07:56,890 --> 00:07:59,280
但是有时候你只有一个核心

182
00:07:59,280 --> 00:08:01,670
或核心不足，因此实际上是在切换

183
00:08:01,670 --> 00:08:04,500
他们之间来回真的很快，没有这样做。 

184
00:08:04,500 --> 00:08:05,840
但是您根本不在乎。 

185
00:08:05,840 --> 00:08:08,460
对您来说，似乎您拥有不同的作品

186
00:08:08,460 --> 00:08:10,420
同时执行的代码。 

187
00:08:10,420 --> 00:08:13,920
他们疯狂地在同一时间运行。 

188
00:08:13,920 --> 00:08:18,550
现在，这可能有点复杂

189
00:08:18,550 --> 00:08:20,560
根据程序员的决定， 

190
00:08:20,560 --> 00:08:22,140
好吧，这个人想跑

191
00:08:22,140 --> 00:08:24,920
在这个执行线程上，这个在这里。 

192
00:08:24,920 --> 00:08:27,850
所以我们确实需要一些帮助

193
00:08:27,850 --> 00:08:31,100
这种多线程代码可读易懂

194
00:08:31,100 --> 00:08:33,650
像我们这样的凡人

195
00:08:33,650 --> 00:08:36,410
我们需要这个，因为这次

196
00:08:36,410 --> 00:08:38,800
关于同时运行的事物

197
00:08:38,800 --> 00:08:41,450
将此第四维度添加到我们的代码中

198
00:08:41,450 --> 00:08:43,580
这对我们来说很难。 

199
00:08:43,580 --> 00:08:45,770
Swift解决了这个复杂性问题

200
00:08:45,770 --> 00:08:48,720
使用称为队列的东西。 

201
00:08:48,720 --> 00:08:53,100
现在，队列不过是一堆代码块

202
00:08:53,100 --> 00:08:56,010
排队等候耐心等待

203
00:08:56,010 --> 00:08:59,150
获得执行线程并运行它们。 

204
00:08:59,150 --> 00:09:01,890
现在和排队我的意思是和排队​​一样

205
00:09:01,890 --> 00:09:04,427
像电影中的队列，或者至少是队列

206
00:09:04,427 --> 00:09:06,030
曾经在电影上

207
00:09:06,030 --> 00:09:07,760
在他们关闭所有电影院之前（笑声） 

208
00:09:07,760 --> 00:09:10,690
冠状病毒，但是，你知道， 

209
00:09:10,690 --> 00:09:12,810
人们在排队的地方，这里也是一样。 

210
00:09:12,810 --> 00:09:14,370
这些只是代码块

211
00:09:14,370 --> 00:09:17,690
等待排队执行。 

212
00:09:17,690 --> 00:09:20,270
因此，使用Swift，我们不会考虑线程。 

213
00:09:20,270 --> 00:09:21,310
我们甚至不考虑它们。 

214
00:09:21,310 --> 00:09:23,270
我们只考虑队列。 

215
00:09:23,270 --> 00:09:26,240
我们让系统掌握所有线程

216
00:09:26,240 --> 00:09:28,960
以及所有可以将这些事情从这些队列中移走的东西

217
00:09:28,960 --> 00:09:30,730
并执行它们，这取决于系统。 

218
00:09:30,730 --> 00:09:33,840
我们只考虑队列和代码块

219
00:09:33,840 --> 00:09:36,173
我们想排在那些队列上。 

220
00:09:37,300 --> 00:09:40,710
我们指定队列中的这些代码块

221
00:09:40,710 --> 00:09:44,450
使用闭包，函数作为参数。 

222
00:09:44,450 --> 00:09:47,870
我们将看到它是如何工作的，代码是什么样的

223
00:09:47,870 --> 00:09:50,460
但是让我们快速讨论一下队列

224
00:09:50,460 --> 00:09:52,367
以及哪些队列首先可用。 

225
00:09:52,367 --> 00:09:56,640
而且是iOS世界中最重要的队列

226
00:09:56,640 --> 00:09:59,180
被称为主队列。 

227
00:09:59,180 --> 00:10:02,400
现在这是队列，上面有所有代码块

228
00:10:02,400 --> 00:10:04,880
与用户界面有关。 

229
00:10:04,880 --> 00:10:07,350
每当您想在用户界面中进行操作时， 

230
00:10:07,350 --> 00:10:09,670
您必须使用主队列。 

231
00:10:09,670 --> 00:10:13,410
绝对是一个错误

232
00:10:13,410 --> 00:10:17,870
在未执行的任何代码块中执行UI， 

233
00:10:17,870 --> 00:10:20,720
不是从主队列中选择的。 

234
00:10:20,720 --> 00:10:24,300
因此，当您点击屏幕时，这将执行代码

235
00:10:24,300 --> 00:10:25,393
在主队列上。 

236
00:10:26,410 --> 00:10:30,930
当您执行以任何方式绘制UI的任何操作时， 

237
00:10:30,930 --> 00:10:33,350
它将从主队列中启动。 

238
00:10:33,350 --> 00:10:35,820
有些东西像动画

239
00:10:35,820 --> 00:10:38,150
动画的所有计算

240
00:10:38,150 --> 00:10:41,463
帧间，我们做过的animableData， 

241
00:10:41,463 --> 00:10:44,410
这将在主队列之外的另一个队列中发生。 

242
00:10:44,410 --> 00:10:47,480
但这一切都将重新协调到主队列中

243
00:10:47,480 --> 00:10:50,010
做图纸，所以一切都发生了

244
00:10:50,010 --> 00:10:51,660
而不互相撞

245
00:10:54,230 --> 00:10:57,320
那么我们该在哪里做长寿的事情， 

246
00:10:57,320 --> 00:11:00,430
非UI的东西，最好的去处

247
00:11:00,430 --> 00:11:03,700
在这堆背景队列中

248
00:11:03,700 --> 00:11:06,410
该系统为您提供。 

249
00:11:06,410 --> 00:11:08,470
这就是我们要做的任何事情

250
00:11:08,470 --> 00:11:10,390
像网络通话一样需要很长时间

251
00:11:10,390 --> 00:11:12,280
或某些（如我所说的）机器学习（笑） 

252
00:11:12,280 --> 00:11:15,210
或其他需要进行的分析， 

253
00:11:15,210 --> 00:11:18,113
超过一毫秒左右的时间。 

254
00:11:19,380 --> 00:11:23,280
系统有，它管理一堆线程

255
00:11:23,280 --> 00:11:27,670
从这些后台队列中删除代码块

256
00:11:27,670 --> 00:11:29,050
并为您运行它们。 

257
00:11:29,050 --> 00:11:31,360
所以您放在这些后台队列中的东西， 

258
00:11:31,360 --> 00:11:33,920
它们似乎几乎同时运行

259
00:11:33,920 --> 00:11:35,910
当然，它们同时运行

260
00:11:35,910 --> 00:11:37,510
与主要队列上的内容。 

261
00:11:37,510 --> 00:11:40,510
但是，当然，主队列始终具有更高的优先级。 

262
00:11:40,510 --> 00:11:43,150
如果有人点击或您放置了自己的代码块

263
00:11:43,150 --> 00:11:48,150
在这个主要队列中，它将运行得更快

264
00:11:48,240 --> 00:11:50,730
比什么都重要

265
00:11:50,730 --> 00:11:52,453
在这些后台队列上。 

266
00:11:53,290 --> 00:11:55,720
可以完成所有这些工作的整个系统

267
00:11:55,720 --> 00:11:57,740
被称为大中央派遣

268
00:11:57,740 --> 00:12:01,590
因为它是从队列中分派代码

269
00:12:01,590 --> 00:12:05,110
由线程执行。 

270
00:12:05,110 --> 00:12:07,320
它具有许多不同的功能

271
00:12:07,320 --> 00:12:09,660
在大中央调度那里

272
00:12:09,660 --> 00:12:12,710
但实际上归结为这两个基本任务

273
00:12:12,710 --> 00:12:14,580
您正在使用GCD进行操作。 

274
00:12:14,580 --> 00:12:16,800
一个正在排队

275
00:12:16,800 --> 00:12:19,400
第二，将代码块放入队列。 

276
00:12:19,400 --> 00:12:24,400
这几乎是GCD的99％。 

277
00:12:24,540 --> 00:12:26,510
协调中还有更多东西

278
00:12:26,510 --> 00:12:28,500
当事情在多个队列中发生时， 

279
00:12:28,500 --> 00:12:31,240
但出于我们的目的，尤其是出于目的

280
00:12:31,240 --> 00:12:36,240
将长期存在的东西排除在UI主队列之外， 

281
00:12:36,350 --> 00:12:38,323
这是我们需要的两件事。 

282
00:12:39,340 --> 00:12:41,560
因此，让我们谈谈这两件事中的第一件事

283
00:12:41,560 --> 00:12:45,690
正在创建或访问队列。 

284
00:12:45,690 --> 00:12:48,470
现在第一个很简单，那就是主队列。 

285
00:12:48,470 --> 00:12:51,200
您将使用这个简单的DispatchQueue.main， 

286
00:12:51,200 --> 00:12:53,000
对，主要是静态功能

287
00:12:53,000 --> 00:12:54,830
在结构DispatchQueue中。 

288
00:12:54,830 --> 00:12:56,710
这就是您要使用的队列

289
00:12:56,710 --> 00:12:58,780
每当您想在用户界面中绘制时。 

290
00:12:58,780 --> 00:13:01,280
再简单不过了，这就是您要做的。 

291
00:13:01,280 --> 00:13:03,020
那所有的后台队列呢？ 

292
00:13:03,020 --> 00:13:05,470
为此，您将调用此静态函数

293
00:13:05,470 --> 00:13:07,800
在DispatchQueue中称为global 

294
00:13:07,800 --> 00:13:12,300
接受参数qos是服务质量

295
00:13:12,300 --> 00:13:14,550
这有点像优先。 

296
00:13:14,550 --> 00:13:17,550
本质上，我们需要多少系统

297
00:13:17,550 --> 00:13:21,810
注意此队列上的代码块。 

298
00:13:21,810 --> 00:13:25,880
您在此处拥有的四个选项是userInteractive。 

299
00:13:25,880 --> 00:13:27,860
这是为了像你在中间

300
00:13:27,860 --> 00:13:30,480
在屏幕上拖动一些东西

301
00:13:30,480 --> 00:13:33,030
并且您需要计算一些东西。 

302
00:13:33,030 --> 00:13:36,430
这可能需要一点时间，所以您无法拖累

303
00:13:36,430 --> 00:13:39,110
烦人，但您现在需要该信息！ 

304
00:13:39,110 --> 00:13:42,073
因此，这是一个超高优先级（轻笑）队列。 

305
00:13:42,073 --> 00:13:44,400
它会得到很多服务。 

306
00:13:44,400 --> 00:13:46,280
然后是userInitiated。 

307
00:13:46,280 --> 00:13:47,890
在这里，您不会陷入困境， 

308
00:13:47,890 --> 00:13:50,137
但用户只是点击了一些东西。 

309
00:13:50,137 --> 00:13:53,190
“为我这样做”，因此您现在需要这样做。 

310
00:13:53,190 --> 00:13:56,310
然后是一个实用程序，它是用户不只是问的

311
00:13:56,310 --> 00:13:58,730
为此，但是它需要完成。 

312
00:13:58,730 --> 00:14:00,410
所以这是非常重要的

313
00:14:00,410 --> 00:14:01,640
但这不像用户

314
00:14:01,640 --> 00:14:03,370
只需单击一个按钮，并希望现在完成。 

315
00:14:03,370 --> 00:14:06,210
然后是优先级较低的背景。 

316
00:14:06,210 --> 00:14:08,780
您知道，这是我正在清理数据库

317
00:14:08,780 --> 00:14:11,356
的旧杂物或背景中发生的事情

318
00:14:11,356 --> 00:14:14,040
确实与用户的感知无关

319
00:14:14,040 --> 00:14:15,760
成为他们的应用程序，但这是我的应用程序

320
00:14:15,760 --> 00:14:19,203
需要进行适当的操作或其他操作。 

321
00:14:20,407 --> 00:14:23,810
就是这样，这就是您获得队列的方式，非常容易。 

322
00:14:23,810 --> 00:14:26,157
您会发现GCD非常简单

323
00:14:26,157 --> 00:14:28,317
排队很简单。 

324
00:14:28,317 --> 00:14:29,890
你要么要做主队列

325
00:14:29,890 --> 00:14:32,363
或这些全局后台队列之一。 

326
00:14:33,750 --> 00:14:37,470
第二件事是将闭包放入队列中。 

327
00:14:37,470 --> 00:14:38,440
那么我们该怎么做呢？ 

328
00:14:38,440 --> 00:14:40,680
好吧，假设我有我的队列，或者是主队列

329
00:14:40,680 --> 00:14:42,410
或这些全局队列之一。 

330
00:14:42,410 --> 00:14:45,290
我要么将这个函数称为异步

331
00:14:45,290 --> 00:14:47,487
或功能在该队列上同步。 

332
00:14:47,487 --> 00:14:50,050
而论点只是闭包

333
00:14:50,050 --> 00:14:52,470
这是一个不带参数的函数

334
00:14:52,470 --> 00:14:54,090
并且不返回任何参数。 

335
00:14:54,090 --> 00:14:56,710
在里面，我要放任何我想要的代码

336
00:14:56,710 --> 00:14:59,450
在该队列上执行。 

337
00:14:59,450 --> 00:15:03,380
现在，其中的第二个.sync块。 

338
00:15:03,380 --> 00:15:06,190
所以它阻止并等待直到那个队列， 

339
00:15:06,190 --> 00:15:07,120
那里的绿色队列， 

340
00:15:07,120 --> 00:15:10,560
它一直等到采取了这段代码

341
00:15:10,560 --> 00:15:13,960
退出队列并执行完毕。 

342
00:15:13,960 --> 00:15:15,520
然后它将继续。 

343
00:15:15,520 --> 00:15:19,500
所以我们永远不会在UI代码中调用queue.sync 

344
00:15:19,500 --> 00:15:21,660
因为它会阻止UI。 

345
00:15:21,660 --> 00:15:24,740
实际上，很少将其称为.sync。 

346
00:15:24,740 --> 00:15:26,900
因此，我们几乎总是使用.async 

347
00:15:26,900 --> 00:15:28,670
这意味着只需要这段代码， 

348
00:15:28,670 --> 00:15:31,560
将其放在另一个队列中，然后继续前进。 

349
00:15:31,560 --> 00:15:32,920
因此，这意味着

350
00:15:32,920 --> 00:15:34,680
在那边的花括号里

351
00:15:34,680 --> 00:15:37,530
它会在将来的某个时间执行。 

352
00:15:37,530 --> 00:15:39,700
我不知道什么时候

353
00:15:39,700 --> 00:15:40,580
绕开它。 

354
00:15:40,580 --> 00:15:42,373
现在希望这是主要的队列， 

355
00:15:42,373 --> 00:15:43,206
很快就会

356
00:15:43,206 --> 00:15:46,963
但这还不是锁定的可靠保证。 

357
00:15:47,850 --> 00:15:50,543
因此，您的代码必须容忍事实

358
00:15:50,543 --> 00:15:53,030
当你说queue.async等等， 

359
00:15:53,030 --> 00:15:56,730
等等之类的事情可能不会被执行， 

360
00:15:56,730 --> 00:15:59,950
你知道，很多毫秒，甚至可能更长。 

361
00:15:59,950 --> 00:16:01,930
所以这有点思考

362
00:16:01,930 --> 00:16:05,940
您在编写代码时必须理解这一点。 

363
00:16:05,940 --> 00:16:07,490
但是异步是我们通常要做的。 

364
00:16:07,490 --> 00:16:10,020
我们只是放这些代码块

365
00:16:10,020 --> 00:16:13,723
放在这些其他队列上以使其执行。 

366
00:16:15,070 --> 00:16:17,340
除了异步和同步外，还有其他一些。 

367
00:16:17,340 --> 00:16:20,310
asyncAfter，它将执行异步

368
00:16:20,310 --> 00:16:23,320
但稍等一会，以便您可以等待

369
00:16:23,320 --> 00:16:26,270
使其执行，但大多数情况下我们将进行异步处理。 

370
00:16:28,130 --> 00:16:30,320
这个GCD API的美， 

371
00:16:30,320 --> 00:16:31,820
当您将这两件事结合在一起时， 

372
00:16:31,820 --> 00:16:34,750
有一个队列并异步将其放置在那里

373
00:16:34,750 --> 00:16:37,827
当您将这些东西相互嵌套时。 

374
00:16:37,827 --> 00:16:39,510
现在让我们在这里看一个例子。 

375
00:16:39,510 --> 00:16:42,870
所以我正在做DispatchQueue全局userInitiated 

376
00:16:42,870 --> 00:16:44,570
所以这是用户要求我做的事情

377
00:16:44,570 --> 00:16:46,600
但我要在后台线程上执行

378
00:16:46,600 --> 00:16:49,530
不在主队列上。 

379
00:16:49,530 --> 00:16:52,230
所以我会用一段代码来调用异步

380
00:16:52,230 --> 00:16:54,020
并在开始的那段代码中

381
00:16:54,020 --> 00:16:54,953
我会做某事

382
00:16:54,953 --> 00:16:56,510
这可能需要很长时间。 

383
00:16:56,510 --> 00:16:58,740
也许我正在访问网络上的某些内容

384
00:16:58,740 --> 00:17:00,550
或进行一些计算。 

385
00:17:00,550 --> 00:17:02,840
这样做很好，因为我没有执行这段代码， 

386
00:17:02,840 --> 00:17:05,770
从那里开始的花括号

387
00:17:05,770 --> 00:17:07,560
在主队列上没有做任何事情。 

388
00:17:07,560 --> 00:17:10,900
所以只要我想在这里花时间就可以了。 

389
00:17:10,900 --> 00:17:13,400
但是，这是我们正在做的长期工作， 

390
00:17:13,400 --> 00:17:15,740
当它回来时可能会需要

391
00:17:15,740 --> 00:17:16,780
更改用户界面。 

392
00:17:16,780 --> 00:17:19,270
也许我拿了一张图片，现在我想放一张图片

393
00:17:19,270 --> 00:17:22,320
在用户界面上，但我们无法在此处执行该用户界面

394
00:17:22,320 --> 00:17:23,880
因为我们目前

395
00:17:23,880 --> 00:17:25,670
这些全局后台队列之一中。 

396
00:17:25,670 --> 00:17:28,260
我们无法在此队列上执行UI。 

397
00:17:28,260 --> 00:17:31,420
所以我们将异步发布到该队列的这段代码

398
00:17:31,420 --> 00:17:33,230
在这里不能做UI。 

399
00:17:33,230 --> 00:17:35,570
但这没问题，让我们转一下

400
00:17:35,570 --> 00:17:38,600
并发布执行UI任务的代码块

401
00:17:38,600 --> 00:17:39,540
回到主队列。 

402
00:17:39,540 --> 00:17:42,280
主队列最终将通过它的队列

403
00:17:42,280 --> 00:17:45,060
并执行此操作。 

404
00:17:45,060 --> 00:17:47,270
再次，主队列，高优先级。 

405
00:17:47,270 --> 00:17:48,990
可能不会花很长时间。 

406
00:17:48,990 --> 00:17:51,200
当您将其放在队列中时，队列上可能没有任何东西， 

407
00:17:51,200 --> 00:17:54,180
繁荣发展很快。 

408
00:17:54,180 --> 00:17:57,150
但从概念上讲，重点是

409
00:17:57,150 --> 00:17:58,697
这段代码并告诉主队列， 

410
00:17:58,697 --> 00:18:00,770
“嘿，你去跑这个东西。” 

411
00:18:00,770 --> 00:18:02,650
因此，您可以在那里进行UI。 

412
00:18:02,650 --> 00:18:06,650
这使得异步代码看起来几乎是同步的

413
00:18:06,650 --> 00:18:08,310
但是他们不完全是。 

414
00:18:08,310 --> 00:18:12,035
第一个外部块在那里，外部黄色DispatchQueue 

415
00:18:12,035 --> 00:18:14,810
异步是，可能需要很长时间。 

416
00:18:14,810 --> 00:18:16,580
这样内线可能不会发生

417
00:18:16,580 --> 00:18:18,020
持续10秒钟。 

418
00:18:18,020 --> 00:18:21,040
如果用户就像完全离开了该怎么办

419
00:18:21,040 --> 00:18:23,160
在他们的用户界面中，他们甚至还没有， 

420
00:18:23,160 --> 00:18:25,550
花了很长时间，他们什至不在乎。 

421
00:18:25,550 --> 00:18:26,617
然后你回来，就像

422
00:18:26,617 --> 00:18:28,500
“哦，现在我想放这张照片，” 

423
00:18:28,500 --> 00:18:29,960
但用户不再关心该图像了。 

424
00:18:29,960 --> 00:18:32,360
他们不打算在应用程序中执行其他操作。 

425
00:18:32,360 --> 00:18:33,800
这就是为什么我说你必须思考一下

426
00:18:33,800 --> 00:18:37,410
关于时间，但至少它使它读起来， 

427
00:18:37,410 --> 00:18:38,880
从概念上讲

428
00:18:38,880 --> 00:18:41,713
在这里看起来几乎像同步代码。 

429
00:18:42,960 --> 00:18:45,600
我们看到的这个DispatchQueue.main.async， 

430
00:18:45,600 --> 00:18:48,240
你会经常这样做。 

431
00:18:48,240 --> 00:18:49,990
而你经常这样做的原因

432
00:18:49,990 --> 00:18:51,590
在进行异步编程时

433
00:18:51,590 --> 00:18:53,810
你会在后台做事吗

434
00:18:53,810 --> 00:18:57,210
会导致影响用户界面的事情

435
00:18:57,210 --> 00:18:59,710
所以你将不得不调度主要异步

436
00:18:59,710 --> 00:19:03,830
回到UI做那些事情的UI结果。 

437
00:19:03,830 --> 00:19:05,730
但是你实际上不会打电话

438
00:19:05,730 --> 00:19:09,910
经常DispatchQueue.global qos。 

439
00:19:09,910 --> 00:19:11,350
你为什么不打那么多电话？ 

440
00:19:11,350 --> 00:19:15,400
嗯，那是因为有更高级别的API 

441
00:19:15,400 --> 00:19:18,750
用于管理此后台活动

442
00:19:18,750 --> 00:19:19,840
你会打电话给你。 

443
00:19:19,840 --> 00:19:22,960
例如，如果您要获取图像

444
00:19:22,960 --> 00:19:24,690
通过我们要做的网络

445
00:19:24,690 --> 00:19:28,000
通过今天晚些时候在演示中进行全球调度， 

446
00:19:28,000 --> 00:19:28,930
但是如果你想这样做， 

447
00:19:28,930 --> 00:19:31,630
您确实会使用称为URLSession的东西。 

448
00:19:31,630 --> 00:19:36,410
因此，URLSession是一个结构，它接收信息

449
00:19:36,410 --> 00:19:38,240
关于您想要的URL，它消失了

450
00:19:38,240 --> 00:19:43,180
并在全局QoS队列中添加了一些内容

451
00:19:43,180 --> 00:19:44,940
去做。 

452
00:19:44,940 --> 00:19:46,640
但是你要小心一点

453
00:19:46,640 --> 00:19:49,740
因为URLSession也有一个参数

454
00:19:49,740 --> 00:19:52,200
你给它的封闭

455
00:19:52,200 --> 00:19:54,910
在图像返回时执行。 

456
00:19:54,910 --> 00:19:58,820
该关闭也将由URLSession执行

457
00:19:58,820 --> 00:20:00,830
在此调度全局队列上。 

458
00:20:00,830 --> 00:20:02,730
因此，我们无法在其中执行UI。 

459
00:20:02,730 --> 00:20:05,080
因此，每当您使用URLSession之类的东西时

460
00:20:05,080 --> 00:20:07,777
您给封口写上，“嘿，去拿这个

461
00:20:07,777 --> 00:20:09,850
“当您完成操作后，请称其为闭包” 

462
00:20:09,850 --> 00:20:12,356
该关闭几乎肯定会做

463
00:20:12,356 --> 00:20:13,189
在其中的DispatchQueue.main.async进行调度

464
00:20:16,278 --> 00:20:19,340
然后返回主队列以放入UI结果

465
00:20:20,470 --> 00:20:23,170
URLSession提取的任何内容。 

466
00:20:24,418 --> 00:20:26,520
今天再次，我希望您了解GCD。 

467
00:20:26,520 --> 00:20:29,720
这就是为什么我们要在全球范围内进行DispatchQueue 

468
00:20:29,720 --> 00:20:30,897
自己，然后我们要做

469
00:20:30,897 --> 00:20:33,360
一个DispatchQueue.main.async自己。 

470
00:20:33,360 --> 00:20:35,730
但是在现实世界中，如果我正在获取图像

471
00:20:35,730 --> 00:20:38,630
这就是我们在演示中所做的，我将使用URLSession。 

472
00:20:39,570 --> 00:20:41,910
好的，让我们立即开始演示。 

473
00:20:41,910 --> 00:20:43,740
我已经说过我们要做什么

474
00:20:43,740 --> 00:20:44,823
所以做吧！ 

475
00:20:46,390 --> 00:20:49,240
这个演示是一个很大的演示。 

476
00:20:49,240 --> 00:20:52,760
我们将从头开始制作一个完整的Nother应用程序。 

477
00:20:52,760 --> 00:20:55,650
这样，您可以比较和对比您看到我们的工作

478
00:20:55,650 --> 00:20:57,927
与一个完全不同的应用程序进行比较。 

479
00:20:57,927 --> 00:21:00,940
然后希望您在记忆中所做的所有事情

480
00:21:00,940 --> 00:21:03,900
似乎并非如此，记住具体。 

481
00:21:03,900 --> 00:21:06,363
您会看到其中哪些只是一般的事情

482
00:21:06,363 --> 00:21:10,900
我们在每个应用程序中所做的与这些特定的事情相比。 

483
00:21:10,900 --> 00:21:13,530
让我告诉你这个应用程序的外观

484
00:21:13,530 --> 00:21:16,110
在我们开始这里之前。 

485
00:21:16,110 --> 00:21:19,630
它称为EmojiArt，它使我们能够构建

486
00:21:19,630 --> 00:21:23,200
当然，这是表情符号中的某种艺术， 

487
00:21:23,200 --> 00:21:25,190
因为我们喜欢表情符号。 

488
00:21:25,190 --> 00:21:27,630
在顶部您可以看到我们有一些表情符号

489
00:21:27,630 --> 00:21:29,280
从中选择

490
00:21:29,280 --> 00:21:32,160
我们甚至可以选择不同种类的表情符号

491
00:21:32,160 --> 00:21:34,920
活动，动物等等。 

492
00:21:34,920 --> 00:21:37,520
这些表情符号列表可由用户编辑。 

493
00:21:37,520 --> 00:21:39,830
如果他们单击此处，他们实际上可以

494
00:21:39,830 --> 00:21:42,630
从那里删除表情符号，甚至单击此处

495
00:21:42,630 --> 00:21:45,830
然后进入表情符号键盘并添加更多表情符号， 

496
00:21:45,830 --> 00:21:50,200
也许在这里或其他地方添加另一张面孔。 

497
00:21:50,200 --> 00:21:53,240
然后您使用表情符号来创作艺术

498
00:21:53,240 --> 00:21:55,580
但是拥有良好的背景当然很好

499
00:21:55,580 --> 00:21:57,340
所以我已经转到了Google。 

500
00:21:57,340 --> 00:22:02,280
顺便说一下，这就是iPad多功能应用程序

501
00:22:02,280 --> 00:22:05,480
用户界面在这里，我的EmojiArt位于左侧

502
00:22:05,480 --> 00:22:07,410
我的右边是Safari。 

503
00:22:07,410 --> 00:22:10,220
如果需要，我可以将Safari完全拉开， 

504
00:22:10,220 --> 00:22:12,950
只是离开我的EmojiArt或在这里下去

505
00:22:12,950 --> 00:22:16,650
抓取Safari并将其再次拖回

506
00:22:16,650 --> 00:22:19,783
然后将其调整为我想要的大小。 

507
00:22:20,670 --> 00:22:23,090
我要在这里选择背景

508
00:22:23,090 --> 00:22:24,993
通过拖放。 

509
00:22:25,920 --> 00:22:28,190
在这里，我在这里搜索了我最喜欢的东西， 

510
00:22:28,190 --> 00:22:31,230
乡村卡通，我只是到处看看

511
00:22:31,230 --> 00:22:34,130
用于互联网上的所有乡村卡通。 

512
00:22:34,130 --> 00:22:37,370
我要在这里选一个并将其提起

513
00:22:37,370 --> 00:22:38,870
当我将其拖到上方时，您会看到

514
00:22:38,870 --> 00:22:41,010
它会在拐角处显示绿色小加号。 

515
00:22:41,010 --> 00:22:45,090
如果我放下，嗯，它将其添加为背景。 

516
00:22:45,090 --> 00:22:47,890
我们会做到的，所以你可以在这里放大

517
00:22:47,890 --> 00:22:51,230
否则我们可以平移一下。 

518
00:22:51,230 --> 00:22:53,160
然后，我们可以添加表情符号。 

519
00:22:53,160 --> 00:22:57,590
所以，让我们看看，如果我们能找到的话，这是一个自行车手。 

520
00:22:57,590 --> 00:23:00,960
所以我们就在这里接单车先生， 

521
00:23:00,960 --> 00:23:02,730
让他上路。 

522
00:23:02,730 --> 00:23:04,880
而且他有点小，所以我要选择他

523
00:23:04,880 --> 00:23:06,533
然后让他变大。 

524
00:23:08,633 --> 00:23:10,240
那当然，我们当然也想要一些自然。 

525
00:23:10,240 --> 00:23:11,690
我们去找一些动物。 

526
00:23:11,690 --> 00:23:16,690
哦，一只蜜蜂，我自然界中最喜欢的东西之一是一只蜜蜂。 

527
00:23:16,830 --> 00:23:19,360
没有蜜蜂，我们会在哪里？ 

528
00:23:19,360 --> 00:23:21,760
也许我们会为此添加一些观点

529
00:23:21,760 --> 00:23:24,810
通过让一些蜜蜂看起来更接近我们

530
00:23:24,810 --> 00:23:27,463
和一些蜜蜂走得更远。 

531
00:23:29,870 --> 00:23:32,180
因此，我们的目标是构建这个应用程序。 

532
00:23:32,180 --> 00:23:34,110
今天，我们要做的就是

533
00:23:34,110 --> 00:23:36,120
把这个小东西放在这里。 

534
00:23:36,120 --> 00:23:37,300
我们不会有选择者

535
00:23:37,300 --> 00:23:38,820
让我们选择不同的种类

536
00:23:38,820 --> 00:23:42,440
我们只是要在这里排一排表情符号。 

537
00:23:42,440 --> 00:23:44,420
而且我们还希望能够拖放

538
00:23:44,420 --> 00:23:46,830
做我们的背景，我们也希望能够

539
00:23:46,830 --> 00:23:50,360
拿起这些表情符号并将它们放在那里。 

540
00:23:50,360 --> 00:23:52,810
那下周的功课就好了

541
00:23:52,810 --> 00:23:56,550
才能选择它们，然后调整这些表情符号的大小

542
00:23:56,550 --> 00:23:59,160
或移动它们。 

543
00:23:59,160 --> 00:24:02,040
然后下周，我们也要去

544
00:24:02,040 --> 00:24:05,133
在这里添加这个小选择器并使其

545
00:24:05,133 --> 00:24:07,410
这样这些文件就可以保留

546
00:24:07,410 --> 00:24:09,920
因为现在，如果我退出此应用并返回， 

547
00:24:09,920 --> 00:24:11,010
我会丢掉我的文件。 

548
00:24:11,010 --> 00:24:14,110
因此，我们显然希望能够保存文档。 

549
00:24:14,110 --> 00:24:16,620
因此，我们与此应用程序有很多工作要做， 

550
00:24:16,620 --> 00:24:19,643
但是，让我们从它的基础开始吧。 

551
00:24:20,500 --> 00:24:24,960
因此，这当然是一个全新的项目。 

552
00:24:24,960 --> 00:24:26,860
现在，您不必遵循， 

553
00:24:26,860 --> 00:24:29,040
您不会被要求在家庭作业中这样做

554
00:24:29,040 --> 00:24:30,450
就像你是前两个星期一样。 

555
00:24:30,450 --> 00:24:34,180
但同样，它总是建议作为学习练习

556
00:24:34,180 --> 00:24:36,370
跟随。 

557
00:24:36,370 --> 00:24:40,210
因此，让我们从这里开始，单击新项目。 

558
00:24:40,210 --> 00:24:43,180
我们总是在此类中选择Single View App。 

559
00:24:43,180 --> 00:24:47,020
我要把这个叫做EmojiArt，好吧。 

560
00:24:47,020 --> 00:24:49,950
其他一切与“记忆”相同。 

561
00:24:49,950 --> 00:24:52,330
我要把它放在这里的开发人员中

562
00:24:52,330 --> 00:24:54,200
与我要记住的地方相同。 

563
00:24:55,761 --> 00:24:58,260
在这里，让我们腾出很多空间

564
00:24:58,260 --> 00:25:00,220
这样我们可以很清楚地看到我们的代码。 

565
00:25:00,220 --> 00:25:02,453
我们甚至在那里将其缩小。 

566
00:25:03,536 --> 00:25:04,369
现在，让我们潜入。 

567
00:25:04,369 --> 00:25:07,490
您已经知道如何做事的基础

568
00:25:07,490 --> 00:25:10,940
因此，让我们开始制作我们的ViewModel。 

569
00:25:10,940 --> 00:25:14,143
所以我要去这里，File，New，File。 

570
00:25:15,050 --> 00:25:17,790
对，这是一个Swift文件，是用户界面的一部分

571
00:25:17,790 --> 00:25:19,180
但不是View本身。 

572
00:25:19,180 --> 00:25:21,771
哦，请确保我们将其放在正确的位置。 

573
00:25:21,771 --> 00:25:25,310
我要在这里叫我的ViewModel EmojiArtDocument 

574
00:25:25,310 --> 00:25:28,480
因为我的ViewModel只能代表一个文档， 

575
00:25:28,480 --> 00:25:29,530
一个EmojiArtDocument。 

576
00:25:30,450 --> 00:25:33,760
您可以想象某天有UI 

577
00:25:33,760 --> 00:25:36,760
在我的EmojiArt中可以打开不同的文档

578
00:25:36,760 --> 00:25:40,033
并且每个模型都将使用自己的ViewModel表示。 

579
00:25:41,230 --> 00:25:42,900
ViewModel当然是UI 

580
00:25:42,900 --> 00:25:46,170
因此我们将成为重要的SwiftUI，并且它们也是类， 

581
00:25:46,170 --> 00:25:49,700
所以我们要让这个EmojiArtDocument成为一个类

582
00:25:49,700 --> 00:25:54,700
而且我们总是为我们的ViewModels做ObservableObject 

583
00:25:54,950 --> 00:25:57,880
因为它们是管理这种反应性的东西

584
00:25:57,880 --> 00:26:00,330
模型之间事物之间的变化

585
00:26:00,330 --> 00:26:03,230
我们会在用户界面中看到它们

586
00:26:03,230 --> 00:26:06,620
现在我们有了一个ViewModel，让我们回到View 

587
00:26:06,620 --> 00:26:08,860
这是ContentView就在这里

588
00:26:08,860 --> 00:26:11,160
使用默认的ContentView业务。 

589
00:26:11,160 --> 00:26:13,040
我要把我的ViewModel放在这里

590
00:26:13,040 --> 00:26:16,940
所以我要有ObservedObject var。 

591
00:26:16,940 --> 00:26:18,620
现在，我将其称为viewModel。 

592
00:26:18,620 --> 00:26:19,670
那就是我们以前所说的。 

593
00:26:19,670 --> 00:26:20,510
我要称呼它

594
00:26:20,510 --> 00:26:22,660
我们实际上会称之为。 （咯咯笑） 

595
00:26:22,660 --> 00:26:25,770
在这种情况下，文档就是EmojiArtDocument。 

596
00:26:26,960 --> 00:26:30,038
我们不会在这里立即预览。 

597
00:26:30,038 --> 00:26:32,820
我们的EmojiArt视图几乎涵盖了所有内容

598
00:26:32,820 --> 00:26:33,653
被拖进去的

599
00:26:33,653 --> 00:26:36,450
当然在预览窗口中我们不能将其拖动

600
00:26:36,450 --> 00:26:38,730
在那里，但最终我们可能会想要

601
00:26:38,730 --> 00:26:42,840
把预览放回去，也许有一些测试数据

602
00:26:42,840 --> 00:26:44,998
背景中的一些表情符号

603
00:26:44,998 --> 00:26:47,420
这样我们就可以确保事情看起来不错。 

604
00:26:47,420 --> 00:26:48,793
但是出于一般目的， 

605
00:26:48,793 --> 00:26:51,003
我们暂时将其关闭。 

606
00:26:52,090 --> 00:26:54,930
我不喜欢这个名称ContentView。 

607
00:26:54,930 --> 00:26:57,620
不好，所以让我们做以前做过的事情。 

608
00:26:57,620 --> 00:27:00,493
命令单击此并说出重命名。 

609
00:27:01,330 --> 00:27:03,790
现在，它可以搜索所有地方， 

610
00:27:03,790 --> 00:27:05,930
您可以在这里看到它出现。 

611
00:27:05,930 --> 00:27:06,850
所以我要重命名

612
00:27:06,850 --> 00:27:08,243
成为EmojiArtDocumentView。 

613
00:27:10,511 --> 00:27:12,756
这将是一个显示文档的视图。 

614
00:27:12,756 --> 00:27:14,560
我们可以看到，嗯，这不会重命名。 

615
00:27:14,560 --> 00:27:17,430
好吧，我们必须自己做。 

616
00:27:17,430 --> 00:27:18,393
在这里

617
00:27:20,890 --> 00:27:22,520
当然，我们必须改变， 

618
00:27:22,520 --> 00:27:24,210
看这叫的地方

619
00:27:24,210 --> 00:27:27,470
并确保我们为这些东西创建一个ViewModel 

620
00:27:27,470 --> 00:27:30,330
我们知道这在我们的SceneDelegate中， 

621
00:27:30,330 --> 00:27:32,293
contentView等于EmojiArtDocumentView。 

622
00:27:33,235 --> 00:27:35,020
现在我们要准备文件

623
00:27:35,020 --> 00:27:39,450
只是默认的EmojiArtDocument，一个空文档。 

624
00:27:39,450 --> 00:27:40,797
没有任何内容。 

625
00:27:40,797 --> 00:27:43,730
而且我们可以进行初始化

626
00:27:43,730 --> 00:27:46,650
没有参数，因为如果我们看我们的EmojiArtDocument 

627
00:27:46,650 --> 00:27:50,200
它没有未初始化的变量，所以很好

628
00:27:50,200 --> 00:27:52,310
以这种方式进行初始化。 

629
00:27:52,310 --> 00:27:56,900
好吧，让我们立即开始构建我们的UI 

630
00:27:56,900 --> 00:28:01,160
而且，如果您还记得的话，我们的用户界面在顶部有这个表情符号。 

631
00:28:01,160 --> 00:28:03,890
因此，让我们尝试构建这个小工具

632
00:28:03,890 --> 00:28:08,170
那里有表情符号的滚动列表，看看我们是否可以做到。 

633
00:28:08,170 --> 00:28:11,060
现在是表情符号的可滚动列表，顶部是调色板， 

634
00:28:11,060 --> 00:28:12,660
由所有文档共享。 

635
00:28:12,660 --> 00:28:17,030
因此，它不希望成为实例中的var 

636
00:28:17,030 --> 00:28:19,030
在文档中，“因为记住了一个实例

637
00:28:19,030 --> 00:28:21,370
这个ViewModel代表一个文档。 

638
00:28:21,370 --> 00:28:23,997
想要成为一个静态变量。 

639
00:28:23,997 --> 00:28:27,040
实际上，现在我们要让他静止不动， 

640
00:28:27,040 --> 00:28:29,900
这个表情符号调色板

641
00:28:29,900 --> 00:28:34,030
好吧，我们现在将一些随机的东西放在这里。 

642
00:28:34,030 --> 00:28:35,400
我们知道如何添加表情符号。 

643
00:28:35,400 --> 00:28:39,210
我们一定要去这里，在那儿放个星星， 

644
00:28:39,210 --> 00:28:42,200
几场乌云，我们还来这里吗？ 

645
00:28:42,200 --> 00:28:46,800
是的，也许是苹果。 

646
00:28:46,800 --> 00:28:49,123
然后我们还得到了椒盐脆饼， 

647
00:28:50,330 --> 00:28:52,350
是的，我不想让你饿

648
00:28:52,350 --> 00:28:54,070
所以我不会在那儿放任何食物

649
00:28:54,070 --> 00:28:57,050
但是也许像棒球一样。 

650
00:28:57,050 --> 00:29:00,410
好的，这就是我们的默认调色板。 

651
00:29:00,410 --> 00:29:04,210
最终这将成为调色板的数组

652
00:29:04,210 --> 00:29:07,760
这样我们就可以有一个不错的选择器

653
00:29:07,760 --> 00:29:11,000
我们可以在这些调色板之间进行选择。 

654
00:29:11,000 --> 00:29:13,940
但是现在，我们还没有，我们没有该功能。 

655
00:29:13,940 --> 00:29:15,500
所以现在有了这个调色板

656
00:29:15,500 --> 00:29:17,530
让我们将文档制作成视图

657
00:29:17,530 --> 00:29:18,950
而不是说“你好，世界！” 

658
00:29:18,950 --> 00:29:21,290
让我们来显示它。 

659
00:29:21,290 --> 00:29:22,960
现在应该可以

660
00:29:22,960 --> 00:29:25,070
立刻想象我们将如何做。 

661
00:29:25,070 --> 00:29:27,973
我们只是要创建一个ForEach的HStack。 

662
00:29:29,150 --> 00:29:32,450
而ForEach将会是那些EmojiArtDocument， 

663
00:29:32,450 --> 00:29:34,310
那个静态调色板。 

664
00:29:34,310 --> 00:29:36,840
然后在那里的每个表情符号

665
00:29:36,840 --> 00:29:39,730
我们只想输入文字表情符号。 

666
00:29:39,730 --> 00:29:43,860
现在这不是很有效，因为这是一个字符串

667
00:29:43,860 --> 00:29:47,610
而且ForEach记得要一个数组， 

668
00:29:47,610 --> 00:29:50,090
整数范围或需要数组

669
00:29:50,090 --> 00:29:51,850
可识别的事物。 

670
00:29:51,850 --> 00:29:53,520
因此，字符串不是数组。 

671
00:29:53,520 --> 00:29:57,260
它很接近，但是String上有一个很棒的小功能

672
00:29:57,260 --> 00:30:00,430
称为map，它将变成一个数组

673
00:30:00,430 --> 00:30:01,770
通过调用一个函数， 

674
00:30:01,770 --> 00:30:04,933
我们将在这里将字符串称为零。 

675
00:30:05,810 --> 00:30:08,700
这个函数接受字符串中的每个字符， 

676
00:30:08,700 --> 00:30:11,790
所以$ 0是字符串中的一个字符

677
00:30:11,790 --> 00:30:14,757
只是，我们将对其应用此功能。 

678
00:30:14,757 --> 00:30:16,380
但是我们只是将其转换为字符串。 

679
00:30:16,380 --> 00:30:18,780
所以String知道如何采用单个字符

680
00:30:18,780 --> 00:30:19,967
并把它变成一个字符串。 

681
00:30:19,967 --> 00:30:23,610
因此，现在我们在字符串数组上有了ForEach。 

682
00:30:23,610 --> 00:30:25,730
该映射返回一个字符串数组。 

683
00:30:25,730 --> 00:30:27,540
这很酷，这意味着该表情符号

684
00:30:27,540 --> 00:30:28,690
将成为一个字符串。 

685
00:30:28,690 --> 00:30:29,600
但它仍然无法正常工作。 

686
00:30:29,600 --> 00:30:33,450
我们得到了可怕的哦，Int的预期范围。 

687
00:30:33,450 --> 00:30:35,010
我们知道为什么会这样。 

688
00:30:35,010 --> 00:30:38,670
ForEach采用可识别的数组

689
00:30:38,670 --> 00:30:42,360
和字符串不可识别。 

690
00:30:42,360 --> 00:30:46,180
现在很有趣，我们可以在String上添加扩展名

691
00:30:46,180 --> 00:30:48,880
使其可识别，像这样。 

692
00:30:48,880 --> 00:30:51,080
只需执行var id。 

693
00:30:51,080 --> 00:30:53,050
我有一个很酷的方法。 

694
00:30:53,050 --> 00:30:55,280
我要让ID为String。 

695
00:30:55,280 --> 00:30:59,260
我要回到自己身边，好吧，我是弦乐。 

696
00:30:59,260 --> 00:31:01,170
字符串是平等的。 

697
00:31:01,170 --> 00:31:04,740
顺便说一句，这不在乎id和Identifiable， 

698
00:31:04,740 --> 00:31:06,660
这不是完整的不在乎。 

699
00:31:06,660 --> 00:31:09,918
显然，此ID必须相等。 

700
00:31:09,918 --> 00:31:11,410
您必须能够对它说==。 

701
00:31:11,410 --> 00:31:13,770
否则我无法分辨两件事

702
00:31:13,770 --> 00:31:14,700
是相同的。 

703
00:31:14,700 --> 00:31:17,000
但是一个字符串，您当然可以在== 

704
00:31:17,000 --> 00:31:18,200
这样很好

705
00:31:18,200 --> 00:31:19,677
但是我得到的是什么错误。 

706
00:31:19,677 --> 00:31:22,817
“必须将属性ID声明为公开

707
00:31:22,817 --> 00:31:24,237
“因为它符合要求

708
00:31:24,237 --> 00:31:27,130
“根据公开协议“可识别”。” 

709
00:31:27,130 --> 00:31:29,690
好吧，可识别确实是一个公共协议

710
00:31:29,690 --> 00:31:31,780
String是一个公共类。 

711
00:31:31,780 --> 00:31:35,320
因此，这使得我们也必须将其标记为公开。 

712
00:31:35,320 --> 00:31:36,610
现在公众是什么意思？ 

713
00:31:36,610 --> 00:31:39,430
我们还没有看到公共访问控制。 

714
00:31:39,430 --> 00:31:43,700
我们看到了私人和私人场景，但还没有看到公共场景。 

715
00:31:43,700 --> 00:31:48,140
在图书馆中，公共是指非私有。 

716
00:31:48,140 --> 00:31:51,800
可识别和字符串显然在SwiftUI中

717
00:31:51,800 --> 00:31:53,910
进口图书馆就在这里。 

718
00:31:53,910 --> 00:31:56,810
因此，他们必须标记自己想要的东西

719
00:31:56,810 --> 00:32:01,100
在图书馆外面，实际上可以与公众共享。 

720
00:32:01,100 --> 00:32:02,940
现在，您将不会在本课程中编写库

721
00:32:02,940 --> 00:32:05,060
因此，您永远不会将任何内容标记为公开。 

722
00:32:05,060 --> 00:32:06,940
但是如果有一天您在图书馆工作， 

723
00:32:06,940 --> 00:32:09,513
您会知道那里有什么公开的内容。 

724
00:32:10,780 --> 00:32:13,440
现在可以正常工作了，您会看到没有错误，对不对？ 

725
00:32:13,440 --> 00:32:15,290
现在这是一个可标识的数组

726
00:32:16,440 --> 00:32:18,270
因为字符串是可识别的。 

727
00:32:18,270 --> 00:32:20,410
但这也是错误的，好吧。 

728
00:32:20,410 --> 00:32:21,480
我们真的不会（笑） 

729
00:32:21,480 --> 00:32:25,220
希望使整个应用程序中的字符串都可识别。 

730
00:32:25,220 --> 00:32:26,760
真的，我们只想要他们

731
00:32:26,760 --> 00:32:29,290
在这里可以识别。 

732
00:32:29,290 --> 00:32:31,370
而且ForEach知道您有时

733
00:32:31,370 --> 00:32:34,170
会传递一些你不想要的东西， 

734
00:32:34,170 --> 00:32:37,950
您不能使其符合“可识别的”。 

735
00:32:37,950 --> 00:32:39,960
所以它有一个很好的额外的论点

736
00:32:39,960 --> 00:32:42,130
您可以指定被叫ID。 

737
00:32:42,130 --> 00:32:47,130
现在，id可让您指定这些内容上的哪个var 

738
00:32:48,240 --> 00:32:50,860
用于唯一地标识它。 

739
00:32:50,860 --> 00:32:53,940
所以本质上就像使用此var作为id 

740
00:32:53,940 --> 00:32:55,850
好像这东西是可识别的

741
00:32:55,850 --> 00:32:57,220
这真的很方便。 

742
00:32:57,220 --> 00:33:01,413
现在，我要在String中使用的var是.self。 

743
00:33:02,290 --> 00:33:05,950
好吧，（笑）所以每个对象本质上都有一个变量

744
00:33:05,950 --> 00:33:09,100
您看不到所谓的自我，那就是自身。 

745
00:33:09,100 --> 00:33:12,140
因此，这是一个很好的字符串标识符。 

746
00:33:12,140 --> 00:33:16,640
但是\ .self在这里的语法是什么？ 

747
00:33:16,640 --> 00:33:19,550
在Swift中，这称为关键路径。 

748
00:33:19,550 --> 00:33:22,630
关键路径只是一个非常酷的简单语法

749
00:33:22,630 --> 00:33:27,130
可以在另一个对象上指定var。 

750
00:33:27,130 --> 00:33:29,980
所以这是反斜杠，这是关键路径

751
00:33:29,980 --> 00:33:33,453
点在这里意味着这个东西， 

752
00:33:33,453 --> 00:33:36,620
这类东西，弦乐，自我。 

753
00:33:36,620 --> 00:33:38,470
而且我可以按任何您知道的任何变量。 

754
00:33:38,470 --> 00:33:41,010
我什至可以这样说，foo.bar 

755
00:33:41,010 --> 00:33:44,260
并调用一个var返回某些内容，然后在其上调用一个var。 

756
00:33:44,260 --> 00:33:46,050
这是一个非常灵活的小系统， 

757
00:33:46,050 --> 00:33:48,700
这个小关键路径导向的东西。 

758
00:33:48,700 --> 00:33:51,900
但是您可以看到这里已修复所有问题。 

759
00:33:51,900 --> 00:33:54,503
因此，让我们运行它，看看我们到了这里。 

760
00:33:55,740 --> 00:33:57,400
而且，不要在iPhone上运行。 

761
00:33:57,400 --> 00:34:00,120
所以我们在这里做的这个程序

762
00:34:00,120 --> 00:34:02,280
将成为一个iPad应用程序。 

763
00:34:02,280 --> 00:34:05,270
我要主要用于iPad。 

764
00:34:05,270 --> 00:34:08,910
我们会发现，由于SwiftUI的强大功能， 

765
00:34:08,910 --> 00:34:10,770
在iPhone上可以很好地工作（轻笑） 

766
00:34:10,770 --> 00:34:13,570
同样，但我们将首先在iPad上进行开发。 

767
00:34:13,570 --> 00:34:16,580
我们将所有这些东西拖放到这里。 

768
00:34:16,580 --> 00:34:19,180
就是这样，是的，这显示了Safari 

769
00:34:19,180 --> 00:34:21,770
现在我们在这里运行我们的EmojiArt版本

770
00:34:21,770 --> 00:34:25,030
所以我们丢掉了我以前给你看的所有东西。 

771
00:34:25,030 --> 00:34:27,010
但是在这里，它们就是表情符号。 

772
00:34:27,010 --> 00:34:29,150
现在，我们的表情符号有点

773
00:34:29,150 --> 00:34:30,210
这里有些问题。 

774
00:34:30,210 --> 00:34:32,360
一，它们很小，我们要

775
00:34:32,360 --> 00:34:35,550
使其可滚动，因此让我们修复其中的一些问题。 

776
00:34:35,550 --> 00:34:37,520
小巧，我们知道如何解决。 

777
00:34:37,520 --> 00:34:41,410
我们只是要说.font而我们将使用系统字体

778
00:34:41,410 --> 00:34:45,140
的大小，我将成为一名优秀的程序员

779
00:34:45,140 --> 00:34:48,330
并在这里稍作放松

780
00:34:48,330 --> 00:34:53,330
可能是私人的，叫我的defaultEmojiSize。 

781
00:34:53,940 --> 00:34:55,317
将会是CGFloat。 

782
00:34:55,317 --> 00:34:57,367
我要说40，我想我尝试过

783
00:34:57,367 --> 00:34:59,100
而且看起来还不错。 

784
00:34:59,100 --> 00:35:02,029
所以在这里说self.defaultEmojiSize。 

785
00:35:02,029 --> 00:35:03,029
那会变得很大。 

786
00:35:04,041 --> 00:35:05,303
让我们看看它是什么样的。 

787
00:35:07,801 --> 00:35:08,870
是的，好的，绝对更好。 

788
00:35:08,870 --> 00:35:10,870
这更接近我们以前拥有的东西。 

789
00:35:10,870 --> 00:35:12,020
可滚动性如何？ 

790
00:35:12,020 --> 00:35:14,360
我拖着它，它没有滚动

791
00:35:14,360 --> 00:35:17,470
在这里来回切换，这在Swift中非常容易。 

792
00:35:17,470 --> 00:35:19,820
所以这很容易，我当时在考虑放幻灯片

793
00:35:19,820 --> 00:35:21,510
关于（笑）和如何做ScrollViews 

794
00:35:21,510 --> 00:35:24,970
但这很简单，甚至几乎不值得

795
00:35:24,970 --> 00:35:26,270
滑过。 

796
00:35:26,270 --> 00:35:28,710
您只需将其放在ScrollView和ScrollView中

797
00:35:28,710 --> 00:35:31,140
将让您指定是否水平滚动

798
00:35:31,140 --> 00:35:32,670
或垂直或两者兼而有之。 

799
00:35:32,670 --> 00:35:36,460
因此，我们的ScrollView显然只能水平滚动。 

800
00:35:36,460 --> 00:35:39,320
我们将其包装在那里，这就是我们要做的。 

801
00:35:39,320 --> 00:35:42,410
现在，我们拥有的这个HStack将是可滚动的。 

802
00:35:42,410 --> 00:35:45,280
你看，我可以滚动它。 

803
00:35:45,280 --> 00:35:47,560
我不喜欢的一件事是，有点接近

804
00:35:47,560 --> 00:35:48,610
在那边

805
00:35:48,610 --> 00:35:51,490
我想要一点空间，我们知道该怎么做， 

806
00:35:51,490 --> 00:35:53,360
给东西增加一点空间。 

807
00:35:53,360 --> 00:35:56,580
因此，让我们使用此ScrollView并添加一些填充。 

808
00:35:56,580 --> 00:35:59,510
而且我只会水平填充。 

809
00:35:59,510 --> 00:36:01,137
你现在可能已经聚集

810
00:36:01,137 --> 00:36:03,630
填充如何有很多不同的论点。 

811
00:36:03,630 --> 00:36:06,530
您可以仅在某些边缘上指定确切的填充

812
00:36:06,530 --> 00:36:08,300
或默认填充或其他内容。 

813
00:36:08,300 --> 00:36:09,950
这将给我默认的填充

814
00:36:09,950 --> 00:36:12,063
但仅在左侧和右侧。 

815
00:36:13,322 --> 00:36:16,480
我可能想要，垂直上我想要这个东西

816
00:36:17,540 --> 00:36:19,520
使用尽可能少的空间。 

817
00:36:19,520 --> 00:36:20,610
所以我真的不想在那边填充

818
00:36:20,610 --> 00:36:23,160
因为我希望我的文件尽可能大。 

819
00:36:24,130 --> 00:36:27,000
说到我的文件，让我们把文件放在那

820
00:36:27,000 --> 00:36:28,610
并把它推到顶部

821
00:36:28,610 --> 00:36:32,053
而我的文档将使用那里的所有剩余空间。 

822
00:36:33,090 --> 00:36:36,490
直到我们编写实际用于文档的代码

823
00:36:36,490 --> 00:36:38,670
可以有背景并且有所有表情符号

824
00:36:38,670 --> 00:36:42,220
在那儿，我将使用一个黄色矩形

825
00:36:42,220 --> 00:36:43,950
作为我的文件。 

826
00:36:43,950 --> 00:36:47,660
因此，我将使用此ScrollView将其放入VStack 

827
00:36:47,660 --> 00:36:50,370
我们刚刚为表情符号制作的

828
00:36:50,370 --> 00:36:55,130
以及一个前景颜色为黄色的矩形。 

829
00:37:00,660 --> 00:37:02,500
好吧，这真是太可笑了（笑） 

830
00:37:02,500 --> 00:37:04,430
完全看完我想要的

831
00:37:04,430 --> 00:37:07,130
好的，我这里有可滚动的表情符号列表。 

832
00:37:07,130 --> 00:37:09,040
我们可以拥有任意数量的表情符号。 

833
00:37:09,040 --> 00:37:10,687
这是我的文件。 

834
00:37:10,687 --> 00:37:14,330
唯一的事情是我真的不想要这条白线

835
00:37:14,330 --> 00:37:17,890
在这里，为什么这不是一直到底部的黄色？ 

836
00:37:17,890 --> 00:37:19,590
并没有一直到底部的黄色

837
00:37:19,590 --> 00:37:23,110
因为它只会在安全区域绘制黄色

838
00:37:23,110 --> 00:37:26,060
所谓的此视图的安全区域。 

839
00:37:26,060 --> 00:37:29,220
而且它认为这里的这个小区域并不安全

840
00:37:29,220 --> 00:37:30,480
因为只有这么少

841
00:37:30,480 --> 00:37:33,880
你在这里看到这个小酒吧吗？ 

842
00:37:33,880 --> 00:37:36,120
这就是您要切换的栏

843
00:37:36,120 --> 00:37:38,600
到iPad中的其他应用程序。 

844
00:37:38,600 --> 00:37:41,150
因此，它认为装饰

845
00:37:41,150 --> 00:37:42,970
总是在屏幕上。 

846
00:37:42,970 --> 00:37:45,200
默认情况下，它不会覆盖

847
00:37:45,200 --> 00:37:46,690
以防万一

848
00:37:46,690 --> 00:37:48,620
您的应用程序正在背后。 

849
00:37:48,620 --> 00:37:51,010
但是我们的应用程序将能够缩放和平移

850
00:37:51,010 --> 00:37:52,770
所以如果有一些重要的表情符号（笑声） 

851
00:37:52,770 --> 00:37:54,790
在此条下面，我们将其移动， 

852
00:37:54,790 --> 00:37:56,780
将我们的文档移开一点。 

853
00:37:56,780 --> 00:37:59,700
因此，我们确实想移到此处的边缘。 

854
00:37:59,700 --> 00:38:03,010
通常，在iOS中，当我们构建应用程序时， 

855
00:38:03,010 --> 00:38:04,560
内容为王。 

856
00:38:04,560 --> 00:38:08,650
我们想为内容使用尽可能多的空间

857
00:38:08,650 --> 00:38:11,190
尽可能少的装饰空间，好吧， 

858
00:38:11,190 --> 00:38:13,030
这些小东西

859
00:38:13,030 --> 00:38:15,350
或喜欢，甚至这里的表情符号。 

860
00:38:15,350 --> 00:38:17,270
我们想尝试保持较小

861
00:38:17,270 --> 00:38:20,160
因此我们的文件空间很大。 

862
00:38:20,160 --> 00:38:22,307
那么我们如何告诉SwiftUI，“是的，继续， 

863
00:38:22,307 --> 00:38:25,500
“在这里使用这些小物件之类的不安全区域。” 

864
00:38:25,500 --> 00:38:29,520
顺便说一句，iPhone上的缺口也是一个不安全的区域。 

865
00:38:29,520 --> 00:38:32,230
因此，如果要使用它，那没问题。 

866
00:38:32,230 --> 00:38:34,380
我们要去这里的矩形

867
00:38:34,380 --> 00:38:37,570
并说忽略安全区域的边缘

868
00:38:37,570 --> 00:38:40,890
是的，我要左右水平边缘

869
00:38:40,890 --> 00:38:43,670
还有底边

870
00:38:43,670 --> 00:38:47,340
因此，我可以在多个方面进行忽略。 

871
00:38:47,340 --> 00:38:49,263
因此，让我们看看它是什么样的。 

872
00:38:53,684 --> 00:38:54,780
-！ 

873
00:38:54,780 --> 00:38:58,010
我们要使那个黄色矩形成为我们的文档

874
00:38:58,010 --> 00:39:00,730
因此我们需要该文档的模型。 

875
00:39:00,730 --> 00:39:03,800
现在我们针对该文档的模型将是

876
00:39:03,800 --> 00:39:05,967
背景，然后是所有表情符号

877
00:39:05,967 --> 00:39:07,760
以及它们的位置和大小。 

878
00:39:07,760 --> 00:39:09,600
也就是说，这就是整个模型。 

879
00:39:09,600 --> 00:39:11,430
现在不要在这里感到困惑

880
00:39:11,430 --> 00:39:14,900
可能只是因为您做过背诵并且有主题， 

881
00:39:14,900 --> 00:39:18,290
您可能会想知道这是怎么回事。 

882
00:39:18,290 --> 00:39:20,240
是的，EmojiArtDocument的模型

883
00:39:21,330 --> 00:39:25,770
代表视觉事物，表情符号艺术本身。 

884
00:39:25,770 --> 00:39:29,080
但这本身不是UI元素。 

885
00:39:29,080 --> 00:39:32,780
它仍然是一种与设备无关的表示形式

886
00:39:32,780 --> 00:39:35,400
EmojiArtDocument的内容，取决于某些用户界面

887
00:39:35,400 --> 00:39:39,280
就像SwiftUI一样，将其变成我们可以绘制的东西。 

888
00:39:39,280 --> 00:39:42,860
我将通过制作坐标来强调这一点

889
00:39:42,860 --> 00:39:45,800
这些表情符号的大小为Ints， 

890
00:39:45,800 --> 00:39:48,320
很明显，SwiftUI在Ints中不起作用， 

891
00:39:48,320 --> 00:39:51,460
它适用于CGFloat，正确的浮点数。 

892
00:39:51,460 --> 00:39:54,330
但是我要使它们成为Int，以便您可以真正

893
00:39:54,330 --> 00:39:56,240
看到我的模型之间的差异， 

894
00:39:56,240 --> 00:39:59,300
这与设备无关，与UI无关

895
00:39:59,300 --> 00:40:01,483
它和我的用户界面的表示形式。 

896
00:40:02,860 --> 00:40:04,757
因此，让我们创建该模型。 

897
00:40:04,757 --> 00:40:07,350
我们要去File，New up here。 

898
00:40:07,350 --> 00:40:11,380
它是一个模型，所以它是一个Swift文件。 

899
00:40:11,380 --> 00:40:12,560
一切都在正确的地方。 

900
00:40:12,560 --> 00:40:15,110
我要称呼我的Model EmojiArt。 

901
00:40:15,110 --> 00:40:17,980
这就是我的模特，这是表情符号艺术。 

902
00:40:17,980 --> 00:40:20,849
在这里，我不会在这里更改为SwiftUI。 

903
00:40:20,849 --> 00:40:23,319
刚要导入基金会。 

904
00:40:23,319 --> 00:40:26,490
这是一个名为EmojiArt的简单结构

905
00:40:26,490 --> 00:40:29,660
它具有这个backgroundURL。 

906
00:40:29,660 --> 00:40:32,454
我要存储背景的URL。 

907
00:40:32,454 --> 00:40:36,330
它的类型将是URL，不过是可选URL。 

908
00:40:36,330 --> 00:40:40,070
该URL只是一个Swift库结构

909
00:40:40,070 --> 00:40:44,097
包含类似https：//的URL。 

910
00:40:44,097 --> 00:40:46,067
那是一个URL，它包含它

911
00:40:46,067 --> 00:40:49,000
并且还可以在其中保存文件URL。 

912
00:40:49,000 --> 00:40:50,690
我将其设为可选的原因

913
00:40:50,690 --> 00:40:52,670
是我们的文件显然开始了

914
00:40:52,670 --> 00:40:55,570
没有背景，实际上是有效的

915
00:40:55,570 --> 00:40:57,664
具有没有背景的EmojiArtDocument。 

916
00:40:57,664 --> 00:41:00,290
它可能只是白色的或类似的东西。 

917
00:41:00,290 --> 00:41:02,100
看起来可能不太好。 

918
00:41:02,100 --> 00:41:04,510
但这当然是合法的，所以这就是为什么

919
00:41:04,510 --> 00:41:06,450
我将使它成为可选项。 

920
00:41:06,450 --> 00:41:08,230
另一件事是表情符号。 

921
00:41:08,230 --> 00:41:11,990
所以表情符号只是一些表情符号数组

922
00:41:11,990 --> 00:41:15,260
某种形式，所以我必须有一个结构表情符号

923
00:41:15,260 --> 00:41:17,270
代表表情符号。 

924
00:41:17,270 --> 00:41:18,920
就像我们在记忆中有卡一样

925
00:41:18,920 --> 00:41:21,600
在这里，我们的EmojiArt中恰好有表情符号。 

926
00:41:21,600 --> 00:41:23,633
表情符号中有什么？ 

927
00:41:23,633 --> 00:41:26,820
显然是文字，对，实际的表情符号

928
00:41:26,820 --> 00:41:29,050
像笑脸之类的

929
00:41:29,050 --> 00:41:31,070
有位置我告诉过你

930
00:41:31,070 --> 00:41:33,820
我将使用Ints进行定位。 

931
00:41:33,820 --> 00:41:35,500
顺便说一下， 

932
00:41:35,500 --> 00:41:38,760
我将拥有这个X和Y的坐标系

933
00:41:38,760 --> 00:41:42,300
在我的文档中心有（0，0）。 

934
00:41:42,300 --> 00:41:44,580
这与iOS的坐标系不同。 

935
00:41:44,580 --> 00:41:46,830
你会记得我们做馅饼的时候

936
00:41:46,830 --> 00:41:47,830
那个坐标系

937
00:41:47,830 --> 00:41:49,790
在左上角是（0，0）。 

938
00:41:49,790 --> 00:41:51,750
我将X和Y放在中间。 

939
00:41:51,750 --> 00:41:54,680
请注意，因为以后我们工作时

940
00:41:54,680 --> 00:41:56,410
在我们看来，我们将不得不转换

941
00:41:56,410 --> 00:41:58,270
从我们模型的坐标系

942
00:41:58,270 --> 00:42:00,580
就是（0，0）是中心， 

943
00:42:00,580 --> 00:42:04,240
到我们的iOS坐标系（0，0）的左上方。 

944
00:42:04,240 --> 00:42:08,320
因此，我们也要确定尺寸，我们也可以使用Int做到这一点。 

945
00:42:08,320 --> 00:42:10,350
请注意，我使文本成为允许。 

946
00:42:10,350 --> 00:42:13,360
一旦您在EmojiArt中创建了笑脸表情符号

947
00:42:13,360 --> 00:42:16,050
或熊猫，自行车或其他任何东西（咯咯笑） 

948
00:42:16,050 --> 00:42:18,110
永远都是那样。 

949
00:42:18,110 --> 00:42:20,941
我们绝不允许您更改该表情符号。 

950
00:42:20,941 --> 00:42:22,010
那只是我的决定

951
00:42:22,010 --> 00:42:24,190
然后我做出决定或表达该决定

952
00:42:24,190 --> 00:42:26,163
通过让它成为。 

953
00:42:27,050 --> 00:42:29,960
现在我们已经可以在用户界面中

954
00:42:30,811 --> 00:42:33,087
这个表情符号将是可识别的。 

955
00:42:33,087 --> 00:42:35,200
显然，我们将不得不

956
00:42:35,200 --> 00:42:38,240
通过我们的表情符号并在屏幕上全部显示。 

957
00:42:38,240 --> 00:42:41,190
所以我要使它可识别。 

958
00:42:41,190 --> 00:42:44,253
这需要我们执行此var id。 

959
00:42:45,340 --> 00:42:48,090
现在我们的身份证是什么？ 

960
00:42:48,090 --> 00:42:51,140
在我们的记忆游戏中，我们做到了

961
00:42:51,140 --> 00:42:53,720
哪对喜欢，首先将它与零和一配对， 

962
00:42:53,720 --> 00:42:55,630
第二对是两个和三个。 

963
00:42:55,630 --> 00:42:58,920
在这里，我们实际上并没有那种对

964
00:42:58,920 --> 00:43:00,670
或类似的东西来使用。 

965
00:43:00,670 --> 00:43:04,990
我们经常将一些用于ID的东西称为UUID。 

966
00:43:04,990 --> 00:43:07,750
这是一个非常独特的标识符。 

967
00:43:07,750 --> 00:43:11,521
在宇宙中，它是独一无二的。 

968
00:43:11,521 --> 00:43:13,020
有点过分了

969
00:43:13,020 --> 00:43:15,520
EmojiArt中的表情符号。 

970
00:43:15,520 --> 00:43:17,710
我在EmojiArt中可以有数百个Emojis 

971
00:43:17,710 --> 00:43:19,800
我可以拥有数百个EmojiArt文档。 

972
00:43:19,800 --> 00:43:22,910
因此，这些很多，生成了这些唯一的ID 

973
00:43:22,910 --> 00:43:24,400
一点都没有。 

974
00:43:24,400 --> 00:43:27,730
实际上，此ID也只需要是可识别的

975
00:43:27,730 --> 00:43:30,350
并且在本文档中是唯一的。 

976
00:43:30,350 --> 00:43:33,580
我们将不需要识别

977
00:43:33,580 --> 00:43:36,300
请参阅许多文档中的表情符号。 

978
00:43:36,300 --> 00:43:40,170
所以我实际上将把它作为一个Int 

979
00:43:40,170 --> 00:43:42,980
我要在此结构中进行管理。 

980
00:43:42,980 --> 00:43:45,210
因此，它将由私人管理。 

981
00:43:45,210 --> 00:43:48,480
只有EmojiArt才会知道这是什么原因

982
00:43:48,480 --> 00:43:50,450
Int我们如何制作此Int。 

983
00:43:50,450 --> 00:43:52,820
但是可识别的当然是公共事物， 

984
00:43:52,820 --> 00:43:55,250
因此人们会看Int。 

985
00:43:55,250 --> 00:43:58,630
由于我们只希望任何人都可以查看此文件， 

986
00:43:58,630 --> 00:44:01,890
您当然可以放手。 

987
00:44:01,890 --> 00:44:05,130
但是我们现在要做的是每次创建时

988
00:44:05,130 --> 00:44:07,280
我给它一个唯一的ID。 

989
00:44:07,280 --> 00:44:11,090
这将通过一个小的私有变量来完成

990
00:44:11,090 --> 00:44:12,730
称为uniqueEmojiId。 

991
00:44:15,204 --> 00:44:17,660
它只是一个Int，我要添加一个函数

992
00:44:17,660 --> 00:44:18,823
叫做addEmoji。 

993
00:44:23,968 --> 00:44:26,820
所有addEmoji要做的就是添加一个表情符号

994
00:44:26,820 --> 00:44:31,010
通过添加我要创建的新表情符号

995
00:44:31,010 --> 00:44:33,053
那里有一个标准的构造函数。 

996
00:44:35,340 --> 00:44:39,313
并以唯一的ID作为ID。 

997
00:44:40,230 --> 00:44:43,900
现在，我当然需要保持唯一的ID为唯一

998
00:44:43,900 --> 00:44:45,650
所以每次有人这样做时， 

999
00:44:45,650 --> 00:44:49,900
我要说的是uniqueEmojiID + = 1。 

1000
00:44:49,900 --> 00:44:53,670
这样，它一直在变化，并且始终是唯一的。 

1001
00:44:53,670 --> 00:44:56,130
现在很好，但是您可以看到我这里有错误

1002
00:44:56,130 --> 00:44:56,963
到处都是。 

1003
00:44:56,963 --> 00:44:59,237
“变异算子的左侧是不可变的。 

1004
00:44:59,237 --> 00:45:01,700
“自我是不可变的，自我是不可变的。” （咯咯笑） 

1005
00:45:01,700 --> 00:45:05,010
是的，这是一个自我变异的功能，对吗？ 

1006
00:45:05,010 --> 00:45:06,500
它改变了这个家伙。 

1007
00:45:06,500 --> 00:45:09,553
因此，我们需要将其标记为变异函数。 

1008
00:45:11,240 --> 00:45:14,080
现在，此策略执行此唯一的EmojiID 

1009
00:45:14,080 --> 00:45:17,270
只要每个人都总是添加表情符号，效果就会很好

1010
00:45:17,270 --> 00:45:18,950
通过调用addEmoji。 

1011
00:45:18,950 --> 00:45:22,570
但是如果有人用自己的ID创建表情符号该怎么办

1012
00:45:22,570 --> 00:45:25,930
然后将其添加到此数组？ 

1013
00:45:25,930 --> 00:45:28,240
这可能很糟糕，特别是如果他们选择一个ID 

1014
00:45:28,240 --> 00:45:30,800
这与我们选择的其他相同

1015
00:45:30,800 --> 00:45:32,440
那个表情符号

1016
00:45:32,440 --> 00:45:35,180
现在您可能会认为私有集，对， 

1017
00:45:35,180 --> 00:45:36,990
私有集应解决此问题

1018
00:45:36,990 --> 00:45:38,440
因为这样使表情符号

1019
00:45:38,440 --> 00:45:41,010
只能由我们写。 

1020
00:45:41,010 --> 00:45:43,290
但我真的不想要

1021
00:45:43,290 --> 00:45:46,410
因为其中有些表情符号之类的东西

1022
00:45:46,410 --> 00:45:50,056
以及我希望人们设置的尺寸。 

1023
00:45:50,056 --> 00:45:50,970
他们可以根据需要设置它们， 

1024
00:45:50,970 --> 00:45:53,380
随意移动表情符号。 

1025
00:45:53,380 --> 00:45:55,490
所以我真的不能在这里使用私有集

1026
00:45:55,490 --> 00:45:57,150
就像我在记忆中所做的一样。 

1027
00:45:58,150 --> 00:46:01,120
所以我要如何防止这种情况的发生

1028
00:46:01,120 --> 00:46:04,223
人们在添加表情符号，而不是这样。 

1029
00:46:05,407 --> 00:46:06,930
我将以一种有趣的方式来做。 

1030
00:46:06,930 --> 00:46:10,060
在这里的表情符号中，我将定义一个init 

1031
00:46:10,060 --> 00:46:13,290
它会有所有相同的论点

1032
00:46:13,290 --> 00:46:17,590
作为您免费获得的结构体的标准初始化。 

1033
00:46:17,590 --> 00:46:19,450
现在这如何解决问题？ 

1034
00:46:19,450 --> 00:46:21,040
实际上，这似乎是一大浪费。 

1035
00:46:21,040 --> 00:46:24,297
我是免费获得的，为什么我要这样做呢？ 

1036
00:46:24,297 --> 00:46:25,750
我要做的原因

1037
00:46:25,750 --> 00:46:29,470
是因为我要将此初始化设为私有。 

1038
00:46:29,470 --> 00:46:31,320
通过将此初始化设为私有， 

1039
00:46:31,320 --> 00:46:34,620
现在没有人可以创建表情符号

1040
00:46:34,620 --> 00:46:37,700
除了表情符号本身，在这里还没有用。 

1041
00:46:37,700 --> 00:46:40,890
即使EmojiArt也无法创建它。 

1042
00:46:40,890 --> 00:46:43,247
因此它确实可以防止他人创建表情符号

1043
00:46:43,247 --> 00:46:45,850
并放在这里，但它可以保护EmojiArt 

1044
00:46:45,850 --> 00:46:47,640
从也这样做。 

1045
00:46:47,640 --> 00:46:49,070
我要告诉你解决的办法

1046
00:46:49,070 --> 00:46:52,603
使用另一种称为fileprivate的访问控制。 

1047
00:46:54,118 --> 00:46:57,450
fileprivate将此文件设为私有。 

1048
00:46:57,450 --> 00:47:00,710
这使EmojiArt拥有称呼它的能力

1049
00:47:00,710 --> 00:47:04,240
并创建此文件，但此文件之外的任何人都无法做到。 

1050
00:47:04,240 --> 00:47:06,100
所以现在我们已经防止了这种情况

1051
00:47:06,100 --> 00:47:09,140
有人创建表情符号并将其放置在此处

1052
00:47:09,140 --> 00:47:12,300
不用经历我们漂亮的独特EmojiID 

1053
00:47:12,300 --> 00:47:14,823
因为没有办法让他们创建表情符号。 

1054
00:47:16,080 --> 00:47:19,340
好的，基本上就是我们的模型。 

1055
00:47:19,340 --> 00:47:21,160
我们的模型非常简单。 

1056
00:47:21,160 --> 00:47:24,900
让我们转到这里的ViewModel 

1057
00:47:24,900 --> 00:47:29,850
并将其添加为@Published私有变量。 

1058
00:47:29,850 --> 00:47:31,940
再说一次，我可以称其为Model，但我不会。 

1059
00:47:31,940 --> 00:47:36,300
我将其称为我的emojiArt，它是EmojiArt类型的。 

1060
00:47:36,300 --> 00:47:39,320
然后将其设置为空的EmojiArt 

1061
00:47:39,320 --> 00:47:44,130
没有背景，没有表情符号。 

1062
00:47:44,130 --> 00:47:47,700
它的发布是因为EmojiArt每次更改

1063
00:47:47,700 --> 00:47:50,750
当然，我们需要使用ObservableObject机制

1064
00:47:50,750 --> 00:47:52,870
使我们的视图重绘。 

1065
00:47:52,870 --> 00:47:56,610
这是私人的，因为我将成为一个非常好的

1066
00:47:56,610 --> 00:47:59,270
小ViewModel在这里，做我的工作之一

1067
00:47:59,270 --> 00:48:02,220
这是为视图解释模型。 

1068
00:48:02,220 --> 00:48:06,490
所以我是一个UI使用者，我是一个UI使用者，这个ViewModel。 

1069
00:48:06,490 --> 00:48:09,050
我知道我们使用CGFloats和CGPoints 

1070
00:48:11,106 --> 00:48:13,520
和CGSizes，我们不使用Ints。 

1071
00:48:13,520 --> 00:48:16,210
我知道这就是我的观点所期望的。 

1072
00:48:16,210 --> 00:48:18,950
因此，我将提供一些Intent。 

1073
00:48:20,440 --> 00:48:23,433
在此处标记意图。 

1074
00:48:24,320 --> 00:48:25,867
这些意图，我们要在其中输入

1075
00:48:25,867 --> 00:48:28,220
真正的快速（笑）与一个片段。 

1076
00:48:28,220 --> 00:48:31,110
这些意图实际上将引起争论

1077
00:48:31,110 --> 00:48:34,430
在位置CGPoint上添加表情符号

1078
00:48:34,430 --> 00:48:35,980
和大小CGFloat， 

1079
00:48:35,980 --> 00:48:39,370
或通过偏移CGSize来移动表情符号， 

1080
00:48:39,370 --> 00:48:41,020
或scaleEmoji（按比例缩放CGFloat）。 

1081
00:48:42,752 --> 00:48:43,890
然后它会转过来

1082
00:48:43,890 --> 00:48:47,120
并访问其数组，但将其实例化。 

1083
00:48:47,120 --> 00:48:49,650
看，Int，Int，我们正在做Int。 

1084
00:48:49,650 --> 00:48:51,570
我们正在将这些东西转化为整数。 

1085
00:48:51,570 --> 00:48:54,350
因此，这使得我的视图将被称为这些。 

1086
00:48:54,350 --> 00:48:56,670
它不能直接访问emojiArt，它是私有的。 

1087
00:48:56,670 --> 00:48:58,353
所以将这些称为Intent函数

1088
00:48:58,353 --> 00:49:00,540
我打算添加一个表情符号， 

1089
00:49:00,540 --> 00:49:03,223
我打算四处移动表情符号，等等。 

1090
00:49:04,290 --> 00:49:05,627
现在注意，我们这里有一个错误。 

1091
00:49:05,627 --> 00:49:08,070
“不能转换值类型的EmojiArt，”等等等等。 

1092
00:49:08,070 --> 00:49:10,580
这是因为我正在使用firstIndex匹配。 

1093
00:49:10,580 --> 00:49:13,010
记住我们添加的很棒的功能

1094
00:49:13,010 --> 00:49:16,030
通过对Array的扩展会查找一些东西

1095
00:49:16,030 --> 00:49:19,000
可识别的数组中可识别的

1096
00:49:19,000 --> 00:49:21,020
并找到它的索引？ 

1097
00:49:21,020 --> 00:49:23,020
我在我的ViewModel中这样做

1098
00:49:23,020 --> 00:49:25,610
因为我也不希望我的观点一定

1099
00:49:25,610 --> 00:49:28,150
必须处理进入数组的索引。 

1100
00:49:28,150 --> 00:49:31,300
现在在记忆中，我们将索引用于数组

1101
00:49:31,300 --> 00:49:33,660
为什么我们在数组中使用索引？ 

1102
00:49:33,660 --> 00:49:35,990
因为我们想对数组进行更改

1103
00:49:35,990 --> 00:49:38,700
就位，我们想在这里做同样的事情。 

1104
00:49:38,700 --> 00:49:40,800
所以我要在这里使用index作为Array。 

1105
00:49:40,800 --> 00:49:43,360
但我真的很希望View能够

1106
00:49:43,360 --> 00:49:45,440
使用EmojiArt对象。 

1107
00:49:45,440 --> 00:49:47,360
由于他们是可识别的，所以当他们问我时

1108
00:49:47,360 --> 00:49:50,320
移动一个或缩放一个， 

1109
00:49:50,320 --> 00:49:53,240
我将使用此firstIndex匹配

1110
00:49:53,240 --> 00:49:56,850
用这里相同的标识来查找

1111
00:49:56,850 --> 00:50:00,160
在我的emojiArt Emojis列表中， 

1112
00:50:00,160 --> 00:50:02,017
好的，因为这些是可识别的。 

1113
00:50:02,017 --> 00:50:05,200
这里的API与必须查看的API略有不同， 

1114
00:50:05,200 --> 00:50:09,223
必须说偏移量处的moveEmoji。 

1115
00:50:10,350 --> 00:50:13,620
现在，当然，我们添加了firstIndex匹配功能

1116
00:50:13,620 --> 00:50:16,170
在“记住”中，所以不在这里，这就是它抱怨的原因。 

1117
00:50:16,170 --> 00:50:19,060
现在我实际上把它放在这里，这个文件， 

1118
00:50:19,060 --> 00:50:21,420
我要拖进去的，我提供给你的

1119
00:50:21,420 --> 00:50:25,310
我肯定会复制进去，而不是链接进去。 

1120
00:50:25,310 --> 00:50:28,940
而且此扩展程序不仅具有firstIndex匹配项， 

1121
00:50:28,940 --> 00:50:31,623
它还有其他一些内容，您稍后会看到， 

1122
00:50:32,470 --> 00:50:34,240
只是些实用工具

1123
00:50:34,240 --> 00:50:37,060
并编写代码，此演示快一点。 

1124
00:50:37,060 --> 00:50:39,920
这是firstIndex，但是有点有趣， 

1125
00:50:39,920 --> 00:50:42,220
我没有将其添加到数组。 

1126
00:50:42,220 --> 00:50:45,860
在这里，我们在记忆中做了数组， 

1127
00:50:45,860 --> 00:50:48,960
但是我在这里收集，现在收集是什么？ 

1128
00:50:48,960 --> 00:50:51,990
集合是Array实现的协议。 

1129
00:50:51,990 --> 00:50:54,320
而且由于Array实现了该协议， 

1130
00:50:54,320 --> 00:50:57,760
如果我添加扩展名，Array会得到这个。 

1131
00:50:57,760 --> 00:50:59,420
因此，这将适用于任何集合。 

1132
00:50:59,420 --> 00:51:02,380
现在为什么将它而不是数组添加到集合中？ 

1133
00:51:02,380 --> 00:51:07,380
好吧，因为Set也实现了一个集合。 

1134
00:51:07,650 --> 00:51:10,510
因此，如果我有一个Set，你会知道SwiftUI Set 

1135
00:51:10,510 --> 00:51:11,940
没有设定作业三。 （咯咯笑） 

1136
00:51:11,940 --> 00:51:14,190
SwiftUI Set，如果我有其中之一

1137
00:51:14,190 --> 00:51:17,500
我也可以对它进行firstIndex匹配。 

1138
00:51:17,500 --> 00:51:22,500
我什至要把它包含匹配元素

1139
00:51:23,090 --> 00:51:27,390
这样我就可以看一下Set或Array的内部， 

1140
00:51:27,390 --> 00:51:30,973
您是否通过匹配包含了这个东西？ 

1141
00:51:32,120 --> 00:51:35,083
所以我在做同样的$ 0等于element.id。 

1142
00:51:36,020 --> 00:51:37,600
为何我要这样做？ 

1143
00:51:37,600 --> 00:51:40,340
好吧，我认为当您完成作业四时

1144
00:51:40,340 --> 00:51:41,350
而你必须管理

1145
00:51:41,350 --> 00:51:43,230
所有这些表情符号的选择， 

1146
00:51:43,230 --> 00:51:45,600
您可能希望将它们放在集合中的机会非常大。 

1147
00:51:45,600 --> 00:51:47,340
您可能可以将它们放入数组中， 

1148
00:51:47,340 --> 00:51:50,320
但是集合比数组更好，因为集合管理身份

1149
00:51:50,320 --> 00:51:52,000
而且你再也不需要同一个表情符号

1150
00:51:52,000 --> 00:51:55,120
两次选择。 

1151
00:51:55,120 --> 00:51:58,190
将它们放入一个集合并放入其中真的很容易。 

1152
00:51:58,190 --> 00:52:00,820
因此，如果您想这样做，则不必使用它。 

1153
00:52:00,820 --> 00:52:03,730
所以任何这些东西，好吧，这只是提供的

1154
00:52:03,730 --> 00:52:06,150
供您使用，但您可能想使用集。 

1155
00:52:06,150 --> 00:52:08,573
所以这就是为什么我要把它放在这里。 

1156
00:52:09,907 --> 00:52:10,950
好的，回到我们的ViewModel。 

1157
00:52:10,950 --> 00:52:14,040
现在，如果我们在这一方面进行编译，它将成功

1158
00:52:14,040 --> 00:52:17,687
我们已经在这里为表情符号建立了Intent。 

1159
00:52:17,687 --> 00:52:20,010
但是我可能还有另外一个意图

1160
00:52:20,010 --> 00:52:22,370
设置背景网址， 

1161
00:52:22,370 --> 00:52:24,120
我将通过拖放来完成。 

1162
00:52:24,120 --> 00:52:27,297
所以在这里我还需要一个func setBackgroundURL 

1163
00:52:28,370 --> 00:52:31,840
而且只需要在此处输入一个URL，URL， 

1164
00:52:31,840 --> 00:52:35,780
输入URL，同样是可选的，我们允许。 

1165
00:52:35,780 --> 00:52:38,767
我们将拥有我们的emojiArt.backgroundURL 

1166
00:52:40,200 --> 00:52:41,290
等于此URL。 

1167
00:52:41,290 --> 00:52:44,180
我要在这里做另一件事

1168
00:52:44,180 --> 00:52:47,130
这些是您拖放的网址

1169
00:52:47,130 --> 00:52:50,710
来自互联网，有时它们是一些时髦的网址

1170
00:52:50,710 --> 00:52:53,420
具有图片的实际网址（笑声） 

1171
00:52:53,420 --> 00:52:55,410
用这个东西嵌入其中

1172
00:52:55,410 --> 00:52:59,310
在这里称为图片网址IMGURL。 

1173
00:52:59,310 --> 00:53:04,100
所以我在URL上放了一点东西来提取图像URL 

1174
00:53:04,100 --> 00:53:07,600
如果这些更复杂的URL不在其中。 

1175
00:53:07,600 --> 00:53:10,593
所以我要在这里称这个小imageURL var。 

1176
00:53:12,490 --> 00:53:14,900
好吧，顺便说一句，如果imageURL走了，看起来

1177
00:53:14,900 --> 00:53:17,380
它找不到那种时髦的小东西

1178
00:53:17,380 --> 00:53:19,050
那么它只是返回URL本身。 

1179
00:53:19,050 --> 00:53:22,750
因此，如果您将普通URL拖入其中，也可以正常工作。 

1180
00:53:22,750 --> 00:53:26,830
所以现在我们的ViewModel已经准备好了

1181
00:53:26,830 --> 00:53:30,860
支持View执行View想要做的事情。 

1182
00:53:30,860 --> 00:53:34,660
因此，让我们转到View并实现它。 

1183
00:53:34,660 --> 00:53:36,250
现在我要做的第一件事

1184
00:53:36,250 --> 00:53:38,090
是拖放好吗。 

1185
00:53:38,090 --> 00:53:40,410
所以在我们的模拟器中

1186
00:53:40,410 --> 00:53:43,380
如果我们在此处使用带有Safari的EmojiArt 

1187
00:53:43,380 --> 00:53:45,370
我捡起来，我希望能够

1188
00:53:45,370 --> 00:53:48,607
将其放入此处，但请注意，它确实无法正常工作。 

1189
00:53:48,607 --> 00:53:50,740
我不知道，当我们第一次做的时候

1190
00:53:50,740 --> 00:53:52,590
您注意到那里有一个绿色的加号。 

1191
00:53:52,590 --> 00:53:55,180
我没有得到绿色的加分，当我放开时， 

1192
00:53:55,180 --> 00:53:58,030
不会，它无法掉落并返回。 

1193
00:53:58,030 --> 00:53:59,850
因此，我希望它放下并在此处绘制。 

1194
00:53:59,850 --> 00:54:01,590
我也不会再发黄了。 

1195
00:54:01,590 --> 00:54:02,990
我要用白色背景。 

1196
00:54:02,990 --> 00:54:05,270
我认为当我们没有图像时看起来会更好

1197
00:54:05,270 --> 00:54:07,460
或者如果我们的图像很小，则有白色

1198
00:54:07,460 --> 00:54:09,720
看起来比黄色更好。 

1199
00:54:09,720 --> 00:54:11,230
因此，让我们进行拖放。 

1200
00:54:11,230 --> 00:54:13,760
现在，在开始拖放之前，请注意以下几点。 

1201
00:54:13,760 --> 00:54:16,670
首先，这仅适用于iOS 13.4。 

1202
00:54:16,670 --> 00:54:19,400
因此，如果您未使用最新的Xcode， 

1203
00:54:19,400 --> 00:54:22,540
在本演示的这一部分，它对您不起作用。 

1204
00:54:22,540 --> 00:54:25,960
第二件事是拖放

1205
00:54:25,960 --> 00:54:28,223
这是一些复杂的API。 

1206
00:54:28,223 --> 00:54:33,040
在SwiftUI中非常简单，但是它使用了一些旧技术

1207
00:54:33,040 --> 00:54:35,290
来自Objective-C世界。 

1208
00:54:35,290 --> 00:54:39,670
因此，不要太在意这个细节。 

1209
00:54:39,670 --> 00:54:42,010
我希望您从概念上了解发生了什么。 

1210
00:54:42,010 --> 00:54:44,810
我不会要你拖放作业

1211
00:54:44,810 --> 00:54:45,740
但这可能是您想要做的

1212
00:54:45,740 --> 00:54:48,320
在您的最终项目中，这将是一个很好的机会

1213
00:54:48,320 --> 00:54:50,370
从那个角度去理解它。 

1214
00:54:51,360 --> 00:54:53,370
因此拖放操作非常简单。 

1215
00:54:53,370 --> 00:54:55,780
您只需在所需的任何地方调用此方法

1216
00:54:55,780 --> 00:54:57,947
为了能够下降，您只需说onDrop。 

1217
00:54:58,990 --> 00:55:02,270
然后onDrop在这里输入一些参数

1218
00:55:02,270 --> 00:55:04,830
进入，然后我们将介绍它们的含义。 

1219
00:55:04,830 --> 00:55:08,830
这第一个论据是说什么样的事情

1220
00:55:08,830 --> 00:55:13,670
您想删除我们想删除的公共图像吗？ 

1221
00:55:13,670 --> 00:55:16,673
因此，公共映像是一个所谓的URI。 

1222
00:55:17,510 --> 00:55:20,660
它指定了一种公共协议

1223
00:55:20,660 --> 00:55:24,520
是图像类型的东西。 

1224
00:55:24,520 --> 00:55:27,290
现在，我们正在寻找URL，而不是图像。 

1225
00:55:27,290 --> 00:55:31,890
但是，如果您拖放图像，提供商很可能

1226
00:55:31,890 --> 00:55:35,180
该图片的还可为您提供其网址。 

1227
00:55:35,180 --> 00:55:37,340
这就是我们将要放弃的东西。 

1228
00:55:37,340 --> 00:55:40,400
如果我在这里说我们希望删除URL， 

1229
00:55:40,400 --> 00:55:42,330
我们可能会从非图片获取网址

1230
00:55:42,330 --> 00:55:43,340
对我们来说这是没有用的。 

1231
00:55:43,340 --> 00:55:45,120
所以为什么我们要寻找那种东西

1232
00:55:45,120 --> 00:55:46,820
要放在这里的是图像。 

1233
00:55:46,820 --> 00:55:48,670
现在，我不再谈论URI。 

1234
00:55:48,670 --> 00:55:50,370
您可以在文档中查找URI。 

1235
00:55:50,370 --> 00:55:51,860
并了解它们是什么。 

1236
00:55:51,860 --> 00:55:53,910
我们实际上要在这里放另一个

1237
00:55:53,910 --> 00:55:57,100
在几分钟内，但这非常简单

1238
00:55:57,100 --> 00:55:58,660
什么是URI。 

1239
00:55:58,660 --> 00:56:00,300
现在这是Targeted。 

1240
00:56:00,300 --> 00:56:03,710
很好，我们不需要这个

1241
00:56:03,710 --> 00:56:06,190
因为此参数称为绑定。 

1242
00:56:06,190 --> 00:56:08,730
下周我们将讨论绑定。 

1243
00:56:08,730 --> 00:56:10,400
但是我们还没有谈论他们

1244
00:56:10,400 --> 00:56:12,960
因此，如果我现在必须解释一下，那就不好了。 

1245
00:56:12,960 --> 00:56:16,160
但这一切基本上就是让我们知道

1246
00:56:16,160 --> 00:56:18,190
当有人拖着我们。 

1247
00:56:18,190 --> 00:56:20,310
不是当它们掉落时，而是当它们拖曳时。 

1248
00:56:20,310 --> 00:56:22,090
幸运的是我不在乎，我只是在乎

1249
00:56:22,090 --> 00:56:23,693
当你把那东西放在我身上。 

1250
00:56:24,550 --> 00:56:27,570
然后onDrop的第三个参数是一个函数， 

1251
00:56:27,570 --> 00:56:29,510
一个闭包，有两个参数。 

1252
00:56:29,510 --> 00:56:31,050
一种是提供者。 

1253
00:56:31,050 --> 00:56:34,470
这些是称为NSItemProviders的对象

1254
00:56:34,470 --> 00:56:37,850
提供要删除的信息。 

1255
00:56:37,850 --> 00:56:40,340
现在被丢弃的信息可能很大， 

1256
00:56:40,340 --> 00:56:41,660
就像它可能实际上是一幅图像。 

1257
00:56:41,660 --> 00:56:43,120
我们只会获取网址， 

1258
00:56:43,120 --> 00:56:45,980
但是您可以抓住整个图像，而且很大。 

1259
00:56:45,980 --> 00:56:48,550
因此，传输必须异步进行

1260
00:56:48,550 --> 00:56:51,680
在这个演示中，我们将讨论异步。 

1261
00:56:51,680 --> 00:56:54,040
这是我们在此演示中要做的主要事情之一。 

1262
00:56:54,040 --> 00:56:56,670
但是我们不是，我们要掩盖这里的异步性

1263
00:56:56,670 --> 00:56:58,010
在这些提供商中。 

1264
00:56:58,010 --> 00:57:01,680
我在此EmojiArtExtensions中再次在此处放置了一些代码

1265
00:57:01,680 --> 00:57:03,750
为我们处理这些东西。 

1266
00:57:03,750 --> 00:57:06,180
因此，不必担心这种异步性。 

1267
00:57:06,180 --> 00:57:09,467
我们将在这里讨论异步。 

1268
00:57:09,467 --> 00:57:11,400
然后是该函数的第二个参数

1269
00:57:11,400 --> 00:57:12,540
是放置的位置。 

1270
00:57:12,540 --> 00:57:15,030
现在，对于背景，我们不在乎将其放置在何处。 

1271
00:57:15,030 --> 00:57:18,230
您现在将它放到我们的大黄色中的任何地方， 

1272
00:57:18,230 --> 00:57:19,950
矩形，我们将接受下降。 

1273
00:57:19,950 --> 00:57:21,590
因此，我们暂时不会在位置上做任何事情。 

1274
00:57:21,590 --> 00:57:23,467
但最终我们要在上面放表情符号

1275
00:57:23,467 --> 00:57:26,910
然后我们会关心位置，但现在还不会。 

1276
00:57:26,910 --> 00:57:28,520
那么，我们在这里该做什么？ 

1277
00:57:28,520 --> 00:57:30,550
我们得到的这个功能应该是

1278
00:57:30,550 --> 00:57:33,600
返回放置是否成功。 

1279
00:57:33,600 --> 00:57:35,800
所以我要为此创建另一个小功能

1280
00:57:35,800 --> 00:57:38,663
跟提供者叫滴， 

1281
00:57:40,010 --> 00:57:41,858
将这些提供者传递过来。 

1282
00:57:41,858 --> 00:57:44,333
而且它将返回是否成功删除。 

1283
00:57:45,370 --> 00:57:46,830
所以，要做那件事。 

1284
00:57:46,830 --> 00:57:50,550
此处有一些私人功能，提供程序提供商。 

1285
00:57:50,550 --> 00:57:52,080
这些提供者是一个数组

1286
00:57:52,080 --> 00:57:54,990
正如我所说，是NSItemProvider。 

1287
00:57:54,990 --> 00:57:57,674
这件事，我不会讲这是什么。 

1288
00:57:57,674 --> 00:58:00,620
那里有点老的Objective-C东西。 

1289
00:58:00,620 --> 00:58:02,650
这将返回一个布尔值， 

1290
00:58:02,650 --> 00:58:05,390
删除是否成功。 

1291
00:58:05,390 --> 00:58:08,010
由于扩展少，我们在这里需要做的所有事情

1292
00:58:08,010 --> 00:58:12,530
我提供了尝试从这些提供商加载URL的方法， 

1293
00:58:12,530 --> 00:58:14,910
看看这些提供商是否可以为我提供实际的网址。 

1294
00:58:14,910 --> 00:58:16,980
我要的是图片，所以它们可能无法

1295
00:58:16,980 --> 00:58:18,950
但通常他们会这么做。 

1296
00:58:18,950 --> 00:58:23,340
所以我要让一个小变量找到相等的提供者

1297
00:58:23,340 --> 00:58:25,420
那是这些项目提供者的数组， 

1298
00:58:25,420 --> 00:58:27,480
加载第一个对象

1299
00:58:28,590 --> 00:58:29,593
网址类型。 

1300
00:58:31,940 --> 00:58:34,170
当您将type指定为参数时， 

1301
00:58:34,170 --> 00:58:38,070
您说的是URL.self，即实际的URL类型。 

1302
00:58:38,070 --> 00:58:42,050
这只是URL类型中的静态变量

1303
00:58:42,050 --> 00:58:44,539
返回类型本身。 

1304
00:58:44,539 --> 00:58:47,820
这适用于实例，也适用于类。 

1305
00:58:47,820 --> 00:58:48,840
所以我能够做到。 

1306
00:58:48,840 --> 00:58:51,730
然后它调用一个传递给您的小函数

1307
00:58:51,730 --> 00:58:54,500
它能够找到的URL。 

1308
00:58:54,500 --> 00:58:56,010
这只是它能够

1309
00:58:56,010 --> 00:58:58,280
加载第一个。 

1310
00:58:58,280 --> 00:59:02,330
现在我们要做的就是索取我们的文件， 

1311
00:59:02,330 --> 00:59:05,260
我们的ViewModel，请设置背景网址

1312
00:59:05,260 --> 00:59:07,710
这只是落在我身上的东西。 

1313
00:59:07,710 --> 00:59:08,810
为确保此方法有效， 

1314
00:59:08,810 --> 00:59:12,473
我要在这里实际打印掉的URL 

1315
00:59:13,980 --> 00:59:16,900
并打印掉掉的东西。 

1316
00:59:16,900 --> 00:59:18,720
这样就可以确保这滴东西

1317
00:59:18,720 --> 00:59:21,740
在去弄清楚之前实际上正在工作

1318
00:59:21,740 --> 00:59:23,673
如何显示此网址。 

1319
00:59:24,920 --> 00:59:25,980
所以我要退回找到的

1320
00:59:25,980 --> 00:59:27,310
下降是否有效， 

1321
00:59:27,310 --> 00:59:30,860
这就是loadFirstObject返回的结果是否有效。 

1322
00:59:30,860 --> 00:59:32,800
拖放就可以了。 （咯咯笑） 

1323
00:59:32,800 --> 00:59:36,110
实际上，拖放操作非常简单。 

1324
00:59:36,110 --> 00:59:38,450
复杂的地方在这里。 

1325
00:59:38,450 --> 00:59:41,690
如果您想了解拖放操作，我鼓励您

1326
00:59:41,690 --> 00:59:44,610
去看看是否可以找出该代码。 

1327
00:59:44,610 --> 00:59:46,100
因此，让我们运行，看看是否至少

1328
00:59:46,100 --> 00:59:47,663
使此打印得以实现。 

1329
00:59:51,842 --> 00:59:54,540
我们走了，所以我要拿起我们的图像，拖动。 

1330
00:59:54,540 --> 00:59:56,630
我已经看到了一些不同的地方。 

1331
00:59:56,630 --> 00:59:59,060
拐角处出现的绿色加号

1332
00:59:59,060 --> 01:00:01,420
的图像，很好，然后下降。 

1333
01:00:01,420 --> 01:00:03,610
而且它什么也没做

1334
01:00:03,610 --> 01:00:06,110
因为我们对网址不做任何事情。 

1335
01:00:06,110 --> 01:00:11,110
但是它确实在这里做了，在这里，说掉了这个URL 

1336
01:00:11,750 --> 01:00:13,170
实际上，这是这些网址之一

1337
01:00:13,170 --> 01:00:17,310
里面嵌入了这个奇怪的imgurl东西。 

1338
01:00:17,310 --> 01:00:20,020
看，这是那里的实际URL。 

1339
01:00:20,020 --> 01:00:22,240
所以，我们拖拉是件好事， 

1340
01:00:22,240 --> 01:00:25,247
将此东西拖出此处，否则将无法正常工作。 

1341
01:00:25,247 --> 01:00:26,080
但这很棒。 

1342
01:00:26,080 --> 01:00:28,440
所以我们有了这个URL，我们将其设置为文档的

1343
01:00:28,440 --> 01:00:32,250
ViewModel中的背景URL，setBackgroundURL， 

1344
01:00:32,250 --> 01:00:34,987
在我们这里的模型中设置

1345
01:00:34,987 --> 01:00:36,570
一切都很好。 

1346
01:00:36,570 --> 01:00:38,010
现在剩下要做的唯一一件事

1347
01:00:38,010 --> 01:00:40,908
实际上是显示该图像。 （咯咯笑） 

1348
01:00:40,908 --> 01:00:42,650
好吧，我们已经有了该图片的网址， 

1349
01:00:42,650 --> 01:00:45,200
但在我们这里没有视野

1350
01:00:45,200 --> 01:00:46,607
我们实际显示图像吗？ 

1351
01:00:46,607 --> 01:00:48,750
我们现在显示的只是一个矩形， 

1352
01:00:48,750 --> 01:00:50,890
边缘忽略掉了。 

1353
01:00:50,890 --> 01:00:53,453
那么我们该怎么做呢？ 

1354
01:00:53,453 --> 01:00:55,410
我们基本上需要通过替换来做到这一点

1355
01:00:55,410 --> 01:00:58,537
此Rectangle前景色为黄色。 

1356
01:00:58,537 --> 01:01:02,030
我将通过将其变为白色矩形来替换它。 

1357
01:01:02,030 --> 01:01:06,390
并叠加在其上将是一个图像

1358
01:01:06,390 --> 01:01:11,150
具有我们文档的backgroundImage。 

1359
01:01:11,150 --> 01:01:14,310
现在，这里的代码行有很多要解压的地方。 

1360
01:01:14,310 --> 01:01:17,020
因此，让我们一步一步地解压缩这是怎么回事

1361
01:01:17,020 --> 01:01:19,720
因为它实际上并不能按原样工作。 

1362
01:01:19,720 --> 01:01:22,840
首先是我拍了白色的长方形

1363
01:01:22,840 --> 01:01:25,640
然后将我的图片覆盖在上面

1364
01:01:25,640 --> 01:01:27,520
我为什么要这样做，为什么我不只是

1365
01:01:27,520 --> 01:01:29,650
在这里制作一个ZStack，对吗？ 

1366
01:01:29,650 --> 01:01:32,600
ZStack将一个视图覆盖在另一个视图之上。 

1367
01:01:32,600 --> 01:01:35,600
这与上浆有关

1368
01:01:35,600 --> 01:01:39,690
因为我们想要文档View或其他任何东西， 

1369
01:01:39,690 --> 01:01:43,390
像矩形一样大小。 

1370
01:01:43,390 --> 01:01:46,190
基本上，我们想使用提供给它的所有空间。 

1371
01:01:46,190 --> 01:01:48,950
我们知道Shapes占用了提供给他们的所有空间

1372
01:01:48,950 --> 01:01:50,320
这就是我们想要的。 

1373
01:01:50,320 --> 01:01:53,500
我们不希望它将其大小调整为图像

1374
01:01:53,500 --> 01:01:57,040
因为图片，这些视图，图片， 

1375
01:01:57,040 --> 01:02:00,210
他们调整自己到图像的大小。 

1376
01:02:00,210 --> 01:02:01,300
因此，如果您的图像很小， 

1377
01:02:01,300 --> 01:02:03,160
我们在那里会有一个小小的视图

1378
01:02:03,160 --> 01:02:05,110
我们希望它尽可能大。 

1379
01:02:05,110 --> 01:02:07,510
还有一种叫做背景的东西

1380
01:02:07,510 --> 01:02:09,360
做同样的事情。 

1381
01:02:09,360 --> 01:02:13,630
调整大小，然后在此处放置任何视图

1382
01:02:13,630 --> 01:02:15,880
作为其他图像的背景。 

1383
01:02:15,880 --> 01:02:17,210
因此，这一切都与调整大小有关。 

1384
01:02:17,210 --> 01:02:22,043
在这里使用叠加层或背景， 

1385
01:02:23,068 --> 01:02:26,043
就是您想要的上浆行为。 

1386
01:02:27,510 --> 01:02:28,440
好吧，否则这非常

1387
01:02:28,440 --> 01:02:31,433
本质上就像一个两视图ZStack。 

1388
01:02:34,180 --> 01:02:37,000
所以这里还不太正确。 

1389
01:02:37,000 --> 01:02:39,510
我们仍在努力解决这一问题。 

1390
01:02:39,510 --> 01:02:43,470
这个图片在这里，需要一些参数

1391
01:02:43,470 --> 01:02:46,670
应该是这张图片，backgroundImage， 

1392
01:02:46,670 --> 01:02:48,550
但是backgroundImage是什么？ 

1393
01:02:48,550 --> 01:02:51,910
我们的文档中没有backgroundImage。 

1394
01:02:51,910 --> 01:02:53,300
因此，我们添加一下。 

1395
01:02:53,300 --> 01:02:56,030
让我们过去吧，我要添加一个变量

1396
01:02:56,030 --> 01:03:00,420
backgroundImage以及它将是什么类型？ 

1397
01:03:00,420 --> 01:03:03,140
您可能认为这可能是图像类型

1398
01:03:03,140 --> 01:03:04,760
但这不是Image类型。 

1399
01:03:04,760 --> 01:03:06,770
我们正在这里创建图像视图。 

1400
01:03:06,770 --> 01:03:10,250
因此，此类型的Image是一个结构，它是一个View。 

1401
01:03:10,250 --> 01:03:13,580
真的，我们要传递给它的是实际图像。 

1402
01:03:13,580 --> 01:03:16,510
并呈现了SwiftUI中的实际图像

1403
01:03:16,510 --> 01:03:19,580
另一件事叫做UIImage。 

1404
01:03:19,580 --> 01:03:22,360
现在是UIImage，以UI开头的东西

1405
01:03:22,360 --> 01:03:27,200
来自旧世界，即以前的SwiftUI世界。 

1406
01:03:27,200 --> 01:03:30,220
这是一个很棒的小物件

1407
01:03:30,220 --> 01:03:33,160
为了处理图像，他们决定保留它。 

1408
01:03:33,160 --> 01:03:35,643
他们对UIColor做同样的事情。 

1409
01:03:35,643 --> 01:03:37,410
我们看到在那之前我们有了色彩。 

1410
01:03:37,410 --> 01:03:40,793
颜色有点像视图，但是UIColor是东西

1411
01:03:40,793 --> 01:03:43,420
实际上代表颜色。 

1412
01:03:43,420 --> 01:03:46,110
顺便说一句，我谈到了UIColor是一个View。 

1413
01:03:46,110 --> 01:03:49,310
UIColor也可以是此处的说明符， 

1414
01:03:49,310 --> 01:03:51,040
前景色Color.white。 

1415
01:03:51,040 --> 01:03:54,650
这不是一个视图，我们只是将颜色指定为白色。 

1416
01:03:54,650 --> 01:03:57,010
但是颜色可以像视图一样工作。 

1417
01:03:57,010 --> 01:03:59,617
我什至可以在这里说Color.white 

1418
01:03:59,617 --> 01:04:01,340
这是完全合法的。 （咯咯笑） 

1419
01:04:01,340 --> 01:04:02,803
这可以是一个视图，我们也知道

1420
01:04:02,803 --> 01:04:05,610
颜色可以是ShapeStyle， 

1421
01:04:05,610 --> 01:04:08,750
在形状中填充颜色或描边颜色。 

1422
01:04:08,750 --> 01:04:10,070
所以Color就像变色龙， 

1423
01:04:10,070 --> 01:04:12,640
可以有很多不同的东西。 

1424
01:04:12,640 --> 01:04:14,320
但是图像在这里是视图。 

1425
01:04:14,320 --> 01:04:18,180
我们可以说uiImage作为它的构造函数

1426
01:04:18,180 --> 01:04:21,550
并将其传递给UIImage，将生成图像。 

1427
01:04:21,550 --> 01:04:23,580
创建图像时我们经常这样做。 

1428
01:04:23,580 --> 01:04:25,920
我们将学习其他创建图片的方法， 

1429
01:04:25,920 --> 01:04:29,370
但是一种方法是我们只将其传递给UIImage。 

1430
01:04:30,385 --> 01:04:32,370
现在这也不起作用

1431
01:04:32,370 --> 01:04:36,020
那是因为这不是真的想要

1432
01:04:36,020 --> 01:04:39,003
作为一个UIImage，它是一个可选的UIImage。 

1433
01:04:39,950 --> 01:04:42,210
同样，因为我们可能没有背景。 

1434
01:04:42,210 --> 01:04:44,790
即使有URL，也可能没有

1435
01:04:44,790 --> 01:04:46,680
并得到了图像。 

1436
01:04:46,680 --> 01:04:49,340
因此，这必须为零。 

1437
01:04:49,340 --> 01:04:50,460
这里另一个重要的事情

1438
01:04:50,460 --> 01:04:52,260
是我要将此设置为私人设置吗？ 

1439
01:04:52,260 --> 01:04:55,860
只有我们的ViewModel会获取图像

1440
01:04:55,860 --> 01:04:56,930
来自网络。 

1441
01:04:56,930 --> 01:05:00,630
我们的视图将仅查看到达的图像

1442
01:05:00,630 --> 01:05:01,623
来自网络。 

1443
01:05:02,760 --> 01:05:04,550
好吧，这样我们的视图就可以了， 

1444
01:05:04,550 --> 01:05:08,550
它设置了backgroundURL，然后是我们的ViewModel 

1445
01:05:08,550 --> 01:05:09,900
那将不得不离开

1446
01:05:09,900 --> 01:05:12,690
并创建此背景图片。 

1447
01:05:12,690 --> 01:05:15,960
因此，这会带来一个问题，使其成为可选项

1448
01:05:15,960 --> 01:05:19,030
因为此Image uiImage构造函数

1449
01:05:19,030 --> 01:05:20,520
不会选择。 

1450
01:05:20,520 --> 01:05:22,970
这必须是非可选的。 

1451
01:05:22,970 --> 01:05:25,150
所以有点让我想进去

1452
01:05:25,150 --> 01:05:26,567
然后说：“是的，我只需要说

1453
01:05:26,567 --> 01:05:29,530
“如果self.document.backgroundImage 

1454
01:05:31,067 --> 01:05:36,067
“不等于nil，那么我将在此处创建此图像

1455
01:05:36,527 --> 01:05:38,900
“我会强迫拆开它的。” 

1456
01:05:38,900 --> 01:05:42,090
看起来像这样，哦，应该可以

1457
01:05:42,090 --> 01:05:44,710
唯一的问题是重叠的参数

1458
01:05:44,710 --> 01:05:47,750
有点不同寻常的不是ViewBuilder。 

1459
01:05:47,750 --> 01:05:49,530
这个没有花括号

1460
01:05:49,530 --> 01:05:50,690
那里没有大括号。 

1461
01:05:50,690 --> 01:05:54,030
这是一个实际的视图，必须是一个视图。 

1462
01:05:54,030 --> 01:05:55,610
而且我们不能在这里。 

1463
01:05:55,610 --> 01:05:57,160
这应该是一个视图。 

1464
01:05:57,160 --> 01:05:59,330
这是一个if语句，而不是View。 

1465
01:05:59,330 --> 01:06:02,700
因此，如果我们想在这里做一些漂亮的ViewBuilder， 

1466
01:06:02,700 --> 01:06:07,010
我们需要把它包装在做ViewBuilder的东西中

1467
01:06:07,010 --> 01:06:09,700
而这正是Group真正擅长的。 

1468
01:06:09,700 --> 01:06:12,230
因此，如果您发现自己必须在某个地方传递视图， 

1469
01:06:12,230 --> 01:06:14,610
但是您需要围绕它开展业务

1470
01:06:14,610 --> 01:06:16,210
继续使用组，因为组

1471
01:06:16,210 --> 01:06:19,440
否则不会修改布局或其他任何内容

1472
01:06:19,440 --> 01:06:23,093
该视图，因此使用Group是一个不错的小技巧。 

1473
01:06:24,490 --> 01:06:25,570
好的，很好。 

1474
01:06:25,570 --> 01:06:28,618
所以一切都很好，没有错误， 

1475
01:06:28,618 --> 01:06:29,490
（咯咯笑）编译的所有内容。 

1476
01:06:29,490 --> 01:06:32,860
唯一的问题是，这总是总是零。 

1477
01:06:32,860 --> 01:06:34,780
我们从来没有设置任何东西。 

1478
01:06:34,780 --> 01:06:37,570
我们的ViewModel将采用此URL 

1479
01:06:37,570 --> 01:06:39,530
并在互联网上获取它。 

1480
01:06:39,530 --> 01:06:42,320
当它获取实际图像并制作UIImage时

1481
01:06:42,320 --> 01:06:44,760
从互联网上找到的任何东西

1482
01:06:44,760 --> 01:06:47,440
那么它将自动在我们的视图中绘制。 

1483
01:06:47,440 --> 01:06:52,223
只要我们使此backgroundImage也发布。 

1484
01:06:53,170 --> 01:06:55,570
我们需要发布它，以便每当发生变化时， 

1485
01:06:55,570 --> 01:06:59,510
我们的观点导致重画，这整个事情都会发生， 

1486
01:06:59,510 --> 01:07:02,410
该叠加层将发生变化，我们将看到该图像。 

1487
01:07:03,550 --> 01:07:05,790
特别是在执行ViewModel时， 

1488
01:07:05,790 --> 01:07:07,667
很容易记住，“哦，是的， 

1489
01:07:07,667 --> 01:07:10,250
“我的模型已发布。” 

1490
01:07:10,250 --> 01:07:12,930
但是您的ViewModel可能还有其他东西

1491
01:07:12,930 --> 01:07:15,920
就是要您的视图做出反应。 

1492
01:07:15,920 --> 01:07:18,950
我们只需使用@Published即可。 

1493
01:07:18,950 --> 01:07:23,000
现在确实有一些方法，今天的演讲内容（咯咯笑） 

1494
01:07:23,000 --> 01:07:26,060
我们将如何获取此backgroundImage 

1495
01:07:26,060 --> 01:07:29,900
并从此URL创建一个UIImage？ 

1496
01:07:29,900 --> 01:07:32,060
我们将通过自己的小功能来实现。 

1497
01:07:32,060 --> 01:07:33,930
我要叫这个功能

1498
01:07:34,807 --> 01:07:36,890
fetchBackgroundImageData。 

1499
01:07:40,225 --> 01:07:42,340
它会去获取背景图像数据

1500
01:07:42,340 --> 01:07:44,820
并制作一个UIImage。 

1501
01:07:44,820 --> 01:07:45,653
因此，让我们创建一个小功能， 

1502
01:07:45,653 --> 01:07:47,760
这是一个私人的小功能。 

1503
01:07:47,760 --> 01:07:51,400
该函数的唯一工作是设置此变量。 

1504
01:07:51,400 --> 01:07:54,490
一旦将这个var设置为它获取的某个UIImage 

1505
01:07:54,490 --> 01:07:57,930
从这个URL，所有内容都会更新，对。 

1506
01:07:57,930 --> 01:08:02,240
我们有反应式用户界面，我们已经构建了用户界面

1507
01:08:02,240 --> 01:08:03,460
处理这个图像。 

1508
01:08:03,460 --> 01:08:06,450
因此，一旦我们设置了它，所有这些都应该会自动发生。 

1509
01:08:06,450 --> 01:08:08,590
所以我们的目标就在这里（笑） 

1510
01:08:08,590 --> 01:08:11,563
是只做一件事，又要做一件事，请设置此变量。 

1511
01:08:13,508 --> 01:08:15,750
好吧，那我们要怎么做呢？ 

1512
01:08:15,750 --> 01:08:18,290
好吧，第一件事是，如果您要我去取货

1513
01:08:18,290 --> 01:08:19,830
背景图像数据， 

1514
01:08:19,830 --> 01:08:24,390
我将当前的backgroundImage设置为nil。 

1515
01:08:24,390 --> 01:08:26,560
所以我正在上网

1516
01:08:26,560 --> 01:08:27,860
并得到一些东西。 

1517
01:08:27,860 --> 01:08:29,230
这可能需要一段时间。 

1518
01:08:29,230 --> 01:08:31,910
也许是一个大形象，或者是它所在的服务器

1519
01:08:31,910 --> 01:08:33,010
真的很慢

1520
01:08:33,010 --> 01:08:35,140
所以与此同时，我要清除backgroundImage 

1521
01:08:35,140 --> 01:08:37,500
只是让你知道，是的，我知道你变了

1522
01:08:37,500 --> 01:08:39,257
backgroundImage，您在我身上放了一些东西。 

1523
01:08:39,257 --> 01:08:40,633
我正在努力。 

1524
01:08:41,700 --> 01:08:44,140
真的，我们要做的就是提供一些UI 

1525
01:08:45,030 --> 01:08:47,030
提供一些我们正在努力的反馈。 

1526
01:08:47,030 --> 01:08:50,530
也许我们会在时间允许的情况下实际进行演示。 

1527
01:08:50,530 --> 01:08:53,010
但是我们绝对需要提供一些反馈

1528
01:08:53,010 --> 01:08:56,100
是的，“是的，我们看到了这种情况，我们正在努力。” 

1529
01:08:56,100 --> 01:08:59,960
就是这样，然后如果删除的URL 

1530
01:08:59,960 --> 01:09:04,790
现在是这个emojiArt.backgroundURL， 

1531
01:09:04,790 --> 01:09:08,090
如果没有，那就没有必要去获取任何东西。 

1532
01:09:08,090 --> 01:09:10,500
所以我要把这个放在URL周围

1533
01:09:10,500 --> 01:09:12,280
这样我只做任何提取

1534
01:09:12,280 --> 01:09:14,090
如果我真的在互联网上（笑） 

1535
01:09:14,090 --> 01:09:16,290
有一个URL去寻找。 

1536
01:09:16,290 --> 01:09:20,810
因此，从URL提取信息非常简单。 

1537
01:09:20,810 --> 01:09:23,540
有一个更复杂的机制可以做到这一点。 

1538
01:09:23,540 --> 01:09:24,800
我们要做最简单的一个

1539
01:09:24,800 --> 01:09:26,390
因为我们只专注于

1540
01:09:26,390 --> 01:09:29,490
在这里进行的异步编程上。 

1541
01:09:29,490 --> 01:09:31,740
但是，如果您真的要下载东西

1542
01:09:31,740 --> 01:09:35,060
从互联网上，您将使用URLSession。 

1543
01:09:35,060 --> 01:09:38,100
而且我不会谈论整个URLSession API 

1544
01:09:38,100 --> 01:09:40,360
但实际上，这只是基于闭包的API。 

1545
01:09:40,360 --> 01:09:43,410
您将闭包传递给它，然后它就会下载内容。 

1546
01:09:43,410 --> 01:09:46,160
下载回来时，它会叫您关闭

1547
01:09:46,160 --> 01:09:49,680
否则会在发生错误时调用其他闭包。 

1548
01:09:49,680 --> 01:09:51,840
但是获取数据的一种简单方法就是说

1549
01:09:51,840 --> 01:09:56,840
如果让imageData相等，请尝试获取数据

1550
01:09:56,860 --> 01:09:59,103
从该URL的内容。 

1551
01:10:00,220 --> 01:10:03,480
这些数据只是一个对象，一个结构， 

1552
01:10:03,480 --> 01:10:06,210
它有一个初始化器，在其中您可以给它一个URL 

1553
01:10:06,210 --> 01:10:07,940
它会在互联网上消失

1554
01:10:07,940 --> 01:10:11,200
并从该URL获取数据并返回。 

1555
01:10:11,200 --> 01:10:14,210
这可能会遇到各种错误： 

1556
01:10:14,210 --> 01:10:17,670
互联网超时，各种各样的事情正在发生。 

1557
01:10:17,670 --> 01:10:19,730
这就是为什么我们必须这样做。 

1558
01:10:19,730 --> 01:10:21,550
在下周的阅读作业中

1559
01:10:21,550 --> 01:10:24,030
您将了解有关尝试并引发错误的信息。 

1560
01:10:24,030 --> 01:10:26,080
我今天不谈论这个， 

1561
01:10:26,080 --> 01:10:28,840
但只知道有一些构造函数

1562
01:10:28,840 --> 01:10:31,170
所调用的函数以及所调用的一些函数

1563
01:10:31,170 --> 01:10:32,850
必须尝试一下。 

1564
01:10:32,850 --> 01:10:35,270
当您尝试使用问号时， 

1565
01:10:35,270 --> 01:10:38,500
表示尝试此操作，如果失败，（咯咯笑） 

1566
01:10:38,500 --> 01:10:40,880
网络超时，无论如何，只返回nil。 

1567
01:10:40,880 --> 01:10:42,390
既然我在做， 

1568
01:10:42,390 --> 01:10:45,173
如果失败，这里的代码将不会执行。 

1569
01:10:46,450 --> 01:10:49,720
现在这行代码存在很大的问题。 

1570
01:10:49,720 --> 01:10:53,740
这可能需要10秒钟或2分钟

1571
01:10:53,740 --> 01:10:55,610
取决于超时时间。 

1572
01:10:55,610 --> 01:10:57,640
当然可能要花至少半秒钟

1573
01:10:57,640 --> 01:11:00,790
一秒钟，在那段时间内我的整个应用

1574
01:11:00,790 --> 01:11:04,180
被困在等待这一行代码（轻笑）执行

1575
01:11:04,180 --> 01:11:06,410
那就是摩擦。 

1576
01:11:06,410 --> 01:11:08,480
我们永远不允许发生。 

1577
01:11:08,480 --> 01:11:12,550
我们永远不能调用这样的函数来阻塞我们的代码

1578
01:11:12,550 --> 01:11:13,640
等待它返回

1579
01:11:13,640 --> 01:11:15,840
因为这样做可能需要几秒钟。 

1580
01:11:15,840 --> 01:11:19,820
永远不要在同一执行线程中调用它

1581
01:11:19,820 --> 01:11:22,750
当我们所有的UI都在发生时，否则我们的应用

1582
01:11:22,750 --> 01:11:25,200
将冻结，用户将点击

1583
01:11:25,200 --> 01:11:27,070
并尝试输入新内容， 

1584
01:11:27,070 --> 01:11:29,760
而且，“我，我不想要该URL，它花费的时间太长。” 

1585
01:11:29,760 --> 01:11:30,593
不，他们什么也不能做。 

1586
01:11:30,593 --> 01:11:33,340
我们的应用程序甚至无法在顶部滚动其表情符号。 

1587
01:11:33,340 --> 01:11:36,130
都冻结了，因为我们的应用程序就在这里

1588
01:11:36,130 --> 01:11:39,323
在这行代码上持续10秒，15秒等等。 

1589
01:11:40,460 --> 01:11:41,870
那么我们如何解决呢？ 

1590
01:11:41,870 --> 01:11:43,670
我们使用幻灯片中讨论的内容， 

1591
01:11:43,670 --> 01:11:45,240
调度机制。 

1592
01:11:45,240 --> 01:11:50,240
因此，我将将此代码分派到全局队列。 

1593
01:11:50,377 --> 01:11:52,670
还有我想要的服务质量

1594
01:11:52,670 --> 01:11:54,890
称为userInitiated。 

1595
01:11:54,890 --> 01:11:57,810
请记住，有这些不同的服务质量。 

1596
01:11:57,810 --> 01:12:00,090
我想要userInitiated，因为那正是发生的情况。 

1597
01:12:00,090 --> 01:12:02,450
用户在这里发起了一个请求。 

1598
01:12:02,450 --> 01:12:04,940
这样一来，您所看到的， 

1599
01:12:04,940 --> 01:12:08,723
这个DispatchQueue.global，它给了我一个全局队列， 

1600
01:12:08,723 --> 01:12:11,280
一个在主队列之外执行其代码的队列， 

1601
01:12:11,280 --> 01:12:12,730
而不是UI所在的位置。 

1602
01:12:12,730 --> 01:12:15,410
我要异步地问

1603
01:12:15,410 --> 01:12:17,480
执行此功能。 

1604
01:12:17,480 --> 01:12:19,500
此函数不带参数，不返回参数。 

1605
01:12:19,500 --> 01:12:23,450
我只是问它请执行此功能

1606
01:12:23,450 --> 01:12:25,780
不管队列是什么， 

1607
01:12:25,780 --> 01:12:30,010
我不会和你有任何关系，只管去做。 

1608
01:12:30,010 --> 01:12:32,393
所以我现在要把它放在这里。 

1609
01:12:33,257 --> 01:12:35,490
这很棒，因为现在这仍然无法解决， 

1610
01:12:35,490 --> 01:12:39,160
仍然需要五秒钟，但是在某些后台队列中关闭了， 

1611
01:12:39,160 --> 01:12:41,147
不在所有代码所在的队列中

1612
01:12:41,147 --> 01:12:43,633
因为我们的UI正在执行。 

1613
01:12:44,800 --> 01:12:45,633
太好了。 

1614
01:12:45,633 --> 01:12:47,530
现在说，imageData回来了。 

1615
01:12:47,530 --> 01:12:48,900
您知道，假设没有错误

1616
01:12:48,900 --> 01:12:51,400
因此，尝试不返回nil。 

1617
01:12:51,400 --> 01:12:53,190
现在我有了imageData！ 

1618
01:12:53,190 --> 01:12:55,390
是JPEG数据或PNG数据

1619
01:12:55,390 --> 01:12:58,020
或来自互联网的某种数据。 

1620
01:12:58,020 --> 01:13:00,420
我需要将其转换为UIImage 

1621
01:13:00,420 --> 01:13:01,730
因为这就是我要在这里做的

1622
01:13:01,730 --> 01:13:03,650
是在这里制作此UIImage。 

1623
01:13:03,650 --> 01:13:06,100
幸运的是，UIImage有一个很棒的方法。 

1624
01:13:06,100 --> 01:13:10,820
我只能说backgroundImage等于UIImage 

1625
01:13:10,820 --> 01:13:12,313
与此数据。 

1626
01:13:13,240 --> 01:13:15,790
这行代码有一个巨大的问题，好的。 

1627
01:13:15,790 --> 01:13:18,260
就像这行代码是被阻止的问题一样

1628
01:13:18,260 --> 01:13:20,490
我们通过放置后台队列来解决此问题。 

1629
01:13:20,490 --> 01:13:23,240
这个有一个很大的问题是

1630
01:13:23,240 --> 01:13:25,360
将要设置此backgroundImage 

1631
01:13:25,360 --> 01:13:28,670
这会导致这种发布发生在这里， 

1632
01:13:28,670 --> 01:13:32,760
这将导致我们在此处的视图重绘

1633
01:13:32,760 --> 01:13:36,010
这意味着UI将会发生

1634
01:13:36,010 --> 01:13:38,940
在后台线程上。 

1635
01:13:38,940 --> 01:13:41,177
那是绝对不允许的

1636
01:13:41,177 --> 01:13:43,030
实际上，当您这样做时， 

1637
01:13:43,030 --> 01:13:45,140
您的应用将开始变得有趣， 

1638
01:13:45,140 --> 01:13:47,810
甚至可能崩溃。 

1639
01:13:47,810 --> 01:13:50,210
而且你会在这里得到一些紫色的警告

1640
01:13:50,210 --> 01:13:52,287
当您在Xcode中运行您的应用程序时， 

1641
01:13:52,287 --> 01:13:54,720
“啊，你在主要队列之外画了一些东西！” 

1642
01:13:54,720 --> 01:13:56,890
所以我们永远不能做这样的事情， 

1643
01:13:56,890 --> 01:14:00,330
会导致绘图发生的一行代码

1644
01:14:00,330 --> 01:14:03,260
在非主线程上。 

1645
01:14:03,260 --> 01:14:05,410
那么我们如何将其放回到主线程上呢？ 

1646
01:14:05,410 --> 01:14:07,810
我们使用与放置此代码完全相同的方式进行操作

1647
01:14:07,810 --> 01:14:10,360
最初在此线程上。 

1648
01:14:10,360 --> 01:14:12,060
但是我们要穿上它而不是

1649
01:14:12,060 --> 01:14:15,500
后台用户启动的服务质量线程， 

1650
01:14:15,500 --> 01:14:19,110
我们要放这个DispatchQueue.main。 

1651
01:14:19,110 --> 01:14:20,210
所以这将是同一件事。 

1652
01:14:20,210 --> 01:14:24,810
我将异步发布一些函数关闭

1653
01:14:24,810 --> 01:14:27,530
进入主队列并说去做。 

1654
01:14:27,530 --> 01:14:30,370
现在异步发布内容

1655
01:14:30,370 --> 01:14:32,240
基本上意味着它进入队列， 

1656
01:14:32,240 --> 01:14:34,480
这就是为什么我们将这些队列称为运行。 

1657
01:14:34,480 --> 01:14:36,300
可能还有其他线程

1658
01:14:36,300 --> 01:14:39,600
发布这些小功能片段

1659
01:14:39,600 --> 01:14:41,172
在主队列上运行。 

1660
01:14:41,172 --> 01:14:42,380
所以这个家伙可能必须排队

1661
01:14:42,380 --> 01:14:43,710
如果有其他事情发生。 

1662
01:14:43,710 --> 01:14:45,830
实际上，其中之一可能正在执行。 

1663
01:14:45,830 --> 01:14:49,120
用户只是触摸了某些东西或滚动了他们的表情符号

1664
01:14:49,120 --> 01:14:51,720
在顶部，所以主队列很忙。 

1665
01:14:51,720 --> 01:14:53,810
但是当它安顿下来时，它并不忙， 

1666
01:14:53,810 --> 01:14:56,280
它将开始处理其请求队列

1667
01:14:56,280 --> 01:14:58,723
最终它将执行此操作。 

1668
01:14:59,610 --> 01:15:02,220
这真的就是全部

1669
01:15:02,220 --> 01:15:03,750
这个多线程编程

1670
01:15:03,750 --> 01:15:08,750
看起来真的很简单，确实如此。 

1671
01:15:09,400 --> 01:15:10,890
但这会给您带来一些麻烦

1672
01:15:10,890 --> 01:15:12,833
正如我将在稍后解释的那样。 

1673
01:15:14,280 --> 01:15:16,210
但这应该足够了，对。 

1674
01:15:16,210 --> 01:15:17,660
我们做了我们说过要做的事

1675
01:15:17,660 --> 01:15:19,284
在此fetchBackgroundImageData中

1676
01:15:19,284 --> 01:15:21,930
我们是否将backgroundImage设置为UIImage 

1677
01:15:21,930 --> 01:15:23,040
从获取该数据。 

1678
01:15:23,040 --> 01:15:24,340
因此，让我们来看一下它的作用。 

1679
01:15:27,880 --> 01:15:29,687
好吧，我们开始吧，去接这个人。 

1680
01:15:29,687 --> 01:15:32,380
我们拖他，他变成绿色了，很好， 

1681
01:15:32,380 --> 01:15:34,820
去这里放！ 

1682
01:15:34,820 --> 01:15:37,870
啊，哇，行得通！ 

1683
01:15:37,870 --> 01:15:39,440
现在略有延迟。 

1684
01:15:39,440 --> 01:15:40,310
我不知道你是否注意到了。 

1685
01:15:40,310 --> 01:15:42,620
我们放下它，花了大约半秒钟

1686
01:15:42,620 --> 01:15:44,340
绘制此图像。 

1687
01:15:44,340 --> 01:15:46,640
在那半秒钟内，它刚过去

1688
01:15:46,640 --> 01:15:48,930
互联网到这个网站

1689
01:15:48,930 --> 01:15:51,043
并把那个图像拉过来。 

1690
01:15:52,040 --> 01:15:53,410
让我们谈一点

1691
01:15:53,410 --> 01:15:56,060
关于这些异步的事情

1692
01:15:56,060 --> 01:15:57,940
以及为什么它并不总是那么简单

1693
01:15:57,940 --> 01:15:59,220
如您所想。 

1694
01:15:59,220 --> 01:16:02,430
我要描述一种情况

1695
01:16:02,430 --> 01:16:05,693
您会看到为什么这段代码实际上不太正确。 

1696
01:16:06,640 --> 01:16:09,530
假设我拖放了一张图片

1697
01:16:09,530 --> 01:16:13,740
从一台非常慢的服务器上，这将花费15秒。 

1698
01:16:13,740 --> 01:16:15,290
大约三到四秒钟后

1699
01:16:15,290 --> 01:16:16,977
作为用户，我想，“啊，我厌倦了等待

1700
01:16:16,977 --> 01:16:20,090
“针对该图像”，然后转到另一台快速服务器， 

1701
01:16:20,090 --> 01:16:21,890
然后将新东西拖进去

1702
01:16:21,890 --> 01:16:24,070
当然，快速服务器可以立即为您提供服务， 

1703
01:16:24,070 --> 01:16:25,227
并把它显示出来

1704
01:16:25,227 --> 01:16:28,330
所以现在它正在显示，也许您继续

1705
01:16:28,330 --> 01:16:30,840
然后您会说：“啊，我要在其中添加一些表情符号” 

1706
01:16:30,840 --> 01:16:33,830
然后另一个终于回来了。 

1707
01:16:33,830 --> 01:16:37,790
然后它会做什么，繁荣，重置您的背景图像。 

1708
01:16:37,790 --> 01:16:40,150
因此，这对于用户而言确实是出乎意料的。 

1709
01:16:40,150 --> 01:16:41,500
我拖了一些东西。 

1710
01:16:41,500 --> 01:16:43,480
我认为它失败了，因为它花费了太长时间。 

1711
01:16:43,480 --> 01:16:44,610
所以我拖了其他东西。 

1712
01:16:44,610 --> 01:16:47,140
很快，就到了，然后10秒钟后， 

1713
01:16:47,140 --> 01:16:49,000
繁荣，老东西进来了。 

1714
01:16:49,000 --> 01:16:52,010
这样我们永远都不会发生。 

1715
01:16:52,010 --> 01:16:54,520
现在很容易防范

1716
01:16:54,520 --> 01:16:56,270
就在我回到这里的时候

1717
01:16:56,270 --> 01:16:58,400
设置这个backgroundImage，我要确保

1718
01:16:58,400 --> 01:17:02,103
我得到的该数据是用于后台URL的

1719
01:17:02,103 --> 01:17:03,440
用户仍然想要的。 

1720
01:17:03,440 --> 01:17:05,800
我们可以在这里说出网址是否

1721
01:17:06,729 --> 01:17:08,870
我刚刚获取的，对，就是这个URL 

1722
01:17:08,870 --> 01:17:10,820
我就在这里。 

1723
01:17:10,820 --> 01:17:13,747
如果等于EmojiArt的

1724
01:17:15,790 --> 01:17:19,750
backgroundURL，然后继续进行加载。 

1725
01:17:19,750 --> 01:17:22,000
但是如果我得到的是其他URL 

1726
01:17:22,000 --> 01:17:24,750
15秒钟前，（咯咯笑）然后我什么也没做。 

1727
01:17:24,750 --> 01:17:25,740
我会忽略它。 

1728
01:17:25,740 --> 01:17:27,570
我还是拿来了，还是到了， 

1729
01:17:27,570 --> 01:17:30,180
但我不会浪费我的时间来制作图像

1730
01:17:30,180 --> 01:17:33,200
并且肯定不会在用户面前大放异彩。 

1731
01:17:33,200 --> 01:17:36,343
所以这是次要的事情， 

1732
01:17:36,343 --> 01:17:38,210
这是您必须具备的能力

1733
01:17:38,210 --> 01:17:40,400
预防和注意

1734
01:17:40,400 --> 01:17:42,260
当您进行异步编程时。 

1735
01:17:42,260 --> 01:17:44,640
您不能只是盲目地来回发布

1736
01:17:44,640 --> 01:17:47,460
并没有考虑如果这样的事情怎么办

1737
01:17:47,460 --> 01:17:51,053
需要很长时间，然后又是另一个。 

1738
01:17:52,040 --> 01:17:54,840
确保没有破坏任何东西，我确定不会破坏。 

1739
01:17:56,900 --> 01:17:58,470
将我们的图像拖到此处。 

1740
01:17:58,470 --> 01:18:00,850
糟糕，运作良好。 

1741
01:18:00,850 --> 01:18:02,400
现在我们的形象在这里发挥了作用， 

1742
01:18:02,400 --> 01:18:04,780
让我们做，以便我们可以捡起来

1743
01:18:04,780 --> 01:18:07,940
并将其拖到此处，将我们的表情符号拖到此处。 

1744
01:18:07,940 --> 01:18:12,840
都是为了做到这一点，所以我们可以删除一些文本

1745
01:18:12,840 --> 01:18:16,080
在我们这里的视图上，但我们也必须做到

1746
01:18:16,080 --> 01:18:17,700
所以这些东西是可拖动的

1747
01:18:17,700 --> 01:18:20,710
这样我们就可以对此进行拖放。 

1748
01:18:20,710 --> 01:18:22,640
所以让我们先做它的缺点

1749
01:18:22,640 --> 01:18:24,290
因为我们已经知道如何丢弃

1750
01:18:24,290 --> 01:18:28,433
而且实际上删除表情符号也很容易。 

1751
01:18:30,540 --> 01:18:33,340
在我们的视图中，这里是onDrop。 

1752
01:18:33,340 --> 01:18:35,360
现在onDrop只允许您放下图像

1753
01:18:35,360 --> 01:18:36,230
为背景。 

1754
01:18:36,230 --> 01:18:39,870
现在我要做到这一点，以便onDrop也可以删除文本

1755
01:18:39,870 --> 01:18:42,430
因为我们的表情只是文字的小片段。 

1756
01:18:42,430 --> 01:18:45,600
因此public.text是Text的URI。 

1757
01:18:45,600 --> 01:18:48,520
现在在这种情况下，我确实需要位置。 

1758
01:18:48,520 --> 01:18:50,570
如果您放下表情符号，我需要

1759
01:18:50,570 --> 01:18:53,570
让我们在此摆脱该URL打印。 

1760
01:18:53,570 --> 01:18:55,960
在这种情况下，我确实需要位置。 

1761
01:18:55,960 --> 01:18:56,880
因此，我们将不得不这样做。 

1762
01:18:56,880 --> 01:19:00,300
现在我们放下时在此处提供的位置

1763
01:19:00,300 --> 01:19:02,000
我认为这实际上是一个错误。 

1764
01:19:02,000 --> 01:19:05,000
但目前在全球坐标系中

1765
01:19:05,000 --> 01:19:08,290
基本上整个设备的坐标系。 

1766
01:19:08,290 --> 01:19:11,730
不是我们这个小小的坐标系， 

1767
01:19:11,730 --> 01:19:14,160
你知道的，在这里加一个图像， 

1768
01:19:14,160 --> 01:19:15,410
这对我们不利。 

1769
01:19:15,410 --> 01:19:17,540
我们需要对其进行转换。 

1770
01:19:17,540 --> 01:19:21,970
所以我为GeometryReader提供了一些扩展

1771
01:19:21,970 --> 01:19:24,800
就在这里，GeometryProxy，可以转换

1772
01:19:24,800 --> 01:19:26,860
从某个坐标空间开始，我们将使用

1773
01:19:26,860 --> 01:19:29,800
这个小功能可以转换这个位置

1774
01:19:29,800 --> 01:19:32,380
从全局坐标那里得到的

1775
01:19:32,380 --> 01:19:34,520
到我们视图的坐标系。 

1776
01:19:34,520 --> 01:19:35,610
很简单，我要创建

1777
01:19:35,610 --> 01:19:37,470
这里有一个小var位置。 

1778
01:19:37,470 --> 01:19:40,220
我将使用GeometryProxy的东西

1779
01:19:40,220 --> 01:19:43,540
我刚告诉你要转换位置

1780
01:19:43,540 --> 01:19:46,500
是从全球获得的。 

1781
01:19:46,500 --> 01:19:50,150
因此，这是从全局坐标转换此位置。 

1782
01:19:50,150 --> 01:19:52,000
现在，我需要执行另一项转换。 

1783
01:19:52,000 --> 01:19:55,400
此位置在iOS坐标系中。 

1784
01:19:55,400 --> 01:19:57,500
还记得iOS坐标系吗？ 

1785
01:19:57,500 --> 01:20:00,030
它的左上角是（0，0）。 

1786
01:20:00,030 --> 01:20:03,610
我的EmojiArt，我要有X和Y 

1787
01:20:03,610 --> 01:20:06,413
从中心偏移。 

1788
01:20:07,360 --> 01:20:10,440
不仅要与众不同，而且我实际上认为这更容易

1789
01:20:10,440 --> 01:20:12,130
以这种方式存储它。 

1790
01:20:12,130 --> 01:20:15,310
因此，我们需要从iOS坐标转换， 

1791
01:20:15,310 --> 01:20:18,190
零，左上角的零，到此坐标， 

1792
01:20:18,190 --> 01:20:19,593
零，中间零。 

1793
01:20:21,500 --> 01:20:25,513
我们的位置等于CGPoint 

1794
01:20:26,900 --> 01:20:29,810
X是您在iOS坐标中给我们的位置

1795
01:20:29,810 --> 01:20:33,380
但减去GeometryReader的

1796
01:20:33,380 --> 01:20:35,650
代理大小。宽度除以二， 

1797
01:20:35,650 --> 01:20:38,700
Y是您在Y中给我们的位置

1798
01:20:38,700 --> 01:20:43,700
减去几何尺寸size.height除以2。 

1799
01:20:45,240 --> 01:20:47,960
现在在这里我都使用我的GeometryReader 

1800
01:20:47,960 --> 01:20:50,370
在这里转换和我的GeometryReader 

1801
01:20:50,370 --> 01:20:51,930
从全球转换。 

1802
01:20:51,930 --> 01:20:54,720
因此，我显然需要在这里使用我的GeometryReader。 

1803
01:20:54,720 --> 01:20:59,093
因此，让我们将GeometryReader放在这周围。 

1804
01:21:00,620 --> 01:21:02,170
然后我们要做的最后一件事

1805
01:21:02,170 --> 01:21:05,660
有这个丢弃处理程序不仅可以使用提供程序

1806
01:21:05,660 --> 01:21:09,060
但它也需要采取地点。 

1807
01:21:09,060 --> 01:21:11,810
因此，让我们增强此放置位置的位置， 

1808
01:21:11,810 --> 01:21:14,263
CGPoint所在位置的逗号。 

1809
01:21:15,960 --> 01:21:17,700
现在在这里，我正在寻找

1810
01:21:17,700 --> 01:21:19,350
将第一个对象作为URL。 

1811
01:21:20,270 --> 01:21:24,370
所以如果我找不到，如果找不到

1812
01:21:24,370 --> 01:21:28,550
那我去看看是否等于提供者

1813
01:21:28,550 --> 01:21:33,550
加载String.self类型的对象。 

1814
01:21:34,110 --> 01:21:37,530
所以我在这里加载Type URL的第一个对象， 

1815
01:21:37,530 --> 01:21:40,530
在这里，我正在加载所有类型为String的对象。 

1816
01:21:40,530 --> 01:21:43,730
这里有一点争论

1817
01:21:43,730 --> 01:21:47,140
这是字符串。 

1818
01:21:47,140 --> 01:21:48,890
这就是这个小功能

1819
01:21:48,890 --> 01:21:51,257
对于在那里找到的所有字符串。 

1820
01:21:51,257 --> 01:21:53,160
我要假设我所有的琴弦都是表情符号。 

1821
01:21:53,160 --> 01:21:54,780
现在这确实意味着我可以拖动

1822
01:21:54,780 --> 01:21:57,790
一个非表情符号的字符串（咯咯笑）， 

1823
01:21:57,790 --> 01:21:59,643
它会起作用，但是没关系。 

1824
01:22:00,650 --> 01:22:02,260
所以在这里我想做什么？ 

1825
01:22:02,260 --> 01:22:05,120
如果发生这种情况，我将在这里使用我的意图， 

1826
01:22:05,120 --> 01:22:09,610
这个document.addEmoji和表情符号是String 

1827
01:22:09,610 --> 01:22:12,090
那落在我身上，关键是位置

1828
01:22:12,090 --> 01:22:13,477
它被丢弃在。 

1829
01:22:13,477 --> 01:22:16,510
大小是默认的EmojiSize。 

1830
01:22:16,510 --> 01:22:19,010
所以我们要放掉表情符号

1831
01:22:19,010 --> 01:22:22,920
是这个默认的EmojiSize，与我们使用的大小相同

1832
01:22:22,920 --> 01:22:24,733
顶部的ScrollView。 

1833
01:22:25,760 --> 01:22:29,242
现在这是在抱怨，因为让发现是让。 

1834
01:22:29,242 --> 01:22:31,010
让我们将其设为var，因为现在我们正在搜索

1835
01:22:31,010 --> 01:22:34,980
这里有两件事，这就是我们要做的全部

1836
01:22:34,980 --> 01:22:36,140
在下降侧。 

1837
01:22:36,140 --> 01:22:39,010
我们找到了位置，我们只是在检查他们

1838
01:22:39,010 --> 01:22:41,300
然后使用此Intent添加它们。 

1839
01:22:41,300 --> 01:22:42,800
记住，每个人都记住这个意图

1840
01:22:42,800 --> 01:22:45,260
我们在这里添加的AddEmoji。 

1841
01:22:45,260 --> 01:22:46,370
我们要做的最后一件事是能够

1842
01:22:46,370 --> 01:22:49,530
将我们的表情符号拖出。 

1843
01:22:49,530 --> 01:22:52,080
这是调色板中的表情符号。 

1844
01:22:52,080 --> 01:22:53,630
要做到这一点非常容易。 

1845
01:22:53,630 --> 01:22:55,850
我们只是要说onDrag。 

1846
01:22:55,850 --> 01:22:58,890
现在onDrag具有一个功能。 

1847
01:22:58,890 --> 01:23:03,040
而此功能只需要返回要拖动的东西即可。 

1848
01:23:03,040 --> 01:23:04,890
这些必须是NSItemProviders。 

1849
01:23:06,100 --> 01:23:08,850
记住NSItemProviders是这些提供程序

1850
01:23:08,850 --> 01:23:10,340
当我们下落时在这里。 

1851
01:23:10,340 --> 01:23:12,060
因此，需要提供者。 

1852
01:23:12,060 --> 01:23:14,210
所以我需要创建一个提供者

1853
01:23:14,210 --> 01:23:16,823
在此提供此表情符号。 

1854
01:23:17,756 --> 01:23:21,460
NSItemProvider几乎有我想要的那个

1855
01:23:21,460 --> 01:23:24,600
为此，它被称为对象

1856
01:23:24,600 --> 01:23:27,550
在NSItemProvider对象上，它将使用此对象

1857
01:23:27,550 --> 01:23:30,440
对于某些已知的类型，例如字符串和图像， 

1858
01:23:30,440 --> 01:23:33,200
它将在此处创建一个ItemProvider。 

1859
01:23:33,200 --> 01:23:37,210
不幸的是，这是旧的Objective-C世界代码

1860
01:23:37,210 --> 01:23:41,010
导入SwiftUI，所以我们必须把它

1861
01:23:41,010 --> 01:23:43,880
作为NSString在这里。 

1862
01:23:43,880 --> 01:23:46,150
这是因为ItemProviders仅会

1863
01:23:46,150 --> 01:23:47,560
这些旧的NS事物。 

1864
01:23:47,560 --> 01:23:50,350
您会看到它以NS开头，这以NS开头。 

1865
01:23:50,350 --> 01:23:52,210
现在就不讨论了。 

1866
01:23:52,210 --> 01:23:54,580
我们稍后再讨论，这意味着什么， 

1867
01:23:54,580 --> 01:23:56,400
但它实际上可以转换此表情符号

1868
01:23:56,400 --> 01:23:59,050
这是字符串类型，这些是字符串， 

1869
01:23:59,050 --> 01:24:03,500
进入这个NS世界，以便NSItemProvider可以做到。 

1870
01:24:03,500 --> 01:24:06,050
当然，实际上我们不需要返回那里。 

1871
01:24:07,440 --> 01:24:08,930
因此，让我们看一下是否可行。 

1872
01:24:08,930 --> 01:24:12,220
我们在这里拖累了我们，我们在这里拖累了我们。 

1873
01:24:12,220 --> 01:24:13,053
让我们看看是否可以做到。 

1874
01:24:13,053 --> 01:24:14,390
让我们从这个背景开始

1875
01:24:14,390 --> 01:24:15,910
确保没有破损。 

1876
01:24:15,910 --> 01:24:19,413
哦，工作正常，让我们也许将其拖到这里。 

1877
01:24:19,413 --> 01:24:21,600
哦，我看到绿色加号！ 

1878
01:24:21,600 --> 01:24:23,430
哦，它没有显示。 

1879
01:24:23,430 --> 01:24:26,080
所以我们的拖放似乎正在起作用

1880
01:24:26,080 --> 01:24:27,890
因为我们得到了绿色的加分。 

1881
01:24:27,890 --> 01:24:31,760
但是我们实际上并没有绘制掉掉的表情符号

1882
01:24:31,760 --> 01:24:34,868
在我们用户界面的任何位置。 

1883
01:24:34,868 --> 01:24:37,250
我们在这里画调色板

1884
01:24:37,250 --> 01:24:38,550
但我们实际上并没有画（笑） 

1885
01:24:38,550 --> 01:24:40,360
被删除的表情符号。 

1886
01:24:40,360 --> 01:24:45,180
我们只需要把它放在这张白色覆盖的图像上

1887
01:24:45,180 --> 01:24:47,430
所以我要做一个ZStack，把这两个东西叠起来

1888
01:24:47,430 --> 01:24:49,220
在对方的顶部，这个家伙。 

1889
01:24:49,220 --> 01:24:51,860
我要把这第二件事放在这里的ZStack中

1890
01:24:51,860 --> 01:24:56,860
只是所有表情符号中的每一个

1891
01:24:58,290 --> 01:25:00,223
在我的文档中。 

1892
01:25:02,200 --> 01:25:04,030
对于这些事情中的每一项，我将拥有

1893
01:25:04,030 --> 01:25:06,750
制作一个视图来绘制它。 

1894
01:25:06,750 --> 01:25:09,600
现在我目前没有任何变种

1895
01:25:09,600 --> 01:25:12,150
这给了我文档中的表情符号。 

1896
01:25:12,150 --> 01:25:14,650
如果您查看我的文档， 

1897
01:25:14,650 --> 01:25:17,730
我的模型是私人的，所以我看不到emojiArt 

1898
01:25:17,730 --> 01:25:21,860
所以我要在这里再换一个表情符号

1899
01:25:21,860 --> 01:25:26,280
它将是EmojiArt.Emoji的Array类型。 

1900
01:25:26,280 --> 01:25:30,700
这东西只是要返回我的emojiArt.emojis 

1901
01:25:30,700 --> 01:25:33,718
因为这是一个仅获取计算的变量。 

1902
01:25:33,718 --> 01:25:36,300
这是此emojiArts的只读版本，好的。 

1903
01:25:36,300 --> 01:25:39,550
这正是我的ViewModel想要做的

1904
01:25:39,550 --> 01:25:42,750
提供对模型的只读访问权限

1905
01:25:42,750 --> 01:25:47,123
因为它通过其Intent函数提供了不变的访问权限。 

1906
01:25:48,630 --> 01:25:51,820
所以在这里，这些表情符号是可识别的。 

1907
01:25:51,820 --> 01:25:54,580
太好了，我们使表情符号可识别。 

1908
01:25:54,580 --> 01:25:57,760
为了显示它们，它只是表情符号的文本。 

1909
01:25:57,760 --> 01:25:59,077
这就是我们要做的。 

1910
01:25:59,077 --> 01:26:03,290
唯一的事情就是我们要设置字体

1911
01:26:03,290 --> 01:26:07,560
成为尺寸，我们要设置此东西的位置

1912
01:26:07,560 --> 01:26:09,900
位置在模型中的任何位置。 

1913
01:26:09,900 --> 01:26:11,550
因此，我们将不得不做这两件事。 

1914
01:26:11,550 --> 01:26:13,240
因此，我将创建一些小功能来实现此目的。 

1915
01:26:13,240 --> 01:26:18,240
因此，让此表情符号的字体返回self.font 

1916
01:26:18,580 --> 01:26:22,440
然后我们将位置恢复为self.position 

1917
01:26:22,440 --> 01:26:24,239
这个表情符号

1918
01:26:24,239 --> 01:26:26,970
为此，由于坐标系空间

1919
01:26:26,970 --> 01:26:29,110
在（0，0）在左中或左上方之间， 

1920
01:26:29,110 --> 01:26:34,110
我要在其中传递这个geometry.size。 

1921
01:26:34,270 --> 01:26:36,220
因此，让我们做这两个小功能

1922
01:26:36,220 --> 01:26:39,510
然后我想我们会在这里完成，字体和位置， 

1923
01:26:39,510 --> 01:26:42,420
私人功能字体

1924
01:26:43,610 --> 01:26:46,387
用于表情符号，EmojiArt.Emoji。 

1925
01:26:47,956 --> 01:26:49,600
这些将返回字体。 

1926
01:26:49,600 --> 01:26:51,530
这很简单。 

1927
01:26:51,530 --> 01:26:55,407
我们将要做Font.system的大小。 

1928
01:26:55,407 --> 01:26:57,100
我们需要获取尺寸。 

1929
01:26:57,100 --> 01:27:01,810
现在，此尺寸实际上已在表情符号中作为尺寸。 

1930
01:27:01,810 --> 01:27:04,340
但这是一个Int，对。 

1931
01:27:04,340 --> 01:27:08,370
在这里，尺寸是我们模型中的一个整数。 

1932
01:27:08,370 --> 01:27:11,300
而且我真的不希望我的观点必须处理

1933
01:27:11,300 --> 01:27:12,370
与整数。 

1934
01:27:12,370 --> 01:27:14,580
所以我要在ViewModel中放一些东西

1935
01:27:14,580 --> 01:27:16,510
就像我做了所有这些事情一样， 

1936
01:27:16,510 --> 01:27:19,540
在这里对浮点数和点数进行一点解释。 

1937
01:27:19,540 --> 01:27:21,100
我要在这里做同样的事情

1938
01:27:21,100 --> 01:27:24,220
字体大小和位置。 

1939
01:27:24,220 --> 01:27:25,740
但是我将以一种不同寻常的方式来做。 

1940
01:27:25,740 --> 01:27:29,120
我要创建EmojiArt的扩展。 

1941
01:27:31,043 --> 01:27:35,040
我要添加var fontSize这是CGFloat 

1942
01:27:36,020 --> 01:27:40,260
并采用了CGFloat版本

1943
01:27:40,260 --> 01:27:43,253
自我大小

1944
01:27:44,830 --> 01:27:48,380
现在，这感觉就像我们在违反MVVM。 

1945
01:27:48,380 --> 01:27:53,300
我刚刚在模型中添加了CGFloat var。 

1946
01:27:53,300 --> 01:27:55,410
但这并不违反MVVM 

1947
01:27:55,410 --> 01:27:58,340
因为此代码在我的ViewModel中。 

1948
01:27:58,340 --> 01:28:00,930
它不在模型中，我正在将其添加到某物中

1949
01:28:00,930 --> 01:28:02,690
在我的模型中，但是这段代码

1950
01:28:02,690 --> 01:28:06,360
这行代码就在我的ViewModel中。 

1951
01:28:06,360 --> 01:28:08,140
这使其完全合法。 

1952
01:28:08,140 --> 01:28:11,430
允许ViewModel做CGFloat，没问题。 

1953
01:28:11,430 --> 01:28:16,120
我在这里可以使用CGPoint做同样的事情。 

1954
01:28:16,120 --> 01:28:19,760
我可以把它变成CGPoint 

1955
01:28:21,670 --> 01:28:24,567
X是CGFloat sub X 

1956
01:28:24,567 --> 01:28:27,610
Y是CGFloat子Y。 

1957
01:28:27,610 --> 01:28:31,450
所以现在我做到了，所以我们不必处理

1958
01:28:31,450 --> 01:28:35,163
我们眼中的Ints。 

1959
01:28:36,034 --> 01:28:38,694
而且我们的ViewModel只是一个很好的ViewModel， 

1960
01:28:38,694 --> 01:28:42,180
可以为我们解释模型。 

1961
01:28:42,180 --> 01:28:44,520
所以在这里我只能说这个大小

1962
01:28:44,520 --> 01:28:47,240
等于此表情符号的fontSize。 

1963
01:28:47,240 --> 01:28:48,857
这将是CGFloat。 

1964
01:28:50,060 --> 01:28:54,410
对于该职位，同样对于私人职能职位

1965
01:28:54,410 --> 01:28:59,193
用于表情符号，EmojiArt.Emoji大小，CGSize。 

1966
01:29:00,220 --> 01:29:01,500
这将给CGPoint 

1967
01:29:01,500 --> 01:29:04,000
那东西去了。 

1968
01:29:04,000 --> 01:29:07,270
那只是做一个CGPoint，我们再次转换

1969
01:29:07,270 --> 01:29:09,000
到中间的那个（0，0） 

1970
01:29:09,000 --> 01:29:10,920
而不是左上角的（0，0）。 

1971
01:29:10,920 --> 01:29:14,820
这就是X是表情符号的位置。 

1972
01:29:14,820 --> 01:29:18,940
加号，再加上size.width除以2 

1973
01:29:18,940 --> 01:29:23,330
Y是表情符号的位置。 

1974
01:29:23,330 --> 01:29:25,880
同样，这个emoji.location是CGPoints 

1975
01:29:26,767 --> 01:29:28,760
来自我们的ViewModel。 

1976
01:29:28,760 --> 01:29:31,253
加上size.height除以2。 

1977
01:29:32,700 --> 01:29:36,700
现在您可能会在以后进行更多转换

1978
01:29:36,700 --> 01:29:38,870
当您开始允许这些东西时

1979
01:29:38,870 --> 01:29:41,590
被定位，四处移动。 

1980
01:29:41,590 --> 01:29:43,632
我们到这里来了吗，哦，是的， 

1981
01:29:43,632 --> 01:29:45,963
不只是表情符号，而是表情符号的文字。 

1982
01:29:47,490 --> 01:29:48,540
因此，让我们来看看！ 

1983
01:29:50,120 --> 01:29:53,460
希望只有我们每个人都可以在其中发短信。 

1984
01:29:53,460 --> 01:29:55,940
同样，让我们​​在这里做一个很好的背景。 

1985
01:29:55,940 --> 01:29:59,560
让我们把它捡起来，放在这里，哦，我们知道了！ 

1986
01:29:59,560 --> 01:30:02,540
一点棒球，是的！ 

1987
01:30:02,540 --> 01:30:05,350
苹果在房子顶上，太好了！ 

1988
01:30:05,350 --> 01:30:08,300
现在下周您的作业将是

1989
01:30:08,300 --> 01:30:11,110
它会成功的，所以您可以单击这些来选择它们

1990
01:30:11,110 --> 01:30:14,210
然后把它们拖过来，好吗？ 

1991
01:30:14,210 --> 01:30:17,300
甚至可以捏，这可以在模拟器上完成

1992
01:30:17,300 --> 01:30:18,970
按住选项键

1993
01:30:18,970 --> 01:30:22,130
并捏以放大和缩小它们。 

1994
01:30:22,130 --> 01:30:23,850
因此，让您开始并理解

1995
01:30:23,850 --> 01:30:25,330
在下一讲中该如何做

1996
01:30:25,330 --> 01:30:27,640
我们要做到这一点，以便我们可以拖动

1997
01:30:27,640 --> 01:30:30,690
并捏住整个图像。 

1998
01:30:30,690 --> 01:30:32,727
因此，我将让您拖拉并捏住整个图像。 

1999
01:30:32,727 --> 01:30:34,750
你会做到的，所以你可以拖动

2000
01:30:34,750 --> 01:30:36,743
并捏在那里的小表情符号。 

2001
01:30:39,315 --> 01:30:40,530
这样就可以了

2002
01:30:40,530 --> 01:30:42,910
然后我们将开始下一个讲座

2003
01:30:42,910 --> 01:30:44,670
有关如何操作的一些幻灯片

2004
01:30:44,670 --> 01:30:48,467
做这些手势，捏，拖和所有这些东西

2005
01:30:48,467 --> 01:30:50,270
然后我们将直接回到这个演示中

2006
01:30:50,270 --> 01:30:51,913
并取得更多进展。 

2007
01:30:53,090 --> 01:30:56,323
-[演示者]有关更多信息，请访问stanford.edu。 

