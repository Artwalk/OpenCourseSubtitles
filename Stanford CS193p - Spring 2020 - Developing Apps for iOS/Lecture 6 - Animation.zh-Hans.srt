1
00:00:00,121 --> 00:00:02,704
（柔和的音乐） 

2
00:00:04,236 --> 00:00:06,250
-[旁白]斯坦福大学

3
00:00:08,500 --> 00:00:12,012
-[讲师] CS193P 2020年春季。 

4
00:00:12,012 --> 00:00:13,952
这是第六讲

5
00:00:13,952 --> 00:00:18,800
今天我要介绍两个简短的主题， 

6
00:00:18,800 --> 00:00:21,603
因为他们是次要话题，所以简短

7
00:00:21,603 --> 00:00:22,950
像财产观察员一样

8
00:00:22,950 --> 00:00:25,390
否则我只会深入了解其中的细节

9
00:00:25,390 --> 00:00:26,940
就像@State。 

10
00:00:26,940 --> 00:00:29,070
然后我们今天将探讨我们的主要主题， 

11
00:00:29,070 --> 00:00:31,881
这是动画，这就是我们的演示

12
00:00:31,881 --> 00:00:32,900
所有关于。 

13
00:00:32,900 --> 00:00:34,370
因此，让我们开始吧。 

14
00:00:34,370 --> 00:00:37,920
物业观察员对此只作简单介绍。 

15
00:00:37,920 --> 00:00:39,360
我要你了解的主要内容

16
00:00:39,360 --> 00:00:43,940
关于财产观察员，这只是观看变量的一种方法

17
00:00:43,940 --> 00:00:47,280
并查看何时更改，然后采取一些措施。 

18
00:00:47,280 --> 00:00:49,164
现在，很多时候人们感到困惑

19
00:00:49,164 --> 00:00:51,723
在属性观察者和计算变量之间。 

20
00:00:51,723 --> 00:00:53,735
他们是完全不同的东西， 

21
00:00:53,735 --> 00:00:55,870
彼此无关。 

22
00:00:55,870 --> 00:00:57,844
在这里，我有这个var isFaceUp 

23
00:00:57,844 --> 00:01:00,144
上面有一个属性观察器。 

24
00:01:00,144 --> 00:01:02,270
该var存储在内存中， 

25
00:01:02,270 --> 00:01:04,493
它无论如何都不是计算变量。 

26
00:01:05,690 --> 00:01:08,953
在属性观察器中，将设置我正在观看

27
00:01:08,953 --> 00:01:11,743
因为何时将设置isFaceUp 

28
00:01:11,743 --> 00:01:14,240
如果设置了新值， 

29
00:01:14,240 --> 00:01:16,810
换句话说，事情会面朝上， 

30
00:01:16,810 --> 00:01:18,310
那么例如在这种情况下， 

31
00:01:18,310 --> 00:01:20,280
就像在我们的“记忆游戏”中一样

32
00:01:20,280 --> 00:01:24,370
我要开始使用奖金时间，开始小馅饼

33
00:01:24,370 --> 00:01:26,730
我们的表情符号后面开始滴答作响。 

34
00:01:26,730 --> 00:01:30,960
如果isFaceUp即将设置为false， 

35
00:01:30,960 --> 00:01:32,887
我将停止使用奖励时间。 

36
00:01:32,887 --> 00:01:35,220
所以newValue在这里是紫色的东西

37
00:01:35,220 --> 00:01:37,046
那是只出现的特殊变种

38
00:01:37,046 --> 00:01:38,717
在遗嘱中设置在这里。 

39
00:01:38,717 --> 00:01:40,260
当然，还有一个didSet 

40
00:01:40,260 --> 00:01:42,064
我将在演示中使用它，只是有所不同， 

41
00:01:42,064 --> 00:01:45,963
在那个oldValue里面是过去的值

42
00:01:45,963 --> 00:01:47,453
在它改变之前。 

43
00:01:48,290 --> 00:01:51,262
好了，对于下一个主题，我想解释一下

44
00:01:51,262 --> 00:01:54,460
关于发生的事情并不清楚

45
00:01:54,460 --> 00:01:56,970
我之前还没有真正谈论过

46
00:01:56,970 --> 00:02:01,502
但是您的视图（例如CardView）和EmojiGameView， 

47
00:02:01,502 --> 00:02:03,713
它们都是只读的。 

48
00:02:04,690 --> 00:02:07,047
换句话说，如果您在顶部查看

49
00:02:07,047 --> 00:02:10,789
以及您设备上的所有SwiftUI，一应俱全。 

50
00:02:10,789 --> 00:02:12,620
您可能会认为这是不可能的。 

51
00:02:12,620 --> 00:02:13,840
我们怎么不能改变观点

52
00:02:13,840 --> 00:02:16,070
观点一直在变化。 

53
00:02:16,070 --> 00:02:17,910
但是我们不是只读的

54
00:02:17,910 --> 00:02:21,950
这意味着拥有存储的var 

55
00:02:21,950 --> 00:02:23,644
在我们看来，这是没有用的。 

56
00:02:23,644 --> 00:02:25,084
反正我们不能设置它的值

57
00:02:25,084 --> 00:02:28,393
唯一的例外是设置的变量

58
00:02:28,393 --> 00:02:30,130
当你创建

59
00:02:30,130 --> 00:02:31,430
风景。 

60
00:02:31,430 --> 00:02:33,190
就像在CardView中，我们有isFaceUp， 

61
00:02:33,190 --> 00:02:35,110
它是由创建它的人设置的

62
00:02:35,110 --> 00:02:38,080
因此将其作为变种是有意义的。 

63
00:02:38,080 --> 00:02:39,635
但是其他没有这样设置的东西

64
00:02:39,635 --> 00:02:41,010
它可能也是一个让。 

65
00:02:41,010 --> 00:02:42,386
或者如果它绝对是计算的var 

66
00:02:42,386 --> 00:02:44,522
只想成为一个只读的计算变量， 

67
00:02:44,522 --> 00:02:48,323
到目前为止，这是我们唯一的一种计算型var。 

68
00:02:48,323 --> 00:02:49,960
为什么？ 

69
00:02:49,960 --> 00:02:51,661
为什么它们都是只读的？ 

70
00:02:51,661 --> 00:02:54,110
好吧，函数式编程

71
00:02:54,110 --> 00:02:55,860
一件令人敬畏的事情， 

72
00:02:55,860 --> 00:02:58,430
关于可变性很清楚， 

73
00:02:58,430 --> 00:03:00,360
什么时候可以更改？ 

74
00:03:00,360 --> 00:03:02,890
好的设计有很大的溢价

75
00:03:02,890 --> 00:03:05,040
使事情变得一成不变。 

76
00:03:05,040 --> 00:03:05,959
当事物是不可变的

77
00:03:05,959 --> 00:03:08,193
没有人在幕后改变它

78
00:03:08,193 --> 00:03:11,810
或做一些破坏可证明性的事情

79
00:03:11,810 --> 00:03:13,721
您的代码实际有效。 

80
00:03:13,721 --> 00:03:17,180
而且，当事物是可变的或不可变的时， 

81
00:03:17,180 --> 00:03:19,057
当他们改变时，你知道他们在改变， 

82
00:03:19,057 --> 00:03:20,233
您可以为此做些事情。 

83
00:03:20,233 --> 00:03:22,933
这就是我们可以在这些属性观察器上使用的方式

84
00:03:22,933 --> 00:03:25,964
价值类型如此有效。 

85
00:03:25,964 --> 00:03:27,822
对于SwiftUI， 

86
00:03:27,822 --> 00:03:30,501
它想知道事情何时发生变化， 

87
00:03:30,501 --> 00:03:33,014
当他们改变的时候，它想做的最少

88
00:03:33,014 --> 00:03:37,930
用正确的视图替换视图层次结构的工作。 

89
00:03:37,930 --> 00:03:39,735
实际上，这就是正在发生的事情， 

90
00:03:39,735 --> 00:03:41,520
如果isFaceUp 

91
00:03:41,520 --> 00:03:42,810
变化， 

92
00:03:42,810 --> 00:03:46,375
它制作了一个新的CardView。 

93
00:03:46,375 --> 00:03:48,493
这就是所有工作的方式。 

94
00:03:48,493 --> 00:03:51,611
这实际上对你来说是一件很棒的事

95
00:03:51,611 --> 00:03:52,957
您可能不这样认为。 

96
00:03:52,957 --> 00:03:55,480
您不能拥有读写var的事实真的很好

97
00:03:55,480 --> 00:03:57,794
因为记住你的观点

98
00:03:57,794 --> 00:03:59,723
应该是无国籍的。 

99
00:03:59,723 --> 00:04:02,511
他们应该一直在反思

100
00:04:02,511 --> 00:04:04,000
模型的状态是什么。 

101
00:04:04,000 --> 00:04:06,528
状态即在模型中。 

102
00:04:06,528 --> 00:04:09,627
因此，您不需要自己的任何状态，对吗？ 

103
00:04:09,627 --> 00:04:12,563
无需将它们设置为只读。 

104
00:04:13,540 --> 00:04:15,792
好吧，主要是

105
00:04:15,792 --> 00:04:17,841
并非100％正确。 

106
00:04:17,841 --> 00:04:21,181
因此，让我们谈谈Views何时确实需要某种状态。 

107
00:04:21,181 --> 00:04:23,510
还有一些罕见的时期

108
00:04:23,510 --> 00:04:26,839
当它确实需要状态时，它总是临时的。 

109
00:04:26,839 --> 00:04:28,878
视图永远不会长期存储

110
00:04:28,878 --> 00:04:30,799
那将永远存在于您的模型中。 

111
00:04:30,799 --> 00:04:32,437
这只是暂时的情况

112
00:04:32,437 --> 00:04:34,750
您可能需要一点存储空间的地方。 

113
00:04:34,750 --> 00:04:37,283
您可能需要哪些临时存储示例？ 

114
00:04:37,283 --> 00:04:40,530
好吧，您可能会进入“编辑模式”， 

115
00:04:40,530 --> 00:04:42,670
您要从用户那里收集一些数据的地方

116
00:04:42,670 --> 00:04:45,870
并收集起来，然后调用意图更改模型

117
00:04:45,870 --> 00:04:47,990
使用您收集的数据或其他方式。 

118
00:04:47,990 --> 00:04:50,760
所以只是暂时的，您正在收集它。 

119
00:04:50,760 --> 00:04:53,580
您可能正在显示另一个视图， 

120
00:04:53,580 --> 00:04:55,200
其他一些正在收集数据的视图

121
00:04:55,200 --> 00:04:57,540
例如TextField或Picker， 

122
00:04:57,540 --> 00:05:00,030
就像我们在广场上的那个帖子中看到的一样

123
00:05:00,030 --> 00:05:02,260
或具有作为警报的视图， 

124
00:05:02,260 --> 00:05:03,650
您正在向用户发出警报， 

125
00:05:03,650 --> 00:05:05,690
你只是想跟踪它上升的事实

126
00:05:05,690 --> 00:05:06,950
直到用户点击“取消”， 

127
00:05:06,950 --> 00:05:08,150
然后您会想，“啊，它不见了”。 

128
00:05:08,150 --> 00:05:09,800
因此，您只是个布尔人， 

129
00:05:09,800 --> 00:05:11,240
那个事情是否发生

130
00:05:11,240 --> 00:05:15,050
那种很小的临时数据或动画。 

131
00:05:15,050 --> 00:05:17,480
动画只反映过去的事物。 

132
00:05:17,480 --> 00:05:18,618
因此，如果您想制作一种动画， 

133
00:05:18,618 --> 00:05:20,720
与当下， 

134
00:05:20,720 --> 00:05:23,310
您必须有一个小var，这就是未来。 

135
00:05:23,310 --> 00:05:25,380
因此您可以将var设置为将来

136
00:05:25,380 --> 00:05:28,490
动画将开始朝着未来发展。 

137
00:05:28,490 --> 00:05:30,230
希望您将未来设定为

138
00:05:30,230 --> 00:05:32,070
最终将是同样的事情

139
00:05:32,070 --> 00:05:33,370
在你的永久状态。 

140
00:05:33,370 --> 00:05:35,109
但是你只用那个变量

141
00:05:35,109 --> 00:05:36,580
在动画发生的时间

142
00:05:36,580 --> 00:05:38,770
我们知道动画很短， 

143
00:05:38,770 --> 00:05:40,024
他们只是暂时的东西。 

144
00:05:40,024 --> 00:05:43,323
动画，这些临时存储的另一种情况， 

145
00:05:43,323 --> 00:05:45,833
我们将在演示中看到这样做。 

146
00:05:45,833 --> 00:05:50,660
实际上，我们可以在只读视图中创建存储

147
00:05:50,660 --> 00:05:53,100
我们通过标记一个var 

148
00:05:53,100 --> 00:05:56,200
使用@State存储我们想要的信息。 

149
00:05:56,200 --> 00:05:57,972
所以@State你知道， 

150
00:05:57,972 --> 00:06:00,590
像@ Published，@ ObservedObject， 

151
00:06:00,590 --> 00:06:02,362
这是一个属性包装器。 

152
00:06:02,362 --> 00:06:06,310
请注意，我已将此状态标记为私有。 

153
00:06:06,310 --> 00:06:09,341
那是因为国家对你是私人的

154
00:06:09,341 --> 00:06:12,930
这只是您在View中使用的临时存储， 

155
00:06:12,930 --> 00:06:14,720
没有其他人会看着它。 

156
00:06:14,720 --> 00:06:16,560
因此，将其标记为私有，只是提醒自己， 

157
00:06:16,560 --> 00:06:18,699
是的，这是一个私人国家

158
00:06:18,699 --> 00:06:20,260
那里的临时状态。 

159
00:06:20,260 --> 00:06:23,650
当然，这个东西的类型可以是任何类型， 

160
00:06:23,650 --> 00:06:26,230
您基本上是在这里声明一个变量， 

161
00:06:26,230 --> 00:06:27,504
那将是可读写的。 

162
00:06:27,504 --> 00:06:30,903
但是它可以是您想要的任何类型。 

163
00:06:30,903 --> 00:06:33,323
要了解有关此状态变量的一件重要事情， 

164
00:06:33,323 --> 00:06:36,412
如果我更改它，这是暂时的， 

165
00:06:36,412 --> 00:06:38,374
我的视图可能会重绘。 

166
00:06:38,374 --> 00:06:41,332
如果我的观点是暂时的， 

167
00:06:41,332 --> 00:06:44,694
它以某种方式改变，使我的身体变得不同

168
00:06:44,694 --> 00:06:46,043
它会被重画。 

169
00:06:46,043 --> 00:06:48,690
和ObservedObject一样，对吗？ 

170
00:06:48,690 --> 00:06:50,530
我们在ViewModel上观察到对象。 

171
00:06:50,530 --> 00:06:52,480
如果ViewModel以某种方式更改

172
00:06:52,480 --> 00:06:54,560
这将使我们的视图看起来与众不同。 

173
00:06:54,560 --> 00:06:56,940
将与状态重新绘制相同的东西

174
00:06:56,940 --> 00:06:58,823
这实际上是它的一个很酷的功能。 

175
00:06:58,823 --> 00:07:01,750
此@State var的空间

176
00:07:01,750 --> 00:07:05,060
将在堆中分配。 

177
00:07:05,060 --> 00:07:07,204
它必须，不能在您的视图中留出空间， 

178
00:07:07,204 --> 00:07:08,680
您的视图是只读的

179
00:07:08,680 --> 00:07:11,020
所以基本上是在做一个指针

180
00:07:11,020 --> 00:07:13,320
所以你的视图里面有一个指针

181
00:07:13,320 --> 00:07:15,240
它指向堆。 

182
00:07:15,240 --> 00:07:17,180
当您的视图重建时， 

183
00:07:17,180 --> 00:07:19,340
导致您的View一直在重建， 

184
00:07:19,340 --> 00:07:21,530
当isFaceUp在CardView中更改时， 

185
00:07:21,530 --> 00:07:23,420
您必须制作一个新的CardView。 

186
00:07:23,420 --> 00:07:24,906
当那件事发生时

187
00:07:24,906 --> 00:07:28,036
该指针移至新版本

188
00:07:28,036 --> 00:07:30,370
所以您仍然指向堆中的同一件事。 

189
00:07:30,370 --> 00:07:32,490
因此，如果isFaceUp发生变化， 

190
00:07:32,490 --> 00:07:35,440
您的CardView不会丢失其临时存储。 

191
00:07:35,440 --> 00:07:37,930
基本上，您的临时存储甚至会保留

192
00:07:37,930 --> 00:07:40,340
以及其他导致您的视图的因素

193
00:07:40,340 --> 00:07:42,050
甚至完全重建

194
00:07:42,050 --> 00:07:43,773
您可以保留@State。 

195
00:07:45,115 --> 00:07:47,365
我们将学习这些@符号事物， 

196
00:07:47,365 --> 00:07:50,176
你知道@Published @ObservedObject @State 

197
00:07:50,176 --> 00:07:52,225
他们被称为属性包装器。 

198
00:07:52,225 --> 00:07:54,930
您可以在阅读中阅读有关内容。 

199
00:07:54,930 --> 00:07:57,020
我认为是下周分配的。 

200
00:07:57,020 --> 00:07:59,996
我最终会在演讲中解释它。 

201
00:07:59,996 --> 00:08:02,126
不过，还没有到那儿。 

202
00:08:02,126 --> 00:08:06,183
现在，只知道您可以使用@State标记var 

203
00:08:06,183 --> 00:08:07,731
现在您可以写了。 

204
00:08:07,731 --> 00:08:10,970
但是请谨慎使用，并且绝对不要

205
00:08:10,970 --> 00:08:13,583
放一些不是临时的东西。 

206
00:08:15,459 --> 00:08:18,290
好的，当天的主题是动画。 

207
00:08:18,290 --> 00:08:19,808
什么是动画？ 

208
00:08:19,808 --> 00:08:23,180
这本质上是一种平滑的写照

209
00:08:23,180 --> 00:08:26,670
在一段时间内，在您的用户界面中， 

210
00:08:26,670 --> 00:08:28,930
顺便说一下， 

211
00:08:28,930 --> 00:08:33,670
您的UI中已经发生的更改。 

212
00:08:33,670 --> 00:08:35,190
当用户观看动画时， 

213
00:08:35,190 --> 00:08:37,260
他们看到的东西已经改变

214
00:08:37,260 --> 00:08:38,920
在模型中，好吧， 

215
00:08:38,920 --> 00:08:40,550
或某处已经改变

216
00:08:40,550 --> 00:08:42,776
至少已经更改了@State。 

217
00:08:42,776 --> 00:08:44,865
已经发生的事情

218
00:08:44,865 --> 00:08:47,224
它无法用其他任何方式做到。 

219
00:08:47,224 --> 00:08:49,719
否则，您模型中的所有变量都将具有

220
00:08:49,719 --> 00:08:52,333
随着动画的进行不断变化

221
00:08:52,333 --> 00:08:54,692
那只是站不住脚的架构，对吗？ 

222
00:08:54,692 --> 00:08:57,370
所以你的模型改变了

223
00:08:57,370 --> 00:09:00,560
您的视图发生了变化，该变化得到

224
00:09:00,560 --> 00:09:02,830
动画在用户的眼前。 

225
00:09:02,830 --> 00:09:05,173
因此，它向您显示了他们最近的过去。 

226
00:09:06,153 --> 00:09:09,035
动画的重点是使用户体验

227
00:09:09,035 --> 00:09:11,580
显然，少一点干涩的

228
00:09:11,580 --> 00:09:14,390
而且要引起人们对事物变化的关注。 

229
00:09:14,390 --> 00:09:16,900
我们想利用用户的外围视觉来注意到

230
00:09:16,900 --> 00:09:18,420
哦那边那个数字在变

231
00:09:18,420 --> 00:09:20,795
哦，无论如何，View都移到了这里。 

232
00:09:20,795 --> 00:09:23,191
那就是我们使用动画的目的

233
00:09:23,191 --> 00:09:25,100
这就是为什么我们有动画。 

234
00:09:25,100 --> 00:09:26,844
这也只会使人更愉快， 

235
00:09:26,844 --> 00:09:29,250
少压力的经历

236
00:09:29,250 --> 00:09:31,150
一直在屏幕上跳跃。 

237
00:09:32,720 --> 00:09:34,905
那么在SwiftUI中，什么可以动画呢？ 

238
00:09:34,905 --> 00:09:37,451
好吧，我要说的是什么可以变得生动起来

239
00:09:37,451 --> 00:09:38,960
但首先，我想说清楚

240
00:09:38,960 --> 00:09:41,814
该动画仅适用于“视图” 

241
00:09:41,814 --> 00:09:43,742
在一个容器里

242
00:09:43,742 --> 00:09:46,430
已经在屏幕上了。 

243
00:09:46,430 --> 00:09:48,691
因此，如果它们位于已经在屏幕上的容器中

244
00:09:48,691 --> 00:09:49,871
他们发生了变化， 

245
00:09:49,871 --> 00:09:52,580
可以产生什么样的变化？ 

246
00:09:52,580 --> 00:09:55,782
好吧，Views的出现和消失

247
00:09:55,782 --> 00:09:58,684
仅当它们在容器中时，才在屏幕上显示

248
00:09:58,684 --> 00:10:03,684
还更改了可动画制作的ViewModifiers的参数， 

249
00:10:03,960 --> 00:10:06,660
例如不透明度和旋转度

250
00:10:06,660 --> 00:10:09,865
提升ViewModifiers知道如何为自己设置动画。 

251
00:10:09,865 --> 00:10:12,480
今天我们要创建自己的一个

252
00:10:12,480 --> 00:10:16,660
对这些参数的更改可以进行动画处理。 

253
00:10:16,660 --> 00:10:18,727
以及论点的改变

254
00:10:18,727 --> 00:10:21,480
是形状的创造。 

255
00:10:21,480 --> 00:10:22,970
如果您创建形状， 

256
00:10:22,970 --> 00:10:24,670
以某种方式配置了某些参数， 

257
00:10:24,670 --> 00:10:26,730
然后你改变那些， 

258
00:10:26,730 --> 00:10:30,283
然后可以对其进行动画处理以进入新状态。 

259
00:10:32,170 --> 00:10:34,630
那么我们如何开始动画呢？ 

260
00:10:34,630 --> 00:10:36,150
顺便说一下，就是改变了

261
00:10:36,150 --> 00:10:37,390
没有别的可以改变

262
00:10:37,390 --> 00:10:39,470
只是ViewModifiers，Shape， 

263
00:10:39,470 --> 00:10:41,080
以及视图的出现和消失， 

264
00:10:41,080 --> 00:10:42,910
想说清楚。 

265
00:10:42,910 --> 00:10:44,990
好了，那么我们如何制作动画呢？ 

266
00:10:44,990 --> 00:10:46,210
好吧，有两种方法可以做到。 

267
00:10:46,210 --> 00:10:48,320
一个是隐式动画

268
00:10:48,320 --> 00:10:51,110
我们要标记一个视图然后说， 

269
00:10:51,110 --> 00:10:55,300
只要此视图上的修饰符之一发生变化， 

270
00:10:55,300 --> 00:10:57,450
我们将动画化这一变化。 

271
00:10:57,450 --> 00:11:00,400
因此，隐式动画将自动

272
00:11:00,400 --> 00:11:03,720
每当该视图上的修改器发生变化时， 

273
00:11:03,720 --> 00:11:05,340
它将对其进行动画处理。 

274
00:11:05,340 --> 00:11:07,750
第二个是明确的

275
00:11:07,750 --> 00:11:11,410
我们将在其中调用一些将要产生的代码

276
00:11:11,410 --> 00:11:14,410
在对ViewModifiers或Shapes的一些更改中， 

277
00:11:14,410 --> 00:11:16,700
或观点将会来去去去。 

278
00:11:16,700 --> 00:11:18,880
我们将包装该代码

279
00:11:18,880 --> 00:11:21,720
通过withAnimation调用此函数。 

280
00:11:21,720 --> 00:11:23,100
在花括号里面， 

281
00:11:23,100 --> 00:11:24,400
我们要把代码

282
00:11:24,400 --> 00:11:27,290
那会导致所有会改变的事情

283
00:11:27,290 --> 00:11:29,015
所有这些更改的ViewModifier参数， 

284
00:11:29,015 --> 00:11:30,310
所有的观点来去去去。 

285
00:11:30,310 --> 00:11:31,960
他们都会一起发生

286
00:11:31,960 --> 00:11:35,070
在一个并发动画中。 

287
00:11:35,070 --> 00:11:37,420
因此，我们在此处明确设置动画， 

288
00:11:37,420 --> 00:11:40,540
我们说的是对此进行动画处理，然后我们通常

289
00:11:40,540 --> 00:11:44,140
做类似在我们的ViewModel中调用Intent的事情。 

290
00:11:44,140 --> 00:11:46,590
而且我们知道这将会带来很多改变

291
00:11:46,590 --> 00:11:49,740
我们希望将所有结果一起动画化。 

292
00:11:49,740 --> 00:11:51,433
这就是显式动画。 

293
00:11:52,600 --> 00:11:55,520
因此，让我们先谈谈隐式动画。 

294
00:11:55,520 --> 00:11:58,100
有人称这种自动动画

295
00:11:58,100 --> 00:12:00,956
本质上只是声明或标记一个视图

296
00:12:00,956 --> 00:12:02,770
这样所有的ViewModifier参数

297
00:12:02,770 --> 00:12:05,280
总是动画

298
00:12:05,280 --> 00:12:06,163
对于此视图。 

299
00:12:07,370 --> 00:12:10,440
您可以指定这些事情的发生方式， 

300
00:12:10,440 --> 00:12:12,660
就像他们发生需要多长时间。 

301
00:12:12,660 --> 00:12:14,980
还有我要谈论的曲线

302
00:12:14,980 --> 00:12:17,580
您确实可以控制它。 

303
00:12:17,580 --> 00:12:22,580
您可以通过在任何View上调用此函数动画来完成此操作。 

304
00:12:23,980 --> 00:12:28,130
所以在这里我称其为不透明度或旋转度

305
00:12:28,130 --> 00:12:30,820
修改后的幽灵文字。 

306
00:12:30,820 --> 00:12:34,130
我说过动画，在那里提供了论据， 

307
00:12:34,130 --> 00:12:36,540
动画的制作方法

308
00:12:36,540 --> 00:12:37,970
多久，所有的东西。 

309
00:12:37,970 --> 00:12:42,440
而且现在永远，只要可怕的变种变化， 

310
00:12:42,440 --> 00:12:44,090
因此不透明度发生了变化， 

311
00:12:44,090 --> 00:12:46,448
或upsideDown var在那里改变

312
00:12:46,448 --> 00:12:49,220
旋转效果将改变旋转。 

313
00:12:49,220 --> 00:12:52,750
每当这些变化发生时，它就会产生动画效果， 

314
00:12:52,750 --> 00:12:57,230
因为此“查看此组合”显示为绿色， 

315
00:12:57,230 --> 00:12:59,520
现在是隐式动画的。 

316
00:12:59,520 --> 00:13:02,313
总是会发生这种情况。 

317
00:13:03,850 --> 00:13:07,420
警告这里，小红字警告，请注意

318
00:13:08,677 --> 00:13:12,700
.animation在容器上查看

319
00:13:12,700 --> 00:13:15,500
无法正常使用您通常认为的方式

320
00:13:15,500 --> 00:13:18,470
你可能想像，它会动画

321
00:13:18,470 --> 00:13:23,470
整个容器就像一个大的，某种程度上的变化。 

322
00:13:24,000 --> 00:13:26,920
但这并不能全部在容器上做动画， 

323
00:13:26,920 --> 00:13:29,270
它只是将动画应用于所有事物

324
00:13:29,270 --> 00:13:30,980
在容器内。 

325
00:13:30,980 --> 00:13:34,817
换句话说，.animation与.padding不同，对。 

326
00:13:34,817 --> 00:13:37,400
.padding使整个ZStack处于填充状态

327
00:13:37,400 --> 00:13:39,410
或整个VStack或其他任何东西。 

328
00:13:39,410 --> 00:13:42,670
它更像.font，或者如果您在ZStack上说.font， 

329
00:13:42,670 --> 00:13:46,680
ZStack中的所有文本，获取该字体，好吧。 

330
00:13:46,680 --> 00:13:48,150
动画更像.font 

331
00:13:48,150 --> 00:13:51,210
如果您在ZStack上说动画， 

332
00:13:51,210 --> 00:13:53,892
里面的所有东西都会得到那个，那就是

333
00:13:53,892 --> 00:13:57,122
很少您真正想要的东西令人惊讶。 

334
00:13:57,122 --> 00:13:59,390
所以我只是警告你

335
00:13:59,390 --> 00:14:04,390
我们通常不将.animation放在容器视图上， 

336
00:14:04,610 --> 00:14:08,670
他们通常戴在叶子视图上， 

337
00:14:08,670 --> 00:14:11,493
至少在很小的独立视图上。 

338
00:14:14,180 --> 00:14:16,010
这样动画论点

339
00:14:16,010 --> 00:14:18,120
在上一张幻灯片中看到的您正在经过的地方， 

340
00:14:18,120 --> 00:14:20,370
轻松进出，这被称为， 

341
00:14:20,370 --> 00:14:23,380
使您可以像控制动画持续时间一样控制动画。 

342
00:14:23,380 --> 00:14:24,270
这要花多长时间？ 

343
00:14:24,270 --> 00:14:26,520
两秒钟或任何延迟

344
00:14:26,520 --> 00:14:29,570
请等待半秒钟，然后再开始播放此动画。 

345
00:14:29,570 --> 00:14:31,420
它可以重复一定次数， 

346
00:14:31,420 --> 00:14:32,760
甚至永远重复

347
00:14:32,760 --> 00:14:35,000
做动画来做这个改变， 

348
00:14:35,000 --> 00:14:36,930
然后不断重复制作动画。 

349
00:14:36,930 --> 00:14:39,350
当然，过去已经进行了更改， 

350
00:14:39,350 --> 00:14:41,380
但只要继续做动画

351
00:14:41,380 --> 00:14:42,717
有时候你想这么做。 

352
00:14:42,717 --> 00:14:46,350
您还可以设置动画的曲线。 

353
00:14:46,350 --> 00:14:48,723
那么动画曲线是什么？ 

354
00:14:49,640 --> 00:14:51,250
这实际上是由

355
00:14:51,250 --> 00:14:53,580
您选择哪种动画。 

356
00:14:53,580 --> 00:14:56,600
动画曲线控制速率

357
00:14:56,600 --> 00:14:59,240
动画播放时

358
00:14:59,240 --> 00:15:02,220
例如，在线性动画中， 

359
00:15:02,220 --> 00:15:04,530
在整个过程中，速率保持恒定

360
00:15:04,530 --> 00:15:08,010
整个动画，从一个不透明度到另一个， 

361
00:15:08,010 --> 00:15:09,390
或一次旋转或另一次旋转

362
00:15:09,390 --> 00:15:12,330
发生时，线性恒定速率。 

363
00:15:12,330 --> 00:15:14,160
然后这种放松，放松

364
00:15:14,160 --> 00:15:16,230
我在上一个提到的那是不同的。 

365
00:15:16,230 --> 00:15:19,440
它开始缓慢，缓慢改变不透明度

366
00:15:19,440 --> 00:15:21,310
旋转，然后加速， 

367
00:15:21,310 --> 00:15:24,680
然后几乎快要减速了。 

368
00:15:24,680 --> 00:15:26,980
为什么要这样的东西？ 

369
00:15:26,980 --> 00:15:28,440
好吧，例如，如果您

370
00:15:28,440 --> 00:15:31,880
在屏幕上将卡片从一个地方移动到另一个地方， 

371
00:15:31,880 --> 00:15:34,800
如果只是拿起步伐，那是一种突然。 

372
00:15:34,800 --> 00:15:36,050
这样做更好

373
00:15:37,110 --> 00:15:40,100
开始缓慢移动，然后移动，然后减速

374
00:15:40,100 --> 00:15:42,840
当它到达时，有点像一架飞机，对。 

375
00:15:42,840 --> 00:15:45,701
从跑道停止处开始，然后慢慢起飞

376
00:15:45,701 --> 00:15:48,490
然后飞到空中，时速达到500英里

377
00:15:48,490 --> 00:15:49,840
然后到达目的地机场

378
00:15:49,840 --> 00:15:52,630
然后减速到每小时100到150英里， 

379
00:15:52,630 --> 00:15:53,463
然后它降落。 

380
00:15:53,463 --> 00:15:57,470
这就是利率的曲线

381
00:15:57,470 --> 00:15:58,800
轻松进出。 

382
00:15:58,800 --> 00:16:00,950
您几乎总是希望事情动起来

383
00:16:00,950 --> 00:16:02,940
至少放松一下，放松一下

384
00:16:02,940 --> 00:16:05,150
如果不是下一个，那就是春天。 

385
00:16:05,150 --> 00:16:08,340
所以春天才是目的地

386
00:16:08,340 --> 00:16:09,960
然后有点反弹

387
00:16:09,960 --> 00:16:11,800
那里有一点软着陆

388
00:16:11,800 --> 00:16:14,190
稍微超出标记并弹回

389
00:16:14,190 --> 00:16:16,330
有点像弹簧连接它

390
00:16:16,330 --> 00:16:18,160
到目的地。 

391
00:16:18,160 --> 00:16:21,653
这些动画曲线使用户界面

392
00:16:21,653 --> 00:16:24,649
给用户带来更多舒适感，更少， 

393
00:16:24,649 --> 00:16:26,573
震颤，不那么突然。 

394
00:16:29,630 --> 00:16:31,680
所以我们来谈谈隐式动画

395
00:16:31,680 --> 00:16:34,650
当我认为我只是在描述一个明确的动画时， 

396
00:16:34,650 --> 00:16:36,650
接下来是我要描述的。 

397
00:16:36,650 --> 00:16:40,460
这些自动的，隐式的动画

398
00:16:40,460 --> 00:16:45,020
它们甚至不是我们制作动画的主要方式。 

399
00:16:45,020 --> 00:16:47,270
这可能取决于应用程序

400
00:16:47,270 --> 00:16:50,080
但大多数情况下，我们不会使用太多

401
00:16:50,080 --> 00:16:55,080
因为当您拥有一组视图时， 

402
00:16:55,360 --> 00:16:58,680
他们想一起做动画。 

403
00:16:58,680 --> 00:17:03,680
这就是为什么将.animation放在ZStack等容器上， 

404
00:17:04,000 --> 00:17:06,590
不只是，我们只是做得并不多。 

405
00:17:06,590 --> 00:17:09,250
因为如果ZStack里面有很多View 

406
00:17:09,250 --> 00:17:12,150
也许在那些大建筑物里面的景色， 

407
00:17:12,150 --> 00:17:15,580
这些视图要一起动画， 

408
00:17:15,580 --> 00:17:19,660
所有相同的持续时间，所有相同的曲线， 

409
00:17:19,660 --> 00:17:21,870
他们想保持同步。 

410
00:17:21,870 --> 00:17:26,360
显式动画是我们导致动画发生的地方

411
00:17:26,360 --> 00:17:29,210
都具有相同的持续时间，都具有相同的曲线

412
00:17:29,210 --> 00:17:31,600
一堆视图。 

413
00:17:31,600 --> 00:17:34,320
而我们要做的就是

414
00:17:34,320 --> 00:17:37,220
withAnimation函数，调用它

415
00:17:37,220 --> 00:17:39,530
这个参数是闭包， 

416
00:17:39,530 --> 00:17:41,540
在封闭内部，我们要做一些事情

417
00:17:41,540 --> 00:17:44,010
就像在我们的ViewModel上调用Intent一样， 

418
00:17:44,010 --> 00:17:46,540
那是我们在那里做的经典事情。 

419
00:17:46,540 --> 00:17:48,340
模型可以疯狂地改变

420
00:17:48,340 --> 00:17:50,520
我们的观点可能会发生疯狂的变化， 

421
00:17:50,520 --> 00:17:54,290
所有那些疯狂的改变都会一起发生

422
00:17:54,290 --> 00:17:57,920
与我们传递给withAnimation的动画有关。 

423
00:17:57,920 --> 00:18:00,980
在这里，我正在做两秒钟的线性动画。 

424
00:18:00,980 --> 00:18:04,130
所以所有的变化都将以线性速率发生

425
00:18:04,130 --> 00:18:05,933
在两秒钟的过程中。 

426
00:18:07,150 --> 00:18:09,360
现在，我在这里用Animation调用一个函数

427
00:18:09,360 --> 00:18:13,020
一个有两个参数，一个动画，然后是一个闭包， 

428
00:18:13,020 --> 00:18:14,400
调用这样的函数

429
00:18:14,400 --> 00:18:17,750
那更多是一种当务之急的编程方法。 

430
00:18:17,750 --> 00:18:20,420
我们知道SwiftUI主要是声明性的， 

431
00:18:20,420 --> 00:18:22,460
我们只是说一切的状态

432
00:18:22,460 --> 00:18:25,100
隐式动画是声明性的。 

433
00:18:25,100 --> 00:18:26,690
你只是在宣布

434
00:18:26,690 --> 00:18:29,960
当这些东西的这些修饰符改变时， 

435
00:18:29,960 --> 00:18:31,320
您将为其设置动画。 

436
00:18:31,320 --> 00:18:33,010
但这实际上是必须的。 

437
00:18:33,010 --> 00:18:36,340
在这里，我们告诉某人

438
00:18:36,340 --> 00:18:38,360
做这个并制作动画

439
00:18:38,360 --> 00:18:39,360
因此势在必行。 

440
00:18:39,360 --> 00:18:43,860
因此，SwiftUI代码中没有很多地方， 

441
00:18:43,860 --> 00:18:46,840
您在进行命令式编程的地方。 

442
00:18:46,840 --> 00:18:49,540
请记住，所有这些代码都必须在您的视图中， 

443
00:18:49,540 --> 00:18:51,730
因为ViewModels看不到View 

444
00:18:51,730 --> 00:18:52,980
所以他们不能这样做。 

445
00:18:52,980 --> 00:18:54,330
这一切都在您的视野中， 

446
00:18:54,330 --> 00:18:57,100
它就在您的SwiftUI代码中， 

447
00:18:57,100 --> 00:19:00,749
您在其中执行命令式代码（例如onTapGesture）， 

448
00:19:00,749 --> 00:19:02,210
点击视图，繁荣， 

449
00:19:02,210 --> 00:19:03,540
你要做一些当务之急， 

450
00:19:03,540 --> 00:19:07,240
您会说选择意图，选择卡片或其他任何东西。 

451
00:19:07,240 --> 00:19:11,120
这些就是发生的事情的地方

452
00:19:11,120 --> 00:19:12,940
就像轻按一样，只是其他手势

453
00:19:12,940 --> 00:19:14,740
我们将在下周学习。 

454
00:19:14,740 --> 00:19:17,643
那就是我们要调用动画的时候。 

455
00:19:19,081 --> 00:19:22,070
现在，正如我所说，动画是明确的， 

456
00:19:22,070 --> 00:19:24,390
通常包裹在Intent之类的东西周围， 

457
00:19:24,390 --> 00:19:25,880
一个ViewModel Intent。 

458
00:19:25,880 --> 00:19:28,340
但您也可以将其包裹在发生的事情周围

459
00:19:28,340 --> 00:19:29,240
仅在用户界面中。 

460
00:19:29,240 --> 00:19:31,760
例如，我正在谈论的编辑模式

461
00:19:31,760 --> 00:19:33,580
假设您要进入编辑模式

462
00:19:33,580 --> 00:19:37,960
和小图标将出现以删除内容或其他内容

463
00:19:37,960 --> 00:19:40,230
那些东西想要平滑地动画

464
00:19:40,230 --> 00:19:41,740
并出现在屏幕上。 

465
00:19:41,740 --> 00:19:44,920
因此，当用户

466
00:19:44,920 --> 00:19:49,920
点击按钮表示进入编辑模式或其他。 

467
00:19:50,200 --> 00:19:53,740
另一个必要的地方是按钮的动作。 

468
00:19:53,740 --> 00:19:56,090
我今天也会在演示中展示Buttons 

469
00:19:56,090 --> 00:19:58,440
然后您会看到Button的动作是另一个地方

470
00:19:58,440 --> 00:20:00,610
我们执行命令式代码，以及在可能的地方

471
00:20:00,610 --> 00:20:02,293
用withAnimation做类似的事情。 

472
00:20:03,430 --> 00:20:06,340
这又是红色，第二个红色的东西。 

473
00:20:06,340 --> 00:20:08,767
第一个是做事的红色

474
00:20:08,767 --> 00:20:11,290
.animation在容器视图上。 

475
00:20:11,290 --> 00:20:15,050
这是提醒您显式动画

476
00:20:15,050 --> 00:20:18,630
不要覆盖隐式动画。 

477
00:20:18,630 --> 00:20:21,090
假定隐式动画出现在“视图”上

478
00:20:21,090 --> 00:20:23,750
他们是独立的，他们独立工作， 

479
00:20:23,750 --> 00:20:25,630
任何动画对他们来说都有意义

480
00:20:25,630 --> 00:20:27,950
无论如何，对他们总是有意义的。 

481
00:20:27,950 --> 00:20:29,030
因此，如果有一个视图， 

482
00:20:29,030 --> 00:20:32,200
并且附有一个隐式动画

483
00:20:32,200 --> 00:20:35,100
那就要做那个隐式动画

484
00:20:35,100 --> 00:20:37,099
每当事情改变时。 

485
00:20:37,099 --> 00:20:38,980
即使有明确的动画

486
00:20:38,980 --> 00:20:40,330
同时进行。 

487
00:20:40,330 --> 00:20:42,340
对他们没有任何影响。 

488
00:20:42,340 --> 00:20:44,233
隐式地动画总是赢。 

489
00:20:46,670 --> 00:20:50,530
现在过渡指定如何为到达动画

490
00:20:50,530 --> 00:20:52,710
和视图的离开。 

491
00:20:52,710 --> 00:20:54,450
记住，这些视图必须放在容器中

492
00:20:54,450 --> 00:20:56,090
已经在屏幕上。 

493
00:20:56,090 --> 00:20:58,900
但是无论何时到达，都希望能够对其进行动画处理

494
00:20:58,900 --> 00:21:02,890
从外太空或其他物体中消失或飞入

495
00:21:02,890 --> 00:21:06,370
您想要该View到达的某种动画。 

496
00:21:06,370 --> 00:21:08,180
现在是过渡

497
00:21:08,180 --> 00:21:09,450
只是

498
00:21:09,450 --> 00:21:12,050
一对ViewModifiers，仅此而已

499
00:21:12,050 --> 00:21:14,480
ViewModifiers之一正在修改

500
00:21:14,480 --> 00:21:17,080
视图，那里应该是什么样子

501
00:21:17,080 --> 00:21:18,673
另一个正在修改视图的内容

502
00:21:18,673 --> 00:21:20,860
它不存在时应该看起来像。 

503
00:21:20,860 --> 00:21:24,380
换句话说，它还没有到达或刚刚离开， 

504
00:21:24,380 --> 00:21:26,240
那里的那个可能会有

505
00:21:26,240 --> 00:21:29,340
假设它是一种淡入淡出，它将从一个开始

506
00:21:29,340 --> 00:21:32,490
ViewModifier，它位于不透明度为1的位置， 

507
00:21:32,490 --> 00:21:36,260
然后另一个的ViewModifier是不透明度为零。 

508
00:21:36,260 --> 00:21:39,930
系统将在这两个ViewModifiers之间进行动画处理

509
00:21:39,930 --> 00:21:42,690
使那个东西出现或消失。 

510
00:21:42,690 --> 00:21:46,740
所以过渡实际上只是一个版本

511
00:21:46,740 --> 00:21:49,310
ViewModifier的参数更改

512
00:21:49,310 --> 00:21:52,090
导致过渡的就是这对修饰符。 

513
00:21:52,090 --> 00:21:54,370
这两个修饰符可以具有不同的参数

514
00:21:54,370 --> 00:21:56,130
就是这样，仅此而已。 

515
00:21:56,130 --> 00:21:57,600
所以过渡不是真的

516
00:21:57,600 --> 00:21:58,433
另一种动画

517
00:21:58,433 --> 00:22:01,580
这只是指定两个ViewModifiers的一种方式

518
00:22:01,580 --> 00:22:03,663
用于何时显示和消失视图。 

519
00:22:05,250 --> 00:22:09,150
那么我们如何指定我们想要的过渡

520
00:22:09,150 --> 00:22:12,030
动画外观时要使用的系统

521
00:22:12,030 --> 00:22:14,900
或给定视图的消失？ 

522
00:22:14,900 --> 00:22:16,980
记住过渡只是一对修饰符， 

523
00:22:16,980 --> 00:22:19,470
所以我们实质上只是要附加两个修饰符

524
00:22:19,470 --> 00:22:22,017
我们想要修改器在屏幕上显示的时间和修改器

525
00:22:22,017 --> 00:22:24,830
当不是视图时

526
00:22:24,830 --> 00:22:29,040
我们使用.transition附加此过渡， 

527
00:22:29,040 --> 00:22:31,160
非常简单的ViewModifier。 

528
00:22:31,160 --> 00:22:33,100
我要在这里以身作则， 

529
00:22:33,100 --> 00:22:36,110
我将使用两个内置的过渡。 

530
00:22:36,110 --> 00:22:38,850
一个叫做.scale，就是那里的蓝色

531
00:22:38,850 --> 00:22:42,630
另一个称为.identity，即紫色。 

532
00:22:42,630 --> 00:22:44,870
因此，.scale过渡

533
00:22:44,870 --> 00:22:49,210
它的两个ViewModifiers是框架修改器。 

534
00:22:49,210 --> 00:22:52,460
屏幕外的一帧为零， 

535
00:22:52,460 --> 00:22:55,230
屏幕上有一个全尺寸的框架

536
00:22:55,230 --> 00:22:56,900
只要它的正常大小。 

537
00:22:56,900 --> 00:23:01,900
因此，比例转换可将View从微小的位置放大和缩小， 

538
00:23:02,080 --> 00:23:06,616
零尺寸，最大尺寸为进出尺寸。 

539
00:23:06,616 --> 00:23:09,760
身份转换是一个有趣的过程， 

540
00:23:09,760 --> 00:23:12,720
它是ViewModifier不执行任何操作。 

541
00:23:12,720 --> 00:23:16,740
因此，既然消失之间没有任何变化， 

542
00:23:16,740 --> 00:23:19,230
当它在那里时，它会立即出现

543
00:23:19,230 --> 00:23:20,710
并立即消失。 

544
00:23:20,710 --> 00:23:22,480
换句话说，没有动画，因为

545
00:23:22,480 --> 00:23:25,350
两个ViewModifiers之间没有区别

546
00:23:25,350 --> 00:23:26,930
完全一样

547
00:23:26,930 --> 00:23:28,980
他们实际上并没有修改视图

548
00:23:28,980 --> 00:23:30,970
因此没有动画发生。 

549
00:23:30,970 --> 00:23:33,030
因此，bloop出现并消失。 

550
00:23:33,030 --> 00:23:34,760
有时候是这样

551
00:23:34,760 --> 00:23:36,440
当您制作动画时， 

552
00:23:36,440 --> 00:23:38,190
你有来来往往的景观， 

553
00:23:38,190 --> 00:23:39,860
也许你可能想要一个视图

554
00:23:39,860 --> 00:23:42,400
只是bloop出现而bloop消失

555
00:23:42,400 --> 00:23:44,380
而不是动画。 

556
00:23:44,380 --> 00:23:46,000
这不是默认值

557
00:23:46,000 --> 00:23:50,090
因此默认的过渡称为.opacity， 

558
00:23:50,090 --> 00:23:53,200
是淡入淡出，淡入淡出，正确。 

559
00:23:53,200 --> 00:23:54,290
这只是不透明

560
00:23:54,290 --> 00:23:55,940
我们上次了解到的

561
00:23:55,940 --> 00:23:58,137
出门时从一变为零

562
00:23:58,137 --> 00:24:00,320
从零到一

563
00:24:00,320 --> 00:24:01,830
所以我们在这种情况下进行了审核

564
00:24:01,830 --> 00:24:04,635
是不透明度ViewModifier。 

565
00:24:04,635 --> 00:24:06,890
让我们在这里看看这个ZStack， 

566
00:24:06,890 --> 00:24:09,894
基本上是我们的卡片

567
00:24:09,894 --> 00:24:12,050
这里简化。 

568
00:24:12,050 --> 00:24:13,627
幻灯片上只有这么多空间， 

569
00:24:13,627 --> 00:24:17,530
您可以从正面朝上看到卡片正面， 

570
00:24:17,530 --> 00:24:18,750
我得到了RoundedRectangles， 

571
00:24:18,750 --> 00:24:20,990
假设没有在此处指定所有内容， 

572
00:24:20,990 --> 00:24:22,170
但是你知道它们是什么。 

573
00:24:22,170 --> 00:24:25,230
而且我没有放.transition修饰符

574
00:24:25,230 --> 00:24:26,322
在RoundedRectangles上。 

575
00:24:26,322 --> 00:24:28,730
因此，他们将获得默认过渡， 

576
00:24:28,730 --> 00:24:31,177
这是不透明的。所以前面的RoundedRectangles 

577
00:24:31,177 --> 00:24:34,240
当它们来来去去时会淡入淡出。 

578
00:24:34,240 --> 00:24:36,417
但是我确实对文本进行了过渡

579
00:24:36,417 --> 00:24:38,220
那里的小鬼。 

580
00:24:38,220 --> 00:24:41,410
那将会无处不在

581
00:24:41,410 --> 00:24:45,450
然后在消失时将其缩小为零。 

582
00:24:45,450 --> 00:24:47,220
这就是.scale的意思。 

583
00:24:47,220 --> 00:24:49,350
然后背面的RoundedRectangle 

584
00:24:49,350 --> 00:24:51,540
我将过渡身份表示为

585
00:24:51,540 --> 00:24:54,010
当后面出现时，它会出现斑点

586
00:24:54,010 --> 00:24:57,220
它不会淡入或长出，它会出现斑点。 

587
00:24:57,220 --> 00:24:59,570
现在它会出现，同时

588
00:24:59,570 --> 00:25:02,500
正面将逐渐消失，变焦缩小

589
00:25:02,500 --> 00:25:03,333
与此同时。 

590
00:25:03,333 --> 00:25:05,680
所以这将不是一个很好的动画。 

591
00:25:05,680 --> 00:25:08,160
这是一种厨房水槽动画， 

592
00:25:08,160 --> 00:25:10,970
你永远不会这样做

593
00:25:10,970 --> 00:25:12,120
但我只想让你明白

594
00:25:12,120 --> 00:25:13,840
所有这些过渡是做什么的。 

595
00:25:13,840 --> 00:25:16,750
顺便说一下，您在这里看到了isFaceUp， 

596
00:25:16,750 --> 00:25:19,920
这只是ViewBuilder内部的条件，对吗？ 

597
00:25:19,920 --> 00:25:20,940
这是ZStack， 

598
00:25:20,940 --> 00:25:23,610
我们知道ZStack的内容是ViewBuilder。 

599
00:25:23,610 --> 00:25:25,450
在ViewBuilder中，它是一个View列表

600
00:25:25,450 --> 00:25:28,470
但是我们可以使用if-thens来包含或不包含某些内容， 

601
00:25:28,470 --> 00:25:30,490
好吧，当然，当我们包括它们时， 

602
00:25:30,490 --> 00:25:33,580
它们出现在屏幕上，因为我们不包含它们， 

603
00:25:33,580 --> 00:25:35,200
他们消失在屏幕上。 

604
00:25:35,200 --> 00:25:39,010
以及ViewBuilders中的这些if-thens 

605
00:25:39,010 --> 00:25:41,480
可能是第一种方法

606
00:25:41,480 --> 00:25:43,170
意见来来去去。 

607
00:25:43,170 --> 00:25:46,630
因此，当您对内容进行动画处理时

608
00:25:46,630 --> 00:25:49,850
一些诸如ZStack之类的ViewBuilder， 

609
00:25:49,850 --> 00:25:51,980
里面有条件

610
00:25:51,980 --> 00:25:53,170
您想考虑过渡， 

611
00:25:53,170 --> 00:25:54,996
因为那些事情会来来去去

612
00:25:54,996 --> 00:25:55,950
如果你不考虑的话

613
00:25:55,950 --> 00:25:57,370
您将会渐入渐出。 

614
00:25:57,370 --> 00:25:59,820
这是默认设置，但您可能需要一些东西

615
00:25:59,820 --> 00:26:01,995
看起来比那更好。 

616
00:26:01,995 --> 00:26:06,107
例如，视图来来去去的另一种方式是， 

617
00:26:06,107 --> 00:26:07,310
在ForEach中。 

618
00:26:07,310 --> 00:26:11,920
因此，ForEach采用了一系列可识别的事物， 

619
00:26:11,920 --> 00:26:13,460
并为他们制作视图。 

620
00:26:13,460 --> 00:26:15,400
好吧，如果该数组发生变化， 

621
00:26:15,400 --> 00:26:16,920
就像增加了新的东西， 

622
00:26:16,920 --> 00:26:18,946
或某些标识符被拔出， 

623
00:26:18,946 --> 00:26:22,260
它会添加新的视图或采用某些视图

624
00:26:22,260 --> 00:26:24,270
它是过去制造出来的。 

625
00:26:24,270 --> 00:26:26,400
那些观点将会来去去去。 

626
00:26:26,400 --> 00:26:28,020
您肯定会在作业中看到这一点

627
00:26:28,020 --> 00:26:30,140
第三，你要拿卡

628
00:26:30,140 --> 00:26:32,640
通过某些ForEach以某种方式显示在屏幕上

629
00:26:32,640 --> 00:26:34,270
也许在年级之内。 

630
00:26:34,270 --> 00:26:36,360
这是一个与众不同的游戏

631
00:26:36,360 --> 00:26:39,290
卡片在您正在做的游戏中来来往往。 

632
00:26:39,290 --> 00:26:41,880
记住卡片实际上总是在屏幕上， 

633
00:26:41,880 --> 00:26:43,600
即使他们匹配，他们也只是隐藏起来。 

634
00:26:43,600 --> 00:26:45,840
他们那里有一个空间

635
00:26:45,840 --> 00:26:47,100
但不必那样。 

636
00:26:47,100 --> 00:26:50,672
所以那些可能是第一和第二种方式

637
00:26:50,672 --> 00:26:53,100
视图来去去去：ViewBuilders中的条件事物

638
00:26:53,100 --> 00:26:56,100
以及诸如ForEach之类的在本质上有条件的事情

639
00:26:56,100 --> 00:26:58,750
为您构建视图。 

640
00:26:58,750 --> 00:27:00,330
好的，回到屏幕代码。 

641
00:27:00,330 --> 00:27:01,560
因此，让我们来看一下， 

642
00:27:01,560 --> 00:27:04,960
如果我们将isFaceUp从一件事更改为另一件事， 

643
00:27:04,960 --> 00:27:05,910
会发生什么？ 

644
00:27:05,910 --> 00:27:08,010
因此，如果我们将isFaceUp更改为false， 

645
00:27:08,010 --> 00:27:09,600
换句话说，我们想露背， 

646
00:27:09,600 --> 00:27:11,590
后面会立刻出现

647
00:27:11,590 --> 00:27:14,620
因为我们说过要转变为身份， 

648
00:27:14,620 --> 00:27:17,620
这意味着不要做任何修改。 

649
00:27:17,620 --> 00:27:18,600
所以没有动画

650
00:27:18,600 --> 00:27:20,930
所以它只是bloop立即出现。 

651
00:27:20,930 --> 00:27:23,610
文本将缩小为空， 

652
00:27:23,610 --> 00:27:25,410
因为它正在使用比例转换

653
00:27:25,410 --> 00:27:27,900
并且前面的RoundedRectangles会淡出

654
00:27:27,900 --> 00:27:29,110
因为他们没有过渡

655
00:27:29,110 --> 00:27:31,863
因此他们获得了默认的不透明度。 

656
00:27:31,863 --> 00:27:33,970
顺便说一下，如果isFaceUp更改为true， 

657
00:27:33,970 --> 00:27:36,020
isFaceUp必须在这里进行更改， 

658
00:27:36,020 --> 00:27:38,573
在进行显式动画制作时。 

659
00:27:38,573 --> 00:27:40,243
如果我们实际上没有动画， 

660
00:27:40,243 --> 00:27:42,430
那么这些过渡就没有任何意义，对。 

661
00:27:42,430 --> 00:27:44,670
这些过渡不会自己制作动画

662
00:27:44,670 --> 00:27:47,390
他们只是指定要使用的ViewModifiers， 

663
00:27:47,390 --> 00:27:49,420
发生动画时。 

664
00:27:49,420 --> 00:27:52,775
因此，如果isFaceUp从false更改为true， 

665
00:27:52,775 --> 00:27:56,235
现在背部会消失，只是消失了

666
00:27:56,235 --> 00:27:57,570
因为再次，它的过渡

667
00:27:57,570 --> 00:28:00,414
是标识ViewModifier。 

668
00:28:00,414 --> 00:28:03,190
因此，标识ViewModifier之间没有区别

669
00:28:03,190 --> 00:28:05,433
当它在那里或不在那里。就是这样

670
00:28:05,433 --> 00:28:08,270
它仍然不在屏幕上，所以它消失了。 

671
00:28:08,270 --> 00:28:10,550
文本将从无到有

672
00:28:10,550 --> 00:28:13,810
将从零尺寸开始，然后增长到正常尺寸。 

673
00:28:13,810 --> 00:28:16,040
从那以后，前面的RoundedRectangles 

674
00:28:16,040 --> 00:28:18,380
没有指定过渡，它们会淡入。 

675
00:28:18,380 --> 00:28:20,530
这将同时发生。 

676
00:28:22,890 --> 00:28:25,750
现在要考虑的一件事是过渡

677
00:28:25,750 --> 00:28:30,240
与动画不同，过渡不会重新分配

678
00:28:30,240 --> 00:28:32,080
到容器的内容视图。 

679
00:28:32,080 --> 00:28:34,000
记住，我告诉过你我们通常不放

680
00:28:34,000 --> 00:28:36,510
容器视图上的隐式动画， 

681
00:28:36,510 --> 00:28:38,980
因为它最终只是给那个动画

682
00:28:38,980 --> 00:28:40,410
里面的每一件事。 

683
00:28:40,410 --> 00:28:42,320
好吧，过渡并不能做到这一点。 

684
00:28:42,320 --> 00:28:46,190
过渡，当您将其放在ZStack或VStack上时

685
00:28:46,190 --> 00:28:48,120
现在正在谈论过渡

686
00:28:48,120 --> 00:28:51,600
当整个ZStack出现在屏幕上时

687
00:28:51,600 --> 00:28:53,070
或关闭屏幕。 

688
00:28:53,070 --> 00:28:56,330
因此，它不会将其分发到其内部。 

689
00:28:56,330 --> 00:28:59,200
它实际上是在谈论动画

690
00:28:59,200 --> 00:29:02,086
ZStack本身的来龙去脉。 

691
00:29:02,086 --> 00:29:05,060
现在Group和ForEach，这些是容器视图

692
00:29:05,060 --> 00:29:07,840
但是由于他们在屏幕上的任何地方都不会放任何东西， 

693
00:29:07,840 --> 00:29:11,390
他们实际上只是在分组或创建视图

694
00:29:11,390 --> 00:29:13,910
从可识别列表中， 

695
00:29:13,910 --> 00:29:16,510
他们确实将.transition分发到其内容视图。 

696
00:29:16,510 --> 00:29:18,880
因此，如果您说一堆东西， 

697
00:29:18,880 --> 00:29:20,150
你说.transition， 

698
00:29:20,150 --> 00:29:22,770
将会谈论其中的每一件事， 

699
00:29:22,770 --> 00:29:24,123
获得过渡。 

700
00:29:26,060 --> 00:29:27,860
这个.transition函数

701
00:29:27,860 --> 00:29:29,880
记得除了指定

702
00:29:29,880 --> 00:29:32,680
这两个ViewModifiers是什么。 

703
00:29:32,680 --> 00:29:35,770
在那里将单词transition视为一个名词。 

704
00:29:35,770 --> 00:29:38,900
这是要使用的过渡。 

705
00:29:38,900 --> 00:29:42,810
它不是动词，就像现在的视图过渡一样， 

706
00:29:42,810 --> 00:29:45,757
过渡仅在显式动画出现时发生

707
00:29:45,757 --> 00:29:47,080
正在进行。 

708
00:29:47,080 --> 00:29:50,810
那是过渡动画唯一发生的时间。 

709
00:29:50,810 --> 00:29:54,150
过渡实际上不适用于隐式动画。 

710
00:29:54,150 --> 00:29:57,290
如果您尝试制作隐式动画， 

711
00:29:57,290 --> 00:29:58,673
在带有过渡的视图上

712
00:29:58,673 --> 00:30:00,360
会有点困惑

713
00:30:00,360 --> 00:30:04,050
而且您可以了解为什么要记住，您知道， 

714
00:30:04,050 --> 00:30:06,180
显式动画用于动画

715
00:30:06,180 --> 00:30:08,360
协调了许多不同的观点

716
00:30:08,360 --> 00:30:10,510
当视图来来去去时。 

717
00:30:10,510 --> 00:30:13,180
隐式动画是独立的， 

718
00:30:13,180 --> 00:30:17,330
独立的工作视图，使它们的动画有意义。 

719
00:30:17,330 --> 00:30:20,190
在我看来，这并不像Views来来去去。 

720
00:30:20,190 --> 00:30:22,770
过渡不打算使用

721
00:30:22,770 --> 00:30:24,040
带有隐式动画

722
00:30:24,040 --> 00:30:27,220
它们将与显式动画一起使用。 

723
00:30:27,220 --> 00:30:29,490
这是过渡动画唯一发生的时间

724
00:30:29,490 --> 00:30:32,480
是在制作动画时。 

725
00:30:32,480 --> 00:30:35,250
转换只是说要使用什么ViewModifier， 

726
00:30:35,250 --> 00:30:36,930
您仍然必须设置动画。 

727
00:30:36,930 --> 00:30:39,400
顺便说一句，如果您在

728
00:30:39,400 --> 00:30:42,760
有过渡的东西，视图就来了， 

729
00:30:42,760 --> 00:30:45,300
它会做一些动画， 

730
00:30:45,300 --> 00:30:47,650
但这可能不会达到您的期望。 

731
00:30:48,840 --> 00:30:50,800
过渡API， 

732
00:30:50,800 --> 00:30:53,130
你知道，就像创建一个实际的过渡

733
00:30:53,130 --> 00:30:55,070
有点有趣。 

734
00:30:55,070 --> 00:30:58,120
并且已被类型擦除。 

735
00:30:58,120 --> 00:31:00,660
这意味着实际的过渡类型

736
00:31:00,660 --> 00:31:03,870
真正的过渡类型将是

737
00:31:03,870 --> 00:31:06,940
不在乎这是两个ViewModifiers 

738
00:31:06,940 --> 00:31:08,880
您正在使用的所有内容。 

739
00:31:08,880 --> 00:31:10,630
它们可能非常复杂。 

740
00:31:10,630 --> 00:31:13,960
我们正在尝试将它们作为.transition的参数传递

741
00:31:13,960 --> 00:31:16,130
我们不想那样，所以我们要简单。 

742
00:31:16,130 --> 00:31:19,290
.transition函数的参数

743
00:31:19,290 --> 00:31:22,010
被称为AnyTransition。 

744
00:31:22,010 --> 00:31:24,820
而且此AnyTransition是类型擦除的过渡。 

745
00:31:24,820 --> 00:31:27,213
想像一下， 

746
00:31:27,213 --> 00:31:32,090
那AnyTransition只是一个带有初始化程序的结构

747
00:31:32,090 --> 00:31:35,040
不用理会， 

748
00:31:35,040 --> 00:31:38,550
这是我们拥有修饰符和所有其他东西的过渡。 

749
00:31:38,550 --> 00:31:42,560
而且它只知道如何使用它进行过渡。 

750
00:31:42,560 --> 00:31:45,030
而您得到的只是AnyTransition 

751
00:31:45,030 --> 00:31:47,443
没有任何不在乎或任何业务。 

752
00:31:48,320 --> 00:31:52,160
如此擦除类型，就可以简化和丢失。 

753
00:31:52,160 --> 00:31:52,993
我们并没有真正失去它， 

754
00:31:52,993 --> 00:31:55,296
但我们看不到所有细节

755
00:31:55,296 --> 00:31:57,665
就像它使用的是哪种ViewModifiers， 

756
00:31:57,665 --> 00:32:00,499
我们在许多情况下都在Swift中做到了， 

757
00:32:00,499 --> 00:32:02,030
你甚至可以用View来做

758
00:32:02,030 --> 00:32:04,690
有一个名为AnyView的视图， 

759
00:32:04,690 --> 00:32:06,940
它的初始化程序将采用任何一种View 

760
00:32:06,940 --> 00:32:09,400
不管有多复杂并返回您的AnyView 

761
00:32:09,400 --> 00:32:11,310
并删除所有这些信息， 

762
00:32:11,310 --> 00:32:13,600
您现在将拥有一个称为AnyView的视图， 

763
00:32:13,600 --> 00:32:14,908
它是AnyView类型的

764
00:32:14,908 --> 00:32:17,240
你对里面的东西一无所知

765
00:32:17,240 --> 00:32:19,421
或修改过的内容，或全部都没有。 

766
00:32:19,421 --> 00:32:21,060
如果你不明白我在说什么

767
00:32:21,060 --> 00:32:23,090
关于类型擦除，不必太担心

768
00:32:23,090 --> 00:32:25,050
我们将在本季度晚些时候再次看到它。 

769
00:32:25,050 --> 00:32:26,890
但重要的是要意识到

770
00:32:26,890 --> 00:32:29,860
那AnyTransition只是一个结构。 

771
00:32:29,860 --> 00:32:32,860
它具有一些用于内置过渡的静态var 

772
00:32:32,860 --> 00:32:36,330
就像不透明，它可以动画化不透明度， 

773
00:32:36,330 --> 00:32:39,330
为框架修改器设置动画的比例

774
00:32:39,330 --> 00:32:42,550
使帧降为零然后返回。 

775
00:32:42,550 --> 00:32:45,290
您的作业有一个非常重要的过渡

776
00:32:45,290 --> 00:32:47,480
叫做offset CGSize， 

777
00:32:47,480 --> 00:32:50,940
这会导致视图在屏幕上移动

778
00:32:50,940 --> 00:32:54,580
来去去有些偏移。 

779
00:32:54,580 --> 00:32:57,500
好吧，在你的家庭作业中

780
00:32:57,500 --> 00:32:59,810
使您的卡片被处理

781
00:32:59,810 --> 00:33:02,450
从屏幕外飞到屏幕上

782
00:33:02,450 --> 00:33:06,060
所以您将要使用此偏移过渡

783
00:33:06,060 --> 00:33:07,453
对于那些意见。 

784
00:33:08,580 --> 00:33:11,600
您当然可以创建自己的过渡

785
00:33:11,600 --> 00:33:14,590
通过仅指定两个ViewModifiers。 

786
00:33:14,590 --> 00:33:18,370
屏幕上有东西时使用的修饰符

787
00:33:18,370 --> 00:33:21,920
并在不正确的时候使用，对，所以

788
00:33:21,920 --> 00:33:25,523
身份是开启时的状态，而活跃时则是活动的状态。 

789
00:33:27,610 --> 00:33:30,180
您还可以覆盖使用的动画

790
00:33:30,180 --> 00:33:32,700
如果您一直想要过渡，请进行过渡

791
00:33:32,700 --> 00:33:35,400
例如，要快或慢。 

792
00:33:35,400 --> 00:33:37,320
您可以使用此.animation 

793
00:33:37,320 --> 00:33:40,300
您对过渡的重视，好吧， 

794
00:33:40,300 --> 00:33:42,870
您知道吗，像.animation一样附加它。 

795
00:33:42,870 --> 00:33:44,950
不要被这个小东西弄糊涂

796
00:33:44,950 --> 00:33:46,650
这不是隐式动画， 

797
00:33:46,650 --> 00:33:49,640
隐式动画过渡，它们不能一起使用。 

798
00:33:49,640 --> 00:33:54,150
这只是覆盖持续时间的一种方法

799
00:33:54,150 --> 00:33:57,080
和曲线以及所有过渡动画

800
00:33:57,080 --> 00:33:58,763
这样总是这样。 

801
00:34:01,150 --> 00:34:05,840
过渡可能很棘手，并且有些令人沮丧

802
00:34:05,840 --> 00:34:07,720
有时候，当您第一次使用它们时， 

803
00:34:07,720 --> 00:34:11,110
因为这个限制

804
00:34:11,110 --> 00:34:13,437
具有视图的屏幕必须已经在屏幕上。 

805
00:34:13,437 --> 00:34:16,598
例如，在您的家庭作业三中， 

806
00:34:16,598 --> 00:34:21,350
您需要以动画方式分发卡片

807
00:34:21,350 --> 00:34:24,061
时尚到屏幕上。不能像在哪里记忆

808
00:34:24,061 --> 00:34:26,010
记住发射，哦， 

809
00:34:26,010 --> 00:34:27,730
屏幕上已经有卡片了。 

810
00:34:27,730 --> 00:34:31,315
不，必须暂时启动

811
00:34:31,315 --> 00:34:34,375
然后卡片飞起来并自动运行， 

812
00:34:34,375 --> 00:34:37,163
屏幕上会出现一种交易动画。 

813
00:34:38,120 --> 00:34:40,940
你如何摆脱这个难题

814
00:34:41,830 --> 00:34:44,905
包含卡片的视图必须首先出现在屏幕上

815
00:34:44,905 --> 00:34:46,297
然后在屏幕上显示之后

816
00:34:46,297 --> 00:34:51,221
那么您可以做一些导致卡片发生的事情。 

817
00:34:51,221 --> 00:34:55,700
View有一个很棒的功能可以帮助您

818
00:34:55,700 --> 00:34:58,610
叫做onAppear，非常简单。 

819
00:34:58,610 --> 00:35:00,367
有点像onTapGesture，对， 

820
00:35:00,367 --> 00:35:05,170
onTapGesture，在发生轻按时会调用此闭包， 

821
00:35:05,170 --> 00:35:08,520
执行一些代码，这是一样的， 

822
00:35:08,520 --> 00:35:13,170
当视图出现在屏幕上时，它将调用此代码。 

823
00:35:13,170 --> 00:35:15,265
所以我们将使用这个不错的小功能

824
00:35:15,265 --> 00:35:17,904
在我们的容器视图上。 

825
00:35:17,904 --> 00:35:20,665
在容器视图上，我们将添加onAppear 

826
00:35:20,665 --> 00:35:23,471
在该代码中，我们将进行更改

827
00:35:23,471 --> 00:35:26,538
我们模型中的某些东西可能使它

828
00:35:26,538 --> 00:35:29,720
所以那些不存在的卡， 

829
00:35:29,720 --> 00:35:31,710
当我的容器视图首次出现时， 

830
00:35:31,710 --> 00:35:32,979
关于他们的一些改变

831
00:35:32,979 --> 00:35:35,310
现在他们需要在那里。 

832
00:35:35,310 --> 00:35:37,410
现在，他们将在屏幕上播放动画。 

833
00:35:38,308 --> 00:35:41,629
我们正在使用这样的事实，我们知道您在Appear上知道

834
00:35:41,629 --> 00:35:43,559
我们的容器视图终于出现在屏幕上了

835
00:35:43,559 --> 00:35:48,036
继续对模型做一些意图，说，好吧， 

836
00:35:48,036 --> 00:35:50,410
您可以立即发卡。 

837
00:35:50,410 --> 00:35:52,275
所以模型必须以某种方式改变

838
00:35:52,275 --> 00:35:56,665
现在突然被扔进了视野， 

839
00:35:56,665 --> 00:35:59,780
因为视图只是反映了模型中的内容。 

840
00:35:59,780 --> 00:36:01,212
因此，如果模型说卡片在那里， 

841
00:36:01,212 --> 00:36:03,723
当应用启动时，它们将在那里。 

842
00:36:03,723 --> 00:36:06,560
因此，在应用启动时，卡片不必在那儿， 

843
00:36:06,560 --> 00:36:08,914
然后在容器上发生onAppear之后， 

844
00:36:08,914 --> 00:36:13,074
然后卡片在那里的地方发生了一些事情。 

845
00:36:13,074 --> 00:36:16,475
所以您已经得到了信息，我敢肯定， 

846
00:36:16,475 --> 00:36:19,160
实际的动画是由ViewModifiers完成的

847
00:36:19,160 --> 00:36:20,540
和形状。 

848
00:36:20,540 --> 00:36:23,622
它们是真正活跃的东西。 

849
00:36:23,622 --> 00:36:26,540
他们如何参与整个动画系统？ 

850
00:36:26,540 --> 00:36:29,673
ViewModifiers和Shapes，如何动画化？ 

851
00:36:29,673 --> 00:36:30,680
好吧，本质上， 

852
00:36:30,680 --> 00:36:33,770
动画系统将持续时间分开

853
00:36:33,770 --> 00:36:36,170
动画分成小块， 

854
00:36:36,170 --> 00:36:37,610
取决于曲线。 

855
00:36:37,610 --> 00:36:40,920
然后它只询问所有形状和ViewModifiers 

856
00:36:40,920 --> 00:36:41,980
可以动画的

857
00:36:41,980 --> 00:36:44,350
在这里，画这幅画，画这幅画，画这幅画，对， 

858
00:36:44,350 --> 00:36:45,680
只是一遍又一遍地吸引他们

859
00:36:45,680 --> 00:36:48,800
然后将其拼凑成小电影， 

860
00:36:48,800 --> 00:36:50,732
这是动画。 

861
00:36:50,732 --> 00:36:51,579
而已。 

862
00:36:51,579 --> 00:36:53,135
这件事就是这样

863
00:36:53,135 --> 00:36:57,743
要使它正常工作，它是非常优雅和简单的。 

864
00:36:58,660 --> 00:37:01,190
动画系统之间的通讯

865
00:37:01,190 --> 00:37:05,540
而ViewModifiers和Shapes只是一个变量， 

866
00:37:05,540 --> 00:37:08,230
此var animatableData。 

867
00:37:08,230 --> 00:37:11,290
这个animatableData在Animatable协议中， 

868
00:37:11,290 --> 00:37:13,350
这是那里唯一的变种。 

869
00:37:13,350 --> 00:37:16,410
您所要做的就是实现这一点。 

870
00:37:16,410 --> 00:37:18,930
如果您是Shape或ViewModifier， 

871
00:37:18,930 --> 00:37:22,653
您可以参加这个分段动画。 

872
00:37:23,540 --> 00:37:26,950
animatableData的类型是无关紧要的。 

873
00:37:26,950 --> 00:37:28,530
其实有点关怀

874
00:37:28,530 --> 00:37:31,097
因为该类型必须实现协议

875
00:37:31,097 --> 00:37:33,670
VectorArithmetic，这很有意义

876
00:37:33,670 --> 00:37:36,125
因为我们要使用这个animableData， 

877
00:37:36,125 --> 00:37:38,785
无论是角度的旋转

878
00:37:38,785 --> 00:37:42,540
派的东西，或者类似的东西

879
00:37:42,540 --> 00:37:43,910
我们将切成小块

880
00:37:43,910 --> 00:37:45,890
所以我们必须能够做一些数学运算

881
00:37:45,890 --> 00:37:49,983
用那条漂亮的曲线把它切成碎片

882
00:37:49,983 --> 00:37:52,940
所以类型几乎总是浮点数

883
00:37:52,940 --> 00:37:55,529
很多时候是浮动的，两倍的或CGFloat的

884
00:37:55,529 --> 00:37:58,490
因为我们正在这里做很多绘图。 

885
00:37:58,490 --> 00:38:01,004
但是还有另一个实现VectorArithmetic的结构

886
00:38:01,004 --> 00:38:04,270
叫做AnimatablePair真的很酷。 

887
00:38:04,270 --> 00:38:08,654
它将两个VectorArithmetic事物组合为一个

888
00:38:08,654 --> 00:38:10,670
动画VectorArithmetic事物。 

889
00:38:10,670 --> 00:38:12,370
当然，您可以拥有AnimatablePairs 

890
00:38:12,370 --> 00:38:13,800
AnimatablePairs。 

891
00:38:13,800 --> 00:38:16,615
因此，您可以拥有任意数量的动画对象。 

892
00:38:16,615 --> 00:38:19,870
另外，如果您有自己的复杂结构， 

893
00:38:19,870 --> 00:38:22,620
封装了动画数据， 

894
00:38:22,620 --> 00:38:24,873
您可以使其实现VectorArithmetic， 

895
00:38:24,873 --> 00:38:26,104
那只是一个协议。 

896
00:38:26,104 --> 00:38:28,790
它可以直接制作动画。 

897
00:38:28,790 --> 00:38:31,670
animatableData只能是某种东西

898
00:38:31,670 --> 00:38:34,070
可以切成小块。 

899
00:38:34,070 --> 00:38:36,677
因此，它必须实现VectorArithmetic。 

900
00:38:36,677 --> 00:38:39,720
正如我所说，这个变种正在双向交流

901
00:38:39,720 --> 00:38:40,930
动画系统之间

902
00:38:40,930 --> 00:38:43,170
以及Shapes和ViewModifiers。 

903
00:38:43,170 --> 00:38:44,623
因此，此var的设置

904
00:38:44,623 --> 00:38:46,248
这就是动画系统说的

905
00:38:46,248 --> 00:38:47,627
这是一小块，画出来， 

906
00:38:47,627 --> 00:38:49,300
这是一小块，画出来， 

907
00:38:49,300 --> 00:38:53,115
因此，这基本上是说曲线中的哪个位置， 

908
00:38:53,115 --> 00:38:56,030
你的一些动画数据是

909
00:38:56,030 --> 00:38:57,780
在这个动画中。 

910
00:38:57,780 --> 00:38:59,699
现在，获取var也对

911
00:38:59,699 --> 00:39:02,803
动画系统知道动画的开始和结束。 

912
00:39:04,908 --> 00:39:07,930
现在，这个animableData 

913
00:39:07,930 --> 00:39:10,774
通常是计算型变数，不是因为必须

914
00:39:10,774 --> 00:39:12,402
绝对不是必须的。 

915
00:39:12,402 --> 00:39:16,600
就像我们在Pie中的代码一样， 

916
00:39:16,600 --> 00:39:19,693
或者您知道我们的Cardify ViewModifier， 

917
00:39:19,693 --> 00:39:22,950
我们将对其进行修改，以便卡片翻转

918
00:39:22,950 --> 00:39:23,783
它旋转了。 

919
00:39:23,783 --> 00:39:25,874
所以在那边，我真的很想称呼轮换

920
00:39:25,874 --> 00:39:27,864
我的翻转卡“旋转” 

921
00:39:27,864 --> 00:39:29,745
我不想称它为animatableData 

922
00:39:29,745 --> 00:39:31,666
这不是var的好名字。 

923
00:39:31,666 --> 00:39:33,804
所以很多时候我们要创建一个计算变量

924
00:39:33,804 --> 00:39:38,085
只是本质上重命名一些内部变量

925
00:39:38,085 --> 00:39:40,343
这样动画系统才能看到它。 

926
00:39:41,465 --> 00:39:43,555
因此，让我们开始进行演示。 

927
00:39:43,555 --> 00:39:46,524
我们将在这里做很多动画工作。 

928
00:39:46,524 --> 00:39:49,700
我们将做隐式动画， 

929
00:39:49,700 --> 00:39:51,004
但显然是做明确的动画

930
00:39:51,004 --> 00:39:52,704
我们要过渡

931
00:39:52,704 --> 00:39:55,410
我们将要修改一个ViewModifier， 

932
00:39:55,410 --> 00:39:58,540
我们将修改Shape的所有内容， 

933
00:39:58,540 --> 00:40:00,265
这是一个很大的，很长的演示。 

934
00:40:00,265 --> 00:40:02,583
因此，让我们现在就深入研究它。 

935
00:40:04,170 --> 00:40:05,960
让我们在这里开始动画演示

936
00:40:05,960 --> 00:40:08,185
带有一些隐式动画。 

937
00:40:08,185 --> 00:40:10,104
再次，这是一个动画，我们将要

938
00:40:10,104 --> 00:40:12,697
有一些非常独立的动画

939
00:40:12,697 --> 00:40:15,525
无论如何，它总是适用。 

940
00:40:15,525 --> 00:40:19,484
它并没有真正与许多其他活动协调

941
00:40:19,484 --> 00:40:21,590
在动画系统中进行。 

942
00:40:21,590 --> 00:40:25,872
为此我们要做的是拥有表情符号

943
00:40:25,872 --> 00:40:27,651
真的很兴奋并庆祝

944
00:40:27,651 --> 00:40:31,604
当他们通过翻筋斗来比赛时。 

945
00:40:31,604 --> 00:40:35,374
所以翻筋斗实际上是在旋转

946
00:40:35,374 --> 00:40:37,070
周围的表情符号。 

947
00:40:37,070 --> 00:40:39,280
旋转真的很容易

948
00:40:39,280 --> 00:40:41,751
在SwiftUI中，有一个ViewModifier 

949
00:40:41,751 --> 00:40:44,060
因为它称为旋转效果。 

950
00:40:44,060 --> 00:40:47,807
所以我要去这里查看我的文字，这是我的表情符号， 

951
00:40:47,807 --> 00:40:52,256
我只是要添加旋转效果

952
00:40:52,256 --> 00:40:53,370
在上面。 

953
00:40:53,370 --> 00:40:56,940
它需要一个角度，所以我要做角度。 

954
00:40:56,940 --> 00:40:59,268
我们在做Pie时就知道了这一点。 

955
00:40:59,268 --> 00:41:01,423
我要说的是，如果卡片匹配， 

956
00:41:01,423 --> 00:41:05,032
然后让我们开始颠倒一下， 

957
00:41:05,032 --> 00:41:08,071
180度旋转

958
00:41:08,071 --> 00:41:10,163
我们最终将不得不进行完全的翻筋斗

959
00:41:10,163 --> 00:41:11,570
一路走来

960
00:41:12,550 --> 00:41:13,383
并运行。 

961
00:41:17,800 --> 00:41:19,700
点击卡片，我们正在寻找比赛。 

962
00:41:19,700 --> 00:41:21,783
哦，有，它倒过来了

963
00:41:21,783 --> 00:41:25,132
但在那里没有做任何形式的动画。 

964
00:41:25,132 --> 00:41:26,753
就和bloop匹配了

965
00:41:26,753 --> 00:41:28,115
他们颠倒了。 

966
00:41:28,115 --> 00:41:30,585
那么我们该如何制作动画呢？ 

967
00:41:30,585 --> 00:41:33,502
好吧，假设我一直想翻筋斗

968
00:41:33,502 --> 00:41:34,786
当卡片匹配时， 

969
00:41:34,786 --> 00:41:36,905
我要做的就是在这里隐式动画

970
00:41:36,905 --> 00:41:39,283
并说动画。 

971
00:41:40,280 --> 00:41:43,840
我只指定动画的参数。 

972
00:41:43,840 --> 00:41:48,060
所以我要让这个动画是线性的

973
00:41:48,060 --> 00:41:52,300
我们将持续一秒钟。 

974
00:41:52,300 --> 00:41:55,690
我们在讲座中谈到的这个动画对象

975
00:41:55,690 --> 00:41:57,910
这绝对是您想要的那种东西

976
00:41:57,910 --> 00:42:01,195
查看此处的开发人员文档， 

977
00:42:01,195 --> 00:42:03,695
我们可以看到所有不同种类的动画

978
00:42:03,695 --> 00:42:07,336
easeIn，easyInOut，线性等所有其他内容。 

979
00:42:07,336 --> 00:42:09,737
我说我们可以做：延迟动画， 

980
00:42:09,737 --> 00:42:13,147
显然会创建具有一定持续时间的内容。 

981
00:42:13,147 --> 00:42:15,740
这是所有需要学习的温泉

982
00:42:15,740 --> 00:42:17,587
关于动画。 

983
00:42:17,587 --> 00:42:20,320
今天我们将做很多这样的事情。 

984
00:42:20,320 --> 00:42:23,020
因此，让我们尝试一下，看看是否可行。 

985
00:42:23,020 --> 00:42:26,117
现在，这会在一秒钟内实现吗， 

986
00:42:26,117 --> 00:42:28,869
这是一个，哦，哇， 

987
00:42:28,869 --> 00:42:32,754
好吧，其中一个动画在这里，而不是两个。 

988
00:42:32,754 --> 00:42:33,923
让我们尝试另一个。 

989
00:42:33,923 --> 00:42:37,203
但同样，它会在一秒钟内完成该动画

990
00:42:37,203 --> 00:42:40,630
做到这一点，但它没有做到这一点。 

991
00:42:40,630 --> 00:42:44,043
现在，事实是，它仅执行其中一项操作， 

992
00:42:44,043 --> 00:42:45,488
有一个很好的理由

993
00:42:45,488 --> 00:42:47,348
我们稍后再讲。 

994
00:42:47,348 --> 00:42:49,279
现在，让我们确定一个正在运行的

995
00:42:49,279 --> 00:42:50,607
在做我们想要的。 

996
00:42:50,607 --> 00:42:55,030
让我们说360 

997
00:42:55,030 --> 00:42:56,213
所以一直。 

998
00:43:01,660 --> 00:43:03,560
我们正在尝试找到一个匹配的配对， 

999
00:43:03,560 --> 00:43:05,184
喔，一直到处翻筋斗。 

1000
00:43:05,184 --> 00:43:06,640
这些家伙呢？ 

1001
00:43:06,640 --> 00:43:11,110
喔，也许一旦配对，我们很兴奋

1002
00:43:11,110 --> 00:43:13,620
我们只是想继续前进或翻筋斗。 

1003
00:43:13,620 --> 00:43:15,439
让我们来看看这里的动画

1004
00:43:15,439 --> 00:43:19,543
这个线性动画，让我们重复RepeatForever。 

1005
00:43:23,250 --> 00:43:24,278
所以它正在做相同的动画

1006
00:43:24,278 --> 00:43:26,476
只是现在它会继续前进。 

1007
00:43:26,476 --> 00:43:29,030
现在的事情是，注意它确实做到了

1008
00:43:29,030 --> 00:43:30,430
但是它有点颠倒了自己

1009
00:43:30,430 --> 00:43:32,535
然后它再次执行并反转自身。 

1010
00:43:32,535 --> 00:43:33,870
这真的不是我们想要的

1011
00:43:33,870 --> 00:43:35,121
我们想四处走走。 

1012
00:43:35,121 --> 00:43:39,990
幸运的是，repeatForever在这里有一个争论， 

1013
00:43:39,990 --> 00:43:43,740
这是自动反转，我们会说自动反转为假， 

1014
00:43:43,740 --> 00:43:45,050
我们不希望它扭转

1015
00:43:45,050 --> 00:43:47,987
我们只想不断重复播放该动画。 

1016
00:43:47,987 --> 00:43:49,745
那是因为这个动画返回

1017
00:43:49,745 --> 00:43:51,305
到它开始的地方，所以很有意义

1018
00:43:51,305 --> 00:43:54,302
不断做下去。 

1019
00:43:54,302 --> 00:43:55,985
关于这个动画的唯一一件事

1020
00:43:55,985 --> 00:43:59,068
想在这里稍微小心一点的是

1021
00:44:00,741 --> 00:44:02,110
最终我们要添加一个新游戏

1022
00:44:02,110 --> 00:44:03,480
你在家庭作业中所做的

1023
00:44:03,480 --> 00:44:06,740
当我们这样做时，这些视图将被重用。 

1024
00:44:06,740 --> 00:44:08,810
而且我们不希望这个动画开始

1025
00:44:08,810 --> 00:44:09,643
在一个新游戏中。 

1026
00:44:09,643 --> 00:44:13,567
因此，从本质上讲，只要卡不匹配， 

1027
00:44:13,567 --> 00:44:17,300
我们不想永远重复一次。 

1028
00:44:17,300 --> 00:44:18,857
因此，无论何时您进行重复的永久动画， 

1029
00:44:18,857 --> 00:44:20,893
您要小心将其关闭

1030
00:44:20,893 --> 00:44:22,724
当它不再适用时。 

1031
00:44:22,724 --> 00:44:27,052
您只需说出卡片是否匹配即可在此处进行操作。 

1032
00:44:27,052 --> 00:44:29,562
我们将永远重复这一过程。 

1033
00:44:29,562 --> 00:44:31,690
但是否则，我们要回去做

1034
00:44:31,690 --> 00:44:34,070
不管默认动画是什么。 

1035
00:44:34,070 --> 00:44:37,893
就像别再做这个动画了。 

1036
00:44:38,861 --> 00:44:41,229
确保没有破坏任何东西。 

1037
00:44:41,229 --> 00:44:42,259
我们去比赛了。 

1038
00:44:42,259 --> 00:44:44,279
Who，它在工作

1039
00:44:44,279 --> 00:44:45,623
它正在工作。 

1040
00:44:48,440 --> 00:44:50,860
现在，我们完成了此隐式动画。 

1041
00:44:50,860 --> 00:44:54,308
让我们继续做一个明确的动画。 

1042
00:44:54,308 --> 00:44:56,798
在做显式动画之前， 

1043
00:44:56,798 --> 00:45:00,030
我将执行您所做的一些工作

1044
00:45:00,030 --> 00:45:01,514
特别是在您的作业中， 

1045
00:45:01,514 --> 00:45:04,224
我要实施洗牌

1046
00:45:04,224 --> 00:45:07,490
而且我还要实施新游戏。 

1047
00:45:07,490 --> 00:45:08,323
洗牌， 

1048
00:45:08,323 --> 00:45:10,993
这是一个简单的到这里的模型

1049
00:45:10,993 --> 00:45:13,453
当我们创建卡片时， 

1050
00:45:13,453 --> 00:45:16,293
我只是说cards.shuffle。 

1051
00:45:17,270 --> 00:45:19,527
显然，如果您还没有做完一项作业， 

1052
00:45:19,527 --> 00:45:22,440
希望您不会观看此视频。 

1053
00:45:22,440 --> 00:45:25,420
但是接下来我要做新游戏

1054
00:45:25,420 --> 00:45:28,760
我们在那里有新游戏，这是第二本作业。 

1055
00:45:28,760 --> 00:45:30,040
希望您已经完成了第二个作业， 

1056
00:45:30,040 --> 00:45:31,705
这是在本次讲座之前。 

1057
00:45:31,705 --> 00:45:33,760
但是如果您还没有完成两个作业， 

1058
00:45:33,760 --> 00:45:36,350
现在该暂停该视频了， 

1059
00:45:36,350 --> 00:45:39,175
去提交你的作业二，然后回来

1060
00:45:39,175 --> 00:45:41,673
并继续观看。 

1061
00:45:41,673 --> 00:45:45,945
因此，使用cards.shuffle可以修复好那根衬纸。 

1062
00:45:45,945 --> 00:45:49,233
喔，这两个东西现在都洗了

1063
00:45:49,233 --> 00:45:50,850
彼此相邻。 

1064
00:45:50,850 --> 00:45:54,213
好吧，我们仍然可以匹配它们。 

1065
00:45:54,213 --> 00:45:56,640
好吧，新游戏怎么样， 

1066
00:45:56,640 --> 00:46:01,640
新游戏要求我们在ViewModel中有一个Intent， 

1067
00:46:01,863 --> 00:46:03,902
就像我们有选择卡片的意图一样， 

1068
00:46:03,902 --> 00:46:07,105
我们将需要一个意图来创建一个新游戏。 

1069
00:46:07,105 --> 00:46:10,020
所以我叫这个resetGame 

1070
00:46:10,020 --> 00:46:13,270
我将通过创建一个新模型来重置游戏

1071
00:46:13,270 --> 00:46:16,483
我会说Model = EmojiMemoryGame.createMemoryGame 

1072
00:46:20,648 --> 00:46:22,748
创建新的记忆游戏， 

1073
00:46:22,748 --> 00:46:24,106
这就是我要做的。 

1074
00:46:24,106 --> 00:46:25,943
显然这将改变模型

1075
00:46:25,943 --> 00:46:28,793
这将导致这个ObservableObject 

1076
00:46:28,793 --> 00:46:30,840
因为此模型是@Published， 

1077
00:46:30,840 --> 00:46:34,388
所有这些都会发生，我们的整体视图将会重绘

1078
00:46:34,388 --> 00:46:36,291
因为这种变化。 

1079
00:46:36,291 --> 00:46:39,479
所以现在我需要在用户界面的某个位置添加一个按钮，对吗？ 

1080
00:46:39,479 --> 00:46:41,964
在我的界面中，我实际上没有新的游戏按钮， 

1081
00:46:41,964 --> 00:46:44,337
我无法让新游戏出现。 

1082
00:46:44,337 --> 00:46:48,550
因此，我将在底部非常简单的方法中添加一个新按钮。 

1083
00:46:48,550 --> 00:46:50,863
我要把我的纸牌放在这里

1084
00:46:50,863 --> 00:46:53,591
在VStack中

1085
00:46:53,591 --> 00:46:55,470
与

1086
00:46:55,470 --> 00:46:56,900
一个按钮。 

1087
00:46:56,900 --> 00:46:58,230
我们没有谈论巴顿

1088
00:46:58,230 --> 00:47:00,910
我没想到你在第二作业中

1089
00:47:00,910 --> 00:47:03,443
一定要做一个按钮， 

1090
00:47:03,443 --> 00:47:05,910
您可以轻松完成文本

1091
00:47:05,910 --> 00:47:09,244
在那儿使用onTapGesture可以了。 

1092
00:47:09,244 --> 00:47:10,840
但是当我们在这里时，让我们继续

1093
00:47:10,840 --> 00:47:12,480
并了解有关Button的知识。 

1094
00:47:12,480 --> 00:47:13,313
按钮很简单

1095
00:47:13,313 --> 00:47:16,640
它只有一个动作，需要执行一些关闭操作

1096
00:47:16,640 --> 00:47:17,800
当按钮被按下时。 

1097
00:47:17,800 --> 00:47:19,223
然后有这个标签

1098
00:47:19,223 --> 00:47:22,940
实际上，这就是您要成为标签的任何视图。 

1099
00:47:22,940 --> 00:47:26,120
所以我要在这里贴上文字标签

1100
00:47:26,120 --> 00:47:28,732
上面写着“新游戏”。 

1101
00:47:28,732 --> 00:47:31,940
就我将要采取的行动而言， 

1102
00:47:31,940 --> 00:47:33,770
让我们双击那里。 

1103
00:47:33,770 --> 00:47:37,999
我要执行刚才提到的Intent。 

1104
00:47:37,999 --> 00:47:40,757
所以self.viewModel.resetgame。 

1105
00:47:42,015 --> 00:47:44,523
通常，当用户界面发生问题时， 

1106
00:47:44,523 --> 00:47:47,801
就像我们点击卡片或单击按钮一样， 

1107
00:47:47,801 --> 00:47:49,420
我们要去做

1108
00:47:49,420 --> 00:47:50,590
两种意图

1109
00:47:50,590 --> 00:47:53,080
否则我们将要做一些完全

1110
00:47:53,080 --> 00:47:56,004
只影响用户界面，只是以某种方式调整用户界面

1111
00:47:56,004 --> 00:47:58,720
它并不会真正影响我们模型中的内容。 

1112
00:47:58,720 --> 00:48:00,339
让我们看看我们的新游戏Button是否有效。 

1113
00:48:00,339 --> 00:48:04,259
我们单击此处运行，嗯，下面有我们的新游戏

1114
00:48:04,259 --> 00:48:05,840
然后我们单击。 

1115
00:48:05,840 --> 00:48:06,950
让我们看看它在做什么。 

1116
00:48:06,950 --> 00:48:08,537
我们到了那里，有了新游戏。 

1117
00:48:08,537 --> 00:48:12,817
哇，是的，它确实改组了他们，在那里放了新卡。 

1118
00:48:12,817 --> 00:48:14,553
好吧，让我们看看是否有一些卡匹配

1119
00:48:14,553 --> 00:48:16,013
然后把它们放回去。 

1120
00:48:16,013 --> 00:48:18,007
因此，我们的新游戏Button正常运行。 

1121
00:48:18,007 --> 00:48:21,380
顺便说一句，这里使用Button和有什么区别

1122
00:48:21,380 --> 00:48:23,745
和带有onTapGesture的文本？ 

1123
00:48:23,745 --> 00:48:28,127
好吧，Button很强大，它知道这是一个Button。 

1124
00:48:28,127 --> 00:48:30,480
因此，由于它出现在不同的平台上， 

1125
00:48:30,480 --> 00:48:32,668
也许是Apple TV或Apple Watch等等

1126
00:48:32,668 --> 00:48:34,890
它会以某种方式绘制此按钮

1127
00:48:34,890 --> 00:48:36,657
在那个平台上有意义。 

1128
00:48:36,657 --> 00:48:38,627
尽管我们使用onTapGesture进行文本处理， 

1129
00:48:38,627 --> 00:48:40,604
它总是看起来像一段文字

1130
00:48:40,604 --> 00:48:41,765
我们点击。 

1131
00:48:41,765 --> 00:48:44,788
所以我们总是想用一个按钮来实现

1132
00:48:44,788 --> 00:48:46,250
当我们做一个按钮。 

1133
00:48:46,250 --> 00:48:49,429
我们不想做一个文本onTapGesture解决方案。 

1134
00:48:49,429 --> 00:48:51,679
我想提及的另一件事，就是我们在这里

1135
00:48:51,679 --> 00:48:55,050
是这个红色的“ New Game”字符串。 

1136
00:48:55,050 --> 00:48:57,010
这些琴弦是红色的，我很高兴它们是红色的。 

1137
00:48:57,010 --> 00:49:00,110
红色通常表示我会注意并且确实

1138
00:49:00,110 --> 00:49:02,219
您确实要注意红色的弦， 

1139
00:49:02,219 --> 00:49:04,445
如果您有红色的弦将出现

1140
00:49:04,445 --> 00:49:07,640
在用户面前，您需要做一些工作， 

1141
00:49:07,640 --> 00:49:08,625
我们现在不讨论

1142
00:49:08,625 --> 00:49:10,785
使它们国际化。 

1143
00:49:10,785 --> 00:49:12,866
这样你可以说

1144
00:49:12,866 --> 00:49:16,155
法语，中文或阿拉伯文的新游戏

1145
00:49:16,155 --> 00:49:18,975
或任何必须解决的问题。 

1146
00:49:18,975 --> 00:49:21,810
因此，我们不再谈论这个， 

1147
00:49:21,810 --> 00:49:23,630
如果您对此有兴趣， 

1148
00:49:23,630 --> 00:49:25,191
也许通过查看开始文档

1149
00:49:25,191 --> 00:49:28,640
在称为localizedString键的位置。 

1150
00:49:28,640 --> 00:49:30,223
那是至少获得你的弦乐的一种方法

1151
00:49:30,223 --> 00:49:32,120
开始本地化。 

1152
00:49:32,120 --> 00:49:34,119
还有其他地方也需要本地化

1153
00:49:34,119 --> 00:49:37,292
像日期之类的东西，日期出现的方式有所不同。 

1154
00:49:37,292 --> 00:49:38,931
再说一次，我们没有时间谈论这个。 

1155
00:49:38,931 --> 00:49:40,351
今天我们在谈论动画。 

1156
00:49:40,351 --> 00:49:42,900
我只想提个提要，那就是事情， 

1157
00:49:42,900 --> 00:49:45,529
我们最终要小心的地方

1158
00:49:45,529 --> 00:49:47,683
关于我们放在这里的弦乐。 

1159
00:49:49,200 --> 00:49:51,020
好吧，新游戏成功了

1160
00:49:51,020 --> 00:49:55,060
但是正如我们在这里看到的那样，它没有激活动画， 

1161
00:49:55,060 --> 00:49:57,520
这样做，哇，它马上就变了。 

1162
00:49:57,520 --> 00:49:58,353
没有动画。 

1163
00:49:58,353 --> 00:50:01,145
所以我们希望整个过程都充满生气， 

1164
00:50:01,145 --> 00:50:03,595
事实证明，这确实很容易

1165
00:50:03,595 --> 00:50:05,076
使用显式动画， 

1166
00:50:05,076 --> 00:50:09,270
我们将包装这个重置游戏，它产生了很大的影响

1167
00:50:09,270 --> 00:50:10,993
在我们的模型上，并更改了所有卡片。 

1168
00:50:10,993 --> 00:50:13,960
好吧，所有这些更改，我们都可以制作动画

1169
00:50:13,960 --> 00:50:17,170
在此处用animation编写了简单的一行代码。 

1170
00:50:17,170 --> 00:50:19,076
就像我们做隐式动画一样， 

1171
00:50:19,076 --> 00:50:22,330
我们将指定所需的动画。 

1172
00:50:22,330 --> 00:50:25,295
我要使用easyInOut。注意我没有打字

1173
00:50:25,295 --> 00:50:30,295
完整的动画点easeInOut，Swift可以推断出

1174
00:50:30,717 --> 00:50:34,704
这是withAnimation的明显论点。 

1175
00:50:34,704 --> 00:50:38,200
然后需要一个闭包，不带任何参数， 

1176
00:50:38,200 --> 00:50:39,033
不返回任何参数， 

1177
00:50:39,033 --> 00:50:40,707
您可以在此处放置任何所需的代码。 

1178
00:50:40,707 --> 00:50:44,063
无论这对我们的UI造成了什么影响， 

1179
00:50:44,063 --> 00:50:45,940
它会变得生动起来。 

1180
00:50:45,940 --> 00:50:47,940
让我们看看这样做的样子。 

1181
00:50:51,640 --> 00:50:54,567
喔，我的天哪，实际上是一大堆

1182
00:50:54,567 --> 00:50:58,070
那里的动画效果很好。 

1183
00:50:58,070 --> 00:51:00,290
现在，如果我们想看看这里到底发生了什么

1184
00:51:00,290 --> 00:51:02,420
因为那里还有其他东西

1185
00:51:02,420 --> 00:51:04,340
持续褪色

1186
00:51:04,340 --> 00:51:08,200
我们可以通过easyInOut来更改持续时间

1187
00:51:08,200 --> 00:51:11,200
持续时间的动画，例如， 

1188
00:51:11,200 --> 00:51:13,420
两三秒。 

1189
00:51:13,420 --> 00:51:14,695
我会放慢动画的速度， 

1190
00:51:14,695 --> 00:51:16,630
我总是建议这样做

1191
00:51:16,630 --> 00:51:19,183
当你做动画的时候是放慢脚步

1192
00:51:19,183 --> 00:51:20,500
看看发生了什么。 

1193
00:51:20,500 --> 00:51:22,743
因此，我们开始尝试新游戏。 

1194
00:51:23,790 --> 00:51:27,396
好吧，看到卡片逐渐消失，朝下， 

1195
00:51:27,396 --> 00:51:30,511
他们就搬到了新位置。 

1196
00:51:30,511 --> 00:51:33,361
这就是动画。 

1197
00:51:33,361 --> 00:51:35,350
那么为什么会这样呢？ 

1198
00:51:35,350 --> 00:51:36,260
这些东西正在消失， 

1199
00:51:36,260 --> 00:51:41,260
那个幽灵，看到他淡出，回到他的卡背上？ 

1200
00:51:41,540 --> 00:51:42,373
那是因为我告诉你

1201
00:51:42,373 --> 00:51:45,000
那过渡

1202
00:51:45,000 --> 00:51:46,860
默认情况下

1203
00:51:46,860 --> 00:51:48,150
不透明。 

1204
00:51:48,150 --> 00:51:49,936
当我们切换时发生了什么

1205
00:51:49,936 --> 00:51:52,257
它正在过渡到新的视图

1206
00:51:52,257 --> 00:51:54,860
所以我们只是在淡化新的

1207
00:51:54,860 --> 00:51:56,750
并将旧的褪色。 

1208
00:51:56,750 --> 00:51:58,661
我们真的不想要那个，我们想要我们的卡片

1209
00:51:58,661 --> 00:52:00,830
他们走时实际上要翻身

1210
00:52:00,830 --> 00:52:03,460
从后到前，从前到后， 

1211
00:52:03,460 --> 00:52:05,720
我们将在几分钟后解决此问题。 

1212
00:52:05,720 --> 00:52:09,440
但首先，让我们使用显式动画的相同功能

1213
00:52:09,440 --> 00:52:12,401
为此，请点击卡片上的动画， 

1214
00:52:12,401 --> 00:52:13,557
因为现在非常突然

1215
00:52:13,557 --> 00:52:16,797
如果您点击卡片，事情就会立即出现

1216
00:52:16,797 --> 00:52:18,660
这样不好

1217
00:52:18,660 --> 00:52:21,780
同样，在这里我们选择卡片

1218
00:52:21,780 --> 00:52:25,471
从我们可以用动画说的命令性代码中

1219
00:52:25,471 --> 00:52:28,869
让我们继续前进，使其成为线性动画

1220
00:52:28,869 --> 00:52:31,591
而且我们会尽可能长，这样我们才能真正

1221
00:52:31,591 --> 00:52:34,800
看到它的实际效果，看看发生了什么。 

1222
00:52:34,800 --> 00:52:37,220
在内部，我们会做我们将要做的一切， 

1223
00:52:37,220 --> 00:52:39,044
那会导致很多变化发生

1224
00:52:39,044 --> 00:52:41,293
并且所有这些更改都将被动画化。 

1225
00:52:46,415 --> 00:52:49,770
好的，我们去点击

1226
00:52:49,770 --> 00:52:53,724
我们可以看到我们正在逐渐淡出

1227
00:52:53,724 --> 00:52:55,240
当我们选择一张卡时。 

1228
00:52:55,240 --> 00:52:57,814
并请注意，我点击了这张卡片，但它动画了

1229
00:52:57,814 --> 00:52:59,594
发生的所有变化，包括

1230
00:52:59,594 --> 00:53:03,168
这些其他卡片朝下翻转。 

1231
00:53:03,168 --> 00:53:06,180
这样，当您放置此显式动画时， 

1232
00:53:06,180 --> 00:53:08,220
它将使发生的一切动画

1233
00:53:08,220 --> 00:53:10,561
做在那里的事的结果。 

1234
00:53:10,561 --> 00:53:13,044
包括类似比赛的内容

1235
00:53:13,044 --> 00:53:17,140
让我们尝试在这里找到自己的比赛。 

1236
00:53:17,140 --> 00:53:18,788
我们不是很擅长这款游戏。 

1237
00:53:18,788 --> 00:53:20,225
让我们看看，有一场比赛。 

1238
00:53:20,225 --> 00:53:23,479
顺便说一下，我们在那里获得了隐式动画

1239
00:53:23,479 --> 00:53:25,300
如果我们点击此处的另一张卡片， 

1240
00:53:25,300 --> 00:53:27,170
这两张卡将消失。 

1241
00:53:27,170 --> 00:53:31,050
让我们看看它们消失的方式，对吗？ 

1242
00:53:31,050 --> 00:53:32,280
因为这是默认过渡

1243
00:53:32,280 --> 00:53:34,170
我们尚未指定任何转换

1244
00:53:34,170 --> 00:53:36,112
我们得到淡入和淡出过渡

1245
00:53:36,112 --> 00:53:38,049
在这里的所有地方。 

1246
00:53:38,049 --> 00:53:41,040
如果我们希望那些东西消失

1247
00:53:41,040 --> 00:53:43,530
成为更酷的动画

1248
00:53:43,530 --> 00:53:47,231
像我们如何让它们缩小并消失？ 

1249
00:53:47,231 --> 00:53:49,837
真的很容易再做一次，我们要去这里

1250
00:53:49,837 --> 00:53:51,928
找到那个视图，那个视图在哪里？ 

1251
00:53:51,928 --> 00:53:53,903
就在这里

1252
00:53:53,903 --> 00:53:57,578
这是View，这是ZStack的名称， 

1253
00:53:57,578 --> 00:54:00,480
当它面朝上时才存在

1254
00:54:00,480 --> 00:54:02,370
或者卡不匹配。 

1255
00:54:02,370 --> 00:54:05,385
因此，一旦卡片匹配且没有面朝上， 

1256
00:54:05,385 --> 00:54:07,754
此视图消失。 

1257
00:54:07,754 --> 00:54:12,754
它过渡出来，好了，从视图中消失了， 

1258
00:54:13,050 --> 00:54:15,930
所以我们可以在这里说过渡

1259
00:54:15,930 --> 00:54:19,783
并选择例如AnyTransition.scale。 

1260
00:54:21,260 --> 00:54:24,720
因此规模是使用框架制造事物的尺度

1261
00:54:24,720 --> 00:54:28,881
放大，缩小到虚无或从无到有。 

1262
00:54:28,881 --> 00:54:32,051
因此，让我们看看是否可以在这里找到另一个匹配项。 

1263
00:54:32,051 --> 00:54:35,410
现在，很难做，因为

1264
00:54:35,410 --> 00:54:37,067
这里的动画太慢了

1265
00:54:37,067 --> 00:54:38,570
哦，有比赛。 

1266
00:54:38,570 --> 00:54:40,240
好吧，当我们点击其他东西时， 

1267
00:54:40,240 --> 00:54:43,403
让我们来看看如何为这些汽车的消失制作动画。 

1268
00:54:44,240 --> 00:54:48,913
哇，现在注意，只有缩小后它们才会消失， 

1269
00:54:48,913 --> 00:54:52,650
但所有其他动画，包括该隐式动画， 

1270
00:54:52,650 --> 00:54:53,882
他们继续前进。 

1271
00:54:53,882 --> 00:54:56,409
关于SwiftUI，您要了解的一件事是

1272
00:54:56,409 --> 00:54:58,421
所有动画都可以同时发生

1273
00:54:58,421 --> 00:55:00,490
他们都在一起工作。 

1274
00:55:00,490 --> 00:55:03,576
确实，这是SwiftUI最好的东西之一， 

1275
00:55:03,576 --> 00:55:05,478
是如何处理所有交互的

1276
00:55:05,478 --> 00:55:08,640
动画同时发生。 

1277
00:55:08,640 --> 00:55:11,737
现在在您的作业中，您将收到卡片

1278
00:55:11,737 --> 00:55:13,128
以及进行。 

1279
00:55:13,128 --> 00:55:15,648
但是你不会让它们缩小

1280
00:55:15,648 --> 00:55:19,190
您将要让您的卡在屏幕上飞行。 

1281
00:55:19,190 --> 00:55:21,462
因此它们将飞离屏幕而不是屏幕， 

1282
00:55:21,462 --> 00:55:23,050
你知道，缩小。 

1283
00:55:23,050 --> 00:55:25,190
当它们被处理后，当它们出现在屏幕上时， 

1284
00:55:25,190 --> 00:55:27,500
他们会飞进去，不会去

1285
00:55:27,500 --> 00:55:29,653
具有很好的收缩效果。 

1286
00:55:30,710 --> 00:55:32,460
并添加该过渡

1287
00:55:32,460 --> 00:55:34,930
对于这些来来往往的事情， 

1288
00:55:34,930 --> 00:55:38,060
还可以使它们回来时，您单击

1289
00:55:38,060 --> 00:55:41,513
在新游戏上，它们又回来了，应该放大。 

1290
00:55:43,490 --> 00:55:45,840
这个AnyTransition和记住的是

1291
00:55:45,840 --> 00:55:48,380
该类型删除的过渡版本。 

1292
00:55:48,380 --> 00:55:51,080
因此，让我们在开发人员文档中进行研究

1293
00:55:51,080 --> 00:55:53,350
真的很快，这里是AnyTransition。 

1294
00:55:53,350 --> 00:55:55,720
这就是我们谈论的身份，不透明性

1295
00:55:55,720 --> 00:55:59,680
这是默认的，缩放，滑动，向下滑动到侧面， 

1296
00:55:59,680 --> 00:56:01,040
这边是偏移量

1297
00:56:01,040 --> 00:56:03,690
这是使视图飞来飞去的一种

1298
00:56:03,690 --> 00:56:04,560
进进出出。 

1299
00:56:04,560 --> 00:56:06,610
因此，这可能就是您要做家庭作业的目的。 

1300
00:56:06,610 --> 00:56:10,522
这是修饰符，您可以在其中指定两个

1301
00:56:10,522 --> 00:56:13,864
ViewModifiers。顺便说一下，这种不对称性使您可以

1302
00:56:13,864 --> 00:56:16,210
可以让卡片带有一个动画

1303
00:56:16,210 --> 00:56:19,210
然后根据需要消失，并显示另一个动画。 

1304
00:56:20,170 --> 00:56:21,880
看到AnyTransition在这里说， 

1305
00:56:21,880 --> 00:56:24,720
这是一种类型擦除的过渡。 

1306
00:56:24,720 --> 00:56:26,240
这种类型擦除是使

1307
00:56:26,240 --> 00:56:28,123
这一切都非常简单。 

1308
00:56:28,123 --> 00:56:30,660
这是这些东西的回报类型

1309
00:56:30,660 --> 00:56:35,040
不是过渡角括号的ViewModifier 

1310
00:56:35,040 --> 00:56:38,210
抵消...这只是AnyTransition。 

1311
00:56:38,210 --> 00:56:41,340
再说一次，我们将更多地讨论类型擦除

1312
00:56:41,340 --> 00:56:42,810
在本季度晚些时候。 

1313
00:56:42,810 --> 00:56:44,240
现在你可以忽略它

1314
00:56:44,240 --> 00:56:47,130
并认为过渡只是哦过渡

1315
00:56:47,130 --> 00:56:49,077
不用担心所有的不在乎

1316
00:56:49,077 --> 00:56:51,000
和其他可能涉及的东西

1317
00:56:51,000 --> 00:56:53,640
具有非类型擦除的过渡。 

1318
00:56:53,640 --> 00:56:56,533
所以这里的房间动画里的大象， 

1319
00:56:56,533 --> 00:57:00,140
我们没有的是卡片翻转。 

1320
00:57:00,140 --> 00:57:02,670
真的，当我们玩纸牌游戏时， 

1321
00:57:02,670 --> 00:57:04,670
当我们点击这些卡片时， 

1322
00:57:04,670 --> 00:57:06,880
你不希望他们像这样淡入淡出

1323
00:57:06,880 --> 00:57:09,170
我们希望他们翻身。 

1324
00:57:09,170 --> 00:57:11,300
这就是纸牌的作用，它们会翻转。 

1325
00:57:11,300 --> 00:57:14,570
那么我们该怎么做翻转动画呢？ 

1326
00:57:14,570 --> 00:57:17,170
好吧，斯威夫特将对我们有很大帮助

1327
00:57:17,170 --> 00:57:20,270
因为它有一个Animatable ViewModifier 

1328
00:57:20,270 --> 00:57:22,920
称为旋转3D效果

1329
00:57:22,920 --> 00:57:26,500
就像我们旋转比赛一样旋转它。 

1330
00:57:26,500 --> 00:57:30,460
如果您还记得，在比赛中，我们以2D旋转， 

1331
00:57:30,460 --> 00:57:31,870
本质上是一圈又一圈。 

1332
00:57:31,870 --> 00:57:35,000
我们也可以3D旋转让此View旋转

1333
00:57:35,000 --> 00:57:37,133
在围绕不同轴的3D中， 

1334
00:57:37,133 --> 00:57:40,720
这个y垂直轴，而不是围绕旋转

1335
00:57:40,720 --> 00:57:43,259
该点的轴线直指我们。 

1336
00:57:43,259 --> 00:57:46,219
因此，让我们对该卡进行3D旋转

1337
00:57:46,219 --> 00:57:47,240
然后看看它是否有效。 

1338
00:57:47,240 --> 00:57:51,330
这就是所谓的rotation3DEffect。 

1339
00:57:51,330 --> 00:57:55,320
然后指定要旋转卡的数量。 

1340
00:57:55,320 --> 00:57:59,720
再次，在这里，我们将做Angle.degrees。 

1341
00:57:59,720 --> 00:58:02,940
如果卡面朝上， 

1342
00:58:02,940 --> 00:58:05,730
那么就不要让它旋转正常

1343
00:58:05,730 --> 00:58:09,520
但是如果它面朝下，让我们将其旋转180度。 

1344
00:58:09,520 --> 00:58:11,510
让我们将其完全翻转。 

1345
00:58:11,510 --> 00:58:14,681
现在，由于这是3D旋转，所以该轴

1346
00:58:14,681 --> 00:58:18,487
该轴表示您要围绕哪个轴旋转， 

1347
00:58:18,487 --> 00:58:19,320
这是三个数字

1348
00:58:19,320 --> 00:58:23,320
因此，例如（0，0，1）将是2D旋转， 

1349
00:58:23,320 --> 00:58:26,250
原因1，最后一个是z轴。 

1350
00:58:26,250 --> 00:58:29,260
那是从屏幕上指向你的那个， 

1351
00:58:29,260 --> 00:58:33,070
而我们想要的是y轴

1352
00:58:33,070 --> 00:58:35,207
y轴是垂直轴， 

1353
00:58:35,207 --> 00:58:36,870
从屏幕顶部开始的那个

1354
00:58:36,870 --> 00:58:38,450
一直到屏幕底部

1355
00:58:38,450 --> 00:58:42,550
我们希望这种旋转围绕该轴发生。 

1356
00:58:42,550 --> 00:58:45,510
看看有什么用，那是不对的。 

1357
00:58:45,510 --> 00:58:47,600
让我们看看我们得到了什么。 

1358
00:58:47,600 --> 00:58:49,620
哇，哇

1359
00:58:49,620 --> 00:58:52,190
所以这很有趣。 

1360
00:58:52,190 --> 00:58:54,420
它在旋转， 

1361
00:58:54,420 --> 00:58:57,460
但是视图在那里出现和消失

1362
00:58:57,460 --> 00:58:59,470
褪色仍在发生

1363
00:58:59,470 --> 00:59:01,430
那真的不是我们想要的。 

1364
00:59:01,430 --> 00:59:03,000
当我们第一次点击该卡片时， 

1365
00:59:03,000 --> 00:59:05,690
如果前后都可见

1366
00:59:05,690 --> 00:59:08,890
一个人逐渐消失，然后逐渐消失， 

1367
00:59:08,890 --> 00:59:12,363
背面完全淡出，正面已经淡入。 

1368
00:59:13,490 --> 00:59:16,088
这很近，很近， 

1369
00:59:16,088 --> 00:59:18,440
我们正在努力完成这项工作， 

1370
00:59:18,440 --> 00:59:20,100
但这不是很正确。 

1371
00:59:20,100 --> 00:59:23,720
因此，有两种方法可以使我完成这项工作。 

1372
00:59:23,720 --> 00:59:27,870
第一，我们可以有自己的自定义过渡， 

1373
00:59:27,870 --> 00:59:30,090
正在过渡的过渡

1374
00:59:30,090 --> 00:59:32,330
在前后之间

1375
00:59:32,330 --> 00:59:36,470
后面有点像我们将它向上翻转， 

1376
00:59:36,470 --> 00:59:38,490
背面显示

1377
00:59:39,784 --> 00:59:41,770
一会儿，直到它站起来

1378
00:59:41,770 --> 00:59:42,940
然后它消失了

1379
00:59:42,940 --> 00:59:44,500
然后当正面出现时， 

1380
00:59:44,500 --> 00:59:47,880
它从边缘开始，然后向下旋转。 

1381
00:59:47,880 --> 00:59:52,290
我们绝对可以编写一个做到这一点的ViewModifier 

1382
00:59:52,290 --> 00:59:53,720
然后从中过渡出来

1383
00:59:53,720 --> 00:59:57,540
或者我们正在使用这种半翻转的方式

1384
00:59:57,540 --> 00:59:59,620
让卡进出。 

1385
00:59:59,620 --> 01:00:01,610
确实有点复杂， 

1386
01:00:01,610 --> 01:00:03,150
比我认为我们需要做的

1387
01:00:03,150 --> 01:00:05,640
因为如果我们还记得动画是如何工作的

1388
01:00:05,640 --> 01:00:08,920
我们知道ViewModifiers是主要的东西

1389
01:00:08,920 --> 01:00:11,000
做动画。 

1390
01:00:11,000 --> 01:00:14,500
那为什么不随便拿我们的ViewModifier 

1391
01:00:14,500 --> 01:00:19,500
这张卡并使其旋转时变得很聪明

1392
01:00:19,960 --> 01:00:23,100
本身，这样它只显示前半部分的前部

1393
01:00:23,100 --> 01:00:26,880
动画，仅在下半场显示背面。 

1394
01:00:26,880 --> 01:00:29,900
换句话说，我们将在这里进行Cardify。 

1395
01:00:29,900 --> 01:00:31,460
这是我们的Cardify 

1396
01:00:31,460 --> 01:00:33,370
当它旋转时

1397
01:00:33,370 --> 01:00:35,420
我们会做到的，这样您就可以旋转自己。 

1398
01:00:35,420 --> 01:00:36,640
这样做的时候

1399
01:00:36,640 --> 01:00:41,640
它将协调旋转时面朝上的内容。 

1400
01:00:41,770 --> 01:00:43,310
轮换的前半部分

1401
01:00:43,310 --> 01:00:46,453
脸朝下将是他们的下半部分旋转，脸朝下。 

1402
01:00:47,680 --> 01:00:50,620
好吧，我们要做的第一件事就是吃这个

1403
01:00:50,620 --> 01:00:52,940
rotation3DEffect在这里

1404
01:00:52,940 --> 01:00:54,980
并将其移入

1405
01:00:54,980 --> 01:00:55,813
我们的

1406
01:00:56,880 --> 01:00:58,210
修饰符。 

1407
01:00:58,210 --> 01:01:00,150
所以如果我们把它放在这里， 

1408
01:01:00,150 --> 01:01:03,630
并将这个ZStack旋转到这里。 

1409
01:01:03,630 --> 01:01:07,740
不用旋转卡

1410
01:01:07,740 --> 01:01:11,440
在0到180之间的二进制意义上， 

1411
01:01:11,440 --> 01:01:13,650
我们希望能够控制

1412
01:01:13,650 --> 01:01:15,560
整个旋转

1413
01:01:15,560 --> 01:01:17,740
因为在上半年，我们只想露出脸

1414
01:01:17,740 --> 01:01:20,460
下半场，我们只想朝下展示。 

1415
01:01:20,460 --> 01:01:23,550
所以我们要在这里更改ViewModifier， 

1416
01:01:23,550 --> 01:01:28,120
其中涉及的主要变量是旋转。 

1417
01:01:28,120 --> 01:01:29,330
所以我要轮换

1418
01:01:29,330 --> 01:01:31,410
我要成为双打，这将成为

1419
01:01:31,410 --> 01:01:34,943
我的度数旋转很简单。 

1420
01:01:36,194 --> 01:01:40,300
如果我要跟踪旋转并为其设置动画， 

1421
01:01:40,300 --> 01:01:42,800
然后isFaceUp真的变成了

1422
01:01:42,800 --> 01:01:44,200
旋转的函数

1423
01:01:44,200 --> 01:01:46,990
如果旋转小于90度

1424
01:01:46,990 --> 01:01:49,360
我旋转了180度

1425
01:01:49,360 --> 01:01:53,350
那么该卡面朝上，否则面朝下

1426
01:01:53,350 --> 01:01:56,533
因此，现在我将旋转和面朝上朝下联系在一起。 

1427
01:01:57,410 --> 01:02:00,210
然后当我有这个rotation3DEffect时

1428
01:02:00,210 --> 01:02:02,513
卡isFaceUp控制旋转的过程， 

1429
01:02:02,513 --> 01:02:05,073
让我们进行实际的旋转。 

1430
01:02:06,070 --> 01:02:08,890
无论我们将此修改器设置为哪种旋转， 

1431
01:02:08,890 --> 01:02:11,090
那将是旋转，它将被选中

1432
01:02:11,090 --> 01:02:15,223
右脸，正面或不正面，旋转

1433
01:02:16,430 --> 01:02:18,900
我仍然希望能够有一个init 

1434
01:02:18,900 --> 01:02:20,663
那就是isFaceUp。 

1435
01:02:21,620 --> 01:02:23,310
但是现在当我这样做时

1436
01:02:23,310 --> 01:02:26,080
那只是将我的旋转设置为零

1437
01:02:26,080 --> 01:02:29,100
如果是正面朝上，如果是正面朝下，则为180， 

1438
01:02:29,100 --> 01:02:33,013
假设isFaceUp问号为零，否则为180。 

1439
01:02:34,400 --> 01:02:36,960
所以我在这里转换了ViewModifier 

1440
01:02:36,960 --> 01:02:40,130
以轮换为基础，而不是面朝上

1441
01:02:40,130 --> 01:02:42,380
并且正面朝上总是跟踪旋转

1442
01:02:42,380 --> 01:02:43,560
因为这是FaceUp它的

1443
01:02:43,560 --> 01:02:46,710
只是看旋转，看看我们是否旋转足够。 

1444
01:02:46,710 --> 01:02:48,750
现在我们如何制作动画

1445
01:02:48,750 --> 01:02:50,500
因为这还不足以使其具有动画效果

1446
01:02:50,500 --> 01:02:51,680
如果我们不在这里跑

1447
01:02:54,280 --> 01:02:55,700
然后点击这些东西。 

1448
01:02:55,700 --> 01:02:58,800
它在做翻转，但仍然做错了事

1449
01:02:58,800 --> 01:03:00,160
关于面朝上和面朝下。 

1450
01:03:00,160 --> 01:03:02,970
当正面朝上和正面朝下的视图在此处来回移动时， 

1451
01:03:02,970 --> 01:03:05,310
他们仍然只是不透明。 

1452
01:03:05,310 --> 01:03:06,840
那是因为这个ViewModifier 

1453
01:03:06,840 --> 01:03:09,290
未标记为可动画。 

1454
01:03:09,290 --> 01:03:12,360
因此SwiftUI认为，这个ViewModifier 

1455
01:03:12,360 --> 01:03:14,110
不知道如何制作动画。 

1456
01:03:14,110 --> 01:03:16,650
所以我只是在这里做普通的动画。 

1457
01:03:16,650 --> 01:03:19,820
我通常会为它设置动画

1458
01:03:19,820 --> 01:03:22,580
通过此处的init来彼此初始化。 

1459
01:03:22,580 --> 01:03:24,990
我只是考虑即将到来的这些观点

1460
01:03:24,990 --> 01:03:27,270
因为isFaceUp而去

1461
01:03:27,270 --> 01:03:28,640
而我只是在过渡他们

1462
01:03:28,640 --> 01:03:31,863
使用标准转换，即不透明度。 

1463
01:03:32,852 --> 01:03:34,440
所以我们可以打开一个ViewModifier 

1464
01:03:34,440 --> 01:03:38,330
通过更改协议进入Animatable修改器

1465
01:03:38,330 --> 01:03:42,980
实现到AnimatableModifier。 

1466
01:03:42,980 --> 01:03:47,340
所以Animatable修饰符实际上只是ViewModifier 

1467
01:03:47,340 --> 01:03:52,150
可动画的，这是可动画的

1468
01:03:52,150 --> 01:03:56,940
如果我们查找它，这个animatableData变量， 

1469
01:03:56,940 --> 01:03:59,800
动画系统之间的这种通信

1470
01:03:59,800 --> 01:04:02,920
以及我们的ViewModifier或Shape。 

1471
01:04:02,920 --> 01:04:05,000
所以我们只需要实现这个animatableData 

1472
01:04:06,210 --> 01:04:09,430
animatableData放在这里，让我们开始吧。 

1473
01:04:09,430 --> 01:04:13,770
让我们将其放在此处，var animatableData。 

1474
01:04:13,770 --> 01:04:16,190
我们的ViewModifier会动画显示什么？ 

1475
01:04:16,190 --> 01:04:18,290
动画旋转

1476
01:04:19,130 --> 01:04:22,520
我们的视图就是您要设置的动画。 

1477
01:04:22,520 --> 01:04:25,590
所以这个Double是我们的轮换。 

1478
01:04:25,590 --> 01:04:28,470
现在，我可以使用这个单词animatableData 

1479
01:04:28,470 --> 01:04:30,300
在这里而不是旋转

1480
01:04:30,300 --> 01:04:34,630
但这不是在此处具有animatableData的很好的代码。 

1481
01:04:34,630 --> 01:04:36,700
所以让我们做我在说的那个把戏

1482
01:04:36,700 --> 01:04:38,150
在我要放的幻灯片上

1483
01:04:38,150 --> 01:04:39,640
这是一个计算属性

1484
01:04:39,640 --> 01:04:42,100
我要归还我的轮换

1485
01:04:42,100 --> 01:04:44,810
然后我将轮换设为相等

1486
01:04:44,810 --> 01:04:47,990
此属性的新值。 

1487
01:04:47,990 --> 01:04:50,120
记住，获取并设置，这就是我们要做的

1488
01:04:50,120 --> 01:04:54,110
计算属性就是读写的。 

1489
01:04:54,110 --> 01:04:57,640
所以我基本上只是将旋转重命名为animatableData 

1490
01:04:57,640 --> 01:04:59,890
因为这是动画系统的名称

1491
01:04:59,890 --> 01:05:01,320
要寻找。 

1492
01:05:01,320 --> 01:05:04,870
顺便说一句，即使这只是全部，您也无法

1493
01:05:04,870 --> 01:05:05,720
发生在这里， 

1494
01:05:05,720 --> 01:05:07,560
你实际上不能只说这个

1495
01:05:07,560 --> 01:05:11,390
您需要说这是一个AnimatableModifier 

1496
01:05:11,390 --> 01:05:14,400
因为这个AnimatableModifier协议

1497
01:05:14,400 --> 01:05:18,230
虽然这和ViewModifier在一起， 

1498
01:05:18,230 --> 01:05:19,870
它也向系统发出信号

1499
01:05:19,870 --> 01:05:22,600
我想参加，我将成为ViewModifier 

1500
01:05:22,600 --> 01:05:25,060
想参加动画系统的人

1501
01:05:25,060 --> 01:05:28,523
因此请确保您说的是冒号AnimatableModifier。 

1502
01:05:30,010 --> 01:05:31,210
好吧，让我们尝试一下。 

1503
01:05:34,605 --> 01:05:36,513
轻按该卡，哦，天哪， 

1504
01:05:38,674 --> 01:05:40,360
真的很简单。 

1505
01:05:40,360 --> 01:05:42,870
在翻转的前半部分看到

1506
01:05:42,870 --> 01:05:44,410
当卡片正面朝下时， 

1507
01:05:44,410 --> 01:05:46,930
它只显示背面，当它面朝上时， 

1508
01:05:46,930 --> 01:05:49,030
它只显示正面，让我们尝试

1509
01:05:49,030 --> 01:05:50,550
并使卡消失

1510
01:05:50,550 --> 01:05:53,143
这样您就可以看到卡片面朝下。 

1511
01:05:56,090 --> 01:05:59,440
这是一场比赛，让它消失。 

1512
01:05:59,440 --> 01:06:01,670
并注意当它消失时仍然可以使用

1513
01:06:01,670 --> 01:06:05,460
动画效果就好于缩放动画。 

1514
01:06:05,460 --> 01:06:07,750
还要注意，当我们翻转卡片时， 

1515
01:06:07,750 --> 01:06:09,620
不再有淡入。 

1516
01:06:09,620 --> 01:06:13,370
这些卡不褪色，背面或正面不褪色。 

1517
01:06:13,370 --> 01:06:15,790
那是因为这个ViewModifier 

1518
01:06:15,790 --> 01:06:17,890
已经控制了动画。 

1519
01:06:17,890 --> 01:06:19,890
因此动画系统不再尝试

1520
01:06:19,890 --> 01:06:22,310
进入这里并自己制作动画

1521
01:06:22,310 --> 01:06:25,260
假定此ViewModifier知道它在做什么。 

1522
01:06:27,000 --> 01:06:30,660
让我们回到一开始就遇到的问题， 

1523
01:06:30,660 --> 01:06:32,710
这是当事物匹配时，让我们找到一些卡片

1524
01:06:32,710 --> 01:06:33,693
在这里匹配。 

1525
01:06:37,592 --> 01:06:38,480
现在我又不太擅长这款游戏。 

1526
01:06:38,480 --> 01:06:41,840
好吧，我认为这是。是的，好的，准备好了，我们开始比赛了。 

1527
01:06:41,840 --> 01:06:43,540
这一个旋转。 

1528
01:06:43,540 --> 01:06:45,660
这一个不旋转。 

1529
01:06:45,660 --> 01:06:48,763
让我们调查一下为什么不旋转？ 

1530
01:06:49,650 --> 01:06:53,620
这不会旋转，因为当我们触摸此卡时， 

1531
01:06:53,620 --> 01:06:56,950
它匹配，并且当时面朝下

1532
01:06:56,950 --> 01:06:58,860
我们将其正面朝上。 

1533
01:06:58,860 --> 01:07:02,970
因此，当它出现在屏幕上时，所有这些融合都在这里， 

1534
01:07:02,970 --> 01:07:06,493
它面朝上并且已经匹配。 

1535
01:07:08,040 --> 01:07:10,250
所以没有变化

1536
01:07:10,250 --> 01:07:13,210
此卡isMatched已为真

1537
01:07:13,210 --> 01:07:16,520
因此无需进行任何更改。 

1538
01:07:16,520 --> 01:07:20,200
动画仅动画更改。 

1539
01:07:20,200 --> 01:07:21,640
所以没有变化

1540
01:07:21,640 --> 01:07:23,926
导致“视图”出现在屏幕上匹配， 

1541
01:07:23,926 --> 01:07:25,746
它永远不会改变以匹配

1542
01:07:25,746 --> 01:07:28,053
它刚匹配时就匹配了。 

1543
01:07:30,610 --> 01:07:33,400
所以如果我们想要一场比赛

1544
01:07:33,400 --> 01:07:36,070
要跟着翻筋斗动画

1545
01:07:36,070 --> 01:07:39,040
我们需要这张卡，这个文本， 

1546
01:07:39,040 --> 01:07:43,360
基本上是卡的正面，需要在屏幕上

1547
01:07:43,360 --> 01:07:45,420
当比赛发生时。 

1548
01:07:45,420 --> 01:07:47,820
但这是一张卡的问题， 

1549
01:07:47,820 --> 01:07:51,080
比赛中的第二张牌，因为它面朝下。 

1550
01:07:51,080 --> 01:07:54,290
让表情符号位于卡片的正面

1551
01:07:54,290 --> 01:07:58,310
它不在屏幕上，但我们仍然可以在屏幕上显示它， 

1552
01:07:58,310 --> 01:08:01,350
但隐藏起来，这是另一种应对方式

1553
01:08:01,350 --> 01:08:04,220
与正在出现和消失的视图

1554
01:08:04,220 --> 01:08:08,990
而不是让它们实际上是-如果-然后-从

1555
01:08:08,990 --> 01:08:11,100
存在。相反，我们可以将它们隐藏起来。 

1556
01:08:11,100 --> 01:08:13,170
而我们隐藏事物的方式就是

1557
01:08:13,170 --> 01:08:16,520
从上次我们已经知道不透明

1558
01:08:16,520 --> 01:08:19,460
完全透明被隐藏

1559
01:08:19,460 --> 01:08:22,650
并且完全不透明在屏幕上完全可见。 

1560
01:08:22,650 --> 01:08:25,780
因此，让我们使用不透明度来获得前后

1561
01:08:25,780 --> 01:08:27,700
我们的卡片是否显示， 

1562
01:08:27,700 --> 01:08:29,510
而不是如果

1563
01:08:29,510 --> 01:08:31,710
使它们完全消失或没有消失。 

1564
01:08:32,560 --> 01:08:35,080
所以这是一种不同的思考方式

1565
01:08:35,080 --> 01:08:37,060
ZStack中发生了什么。 

1566
01:08:37,060 --> 01:08:40,310
而不是随着这些前视图的来临而思考

1567
01:08:40,310 --> 01:08:41,490
当它面朝上时

1568
01:08:41,490 --> 01:08:43,167
然后当面朝下时他们走了

1569
01:08:43,167 --> 01:08:45,900
当它面朝下时就来了，面朝上了。 

1570
01:08:45,900 --> 01:08:49,630
相反，我将总是拥有所有这四个

1571
01:08:49,630 --> 01:08:51,170
卡上。 

1572
01:08:51,170 --> 01:08:52,450
当它面朝下时

1573
01:08:52,450 --> 01:08:55,530
我看不到这三个。 

1574
01:08:55,530 --> 01:08:57,400
因此，让我们采用这三个， 

1575
01:08:57,400 --> 01:09:00,830
我什至会把它们分组以使自己更轻松。 

1576
01:09:00,830 --> 01:09:05,230
然后设置它们的不透明度，以便如果卡片朝上， 

1577
01:09:05,230 --> 01:09:06,750
他们是完全不透明的

1578
01:09:06,750 --> 01:09:08,930
否则它们是完全透明的。 

1579
01:09:08,930 --> 01:09:12,920
而且这个同样会说它的不透明性

1580
01:09:12,920 --> 01:09:16,980
如果面朝上，则完全透明。 

1581
01:09:16,980 --> 01:09:19,203
否则，基于此， 

1582
01:09:19,203 --> 01:09:21,690
移动这些东西，使它们更容易阅读

1583
01:09:24,420 --> 01:09:27,230
所以现在在这里，如果没有， 

1584
01:09:27,230 --> 01:09:28,990
这个ViewBuilder中没有ifs 

1585
01:09:28,990 --> 01:09:31,700
意见不再来去去了。 

1586
01:09:31,700 --> 01:09:34,070
这也意味着该内容， 

1587
01:09:34,070 --> 01:09:35,950
此文本始终显示在屏幕上

1588
01:09:35,950 --> 01:09:38,290
即使我们面朝下，也只是隐藏起来。 

1589
01:09:38,290 --> 01:09:41,270
因此，这意味着当它稍后设置为匹配时， 

1590
01:09:41,270 --> 01:09:44,580
这种隐式动画将有所改变

1591
01:09:44,580 --> 01:09:45,913
直到它开始运行。 

1592
01:09:46,880 --> 01:09:47,980
让我们尝试一下。 

1593
01:09:50,350 --> 01:09:54,880
这是我们的卡片，哎呀，在那儿仍然可以正常使用， 

1594
01:09:54,880 --> 01:09:56,870
卡的正面没有显示

1595
01:09:56,870 --> 01:09:58,730
看到卡的正面就在那里

1596
01:09:58,730 --> 01:10:00,380
在这张卡的另一面

1597
01:10:00,380 --> 01:10:01,930
如果你想这样想

1598
01:10:01,930 --> 01:10:04,077
尽管它是隐藏的，但其不透明度为零。 

1599
01:10:04,077 --> 01:10:05,747
当我单击它时，它的不透明度仍为零

1600
01:10:05,747 --> 01:10:07,280
现在它的不透明度是

1601
01:10:07,280 --> 01:10:09,203
背面的不透明度设为零。 

1602
01:10:10,120 --> 01:10:12,687
因此，希望我们能在这里找到比赛的地方， 

1603
01:10:14,240 --> 01:10:15,073
这家伙

1604
01:10:16,580 --> 01:10:18,850
和这个家伙，他们都会旋转

1605
01:10:18,850 --> 01:10:22,083
您会看到该卡转过身时正在旋转。 

1606
01:10:23,174 --> 01:10:24,930
让我们在这里再配一个

1607
01:10:24,930 --> 01:10:26,880
看着卡片转过身来

1608
01:10:26,880 --> 01:10:29,430
你会看到它已经旋转了

1609
01:10:29,430 --> 01:10:33,170
因为它在那里藏着，正在旋转， 

1610
01:10:33,170 --> 01:10:35,860
隐藏直到它变得可见。 

1611
01:10:35,860 --> 01:10:40,860
使用不透明度使事情来来去去的技巧

1612
01:10:41,320 --> 01:10:43,780
这实际上是您可以控制自己是否在做的一种方式

1613
01:10:43,780 --> 01:10:46,840
随Views转换而来的动画， 

1614
01:10:46,840 --> 01:10:50,500
还是直接在屏幕上进行控制

1615
01:10:50,500 --> 01:10:52,420
使用不透明度。 

1616
01:10:52,420 --> 01:10:55,860
而且它们都是完全有效的方法。 

1617
01:10:55,860 --> 01:10:58,180
您可以决定是否有意义

1618
01:10:58,180 --> 01:10:59,743
在本演示的稍后部分，您将看到

1619
01:10:59,743 --> 01:11:02,220
我们实际上将要利用

1620
01:11:02,220 --> 01:11:04,930
使我们的小馅饼来来去去。 

1621
01:11:04,930 --> 01:11:06,350
当我们的派动画时， 

1622
01:11:06,350 --> 01:11:08,630
我们希望它在那里有动画效果， 

1623
01:11:08,630 --> 01:11:10,510
但是我们要放一个不同的派

1624
01:11:10,510 --> 01:11:12,750
如果不是，那将是一个巨大的优势

1625
01:11:12,750 --> 01:11:14,680
知道什么时候来来去去。 

1626
01:11:14,680 --> 01:11:17,040
因此，并非总是要使用不透明度

1627
01:11:17,040 --> 01:11:19,450
有时您想要视图来去去， 

1628
01:11:19,450 --> 01:11:22,480
这仅取决于您是否触发了此事

1629
01:11:22,480 --> 01:11:24,130
以及您是否要使用过渡， 

1630
01:11:24,130 --> 01:11:26,950
或只是普通动画。 

1631
01:11:26,950 --> 01:11:28,900
现在我要做的最后一件事是， 

1632
01:11:28,900 --> 01:11:32,130
现在我们有了动画， 

1633
01:11:32,130 --> 01:11:34,570
翻转卡片效果很好

1634
01:11:34,570 --> 01:11:36,580
为了让它们消失， 

1635
01:11:36,580 --> 01:11:38,780
我将再次加速它们

1636
01:11:38,780 --> 01:11:40,410
然后我们去制作动画

1637
01:11:40,410 --> 01:11:41,660
这个小馅饼。 

1638
01:11:41,660 --> 01:11:44,120
因此，让我们加快备份速度，这很容易做到。 

1639
01:11:44,120 --> 01:11:47,490
回到这里，继续努力

1640
01:11:47,490 --> 01:11:49,010
也许我们有默认的持续时间， 

1641
01:11:49,010 --> 01:11:52,890
让我们尝试这两者的默认持续时间， 

1642
01:11:52,890 --> 01:11:57,310
通常是默认时间的一秒以内。 

1643
01:11:57,310 --> 01:11:58,657
看看这是什么样子

1644
01:11:58,657 --> 01:12:00,930
嗯，实际上可能有点快， 

1645
01:12:00,930 --> 01:12:03,080
我对此不满意

1646
01:12:03,080 --> 01:12:05,460
我很快就消失了

1647
01:12:05,460 --> 01:12:07,920
但是当我翻转卡片时我想放慢速度

1648
01:12:07,920 --> 01:12:08,753
一点点。 

1649
01:12:08,753 --> 01:12:10,180
所以我要说持续时间

1650
01:12:10,180 --> 01:12:13,050
假设0.75， 

1651
01:12:13,050 --> 01:12:14,683
看看效果如何。 

1652
01:12:17,952 --> 01:12:19,720
好吧，对我来说看起来更好

1653
01:12:19,720 --> 01:12:22,560
当然不会比这更慢

1654
01:12:22,560 --> 01:12:24,310
但我认为这看起来不错。 

1655
01:12:25,760 --> 01:12:28,110
这种蓝色显然是某种东西

1656
01:12:28,110 --> 01:12:30,610
我们想放下我们的绘图常数。 

1657
01:12:30,610 --> 01:12:32,050
我现在不打算这样做以节省时间

1658
01:12:32,050 --> 01:12:34,420
但是只要您看到那里有一个蓝色数字， 

1659
01:12:34,420 --> 01:12:36,960
这些蓝色的数字也是我们上次没有做的

1660
01:12:36,960 --> 01:12:38,780
这些东西都应该放在这里

1661
01:12:38,780 --> 01:12:41,240
在绘图常量中，您可以使用控制面板

1662
01:12:41,240 --> 01:12:42,810
在这里进行调整并转动拨盘

1663
01:12:42,810 --> 01:12:44,563
使您的用户界面看起来像您想要的那样。 

1664
01:12:45,650 --> 01:12:47,417
我们有这个派

1665
01:12:47,417 --> 01:12:50,530
现在Pie被卡在这个位置上

1666
01:12:50,530 --> 01:12:52,800
但实际上，每当卡片翻转时， 

1667
01:12:52,800 --> 01:12:54,390
我们希望它开始倒计时

1668
01:12:54,390 --> 01:12:55,400
当它向下翻转时， 

1669
01:12:55,400 --> 01:12:57,260
我们停止计数，然后再向上推。 

1670
01:12:57,260 --> 01:12:58,610
它一直计数然后向下翻转

1671
01:12:58,610 --> 01:13:00,050
它停止计数，然后当然

1672
01:13:00,050 --> 01:13:02,280
当它匹配时，我们停止计数

1673
01:13:02,280 --> 01:13:03,690
因为现在您已经匹配了它。 

1674
01:13:03,690 --> 01:13:05,030
如果它完全消失， 

1675
01:13:05,030 --> 01:13:08,300
你得的积分不如你做的多

1676
01:13:08,300 --> 01:13:09,950
在它消失之前。 

1677
01:13:09,950 --> 01:13:12,670
为此，我们需要做一些事情。 

1678
01:13:12,670 --> 01:13:15,830
一个是我们将不得不改进我们的模型

1679
01:13:15,830 --> 01:13:20,050
知道还剩下多少奖金时间，等等。 

1680
01:13:20,050 --> 01:13:23,630
所以我实际上放了一些代码

1681
01:13:23,630 --> 01:13:26,220
在这里，我向你们提供了

1682
01:13:26,220 --> 01:13:30,020
在之前的论坛上，所以你们所有人都拥有它。 

1683
01:13:30,020 --> 01:13:32,840
如果没有，您可以暂停该视频

1684
01:13:32,840 --> 01:13:34,670
并从这里复制它

1685
01:13:34,670 --> 01:13:36,780
以其他方式获得它。 

1686
01:13:36,780 --> 01:13:40,060
但是这段代码基本上是在做跟踪

1687
01:13:40,060 --> 01:13:41,980
每次卡上下时

1688
01:13:41,980 --> 01:13:44,500
或映射它跟踪使用的时间

1689
01:13:44,500 --> 01:13:45,958
然后它回答诸如

1690
01:13:45,958 --> 01:13:47,840
还剩多少时间

1691
01:13:47,840 --> 01:13:51,830
或剩余的时间百分比

1692
01:13:51,830 --> 01:13:54,030
我们可以了解我们是否获得奖金

1693
01:13:54,030 --> 01:13:56,370
并开始使用奖励时间

1694
01:13:56,370 --> 01:13:58,320
并停止使用奖励时间。 

1695
01:13:58,320 --> 01:14:00,130
通过这些功能，我要确保

1696
01:14:00,130 --> 01:14:03,290
当卡片正面朝上和正面朝下时，我称这些为

1697
01:14:03,290 --> 01:14:05,440
在我的模型中以及匹配时。 

1698
01:14:05,440 --> 01:14:08,010
因此，让我们使用我们讨论过的那些财产观察员

1699
01:14:08,010 --> 01:14:10,090
调用这些功能。 

1700
01:14:10,090 --> 01:14:12,040
这是我的

1701
01:14:12,040 --> 01:14:13,770
卡的vars。 

1702
01:14:13,770 --> 01:14:15,233
我要做到，每次

1703
01:14:15,233 --> 01:14:16,657
isFaceUp在这里更改了， 

1704
01:14:16,657 --> 01:14:19,790
我将使用幻灯片中显示的willSet的didSet， 

1705
01:14:19,790 --> 01:14:21,357
但我只是在这里与众不同

1706
01:14:21,357 --> 01:14:23,040
并向您显示didSet。 

1707
01:14:23,040 --> 01:14:24,560
当这种情况发生时，我要说

1708
01:14:24,560 --> 01:14:28,790
如果isFaceUp更改为true。 

1709
01:14:28,790 --> 01:14:30,490
因此，卡面朝上

1710
01:14:30,490 --> 01:14:33,370
然后我将开始再次运行奖金时间， 

1711
01:14:33,370 --> 01:14:35,240
开始使用奖励时间。 

1712
01:14:35,240 --> 01:14:36,970
否则，如果卡面朝下， 

1713
01:14:36,970 --> 01:14:39,223
我将停止使用奖励时间。 

1714
01:14:40,060 --> 01:14:43,170
所以我只是在我的卡片上看着这个面朝上和面朝下

1715
01:14:43,170 --> 01:14:44,407
每当它发生变化时， 

1716
01:14:44,407 --> 01:14:47,280
这比尝试更可靠

1717
01:14:47,280 --> 01:14:51,320
一直看我说isFaceUp是对还是错

1718
01:14:51,320 --> 01:14:55,210
然后尝试同时调用startUsingBonusTime 

1719
01:14:55,210 --> 01:14:57,440
我可能会犯一个错误，却忘记了它。 

1720
01:14:57,440 --> 01:14:59,830
这样，每次我更改此设置时，它都是可靠的

1721
01:14:59,830 --> 01:15:01,860
繁荣我们开始和停止的时间。 

1722
01:15:01,860 --> 01:15:03,850
同样，对于isMatched在这里， 

1723
01:15:03,850 --> 01:15:08,430
当didSet时，我们可以停止使用奖励时间。 

1724
01:15:08,430 --> 01:15:10,320
如果isMatched设置为false，则可能

1725
01:15:10,320 --> 01:15:12,550
也许我们正在重置游戏或重置卡片， 

1726
01:15:12,550 --> 01:15:14,620
不知道我们在那做什么。 

1727
01:15:14,620 --> 01:15:15,940
但似乎是奖金时间

1728
01:15:15,940 --> 01:15:17,810
不应该再开始了。 

1729
01:15:17,810 --> 01:15:21,030
该属性观察器，一种非常强大的同步方式

1730
01:15:21,030 --> 01:15:23,540
您的代码内部发生了什么。 

1731
01:15:23,540 --> 01:15:27,050
所以现在我们的模型知道还剩多少时间

1732
01:15:27,050 --> 01:15:28,430
在奖金和所有这些东西上。 

1733
01:15:28,430 --> 01:15:30,640
这就是我在这里所做的所有代码。 

1734
01:15:30,640 --> 01:15:32,560
因此，让我们使用这些东西

1735
01:15:32,560 --> 01:15:35,560
在我们的用户界面中显示该动画。 

1736
01:15:35,560 --> 01:15:38,910
现在让我们的卡片派动画

1737
01:15:38,910 --> 01:15:42,980
我们必须在此处增强Shape的动画效果。 

1738
01:15:42,980 --> 01:15:46,300
现在形状真的已经有了这个Animatable， 

1739
01:15:46,300 --> 01:15:49,210
与ViewModifier使用的协议相同， 

1740
01:15:49,210 --> 01:15:51,070
在所有形状上都差不多

1741
01:15:51,070 --> 01:15:55,160
假定所有形状都可以动画

1742
01:15:55,160 --> 01:15:57,320
这只是形状的一部分。 

1743
01:15:57,320 --> 01:15:59,480
这种情况太普遍了，我们甚至不必说

1744
01:15:59,480 --> 01:16:00,750
逗号可在此处动画化， 

1745
01:16:00,750 --> 01:16:02,790
形状只是假设您要这样做。 

1746
01:16:02,790 --> 01:16:04,870
现在，如果您不放置animatableData， 

1747
01:16:04,870 --> 01:16:06,980
你不会得到任何动画

1748
01:16:06,980 --> 01:16:09,010
但是通常我们想要它。 

1749
01:16:09,010 --> 01:16:10,580
所以我们要在这里制作动画

1750
01:16:10,580 --> 01:16:12,500
在我们的Cardify ViewModifier中， 

1751
01:16:12,500 --> 01:16:15,170
我们四处走动时动画旋转， 

1752
01:16:15,170 --> 01:16:18,540
好吧，在我们的Pie动画中， 

1753
01:16:18,540 --> 01:16:20,720
我们有点想动画化这个角度， 

1754
01:16:20,720 --> 01:16:22,200
看到这里的角度， 

1755
01:16:22,200 --> 01:16:25,110
当它绕这个角度变化时

1756
01:16:25,110 --> 01:16:26,520
此处的结束角度。 

1757
01:16:26,520 --> 01:16:28,130
如果我们要成为一个好馅饼， 

1758
01:16:28,130 --> 01:16:30,970
让我们使两个角度都可以动画

1759
01:16:30,970 --> 01:16:32,800
开始和结束。 

1760
01:16:32,800 --> 01:16:34,370
这样我们就可以为任何一侧设置动画， 

1761
01:16:34,370 --> 01:16:36,470
取决于我们认为看起来不错。 

1762
01:16:36,470 --> 01:16:40,320
因此，基本上我该如何同时为两件事设置动画

1763
01:16:40,320 --> 01:16:42,503
我要用那个AnimatablePair， 

1764
01:16:43,830 --> 01:16:44,663
对。 

1765
01:16:44,663 --> 01:16:46,510
而AnimatablePair将是一对Doubles， 

1766
01:16:46,510 --> 01:16:49,990
那些双打将成为我的视角

1767
01:16:49,990 --> 01:16:52,250
他们以弧度为单位。 

1768
01:16:52,250 --> 01:16:56,180
角度本身不是VectorArithmetic的东西

1769
01:16:56,180 --> 01:17:00,480
但是显然弧度的角度是Double 

1770
01:17:00,480 --> 01:17:02,110
所以这个animableData再次

1771
01:17:02,110 --> 01:17:03,870
我将使用相同的技巧

1772
01:17:03,870 --> 01:17:06,936
获取和设置。有点棘手

1773
01:17:06,936 --> 01:17:09,486
因为我们必须在这里使用AnimatablePair， 

1774
01:17:09,486 --> 01:17:12,820
但是AnimatablePair只有两个变量，第一个和第二个， 

1775
01:17:12,820 --> 01:17:14,700
返回第一个可动画的东西

1776
01:17:14,700 --> 01:17:17,060
关于第二个可动画化的事情。 

1777
01:17:17,060 --> 01:17:19,900
所以对于我们来说，我们将返回一个AnimatablePair 

1778
01:17:21,020 --> 01:17:24,950
首先是startAngle的弧度。 

1779
01:17:26,590 --> 01:17:28,893
第二个是endAngle的

1780
01:17:30,906 --> 01:17:32,580
角弧度。 

1781
01:17:32,580 --> 01:17:34,770
那就是我们的animableData 

1782
01:17:34,770 --> 01:17:37,750
然后设置它只是设置我们的startAngle 

1783
01:17:37,750 --> 01:17:42,160
成为弧度为

1784
01:17:42,160 --> 01:17:46,850
这是AnimatablePair，即newValue，先点

1785
01:17:46,850 --> 01:17:49,660
和endAngle 

1786
01:17:49,660 --> 01:17:52,600
是一个角度，弧度， 

1787
01:17:52,600 --> 01:17:55,463
这是AnimatablePair的第二个。 

1788
01:17:56,930 --> 01:18:01,240
所以在这里我们连接了两个变量

1789
01:18:01,240 --> 01:18:04,720
此动画，分段动画

1790
01:18:04,720 --> 01:18:07,720
这就是我们需要做的。 

1791
01:18:07,720 --> 01:18:10,020
因为这只是意味着这个形状将会

1792
01:18:10,020 --> 01:18:13,460
在动画过程中反复绘制

1793
01:18:13,460 --> 01:18:15,410
这两个东西都被动画化了

1794
01:18:15,410 --> 01:18:17,100
因为它们是东西被切成薄片

1795
01:18:17,100 --> 01:18:19,730
动画系统将其分解成小块。 

1796
01:18:19,730 --> 01:18:22,000
这就是animatableData的全部内容。 

1797
01:18:22,000 --> 01:18:24,210
现在，我告诉你，这个动画系统很优雅， 

1798
01:18:24,210 --> 01:18:26,290
就是只有一个变种

1799
01:18:26,290 --> 01:18:29,800
作为双向双向访问的唯一入口

1800
01:18:29,800 --> 01:18:34,740
动画的东西。我认为设计很不错。 

1801
01:18:34,740 --> 01:18:35,740
我不为苹果工作

1802
01:18:35,740 --> 01:18:39,220
因此，我认为我是独立的第三方， 

1803
01:18:39,220 --> 01:18:41,640
我认为他们在这方面做得很好。 

1804
01:18:41,640 --> 01:18:45,140
好吧，现在这个Pie可以动画了

1805
01:18:45,140 --> 01:18:48,950
现在我们的模型知道如何追踪

1806
01:18:48,950 --> 01:18:50,120
剩余时间。 

1807
01:18:50,120 --> 01:18:53,800
因此，让我们采用“视图”并将这两件事放在一起。 

1808
01:18:53,800 --> 01:18:56,220
这是我们的派，就在这里

1809
01:18:56,220 --> 01:18:59,240
我们想要，我要离开起点

1810
01:18:59,240 --> 01:19:02,650
始终笔直向上，零度，向上向上。 

1811
01:19:02,650 --> 01:19:05,100
我要改变我的endAngle取决于

1812
01:19:05,100 --> 01:19:06,980
我还剩下多少时间。 

1813
01:19:06,980 --> 01:19:09,530
让我们从一个简单的开始，即

1814
01:19:09,530 --> 01:19:13,110
让我们拿卡剩余的红利， 

1815
01:19:13,110 --> 01:19:17,300
这是剩余的百分比奖金乘以360。 

1816
01:19:17,300 --> 01:19:20,560
我要倒退，因为这个派

1817
01:19:20,560 --> 01:19:22,460
负面地下降到零

1818
01:19:22,460 --> 01:19:25,580
我最终希望将其降低到零。 

1819
01:19:25,580 --> 01:19:26,693
看看有什么用。 

1820
01:19:29,990 --> 01:19:33,150
好吧，我们开始吧，哦，这不是动画。 

1821
01:19:33,150 --> 01:19:34,400
嗯，这很奇怪。 

1822
01:19:34,400 --> 01:19:37,100
哦，但我以为我在那里看到了什么。 

1823
01:19:37,100 --> 01:19:41,060
哦，看起来它实际上在向我们显示剩余时间

1824
01:19:41,060 --> 01:19:43,660
因为我花了差不多那张卡片

1825
01:19:43,660 --> 01:19:46,470
这是六秒钟，我将其设置为绕转。 

1826
01:19:46,470 --> 01:19:49,800
所以我认为这张卡面朝上大约四秒钟

1827
01:19:49,800 --> 01:19:51,730
可以，但是实际上并没有为它设置动画

1828
01:19:51,730 --> 01:19:54,680
然后这样一看，好像一直都在

1829
01:19:54,680 --> 01:19:56,650
但是，如果我单击离开然后再单击返回， 

1830
01:19:56,650 --> 01:19:58,140
哦，实际上我一直都在用光

1831
01:19:58,140 --> 01:20:00,660
导致该卡面朝上坐了这么长时间。 

1832
01:20:00,660 --> 01:20:03,130
现在，我认为这只是一点点。 

1833
01:20:03,130 --> 01:20:05,383
是的，那只是一点点。 

1834
01:20:06,290 --> 01:20:09,550
这个刚刚出现，所以它实际上在工作

1835
01:20:09,550 --> 01:20:13,230
它正在对此进行调整，但不是对其进行动画处理。 

1836
01:20:13,230 --> 01:20:15,570
那么我们该如何对其进行动画处理？ 

1837
01:20:15,570 --> 01:20:18,890
要对此进行动画处理有些挑战

1838
01:20:18,890 --> 01:20:22,700
因为这真正使人生气的是这个角度

1839
01:20:22,700 --> 01:20:27,700
从现在的位置（如此处）到零。 

1840
01:20:28,260 --> 01:20:31,250
我告诉你动画只显示你的东西

1841
01:20:31,250 --> 01:20:32,970
那已经发生了。 

1842
01:20:32,970 --> 01:20:36,830
但是当显示卡时，此时钟开始计时， 

1843
01:20:36,830 --> 01:20:38,590
它还没有达到零。 

1844
01:20:38,590 --> 01:20:41,210
那我该如何开始要制作的动画

1845
01:20:41,210 --> 01:20:44,230
当零还没有发生时，这个东西变成零吗？ 

1846
01:20:44,230 --> 01:20:47,840
那是个难题22。 

1847
01:20:47,840 --> 01:20:51,620
所以这个陷阱22会阻止我们

1848
01:20:51,620 --> 01:20:56,620
使用此奖励后直接从模型中获得。 

1849
01:20:56,660 --> 01:20:58,780
现在，如果我问模型， 

1850
01:20:58,780 --> 01:21:01,020
奖金剩余百分比是多少？ 

1851
01:21:01,020 --> 01:21:03,140
它会告诉我它总是会做的正确答案

1852
01:21:03,140 --> 01:21:04,600
那是模型的工作。 

1853
01:21:04,600 --> 01:21:06,260
因此，模型正在履行职责

1854
01:21:06,260 --> 01:21:08,880
但是，模型并没有不断变化。 

1855
01:21:08,880 --> 01:21:10,570
哦，还剩4.1秒， 

1856
01:21:10,570 --> 01:21:12,360
哦，我改变了，现在只有四秒钟， 

1857
01:21:12,360 --> 01:21:15,080
哦，我改变了，现在还剩下3.9秒， 

1858
01:21:15,080 --> 01:21:18,050
该模型不能做到这一点可笑。 

1859
01:21:18,050 --> 01:21:20,300
它正在做它的工作，但它以某种方式做到了

1860
01:21:20,300 --> 01:21:23,160
不会导致我们的用户界面发生变化

1861
01:21:23,160 --> 01:21:26,180
而动画只能使变化动起来。 

1862
01:21:26,180 --> 01:21:28,770
我们只是不能直接在模型中使用它， 

1863
01:21:28,770 --> 01:21:31,040
我们仍然必须与模型保持同步

1864
01:21:31,040 --> 01:21:33,560
但是我们不能直接使用它。 

1865
01:21:33,560 --> 01:21:35,470
所以我要动画这个角度

1866
01:21:35,470 --> 01:21:39,580
在这里使用我自己的小临时变量

1867
01:21:39,580 --> 01:21:41,580
它必须是可写的。 

1868
01:21:41,580 --> 01:21:43,450
我将不得不将其与模型同步。 

1869
01:21:43,450 --> 01:21:45,000
所以它将是一个@State 

1870
01:21:45,000 --> 01:21:47,540
正如我们在幻灯片中谈到的

1871
01:21:47,540 --> 01:21:50,080
而且是私人的，仅供我使用

1872
01:21:50,080 --> 01:21:54,400
因此，var，我将其命名为我的animatedBonusRemaining。 

1873
01:21:54,400 --> 01:21:56,720
我们将其设为度数的Double 

1874
01:21:56,720 --> 01:21:58,430
当然必须初始化

1875
01:21:58,430 --> 01:22:00,430
因为所有的变量都必须初始化

1876
01:22:00,430 --> 01:22:03,150
甚至是@State。 

1877
01:22:03,150 --> 01:22:05,980
所以我要用它代替奖金

1878
01:22:05,980 --> 01:22:08,070
直接来自模型

1879
01:22:08,070 --> 01:22:11,823
我将使用我的animatedBonusRemaining。 

1880
01:22:13,120 --> 01:22:16,030
现在我必须以某种方式使它成为正确的价值观

1881
01:22:16,030 --> 01:22:18,140
使动画发生。 

1882
01:22:18,140 --> 01:22:19,720
我要做的第一件事

1883
01:22:19,720 --> 01:22:21,800
得到它与模型同步。 

1884
01:22:21,800 --> 01:22:24,320
这必须与模型同步。 

1885
01:22:24,320 --> 01:22:25,770
我该怎么办？ 

1886
01:22:25,770 --> 01:22:28,590
好吧，真的，我什么时候要使其同步？ 

1887
01:22:28,590 --> 01:22:30,970
每次出现此视图时， 

1888
01:22:30,970 --> 01:22:32,620
我希望它与模型同步。 

1889
01:22:33,500 --> 01:22:35,410
现在，什么时候出现在屏幕上？ 

1890
01:22:35,410 --> 01:22:38,320
现在它以其容器出现在屏幕上

1891
01:22:38,320 --> 01:22:39,880
我们没有任何过渡

1892
01:22:39,880 --> 01:22:42,320
如果我们不知道什么时候发生，等等。 

1893
01:22:42,320 --> 01:22:44,650
所以我要让它只出现在屏幕上

1894
01:22:44,650 --> 01:22:47,680
如果我的卡是ConsumingBonusTime。 

1895
01:22:47,680 --> 01:22:51,750
所以这只是我模型中的变量告诉我

1896
01:22:51,750 --> 01:22:54,920
目前是否有卡

1897
01:22:54,920 --> 01:22:56,410
消耗奖金时间。 

1898
01:22:56,410 --> 01:22:59,230
这意味着它面朝上，尚未匹配

1899
01:22:59,230 --> 01:23:01,810
还有一些剩余时间可能是其他原因。 

1900
01:23:01,810 --> 01:23:04,120
我不在乎由我的模特告诉我

1901
01:23:04,120 --> 01:23:07,160
当前是否正在消耗骨骼时间。 

1902
01:23:07,160 --> 01:23:10,363
如果是，则此视图将显示在屏幕上。 

1903
01:23:11,240 --> 01:23:14,020
现在，为什么我只希望将其显示在屏幕上

1904
01:23:14,020 --> 01:23:15,900
当它实际上是动画时？ 

1905
01:23:15,900 --> 01:23:18,300
好吧，因为我正在使用这个动画值

1906
01:23:18,300 --> 01:23:19,790
剩下的奖金，好吗？ 

1907
01:23:19,790 --> 01:23:22,280
那真的，我只想这样做

1908
01:23:22,280 --> 01:23:23,790
当我实际上在做动画时

1909
01:23:23,790 --> 01:23:26,553
而且，它还允许我使用onAppear。 

1910
01:23:27,820 --> 01:23:30,810
所以您还记得我们在幻灯片中讨论过的onAppear。 

1911
01:23:30,810 --> 01:23:33,790
这是一个调用此关闭的函数

1912
01:23:33,790 --> 01:23:36,920
只要此视图出现在屏幕上。 

1913
01:23:36,920 --> 01:23:38,420
而这正是我想要的

1914
01:23:38,420 --> 01:23:40,790
因为每当这个东西出现在屏幕上时， 

1915
01:23:40,790 --> 01:23:44,250
我要重设我的奖金时间

1916
01:23:44,250 --> 01:23:46,300
成为模型中的内容。 

1917
01:23:46,300 --> 01:23:48,450
所以这个视图总是会开始的

1918
01:23:48,450 --> 01:23:50,030
与模型同步， 

1919
01:23:50,030 --> 01:23:51,950
然后我可以开始制作动画

1920
01:23:51,950 --> 01:23:54,020
但我们必须使其同步。 

1921
01:23:54,020 --> 01:23:56,560
所以我们在这里做一些功能

1922
01:23:56,560 --> 01:23:59,393
另一个小私人，称它为func 

1923
01:24:00,592 --> 01:24:05,190
假设是startBonusTimeAnimation。 

1924
01:24:05,190 --> 01:24:08,550
我想在这里做的第一件事就是设定

1925
01:24:08,550 --> 01:24:13,550
我的animationBonusRemaining等于模型中的值。 

1926
01:24:13,790 --> 01:24:15,000
这样我就一直保持同步。 

1927
01:24:15,000 --> 01:24:17,675
总是叫这个东西， 

1928
01:24:17,675 --> 01:24:19,930
startBonusTimeAnimation。 

1929
01:24:19,930 --> 01:24:22,710
每当这个Pie出现在屏幕上时， 

1930
01:24:22,710 --> 01:24:25,300
它会与模型同步，非常重要

1931
01:24:25,300 --> 01:24:29,090
如果您要拥有自己的版本

1932
01:24:29,090 --> 01:24:31,070
至少要在模型中进行动画处理

1933
01:24:31,070 --> 01:24:33,723
当它第一次出现在屏幕上时使其同步。 

1934
01:24:34,760 --> 01:24:36,400
那么，现在我该怎么办？ 

1935
01:24:36,400 --> 01:24:38,450
我的派出现在屏幕上，正在显示

1936
01:24:38,450 --> 01:24:40,200
剩余适当数量的奖励时间， 

1937
01:24:40,200 --> 01:24:43,690
但现在它希望将滴答声设置为零。 

1938
01:24:43,690 --> 01:24:46,050
所以我要照我说的去做

1939
01:24:46,050 --> 01:24:48,270
动画滴答声降为零

1940
01:24:48,270 --> 01:24:50,370
withAnimation 

1941
01:24:50,370 --> 01:24:52,403
让我们使用线性动画。 

1942
01:24:53,730 --> 01:24:56,173
请打零。 

1943
01:24:57,570 --> 01:25:00,690
我只是在动画剩余的奖金

1944
01:25:00,690 --> 01:25:02,330
滴答作响到零。 

1945
01:25:02,330 --> 01:25:03,210
等一下

1946
01:25:03,210 --> 01:25:06,540
制作动画需要多长时间？ 

1947
01:25:06,540 --> 01:25:10,150
好吧，最好剩下多少时间， 

1948
01:25:10,150 --> 01:25:12,260
我不希望它降到零慢

1949
01:25:12,260 --> 01:25:14,250
或比剩余时间快。 

1950
01:25:14,250 --> 01:25:15,120
所以我要

1951
01:25:15,120 --> 01:25:17,290
我动画的持续时间， 

1952
01:25:17,290 --> 01:25:20,090
等于卡的BonusTimeRemaining。 

1953
01:25:20,090 --> 01:25:21,520
剩下多少秒了

1954
01:25:21,520 --> 01:25:23,900
这是剩余的百分比

1955
01:25:23,900 --> 01:25:27,572
这是剩余的秒数。 

1956
01:25:27,572 --> 01:25:29,770
就是这样，所以这真的是我需要做的。 

1957
01:25:29,770 --> 01:25:33,630
我只剩下一点自己的奖金时间， 

1958
01:25:33,630 --> 01:25:35,000
我同步到模型

1959
01:25:35,000 --> 01:25:37,500
然后立即开始向零动画。 

1960
01:25:38,370 --> 01:25:40,540
如果派呆了那么久

1961
01:25:40,540 --> 01:25:42,520
我们将看到动画一直到零。 

1962
01:25:42,520 --> 01:25:44,520
如果停止消耗奖金时间， 

1963
01:25:44,520 --> 01:25:46,290
此视图将消失。 

1964
01:25:46,290 --> 01:25:48,010
它可能不会完成其动画

1965
01:25:48,010 --> 01:25:51,380
没关系，它只会在这里消失。 

1966
01:25:51,380 --> 01:25:54,800
现在，如果我们不浪费奖金时间， 

1967
01:25:54,800 --> 01:25:57,080
比如说卡片是匹配的。 

1968
01:25:57,080 --> 01:25:59,110
他们已经被配对，没有花费额外的时间。 

1969
01:25:59,110 --> 01:26:01,110
我实际上还是要在那里派

1970
01:26:01,110 --> 01:26:03,560
我只是不想让它动画。 

1971
01:26:03,560 --> 01:26:05,990
这很容易，在其他情况下， 

1972
01:26:05,990 --> 01:26:08,680
我也要放一个馅饼。 

1973
01:26:08,680 --> 01:26:10,030
现在，这个派， 

1974
01:26:10,030 --> 01:26:11,620
我们不在乎它何时出现

1975
01:26:11,620 --> 01:26:12,850
因为我们没有动画。 

1976
01:26:12,850 --> 01:26:15,620
它当然不能使用此animationBonusRemaining 

1977
01:26:15,620 --> 01:26:17,250
这就是这个派的意思。 

1978
01:26:17,250 --> 01:26:20,110
因此，让我们将其与

1979
01:26:20,110 --> 01:26:22,673
无论模型中说什么。 

1980
01:26:23,860 --> 01:26:26,030
现在，我不喜欢这里重复的代码， 

1981
01:26:26,030 --> 01:26:28,430
看到他们两个都有这种填充和不透明度

1982
01:26:28,430 --> 01:26:30,567
所以让我们离开这里。 

1983
01:26:30,567 --> 01:26:34,480
相反，我们将在整个过程中使用一个组

1984
01:26:34,480 --> 01:26:37,790
对它应用填充和不透明度。 

1985
01:26:37,790 --> 01:26:40,380
希望这应该涵盖这里的所有基础。 

1986
01:26:40,380 --> 01:26:43,200
这是动画时出现的Pie， 

1987
01:26:43,200 --> 01:26:44,750
我们与模型同步

1988
01:26:44,750 --> 01:26:46,960
然后开始趋向于零

1989
01:26:46,960 --> 01:26:48,430
但是还剩下很多时间。 

1990
01:26:48,430 --> 01:26:51,130
如果我们不浪费奖金时间，就没有动画

1991
01:26:51,130 --> 01:26:52,760
那我们就做一个普通的派

1992
01:26:52,760 --> 01:26:54,310
奖金留在那里。 

1993
01:26:55,232 --> 01:26:56,132
看看是否可行。 

1994
01:26:59,390 --> 01:27:01,050
好吧，让我们看。 

1995
01:27:01,050 --> 01:27:03,670
喔，看看这个动画

1996
01:27:03,670 --> 01:27:05,510
哦，甚至匹配。 

1997
01:27:05,510 --> 01:27:07,490
这是一个很好的例子，因为

1998
01:27:07,490 --> 01:27:09,220
我一点击就匹配了这个

1999
01:27:09,220 --> 01:27:12,210
所以我没有用我的奖金时间，所以看起来不错

2000
01:27:12,210 --> 01:27:13,760
然后，一旦我有一场比赛， 

2001
01:27:13,760 --> 01:27:15,700
它切换到这里使用这个派

2002
01:27:15,700 --> 01:27:17,950
只是告诉我我还有多少钱

2003
01:27:17,950 --> 01:27:20,000
当事物匹配时。 

2004
01:27:20,000 --> 01:27:20,842
对，让我们在这里再看一个

2005
01:27:20,842 --> 01:27:24,890
鬼和这个家伙，让我们远离这些

2006
01:27:24,890 --> 01:27:26,210
这将开始并返回

2007
01:27:26,210 --> 01:27:28,380
看看是否还有剩余的奖金时间

2008
01:27:28,380 --> 01:27:31,060
当我们面朝下继续时。 

2009
01:27:31,060 --> 01:27:32,850
哦，是的。 

2010
01:27:32,850 --> 01:27:34,653
好的， 

2011
01:27:35,810 --> 01:27:38,390
看看那里发生了什么事

2012
01:27:38,390 --> 01:27:39,240
就那么简单。 

2013
01:27:39,240 --> 01:27:44,240
现在，这比

2014
01:27:44,590 --> 01:27:45,810
一些动画

2015
01:27:45,810 --> 01:27:49,050
但是有这样的情况并不少见

2016
01:27:49,886 --> 01:27:52,060
您的模型或任何数据源

2017
01:27:52,060 --> 01:27:53,880
可以告诉你发生了什么事， 

2018
01:27:53,880 --> 01:27:56,040
但它并没有不断变化。 

2019
01:27:56,040 --> 01:27:57,380
这就是为什么有时您必须创建

2020
01:27:57,380 --> 01:28:01,130
您可以在此处创建动画的自己的变体， 

2021
01:28:01,130 --> 01:28:02,820
但请确保您将其与模型同步

2022
01:28:02,820 --> 01:28:04,393
在您这样做之前。 

2023
01:28:05,360 --> 01:28:08,180
好，今天是动画

2024
01:28:08,180 --> 01:28:10,560
我们覆盖了很多领域。 

2025
01:28:10,560 --> 01:28:12,910
我们谈到了隐式动画， 

2026
01:28:12,910 --> 01:28:16,710
我们的筋斗表情很激动

2027
01:28:16,710 --> 01:28:17,870
他们有一场比赛。 

2028
01:28:17,870 --> 01:28:20,350
我们有几个明确的动画

2029
01:28:20,350 --> 01:28:22,880
当我们选择一张卡时，我们在这里做了一个

2030
01:28:22,880 --> 01:28:25,533
当我们制作新游戏时，我们在这里又做了一个。 

2031
01:28:26,450 --> 01:28:30,500
我们还展示了动画ViewModifiers 

2032
01:28:30,500 --> 01:28:33,120
我们的卡片正在制作动画

2033
01:28:33,120 --> 01:28:36,800
我们甚至展示了如何不让View来来去去

2034
01:28:36,800 --> 01:28:39,620
如果我们不希望他们来来去去， 

2035
01:28:39,620 --> 01:28:41,140
我们动画了我们的形状

2036
01:28:42,200 --> 01:28:43,880
我们要做的就是说

2037
01:28:43,880 --> 01:28:46,930
Shape内的哪些数据可以动画显示， 

2038
01:28:46,930 --> 01:28:49,990
在我们的情况下，这是此处的起始终止角度。 

2039
01:28:49,990 --> 01:28:51,800
我们也做了一些过渡，对， 

2040
01:28:51,800 --> 01:28:54,510
我们进行了比例转换，以便当卡片匹配时， 

2041
01:28:54,510 --> 01:28:55,630
他们会消失。 

2042
01:28:55,630 --> 01:28:58,440
顺便说一下，我们可以进行类似的转换

2043
01:28:58,440 --> 01:29:01,440
例如，如果我们把这些饼放在这里， 

2044
01:29:01,440 --> 01:29:04,160
.scale饼图上的过渡， 

2045
01:29:04,160 --> 01:29:06,450
然后当我们的馅饼出现时， 

2046
01:29:09,280 --> 01:29:12,510
放大到不错的样子

2047
01:29:12,510 --> 01:29:13,490
有点放大。 

2048
01:29:13,490 --> 01:29:16,070
如果我们没有规模，我不知道你以前是否注意到， 

2049
01:29:16,070 --> 01:29:18,007
但这实际上是一种淡入

2050
01:29:18,007 --> 01:29:20,360
也许我们可能想说我们不想要任何一个

2051
01:29:20,360 --> 01:29:23,820
我们将使用身份转换

2052
01:29:23,820 --> 01:29:26,398
然后这个派，不管它来来去去， 

2053
01:29:26,398 --> 01:29:28,790
它会出现。很好，因为通常

2054
01:29:28,790 --> 01:29:30,890
卡片正面朝下时发生

2055
01:29:30,890 --> 01:29:32,560
或在两个派之间切换

2056
01:29:32,560 --> 01:29:36,463
如果我们匹配，则它们具有完全相同的值。 

2057
01:29:37,690 --> 01:29:39,000
动画就是这样

2058
01:29:39,000 --> 01:29:40,560
希望这就是您所需要知道的

2059
01:29:40,560 --> 01:29:41,800
关于动画。 

2060
01:29:41,800 --> 01:29:45,040
我的意思是，动画当然是一个强大的子系统， 

2061
01:29:45,040 --> 01:29:47,500
我们不必在应用程序中添加很多行代码

2062
01:29:47,500 --> 01:29:49,960
使其做所有这些疯狂的事情。 

2063
01:29:49,960 --> 01:29:52,240
但我并没有尽一切可能给你看

2064
01:29:52,240 --> 01:29:54,680
您可以通过任何方式在动画中使用。 

2065
01:29:54,680 --> 01:29:55,830
所以还有很多东西要学

2066
01:29:55,830 --> 01:29:57,593
但现在让您了解基本知识。 

2067
01:29:58,480 --> 01:30:00,560
下周，我不确定我们要做什么

2068
01:30:00,560 --> 01:30:03,420
下周，我们要做一些手势， 

2069
01:30:03,420 --> 01:30:06,840
你可能知道，捏手势之类的东西

2070
01:30:06,840 --> 01:30:09,410
否则我们可能会做

2071
01:30:09,410 --> 01:30:13,070
TextFields和Pickers，我看到了这个问题

2072
01:30:13,070 --> 01:30:14,607
在班级论坛上， 

2073
01:30:14,607 --> 01:30:15,960
也许我们会这样做。 

2074
01:30:15,960 --> 01:30:19,120
我们不太确定下周要去哪里

2075
01:30:19,120 --> 01:30:21,593
但请继续关注，然后您会发现的， 

2076
01:30:22,430 --> 01:30:25,130
-[旁白]欲了解更多信息，请访问stanford.edu 

