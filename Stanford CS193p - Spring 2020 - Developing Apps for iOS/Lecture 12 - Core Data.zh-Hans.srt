1
00:00:00,377 --> 00:00:03,127
（戏剧音乐） 

2
00:00:04,930 --> 00:00:06,843
-[Animaker Voice]斯坦福大学。 

3
00:00:08,790 --> 00:00:09,870
-[讲师]好的，我们来了， 

4
00:00:09,870 --> 00:00:14,870
讲座12，斯坦福CS193p，2020年春季。 

5
00:00:15,120 --> 00:00:18,200
今天的主题是核心数据

6
00:00:18,200 --> 00:00:22,720
这是一个面向对象的数据库。 

7
00:00:22,720 --> 00:00:24,470
我们已经做了很多

8
00:00:24,470 --> 00:00:27,070
本季度的函数式编程。 

9
00:00:27,070 --> 00:00:28,730
我们所做的几乎所有事情

10
00:00:28,730 --> 00:00:30,350
已经进行了功能编程。 

11
00:00:30,350 --> 00:00:32,420
我们现在要切换到做一些

12
00:00:32,420 --> 00:00:34,700
面向对象的编程。 

13
00:00:34,700 --> 00:00:37,630
可能甚至不会注意到这里的区别。 

14
00:00:37,630 --> 00:00:40,417
尽管Core Data基于面向对象的编程

15
00:00:40,417 --> 00:00:43,050
和Swift都支持面向对象

16
00:00:43,050 --> 00:00:44,800
和功能编程一样。 

17
00:00:45,890 --> 00:00:47,500
我们本质上将使用此核心数据

18
00:00:47,500 --> 00:00:50,490
存储和检索对象的基础架构

19
00:00:50,490 --> 00:00:53,323
或数据库中的类。 

20
00:00:54,410 --> 00:00:57,830
现在，有一种非常成熟的技术， 

21
00:00:57,830 --> 00:01:02,270
存储大型数据集已经有很长时间了， 

22
00:01:02,270 --> 00:01:04,890
它被称为SQL。 

23
00:01:04,890 --> 00:01:09,170
但是用SQL编程与那种编程有很大不同

24
00:01:09,170 --> 00:01:10,560
我们在Swift中进行的编程

25
00:01:10,560 --> 00:01:14,570
SQL是一种语言，它具有自己的语法

26
00:01:14,570 --> 00:01:16,340
这是完全不同的。 

27
00:01:16,340 --> 00:01:19,220
如果所有这些学习对我们来说将是一个遗憾

28
00:01:19,220 --> 00:01:21,230
我们已经完成了有关如何在Swift中进行编程的工作， 

29
00:01:21,230 --> 00:01:23,670
无法应用于存储数据。 

30
00:01:23,670 --> 00:01:26,190
所以我们要在这两个方面都做到最好

31
00:01:26,190 --> 00:01:30,760
因为Core Data实际上是用SQL存储的， 

32
00:01:30,760 --> 00:01:33,220
但我们将与我们的数据进行交互

33
00:01:33,220 --> 00:01:35,260
完全以面向对象的方式。 

34
00:01:35,260 --> 00:01:38,750
我们甚至不需要知道一个SQL语句

35
00:01:38,750 --> 00:01:40,710
为了做到这一点。 

36
00:01:40,710 --> 00:01:44,780
现在，在核心数据中进行此工作的核心是这张地图。 

37
00:01:44,780 --> 00:01:49,050
它是对象和对象上的变量之间的映射

38
00:01:49,050 --> 00:01:53,960
对象，以及关系数据库的表和行。 

39
00:01:53,960 --> 00:01:56,340
现在，如果您不知道什么是关系数据库

40
00:01:56,340 --> 00:01:57,770
所有这些，您真的不需要知道

41
00:01:57,770 --> 00:02:01,210
因为您将专注于对象和变量， 

42
00:02:01,210 --> 00:02:04,894
不在关系数据库中的表和行上， 

43
00:02:04,894 --> 00:02:08,120
Xcode对此地图有一个内置的编辑器， 

44
00:02:08,120 --> 00:02:09,810
真的很棒

45
00:02:09,810 --> 00:02:13,300
这个编辑器不仅让我们在

46
00:02:13,300 --> 00:02:16,810
vars，它使我们能够以图形方式创建关系

47
00:02:16,810 --> 00:02:19,990
在对象之间，因为这确实很重要， 

48
00:02:19,990 --> 00:02:21,740
不只是要在上面放有var的对象， 

49
00:02:21,740 --> 00:02:23,010
但是你有一些东西

50
00:02:23,010 --> 00:02:25,432
与其他对象的关系。 

51
00:02:25,432 --> 00:02:27,490
我们将看到一些示例， 

52
00:02:27,490 --> 00:02:30,290
很快，我们就会在演示中看到这一点。 

53
00:02:31,370 --> 00:02:33,460
那然后创建这张地图， 

54
00:02:33,460 --> 00:02:34,450
那你该怎么办？ 

55
00:02:34,450 --> 00:02:39,160
好吧，Xcode在幕后会生成类， 

56
00:02:39,160 --> 00:02:40,920
是的，类的代码， 

57
00:02:40,920 --> 00:02:42,520
代表那些对象和变量

58
00:02:42,520 --> 00:02:44,960
您在地图上创建的。 

59
00:02:44,960 --> 00:02:49,960
我们可以像使用其他扩展程序一样使用扩展程序

60
00:02:50,000 --> 00:02:50,870
一种数据结构。 

61
00:02:50,870 --> 00:02:53,500
我们可以使用扩展来添加我们自己的方法

62
00:02:53,500 --> 00:02:55,960
和我们自己对这些类的计算变量

63
00:02:55,960 --> 00:03:00,630
因为，存储变量存储在数据库中。 

64
00:03:00,630 --> 00:03:03,810
然后为我们创建的这些对象

65
00:03:03,810 --> 00:03:07,000
并且我们已经扩展了服务数据源

66
00:03:07,000 --> 00:03:09,090
用于用户界面中的元素。 

67
00:03:09,090 --> 00:03:11,510
因此，我们所有的SwiftUI都在做所有事情， 

68
00:03:11,510 --> 00:03:13,750
显然是将数据显示在屏幕上， 

69
00:03:13,750 --> 00:03:17,283
现在我们将它们存储在我们拥有的ViewModels中

70
00:03:17,283 --> 00:03:19,370
数组和字典以及所有这些东西。 

71
00:03:19,370 --> 00:03:22,160
好吧，现在这些数据将来自

72
00:03:22,160 --> 00:03:25,120
这个数据库，我们将要访问这些

73
00:03:25,120 --> 00:03:27,100
放置在屏幕上的对象。 

74
00:03:27,100 --> 00:03:30,593
完全自然，就像我们通常会做的那样。 

75
00:03:32,020 --> 00:03:34,110
那么，核心数据有哪些功能？ 

76
00:03:34,110 --> 00:03:37,270
当然，它具有用于创建对象的功能。 

77
00:03:37,270 --> 00:03:39,550
您必须能够在数据库中创建对象， 

78
00:03:39,550 --> 00:03:43,100
很自然地让您更改值

79
00:03:43,100 --> 00:03:45,850
这些对象上的var，因此只需更改它们即可。 

80
00:03:45,850 --> 00:03:47,950
它们只是变量，您将它们设置为等于

81
00:03:47,950 --> 00:03:50,130
繁荣，您只需更改数据库中的数据。 

82
00:03:50,130 --> 00:03:53,440
而且它甚至拥有漂亮的基础架构

83
00:03:53,440 --> 00:03:55,740
这些对象之间的关系。 

84
00:03:55,740 --> 00:03:57,969
基本上只需设置一个var 

85
00:03:57,969 --> 00:04:02,190
在一个对象和另一个对象之间建立关系

86
00:04:02,190 --> 00:04:03,990
通过关系，我的意思是

87
00:04:03,990 --> 00:04:06,170
航班有始发机场。 

88
00:04:06,170 --> 00:04:08,230
所以飞行物体和机场物体， 

89
00:04:08,230 --> 00:04:09,533
他们有关系。 

90
00:04:10,460 --> 00:04:14,080
当然，有一种方法可以保存这些对象

91
00:04:14,080 --> 00:04:16,620
非常重要的一点是您可以获取

92
00:04:16,620 --> 00:04:20,390
根据某些条件从数据库中获取对象。 

93
00:04:20,390 --> 00:04:22,370
你想说，我要所有的航班

94
00:04:22,370 --> 00:04:25,720
符合特定条件，在特定时间到达

95
00:04:25,720 --> 00:04:27,760
或任何可能的。 

96
00:04:27,760 --> 00:04:31,320
它具有出色的简单API 

97
00:04:31,320 --> 00:04:32,853
对象的获取。 

98
00:04:34,040 --> 00:04:37,510
现在，它除了具有以下功能外，还具有很多其他数据库功能

99
00:04:37,510 --> 00:04:40,252
它，乐观锁定和所有这些东西。 

100
00:04:40,252 --> 00:04:41,870
我们不会谈论这个。 

101
00:04:41,870 --> 00:04:42,990
这是入门课程， 

102
00:04:42,990 --> 00:04:45,510
所以我们这里只介绍核心数据的概念， 

103
00:04:45,510 --> 00:04:48,120
但是里面有很多东西

104
00:04:48,120 --> 00:04:50,223
使其达到很高的水平。 

105
00:04:51,800 --> 00:04:54,830
现在让我们谈谈SwiftUI的集成， 

106
00:04:54,830 --> 00:04:57,600
此核心数据数据库。 

107
00:04:57,600 --> 00:05:00,320
我们在数据库中创建的对象

108
00:05:00,320 --> 00:05:02,100
是ObservableObjects。 

109
00:05:02,100 --> 00:05:05,760
他们本质上是迷你ViewModel， 

110
00:05:05,760 --> 00:05:10,230
还有一个非常强大的属性包装器

111
00:05:10,230 --> 00:05:12,323
在名为@FetchRequest的SwiftUI中， 

112
00:05:13,360 --> 00:05:16,760
为我们获取这些对象。 

113
00:05:16,760 --> 00:05:20,020
因此，此FetchRequest不仅仅是一次获取。 

114
00:05:20,020 --> 00:05:22,560
这是一个常设查询， 

115
00:05:22,560 --> 00:05:26,970
只是不断地尝试匹配任何条件

116
00:05:26,970 --> 00:05:28,140
你说的是

117
00:05:28,140 --> 00:05:30,330
并返回数据库中的所有内容。 

118
00:05:30,330 --> 00:05:32,050
因此，当事情被添加到数据库中时， 

119
00:05:32,050 --> 00:05:35,120
如果它们符合该FetchRequest的条件， 

120
00:05:35,120 --> 00:05:37,470
然后将更新您的用户界面。 

121
00:05:37,470 --> 00:05:39,660
这样，我们的用户界面始终保持同步

122
00:05:39,660 --> 00:05:42,663
数据库真的，真的很棒。 

123
00:05:44,570 --> 00:05:47,870
那么如何将Core Data放入应用程序呢？ 

124
00:05:47,870 --> 00:05:49,030
您如何设置？ 

125
00:05:49,030 --> 00:05:51,750
好吧，设置它的真正方法

126
00:05:51,750 --> 00:05:53,560
当您创建一个新项目时， 

127
00:05:53,560 --> 00:05:55,430
你看到的那个按钮

128
00:05:55,430 --> 00:05:57,667
称为核心数据，请使用核心数据。 

129
00:05:57,667 --> 00:05:59,340
然后您要单击该

130
00:05:59,340 --> 00:06:02,100
这会做一些设置。 

131
00:06:02,100 --> 00:06:04,710
现在，如果您已经有一个应用程序并且已经决定， 

132
00:06:04,710 --> 00:06:06,600
哦，我想添加核心数据， 

133
00:06:06,600 --> 00:06:08,620
我建议返回并创建一个新项目

134
00:06:08,620 --> 00:06:10,870
然后单击此按钮，然后移动所有

135
00:06:10,870 --> 00:06:13,390
源代码，因为此按钮确实

136
00:06:13,390 --> 00:06:15,750
设置好工作。 

137
00:06:15,750 --> 00:06:18,150
那么这个按钮有什么作用呢？ 

138
00:06:18,150 --> 00:06:20,550
好吧，它为您创建了一个空白地图。 

139
00:06:20,550 --> 00:06:22,670
我告诉你的这张地图有内置的编辑器， 

140
00:06:22,670 --> 00:06:23,740
你有一片空白，其中之一， 

141
00:06:23,740 --> 00:06:26,370
因此您可以开始添加对象和var。 

142
00:06:26,370 --> 00:06:29,890
它将一些代码添加到您的AppDelegate中， 

143
00:06:29,890 --> 00:06:31,100
我将在演示中向您展示。 

144
00:06:31,100 --> 00:06:32,510
您还没有看过。 

145
00:06:32,510 --> 00:06:35,190
真的没什么，我们对此很感兴趣， 

146
00:06:35,190 --> 00:06:36,960
但是它确实添加了一点点代码

147
00:06:36,960 --> 00:06:40,413
创建数据库存储，实际的SQL数据库， 

148
00:06:40,413 --> 00:06:42,987
这些东西将被存储在里面。 

149
00:06:42,987 --> 00:06:45,260
因此，您无需查看该代码， 

150
00:06:45,260 --> 00:06:47,160
即使，这一切都是自动发生的。 

151
00:06:47,160 --> 00:06:48,250
我只是想让你知道

152
00:06:48,250 --> 00:06:50,550
它确实在那里做某事。 

153
00:06:50,550 --> 00:06:53,170
现在它确实添加了几行代码

154
00:06:53,170 --> 00:06:55,920
到您创建的地方的SceneDelegate 

155
00:06:55,920 --> 00:06:57,983
内容在那里查看。 

156
00:06:58,830 --> 00:07:02,980
代码行之一进入该存储区， 

157
00:07:02,980 --> 00:07:06,527
AppDelegate中的SQL存储代码，它捕获

158
00:07:06,527 --> 00:07:10,860
称为NSManagedObjectContext的东西。 

159
00:07:10,860 --> 00:07:14,170
而这种情况对于使用核心数据至关重要。 

160
00:07:14,170 --> 00:07:17,870
它是我们看到的窗户

161
00:07:17,870 --> 00:07:20,600
我们数据库中的所有对象， 

162
00:07:20,600 --> 00:07:22,660
而且您会发现我们每当我们需要联系时

163
00:07:22,660 --> 00:07:26,500
创建对象，我们就可以提取任何东西。 

164
00:07:26,500 --> 00:07:29,470
因此这两行具有SceneDelegate代码顺序， 

165
00:07:29,470 --> 00:07:31,810
从商店中获取上下文。 

166
00:07:31,810 --> 00:07:32,920
然后是第二个

167
00:07:32,920 --> 00:07:37,920
有趣的是将该上下文传递到您的SwiftUI 

168
00:07:38,750 --> 00:07:40,487
通过环境查看。 

169
00:07:40,487 --> 00:07:42,830
例如，我们已经看到了环境

170
00:07:42,830 --> 00:07:44,220
使用编辑模式。 

171
00:07:44,220 --> 00:07:45,810
这是再次使用环境， 

172
00:07:45,810 --> 00:07:48,970
这样您所有的SwiftUI视图都将具有此上下文

173
00:07:48,970 --> 00:07:51,480
他们可以看到数据库并获取对象

174
00:07:51,480 --> 00:07:53,620
摆脱所有这些。 

175
00:07:53,620 --> 00:07:56,250
因此，这已添加到您的SceneDelegate。 

176
00:07:56,250 --> 00:07:58,330
这几乎就是您需要的所有设置， 

177
00:07:58,330 --> 00:08:00,810
因为现在您可以创建对象，提取对象， 

178
00:08:00,810 --> 00:08:03,330
无论您拥有所需的数据库窗口， 

179
00:08:03,330 --> 00:08:05,030
您已经创建了地图， 

180
00:08:05,030 --> 00:08:07,730
无论您想要什么变量中的对象， 

181
00:08:07,730 --> 00:08:08,880
而你在路上。 

182
00:08:10,000 --> 00:08:11,550
因此，让我们看一下该地图。 

183
00:08:11,550 --> 00:08:14,370
我要，因为该演示将创建

184
00:08:14,370 --> 00:08:17,340
机场，航空公司和航班的详细地图

185
00:08:17,340 --> 00:08:20,190
在我们的途中，没有理由在这里进行检查， 

186
00:08:20,190 --> 00:08:22,350
但是只是为了给您一个印象， 

187
00:08:22,350 --> 00:08:24,670
看起来像这样，左边是一个例子， 

188
00:08:24,670 --> 00:08:28,020
我们有一个，看起来像是一次飞行

189
00:08:28,020 --> 00:08:31,740
它具有一些属性，例如何时到达

190
00:08:31,740 --> 00:08:33,170
或即将到来， 

191
00:08:33,170 --> 00:08:36,170
这是唯一的，甚至与其他人的关系

192
00:08:36,170 --> 00:08:38,280
诸如目的地机场， 

193
00:08:38,280 --> 00:08:39,577
始发机场的航空公司。 

194
00:08:39,577 --> 00:08:40,470
然后在右边， 

195
00:08:40,470 --> 00:08:43,330
您可以看到此图之间的关系图

196
00:08:43,330 --> 00:08:45,480
机场，航班和航空公司。 

197
00:08:45,480 --> 00:08:47,970
例如，如果您看到“航班”， 

198
00:08:47,970 --> 00:08:50,760
与机场有这种关系， 

199
00:08:50,760 --> 00:08:53,360
这是起源和另一个关系， 

200
00:08:53,360 --> 00:08:56,160
目的地，并注意机场有

201
00:08:56,160 --> 00:08:59,430
关系沿着同一条线， 

202
00:08:59,430 --> 00:09:01,047
这是从这个机场出发的航班， 

203
00:09:01,047 --> 00:09:03,290
以及飞往这个机场的航班。 

204
00:09:03,290 --> 00:09:07,830
现在，在Flight中，这些起点和终点的关系， 

205
00:09:07,830 --> 00:09:10,040
这些只是机场的物体。 

206
00:09:10,040 --> 00:09:13,590
那就是那些变量的类型，所有那些黑色的小词

207
00:09:13,590 --> 00:09:16,120
您会在此处看到代号，简称，飞机， 

208
00:09:16,120 --> 00:09:19,210
这些都只是我的Flight对象中的var， 

209
00:09:19,210 --> 00:09:21,040
我的航空公司对象，我的机场对象， 

210
00:09:21,040 --> 00:09:24,160
机场对象和目的地，起点只是变种

211
00:09:24,160 --> 00:09:26,610
他们的类型是机场。 

212
00:09:26,610 --> 00:09:28,800
现在，flightsFrom和flightsTo， 

213
00:09:28,800 --> 00:09:30,895
他们有点有趣，因为

214
00:09:30,895 --> 00:09:32,430
有多个往返机场的航班。 

215
00:09:32,430 --> 00:09:35,280
因此，这些实际上将是“航班集”。 

216
00:09:35,280 --> 00:09:37,740
那就是那个var的类型，那是一个Set， 

217
00:09:37,740 --> 00:09:39,498
一种旧的Objective-C风格的集。 

218
00:09:39,498 --> 00:09:41,610
我们将在演示中讨论这一点， 

219
00:09:41,610 --> 00:09:43,160
但这就是那里发生的事情。 

220
00:09:43,160 --> 00:09:45,520
所以我们在屏幕上看到的所有这些只是

221
00:09:45,520 --> 00:09:48,950
变成物体，航空公司，飞行和机场物体， 

222
00:09:48,950 --> 00:09:51,640
与无功，飞机，到达，出发文件， 

223
00:09:51,640 --> 00:09:54,480
这些都是这些东西上的变量。 

224
00:09:54,480 --> 00:09:55,850
这就是这张地图正在做的事情。 

225
00:09:55,850 --> 00:09:58,350
这实际上就是地图的全部内容。 

226
00:09:59,740 --> 00:10:02,640
所以一旦有了这张地图，现在就有了

227
00:10:02,640 --> 00:10:04,640
被传递到我们讨论过的您的环境中

228
00:10:04,640 --> 00:10:07,150
您的SceneDelegate，该怎么办？ 

229
00:10:07,150 --> 00:10:09,660
好吧，你可以得到那个窗口， 

230
00:10:09,660 --> 00:10:12,590
通过您的环境的那个managedObjectContext， 

231
00:10:12,590 --> 00:10:15,617
它是\ .managedObjectContext。 

232
00:10:15,617 --> 00:10:17,170
现在您有了这个上下文变量， 

233
00:10:17,170 --> 00:10:19,810
您可以使用它来执行创建对象之类的操作。 

234
00:10:19,810 --> 00:10:21,960
您只要说出Flight即可， 

235
00:10:21,960 --> 00:10:24,430
与参数上下文，以便知道

236
00:10:24,430 --> 00:10:25,660
进入数据库的窗口

237
00:10:25,660 --> 00:10:27,210
它将为您创建一个航班。 

238
00:10:27,210 --> 00:10:30,870
现在您在这里有一个绿色的航班

239
00:10:30,870 --> 00:10:33,430
您就可以开始在其上设置变量了。 

240
00:10:33,430 --> 00:10:36,350
与飞机一样，将其设置为“ B737”， 

241
00:10:36,350 --> 00:10:38,500
波音737飞机。 

242
00:10:38,500 --> 00:10:41,170
这是我要创建的机场的另一件事

243
00:10:41,170 --> 00:10:45,150
叫做KSJC，我将其设置为ICAO， 

244
00:10:45,150 --> 00:10:49,980
它是“ KSJC”机场的唯一标识符。 

245
00:10:49,980 --> 00:10:52,670
我什至可以做非常强大的var设置

246
00:10:52,670 --> 00:10:57,670
就像我将广告投放的.origin设置为ksjc一样， 

247
00:10:57,680 --> 00:11:00,570
因为kscj是机场，而原点是var 

248
00:11:00,570 --> 00:11:04,060
那是Airport类型，然后设置了这种关系。 

249
00:11:04,060 --> 00:11:07,280
这也会影响到相反的关系

250
00:11:07,280 --> 00:11:10,690
ksjc的flightFrom，将自动获得

251
00:11:10,690 --> 00:11:12,460
航班已添加到其中。 

252
00:11:12,460 --> 00:11:14,330
因此，您甚至不必担心平衡问题， 

253
00:11:14,330 --> 00:11:18,620
双方，是一组航班，一个是起点。 

254
00:11:18,620 --> 00:11:20,200
它会自动保持双方。 

255
00:11:20,200 --> 00:11:21,900
如果我已将其添加到“航班组”中， 

256
00:11:21,900 --> 00:11:24,410
然后将其设置为另一侧的原点。 

257
00:11:24,410 --> 00:11:27,040
因此，这是一个非常酷的系统。 

258
00:11:27,040 --> 00:11:28,690
所以这只是对象和变量。 

259
00:11:28,690 --> 00:11:30,360
所以你看起来就像

260
00:11:30,360 --> 00:11:31,660
对象和变量给我们。 

261
00:11:31,660 --> 00:11:34,510
我们对SQL或表和行一无所知， 

262
00:11:34,510 --> 00:11:35,610
只是对象和变量。 

263
00:11:37,090 --> 00:11:41,240
保存它，真的很容易，context.save（）， 

264
00:11:41,240 --> 00:11:45,590
但是，现在为什么要尝试保存它

265
00:11:45,590 --> 00:11:47,597
扔？好吧，之前的光盘可能已满， 

266
00:11:47,597 --> 00:11:49,390
一方面，这是极不可能的， 

267
00:11:49,390 --> 00:11:52,610
但是您的iOS设备没有无限的存储空间， 

268
00:11:52,610 --> 00:11:55,890
但可能还有其他错误，但你知道， 

269
00:11:55,890 --> 00:11:59,330
通常这不会失败，但是会抛出。 

270
00:11:59,330 --> 00:12:02,383
这就是为什么我们保存时必须在上面进行尝试。 

271
00:12:03,760 --> 00:12:05,070
现在，如何获取对象呢？ 

272
00:12:05,070 --> 00:12:06,170
将它们移出数据库？ 

273
00:12:06,170 --> 00:12:08,660
好吧，我们使用这个非常重要的对象

274
00:12:08,660 --> 00:12:11,190
在核心数据中称为NSFetchRequest。 

275
00:12:11,190 --> 00:12:12,023
行。 

276
00:12:12,023 --> 00:12:13,190
而且它不在乎

277
00:12:13,190 --> 00:12:16,510
这是您要获取的东西。 

278
00:12:16,510 --> 00:12:19,530
然后只需指定事物的名称即可创建一个

279
00:12:19,530 --> 00:12:23,520
在您的地图中，这就是您要获取的东西。 

280
00:12:23,520 --> 00:12:27,260
所以在这种情况下，Flight是我在地图上所说的

281
00:12:27,260 --> 00:12:28,770
飞行对象。 

282
00:12:28,770 --> 00:12:30,970
所以这将创建一个FetchRequest 

283
00:12:30,970 --> 00:12:32,760
并获取航班。 

284
00:12:32,760 --> 00:12:33,900
这就是这个要求。 

285
00:12:33,900 --> 00:12:37,870
现在，它如何知道要搭乘哪个航班？ 

286
00:12:37,870 --> 00:12:41,040
好吧，此请求中包含一个称为谓词的变量， 

287
00:12:41,040 --> 00:12:44,100
然后为它分配一个NSPredicate。 

288
00:12:44,100 --> 00:12:46,519
您一定要看一下文档

289
00:12:46,519 --> 00:12:50,200
的NSPredicate，并看到所有令人难以置信的广泛范围

290
00:12:50,200 --> 00:12:53,601
它可以指定您想要的航班的功能。 

291
00:12:53,601 --> 00:12:56,377
例如，我在这里创建了一个谓词， 

292
00:12:56,377 --> 00:12:59,120
谓词kinda有点printf 

293
00:12:59,120 --> 00:13:00,560
有种感觉。 

294
00:13:00,560 --> 00:13:02,430
这已经有很长时间了， 

295
00:13:02,430 --> 00:13:04,343
早在Swift尚未存在之前。 

296
00:13:05,290 --> 00:13:06,740
所以有点打印。 

297
00:13:06,740 --> 00:13:09,890
所以我的断言是我想到达

298
00:13:09,890 --> 00:13:13,810
在某物之前，而原点等于某物。 

299
00:13:13,810 --> 00:13:15,680
然后我提供一些东西。 

300
00:13:15,680 --> 00:13:19,017
首先是当前日期和时间。 

301
00:13:19,017 --> 00:13:21,290
第二个是ksjc。 

302
00:13:21,290 --> 00:13:22,570
所以这个谓词意味着

303
00:13:22,570 --> 00:13:25,840
告诉我现在之前到达的所有事物。 

304
00:13:25,840 --> 00:13:29,640
所以他们已经到了，他们的起源是圣何塞。 

305
00:13:29,640 --> 00:13:31,220
他们来自圣何塞。 

306
00:13:31,220 --> 00:13:33,460
这就是我在这里所做的判断。 

307
00:13:33,460 --> 00:13:35,010
所以有点，你知道， 

308
00:13:35,870 --> 00:13:39,050
那里的文本性定向谓词， 

309
00:13:39,050 --> 00:13:41,500
但您绝对必须去看看

310
00:13:41,500 --> 00:13:44,150
NSPredicate了解的文档

311
00:13:44,150 --> 00:13:46,330
它可以做的所有事情。 

312
00:13:46,330 --> 00:13:47,960
这就是指定哪个航班

313
00:13:47,960 --> 00:13:48,910
我想要一个数据库。 

314
00:13:48,910 --> 00:13:51,837
现在，您还需要其他一些要求， 

315
00:13:51,837 --> 00:13:54,070
这就是所谓的sortDescriptors。 

316
00:13:54,070 --> 00:13:56,620
这是因为当我们将此请求发送到

317
00:13:56,620 --> 00:13:59,320
数据库，它将以数组形式返回。 

318
00:13:59,320 --> 00:14:01,240
而且该数组必须排序。 

319
00:14:01,240 --> 00:14:04,280
并且我们指定sortDescriptors以便排序

320
00:14:04,280 --> 00:14:06,550
发生在数据库方面

321
00:14:06,550 --> 00:14:09,320
SQL数据库非常擅长对事物进行排序。 

322
00:14:09,320 --> 00:14:12,150
因此，如果可能的话，我们将让它进行排序。 

323
00:14:12,150 --> 00:14:14,370
然后使用sortDescriptors var 

324
00:14:14,370 --> 00:14:17,459
只是这些NSSortDescriptor的数组， 

325
00:14:17,459 --> 00:14:21,240
而SortDescriptor只是说var，ident 

326
00:14:21,240 --> 00:14:23,850
在这种情况下，这就是广告投放标识符

327
00:14:23,850 --> 00:14:24,950
你想排序， 

328
00:14:24,950 --> 00:14:27,420
以及您是要上升还是下降，对， 

329
00:14:27,420 --> 00:14:29,720
字母顺序从A到Z或Z到A。 

330
00:14:29,720 --> 00:14:33,100
然后我们如何问我们的情况， 

331
00:14:33,100 --> 00:14:36,110
我们的数据库，为我们获取这些东西？ 

332
00:14:36,110 --> 00:14:39,870
我们使用获取功能来做到这一点。 

333
00:14:39,870 --> 00:14:43,780
所以我们说context.fetch这个请求，它将去

334
00:14:43,780 --> 00:14:48,130
进入数据库并查找所有航班并进行匹配

335
00:14:48,130 --> 00:14:51,030
这个到达和起源的谓词， 

336
00:14:51,030 --> 00:14:52,580
并将它们还给我们。 

337
00:14:52,580 --> 00:14:56,770
现在，这种提取也可以抛出，就像保存可以抛出一样， 

338
00:14:56,770 --> 00:15:00,577
可以提取，因此我们需要尝试一下。 

339
00:15:00,577 --> 00:15:02,770
很多时候，我们会编写如下代码

340
00:15:02,770 --> 00:15:05,010
让航班=尝试？ 

341
00:15:05,010 --> 00:15:07,300
然后是context.fetch。 

342
00:15:07,300 --> 00:15:08,470
如果我们这样做

343
00:15:08,470 --> 00:15:11,330
那么，航班var要么为零， 

344
00:15:11,330 --> 00:15:16,330
如果获取失败，则为空数组，如果没有失败， 

345
00:15:17,120 --> 00:15:20,010
但没有任何航班符合我们的谓词。 

346
00:15:20,010 --> 00:15:22,640
否则，它只是一个飞行对象数组， 

347
00:15:22,640 --> 00:15:24,090
匹配的。 

348
00:15:24,090 --> 00:15:26,500
同样，非常面向对象。 

349
00:15:26,500 --> 00:15:28,360
我只是得到这些飞行对象

350
00:15:28,360 --> 00:15:29,713
与我的谓词相符。 

351
00:15:30,620 --> 00:15:32,180
我把所有这些都扔在一张幻灯片上， 

352
00:15:32,180 --> 00:15:34,807
只是让您对所有代码都有感觉。 

353
00:15:34,807 --> 00:15:37,750
因此，您对它有一种快速参考指南， 

354
00:15:37,750 --> 00:15:40,560
但是我们当然要进行一个大型演示， 

355
00:15:40,560 --> 00:15:42,163
显示所有发生的事情。 

356
00:15:43,070 --> 00:15:45,230
现在如何与所有这些东西集成

357
00:15:45,230 --> 00:15:46,320
和SwiftUI？ 

358
00:15:46,320 --> 00:15:48,250
好吧，集成有两个要点

359
00:15:48,250 --> 00:15:49,110
我们谈过的。 

360
00:15:49,110 --> 00:15:52,260
一个就是这个ObservedObject。 

361
00:15:52,260 --> 00:15:55,880
飞行时，在您的SwiftUI之一中作为var 

362
00:15:55,880 --> 00:15:58,880
视图，它将是一个@ObservedObject。 

363
00:15:58,880 --> 00:16:03,019
然后，您可以在此处使用它像Text（flight.ident）一样， 

364
00:16:03,019 --> 00:16:04,723
并显示出自己的身份并运用您想做的任何事情， 

365
00:16:04,723 --> 00:16:06,670
这只是一个对象。 

366
00:16:06,670 --> 00:16:09,880
顺便说一下，据我所知， 

367
00:16:09,880 --> 00:16:11,840
似乎不会自动触发

368
00:16:11,840 --> 00:16:13,890
当数据库中发生更改时。 

369
00:16:13,890 --> 00:16:15,260
因此，如果您希望他们进行更改， 

370
00:16:15,260 --> 00:16:18,250
您需要显式调用objectWillChange。 

371
00:16:18,250 --> 00:16:21,900
但是这些确实使这些航班，机场和航空公司

372
00:16:21,900 --> 00:16:24,450
感觉就像迷你ViewModels一样。 

373
00:16:24,450 --> 00:16:26,030
这就是它们的本质。 

374
00:16:26,030 --> 00:16:28,743
他们只是小小的ViewModels， 

375
00:16:29,810 --> 00:16:32,150
但是很多时候我们想要在用户界面中显示的更多

376
00:16:32,150 --> 00:16:34,210
而不是一个航班或一个航空公司。 

377
00:16:34,210 --> 00:16:36,240
我们想显示所有航班，例如， 

378
00:16:36,240 --> 00:16:38,787
匹配某个FetchRequest或谓词。 

379
00:16:38,787 --> 00:16:42,400
因此，还有一个非常重要的功能

380
00:16:42,400 --> 00:16:46,800
在SwiftUI中，称为FetchRequest属性包装器。 

381
00:16:46,800 --> 00:16:50,760
现在，使用该属性包装器，使用参数创建它， 

382
00:16:50,760 --> 00:16:53,150
要么是与FetchRequest相同的参数， 

383
00:16:53,150 --> 00:16:54,250
是实体

384
00:16:54,250 --> 00:16:56,610
请记住，实体名称是飞行， 

385
00:16:56,610 --> 00:16:58,710
以及sortDescriptors和Predicate。 

386
00:16:58,710 --> 00:17:00,460
因此，您可以以这种方式创建FetchRequest， 

387
00:17:00,460 --> 00:17:02,270
或者您可以实际创建FetchRequest 

388
00:17:02,270 --> 00:17:04,570
只要给它一个您创建的FetchRequest， 

389
00:17:04,570 --> 00:17:08,350
无论哪种方式，您都指定要获取的内容。 

390
00:17:08,350 --> 00:17:10,250
这是一个属性包装器，对吗？ 

391
00:17:10,250 --> 00:17:12,585
因此，它包装了一些var。 

392
00:17:12,585 --> 00:17:16,050
包装的var的类型称为

393
00:17:16,050 --> 00:17:19,140
FetchedResults，也有不在乎， 

394
00:17:19,140 --> 00:17:21,300
那当然不在乎是什么样的事情

395
00:17:21,300 --> 00:17:22,440
它应该获取。 

396
00:17:22,440 --> 00:17:24,784
这样可以更好地匹配您的FetchRequest 

397
00:17:24,784 --> 00:17:28,140
说它正在尝试获取。 

398
00:17:28,140 --> 00:17:32,000
现在，此FetchedResults变量是集合。 

399
00:17:32,000 --> 00:17:34,940
因此，您可以将其传递给ForEach，如您所见。 

400
00:17:34,940 --> 00:17:37,050
但这不是一个数组

401
00:17:37,050 --> 00:17:39,420
但是如果你想把这个东西变成一个数组

402
00:17:39,420 --> 00:17:42,450
真的很容易，您可以将其作为数组的

403
00:17:42,450 --> 00:17:44,610
初始化程序，因为数组知道如何取任何

404
00:17:44,610 --> 00:17:46,870
收集并将其转换为数组。 

405
00:17:46,870 --> 00:17:49,370
您还可以向其发送诸如已排序的消息， 

406
00:17:49,370 --> 00:17:51,640
排序后可以发送到任何收藏集， 

407
00:17:51,640 --> 00:17:53,010
它返回一个数组。 

408
00:17:53,010 --> 00:17:57,140
而那个收藏里充满了那些

409
00:17:57,140 --> 00:18:00,450
您正在获取航班对象或机场对象。 

410
00:18:00,450 --> 00:18:05,100
现在，您在这里创建的这个var的最酷的地方是

411
00:18:05,100 --> 00:18:08,640
航班或机场是它一直在努力

412
00:18:08,640 --> 00:18:11,450
获取该FetchRequest。 

413
00:18:11,450 --> 00:18:12,283
行， 

414
00:18:12,283 --> 00:18:14,620
这不是一次性提取，而是要提取出来的

415
00:18:14,620 --> 00:18:15,600
并给你结果。 

416
00:18:15,600 --> 00:18:18,250
它一直在进行此提取。 

417
00:18:18,250 --> 00:18:19,680
这就像一个常设查询。 

418
00:18:19,680 --> 00:18:23,550
因此，每次添加新的机场或新的航班

419
00:18:23,550 --> 00:18:26,420
在那里，或者即使现有的机场或航班发生变化

420
00:18:26,420 --> 00:18:29,940
其中一个变量，因此现在它与您的谓词匹配， 

421
00:18:29,940 --> 00:18:32,170
它会更新。 

422
00:18:32,170 --> 00:18:33,460
当它更新时

423
00:18:33,460 --> 00:18:37,710
您的SwiftUI将失效并重新绘制。 

424
00:18:37,710 --> 00:18:40,620
因此，您的用户界面总是会显示

425
00:18:40,620 --> 00:18:42,060
数据库中有什么。 

426
00:18:42,060 --> 00:18:45,520
您无需告诉它去获取。 

427
00:18:45,520 --> 00:18:48,760
这都是SwiftUI声明性性质的一部分。 

428
00:18:48,760 --> 00:18:50,650
你不是说做事

429
00:18:50,650 --> 00:18:52,950
在SwiftUI中，您只需声明事物是确定的

430
00:18:52,950 --> 00:18:55,160
方式，而且它们始终都是那样。 

431
00:18:55,160 --> 00:18:56,820
当然，有了Core Data， 

432
00:18:56,820 --> 00:18:58,750
我们总是希望他们看起来像什么

433
00:18:58,750 --> 00:19:00,110
在数据库中。 

434
00:19:00,110 --> 00:19:03,310
所以我们倾向于使用@FetchRequests， 

435
00:19:03,310 --> 00:19:07,380
有时即使我们只是在获取一个对象，对吗？ 

436
00:19:07,380 --> 00:19:10,570
我们可能拥有谓词，就像身份一样， 

437
00:19:10,570 --> 00:19:12,860
等于某件事能飞行

438
00:19:12,860 --> 00:19:14,100
要匹配一次飞行。 

439
00:19:14,100 --> 00:19:16,150
但是很棒的是，如果航班发生变化， 

440
00:19:16,150 --> 00:19:18,230
这将被更新。 

441
00:19:18,230 --> 00:19:21,150
这就是为什么ObservedObjects在那里的事实， 

442
00:19:21,150 --> 00:19:23,813
我们正在谈论不要似乎在做他们的

443
00:19:23,813 --> 00:19:26,150
当某些更改时，objectWillChange。 

444
00:19:26,150 --> 00:19:27,580
那真的不是什么大问题， 

445
00:19:27,580 --> 00:19:29,970
因为我们可能只有一个FetchRequest 

446
00:19:29,970 --> 00:19:31,010
拿到一件事。 

447
00:19:31,010 --> 00:19:34,210
这将改变，因为FetchRequest始终

448
00:19:34,210 --> 00:19:35,950
跟踪数据库中发生的事情。 

449
00:19:35,950 --> 00:19:38,540
这确实是一个很棒的属性包装器。 

450
00:19:38,540 --> 00:19:42,330
您在这里看到的这个API非常优雅， 

451
00:19:42,330 --> 00:19:46,060
简单的一件事，使您的用户界面始终

452
00:19:46,060 --> 00:19:47,670
与核心数据匹配。 

453
00:19:47,670 --> 00:19:49,170
这真的很酷。 

454
00:19:50,500 --> 00:19:53,520
顺便说一下，我在那里显示了FetchRequest。 

455
00:19:53,520 --> 00:19:55,220
我正在创建它。 

456
00:19:55,220 --> 00:19:58,410
当我用所需的FetchRequest声明vars时， 

457
00:19:58,410 --> 00:20:00,690
但是你当然可以声明它，我会告诉你

458
00:20:00,690 --> 00:20:02,810
在演示中，然后使用您的init 

459
00:20:02,810 --> 00:20:05,410
并设置_flights，右_flights 

460
00:20:05,410 --> 00:20:08,410
是实际的结构，FetchRequest结构

461
00:20:08,410 --> 00:20:10,330
然后成为您创造的东西。 

462
00:20:10,330 --> 00:20:13,000
因此，例如，如果您要传递谓词， 

463
00:20:13,000 --> 00:20:15,810
您想要使用的，可以将其传递给您的init， 

464
00:20:15,810 --> 00:20:18,610
然后您的init就可以初始化FetchRequest 

465
00:20:18,610 --> 00:20:21,630
事情，就像我们已经初始化了这样的绑定

466
00:20:21,630 --> 00:20:24,130
陈述其包装的价值， 

467
00:20:24,130 --> 00:20:25,877
您可以在这里做同样的事情。 

468
00:20:25,877 --> 00:20:27,830
我们将在演示中看到这一点。 

469
00:20:27,830 --> 00:20:31,850
说到这，让我们直接进入演示

470
00:20:31,850 --> 00:20:34,300
告诉你做这些事情的样子。 

471
00:20:35,480 --> 00:20:38,890
我们在此演示中的目标是转换我们的路线， 

472
00:20:38,890 --> 00:20:42,290
使用我们的核心数据数据库并存储所有信息

473
00:20:42,290 --> 00:20:45,190
从FlightAware降到数据库中

474
00:20:45,190 --> 00:20:48,800
然后只需查看数据库即可构建整个UI。 

475
00:20:48,800 --> 00:20:50,930
现在，我们实际上正在获取这些东西。 

476
00:20:50,930 --> 00:20:52,630
当它回到FlightAware中时， 

477
00:20:52,630 --> 00:20:54,240
我们直接在用户界面中显示它， 

478
00:20:54,240 --> 00:20:56,630
在这里，我们将从FlightAware获取所有信息， 

479
00:20:56,630 --> 00:20:58,800
放入数据库，然后使用我们的用户界面， 

480
00:20:58,800 --> 00:21:00,810
完全只看数据库。 

481
00:21:00,810 --> 00:21:04,560
这是开发一种

482
00:21:04,560 --> 00:21:08,010
提取数据的应用程序，而不必尝试

483
00:21:08,010 --> 00:21:10,730
跟踪并获取所有最新信息

484
00:21:10,730 --> 00:21:11,900
一直有信息

485
00:21:11,900 --> 00:21:12,977
您只需将其放入数据库中即可。 

486
00:21:12,977 --> 00:21:15,280
因此，您始终在查看数据库

487
00:21:15,280 --> 00:21:18,080
并使您的代码在UI端更加简单。 

488
00:21:18,080 --> 00:21:19,830
这正是我们要做的。 

489
00:21:20,690 --> 00:21:22,850
现在，如果您想在应用中使用Core Data， 

490
00:21:22,850 --> 00:21:27,830
最好的方法是当您说“新项目”时

491
00:21:27,830 --> 00:21:31,950
在这里，单击此按钮，使用Core Data。 

492
00:21:31,950 --> 00:21:33,450
如果您点击此按钮，请使用“核心数据”， 

493
00:21:33,450 --> 00:21:36,770
您将获得少量非常重要的代码

494
00:21:36,770 --> 00:21:40,640
可以将您连接到数据库，该附加按钮， 

495
00:21:40,640 --> 00:21:43,130
通过使用CloudKit的方式，这非常酷。 

496
00:21:43,130 --> 00:21:45,060
这样可以使您放入的所有内容

497
00:21:45,060 --> 00:21:48,360
数据库镜像到iCloud。 

498
00:21:48,360 --> 00:21:51,670
这样用户将可以在所有设备上看到它

499
00:21:51,670 --> 00:21:52,503
在核心数据中。 

500
00:21:52,503 --> 00:21:53,520
相当了不起。 

501
00:21:53,520 --> 00:21:55,270
我们不会做那一部分。 

502
00:21:55,270 --> 00:21:56,710
这个演示已经足够长了， 

503
00:21:56,710 --> 00:21:58,700
所以我们只关注核心数据部分， 

504
00:21:58,700 --> 00:22:00,740
但这并不复杂。 

505
00:22:00,740 --> 00:22:01,610
如果您对此感兴趣， 

506
00:22:01,610 --> 00:22:03,693
您当然可以查找该怎么做。 

507
00:22:04,620 --> 00:22:06,100
现在，如果您已经启动了应用程序， 

508
00:22:06,100 --> 00:22:08,650
就像我们在Enroute中一样，您想添加， 

509
00:22:08,650 --> 00:22:10,510
核心数据功能

510
00:22:10,510 --> 00:22:12,560
我实际上建议做我做的事， 

511
00:22:12,560 --> 00:22:15,800
马上回去创建了一个新项目， 

512
00:22:15,800 --> 00:22:18,280
然后复制并粘贴我的所有代码， 

513
00:22:18,280 --> 00:22:21,150
将我的文件拖回新项目中， 

514
00:22:21,150 --> 00:22:23,480
因为这个小小的开关确实做得很好， 

515
00:22:23,480 --> 00:22:24,803
通过设置。 

516
00:22:25,700 --> 00:22:26,910
因此，让我们看一下该设置。 

517
00:22:26,910 --> 00:22:30,050
让我们看看这个小开关的作用。 

518
00:22:30,050 --> 00:22:33,660
并真正添加了两个重要的代码段。 

519
00:22:33,660 --> 00:22:36,300
一个叫做AppDelegate的东西就在这里， 

520
00:22:36,300 --> 00:22:39,330
我们还没有看过AppDelegate， 

521
00:22:39,330 --> 00:22:41,640
但是我们现在要看看

522
00:22:41,640 --> 00:22:44,080
在这里您可以看到它已经添加了这个叫做Core Data的东西

523
00:22:44,080 --> 00:22:47,350
与此持久容器堆叠在这里。 

524
00:22:47,350 --> 00:22:51,270
那就是保存您的核心数据数据库的东西。 

525
00:22:51,270 --> 00:22:54,260
因此，我们将使用它， 

526
00:22:54,260 --> 00:22:56,590
访问数据库。 

527
00:22:56,590 --> 00:22:59,810
在我们的SceneDelegate中，创建我们的小东西

528
00:22:59,810 --> 00:23:03,082
FlightsEnrouteView，请注意，它添加了几行

529
00:23:03,082 --> 00:23:06,500
此上下文中的代码

530
00:23:06,500 --> 00:23:08,760
容器，我们只是在谈论它， 

531
00:23:08,760 --> 00:23:11,390
得到一些叫做上下文的东西。 

532
00:23:11,390 --> 00:23:15,500
然后在这种情况下通过环境传递

533
00:23:15,500 --> 00:23:17,050
我们所有的观点。 

534
00:23:17,050 --> 00:23:20,760
现在我们要非常确定，当我们提出一个新的

535
00:23:20,760 --> 00:23:23,990
视图环境，例如当我们使用工作表或弹出窗口时

536
00:23:23,990 --> 00:23:27,550
或类似的东西，我们将其传递给它。 

537
00:23:27,550 --> 00:23:29,720
现在，将环境提供给视图时，请记住它， 

538
00:23:29,720 --> 00:23:32,803
人体中的所有视图，实际上是人体中的视图

539
00:23:32,803 --> 00:23:34,830
获得相同的环境。 

540
00:23:34,830 --> 00:23:36,170
因此，您不必将它们传递到那里。 

541
00:23:36,170 --> 00:23:37,940
但是，如果您现在进行工作表或弹出框， 

542
00:23:37,940 --> 00:23:41,400
你有点像一个新的基体。 

543
00:23:41,400 --> 00:23:43,520
所以您确实需要通过，然后您会看到的， 

544
00:23:43,520 --> 00:23:45,520
因为，当然，我们在此应用程序中做了一张表格， 

545
00:23:45,520 --> 00:23:47,743
我们有那个过滤航班。 

546
00:23:49,020 --> 00:23:52,540
因此，此上下文是我们进入数据库的窗口。 

547
00:23:52,540 --> 00:23:55,830
数据库本身在哪里或数据库是什么？ 

548
00:23:55,830 --> 00:23:59,340
而数据库是我们使用这小部分设计的

549
00:23:59,340 --> 00:24:00,470
文件夹就在这里， 

550
00:24:00,470 --> 00:24:03,620
使用核心数据也可以提供此功能。 

551
00:24:03,620 --> 00:24:04,600
这里是。 

552
00:24:04,600 --> 00:24:07,080
这是所有的对象

553
00:24:07,080 --> 00:24:08,810
我们将在数据库中创建的内容。 

554
00:24:08,810 --> 00:24:12,810
现在，请记住，这是一个面向对象的编程层

555
00:24:12,810 --> 00:24:16,270
在这种情况下，位于SQL数据库之上。 

556
00:24:16,270 --> 00:24:17,877
普通的关系数据库。 

557
00:24:17,877 --> 00:24:19,730
因此，它正在为我们完成所有映射。 

558
00:24:19,730 --> 00:24:22,070
我们不知道那是一个SQL数据库，我们

559
00:24:22,070 --> 00:24:25,060
不想知道，我们只是要创建对象。 

560
00:24:25,060 --> 00:24:26,920
这就是这里的工具， 

561
00:24:26,920 --> 00:24:30,730
此工具正在编辑此.xcdatamodeld文件

562
00:24:30,730 --> 00:24:33,680
让我们去做，定义我们想要的对象

563
00:24:33,680 --> 00:24:37,640
数据库，这些对象上的变量是什么。 

564
00:24:37,640 --> 00:24:39,730
因此，让我们深入研究并创建我们的对象。 

565
00:24:39,730 --> 00:24:41,070
这是途中。 

566
00:24:41,070 --> 00:24:42,490
我们有什么物品？ 

567
00:24:42,490 --> 00:24:44,180
好吧，我们有航班。 

568
00:24:44,180 --> 00:24:45,360
那是主要对象

569
00:24:45,360 --> 00:24:47,110
我们展示的所有这些航班， 

570
00:24:47,110 --> 00:24:50,020
但是我们也有一些辅助对象，例如

571
00:24:50,020 --> 00:24:52,570
航空公司和机场的对象。 

572
00:24:52,570 --> 00:24:56,680
因此，让我们在此处创建Flight，Airline和Airport对象。 

573
00:24:56,680 --> 00:25:00,417
该实体是我们想要的对象列表。 

574
00:25:00,417 --> 00:25:03,250
然后将其添加到此处，即添加实体。 

575
00:25:03,250 --> 00:25:05,050
如此繁荣。 

576
00:25:05,050 --> 00:25:08,550
我们称我们的第一个实体为Airport。 

577
00:25:08,550 --> 00:25:10,840
让我们添加另一个实体， 

578
00:25:10,840 --> 00:25:15,480
称为航空公司，我们的第三个实体， 

579
00:25:15,480 --> 00:25:17,223
这是一次飞行。 

580
00:25:19,090 --> 00:25:20,670
所以我们在这里创建了对象

581
00:25:20,670 --> 00:25:22,210
但他们没有var。 

582
00:25:22,210 --> 00:25:24,680
右边的这是显示vars， 

583
00:25:24,680 --> 00:25:27,270
尤其是这部分属性的顶部， 

584
00:25:27,270 --> 00:25:30,610
当然，我们的对象还没有任何变量。 

585
00:25:30,610 --> 00:25:33,320
让我们从最简单的航空公司开始。 

586
00:25:33,320 --> 00:25:35,040
它只有三个变量。 

587
00:25:35,040 --> 00:25:39,617
它具有一个代码，并且此代码的​​类型为String。 

588
00:25:41,050 --> 00:25:42,490
这就是我们添加变量的方式， 

589
00:25:42,490 --> 00:25:44,110
我们只要按加号

590
00:25:44,110 --> 00:25:47,640
给它一个vars一个名字，然后输入它的类型。 

591
00:25:47,640 --> 00:25:51,170
它也有一个名字。 

592
00:25:51,170 --> 00:25:55,303
该名称也是一个字符串，它是

593
00:25:55,303 --> 00:25:59,030
像“联合航空公司”这样的航空公司， 

594
00:25:59,030 --> 00:26:00,310
这样的东西。 

595
00:26:00,310 --> 00:26:03,930
但它在FlightAware信息中也有一个简短的名称

596
00:26:03,930 --> 00:26:08,210
回来了，就像“曼联” 

597
00:26:08,210 --> 00:26:11,687
又甜美，不是一个昵称，而是它的简称。 

598
00:26:11,687 --> 00:26:12,520
就是这样。 

599
00:26:12,520 --> 00:26:14,820
这就是FlightAware的全部功能

600
00:26:14,820 --> 00:26:17,800
对于我们感兴趣的航空公司。 

601
00:26:17,800 --> 00:26:18,730
那机场呢？ 

602
00:26:18,730 --> 00:26:22,530
因此，机场有一件非常重要的事情叫国际民航组织， 

603
00:26:22,530 --> 00:26:27,530
这是一个字符串，就像KSFO或KDFW，KSJC 

604
00:26:29,190 --> 00:26:31,700
对于圣何塞，那是唯一的代码。 

605
00:26:31,700 --> 00:26:33,970
您会注意到，它们都是以K开头的机场

606
00:26:33,970 --> 00:26:36,150
美国以K开头。 

607
00:26:36,150 --> 00:26:40,410
因此，这对我们来说很重要， 

608
00:26:40,410 --> 00:26:42,170
但他们也会得到一些很酷的东西， 

609
00:26:42,170 --> 00:26:44,300
就像我们得到的经度和纬度一样

610
00:26:44,300 --> 00:26:46,170
那些是双打。 

611
00:26:46,170 --> 00:26:49,630
这些是从FlightAware遇到的数字， 

612
00:26:49,630 --> 00:26:51,170
所以我们要把它们存放在这里

613
00:26:51,170 --> 00:26:53,513
在我们的数据库中为Doubles。 

614
00:26:54,410 --> 00:26:57,280
还有其他一些东西，例如机场的位置。 

615
00:26:57,280 --> 00:27:00,750
所以对于圣何塞，那就是加利福尼亚州圣何塞

616
00:27:00,750 --> 00:27:02,150
是它的位置。 

617
00:27:02,150 --> 00:27:05,910
我们也有它所在的时区。 

618
00:27:05,910 --> 00:27:10,010
当我们在天空飞翔的时候，所有的飞行员， 

619
00:27:10,010 --> 00:27:13,930
格林威治标准时间，一切都在格林尼治标准时间进行。 

620
00:27:13,930 --> 00:27:17,400
很高兴知道实际机场的时区

621
00:27:17,400 --> 00:27:19,890
我们将要转换为本地时间。 

622
00:27:19,890 --> 00:27:22,490
然后所有的机场都有一个名字。 

623
00:27:22,490 --> 00:27:25,210
就像我认为的旧金山国际机场

624
00:27:25,210 --> 00:27:27,083
是SFO的全名。 

625
00:27:28,220 --> 00:27:29,053
那是机场。 

626
00:27:29,053 --> 00:27:30,290
那航班呢？ 

627
00:27:30,290 --> 00:27:34,170
航班在FlightAware中称为ident。 

628
00:27:34,170 --> 00:27:38,520
这就像UA475联合航空的475号航班。 

629
00:27:38,520 --> 00:27:40,120
表示其唯一标识符。 

630
00:27:40,120 --> 00:27:41,470
我们绝对希望能够独一无二

631
00:27:41,470 --> 00:27:43,423
确定我们的航班。 

632
00:27:44,410 --> 00:27:47,640
我们的航班也有飞机。 

633
00:27:47,640 --> 00:27:52,640
所以这就像一个字符串“ 737”之类。 

634
00:27:52,990 --> 00:27:56,990
当然我们有到达时间和离开时间。 

635
00:27:56,990 --> 00:28:01,923
这些是日期，请在此处输入日期，到达和离开。 

636
00:28:03,400 --> 00:28:06,100
事实证明，航班还有另一个日期， 

637
00:28:06,100 --> 00:28:09,990
这是他们提起的出发，因为某些航班

638
00:28:09,990 --> 00:28:11,870
还在地上，他们还没有离开

639
00:28:11,870 --> 00:28:14,270
要么延迟，要么还没计划离开， 

640
00:28:14,270 --> 00:28:17,700
但是他们已经提起，飞行员已经提起了一段时间

641
00:28:17,700 --> 00:28:19,810
他们要你离开。 

642
00:28:19,810 --> 00:28:20,950
就是这样了。 

643
00:28:20,950 --> 00:28:24,560
这些是我们的对象及其变量

644
00:28:24,560 --> 00:28:27,200
但是我们的面向对象难题还有另外一块

645
00:28:27,200 --> 00:28:30,880
在这里，这是对象之间的关系。 

646
00:28:30,880 --> 00:28:35,150
例如，航班有始发地和目的地机场。 

647
00:28:35,150 --> 00:28:36,490
那里有关系

648
00:28:36,490 --> 00:28:38,940
航班也有航空公司。 

649
00:28:38,940 --> 00:28:42,070
因此，我们可以在此部分中添加这些关系， 

650
00:28:42,070 --> 00:28:45,620
关系，但我们通常不那样做。 

651
00:28:45,620 --> 00:28:48,530
相反，我们转到这里，直到

652
00:28:48,530 --> 00:28:51,640
角落，我们从这种面向表的表切换

653
00:28:51,640 --> 00:28:55,010
我们正在使用这个图形版本。 

654
00:28:55,010 --> 00:28:57,177
这为我们提供了与以前一样的信息， 

655
00:28:57,177 --> 00:29:01,450
取决于一些图形版本和这些个人

656
00:29:01,450 --> 00:29:03,080
vars，如果我们点击它们， 

657
00:29:03,080 --> 00:29:05,810
我们可以通过这里查看类型和所有内容

658
00:29:05,810 --> 00:29:08,350
并调出第三个窗格检查器， 

659
00:29:08,350 --> 00:29:10,520
我们真的没有看过

660
00:29:10,520 --> 00:29:12,710
整个季度的时间，因为SwiftUI并未真正使用它

661
00:29:12,710 --> 00:29:15,380
这么多，但在这里真的很有价值。 

662
00:29:15,380 --> 00:29:19,230
这是该检查器中的第四个选项卡， 

663
00:29:19,230 --> 00:29:22,330
并显示此位置是var，这是此类型

664
00:29:22,330 --> 00:29:24,640
请注意，此处显示“可选”。 

665
00:29:24,640 --> 00:29:29,080
这并不意味着像Swift Optionals一样可选。 

666
00:29:29,080 --> 00:29:31,300
这意味着它在数据库中是可选的。 

667
00:29:31,300 --> 00:29:33,980
所以这个不幸的是，它具有确切的名称， 

668
00:29:33,980 --> 00:29:36,110
但这确实无关。 

669
00:29:36,110 --> 00:29:39,697
所有这些var和Swift，都是可选的。 

670
00:29:40,644 --> 00:29:44,210
那确实是那里的设计决定

671
00:29:44,210 --> 00:29:47,310
因为您的数据库可能已损坏，您可能会认为

672
00:29:47,310 --> 00:29:50,600
所有这些东西都有价值，但它们没有价值。 

673
00:29:50,600 --> 00:29:54,120
他们是开始创建对象并失败了， 

674
00:29:54,120 --> 00:29:56,030
因此现在没有设置这些变量。 

675
00:29:56,030 --> 00:29:58,250
这就是为什么这些是可选的。 

676
00:29:58,250 --> 00:30:01,290
我将向您展示一些设计策略

677
00:30:01,290 --> 00:30:04,300
或我代码中的任何内容，以识别那些

678
00:30:04,300 --> 00:30:07,584
确实不应该是可选的，并覆盖一下它们

679
00:30:07,584 --> 00:30:10,890
加上一些语法糖，或者实际上我只是要使用

680
00:30:10,890 --> 00:30:14,070
计算的var，以使它们不是可选的。 

681
00:30:14,070 --> 00:30:15,150
您会看到我们如何做到的。 

682
00:30:15,150 --> 00:30:17,610
但是默认情况下，所有这些都是可选的，并且没有任何内容

683
00:30:17,610 --> 00:30:19,700
在这里使用此开关。 

684
00:30:19,700 --> 00:30:20,740
所以我们可以设置其他内容， 

685
00:30:20,740 --> 00:30:22,500
默认值之类的东西。 

686
00:30:22,500 --> 00:30:25,400
但主要是我们在此图形中所做的

687
00:30:25,400 --> 00:30:30,310
安排是在这些对象之间创建连接。 

688
00:30:30,310 --> 00:30:32,440
例如，让我们谈谈我们的航班。 

689
00:30:32,440 --> 00:30:36,560
它想要目的地机场和始发机场。 

690
00:30:36,560 --> 00:30:37,393
那么我们该怎么做呢？ 

691
00:30:37,393 --> 00:30:39,050
好吧，我们用控制键来做到这一点。 

692
00:30:39,050 --> 00:30:42,010
所以我按住控制键，您会看到加号出现。 

693
00:30:42,010 --> 00:30:45,030
我要从航班上拖走

694
00:30:45,030 --> 00:30:48,540
转到我的机场，然后放手。 

695
00:30:48,540 --> 00:30:52,040
它在这里创建了一点关系，一点线。 

696
00:30:52,040 --> 00:30:55,340
现在这只是双方的变种， 

697
00:30:55,340 --> 00:30:56,270
在飞行方面， 

698
00:30:56,270 --> 00:30:58,790
目前称为var newRelationship。 

699
00:30:58,790 --> 00:31:00,880
我只是双击它

700
00:31:00,880 --> 00:31:04,340
但我实际上希望这是我的目的地机场。 

701
00:31:04,340 --> 00:31:07,180
我叫这个var目的地。 

702
00:31:07,180 --> 00:31:10,640
现在，这个var是什么类型

703
00:31:10,640 --> 00:31:13,810
当Xcode创建构成该对象的所有代码时

704
00:31:13,810 --> 00:31:17,280
东西，这将是一个类型的变量

705
00:31:17,280 --> 00:31:19,980
机场，因为机场是一个对象， 

706
00:31:19,980 --> 00:31:21,700
我们在这里进行面向对象的编程。 

707
00:31:21,700 --> 00:31:24,730
这些都是Xcode会提供的一种新对象

708
00:31:24,730 --> 00:31:25,770
为我们创建代码。 

709
00:31:25,770 --> 00:31:27,510
真的很酷。 

710
00:31:27,510 --> 00:31:28,990
现在在这边的机场呢？ 

711
00:31:28,990 --> 00:31:31,830
好吧，这里的关系真的像

712
00:31:31,830 --> 00:31:34,922
飞往这个机场的航班。 

713
00:31:34,922 --> 00:31:37,470
这是复数的航班， 

714
00:31:37,470 --> 00:31:41,400
因为如果我有20个航班全部飞往同一个机场， 

715
00:31:41,400 --> 00:31:44,330
好吧，这一定是

716
00:31:44,330 --> 00:31:45,690
多个航班或其他内容。 

717
00:31:45,690 --> 00:31:46,620
这是如何运作的？ 

718
00:31:46,620 --> 00:31:48,550
因为这不可能是航班。 

719
00:31:48,550 --> 00:31:51,040
这一定像一堆航班。 

720
00:31:51,040 --> 00:31:54,400
确实，我们这样做的方式是可以检查

721
00:31:54,400 --> 00:31:58,080
特殊的关系，并说而不是“一对一” 

722
00:31:58,080 --> 00:32:01,750
关系，这里每个机场有一个航班， 

723
00:32:01,750 --> 00:32:05,860
这是“多对多”的关系，您可以看到

724
00:32:05,860 --> 00:32:08,150
箭头变成了双箭头。 

725
00:32:08,150 --> 00:32:11,550
现在，这不再只是一次飞行。 

726
00:32:11,550 --> 00:32:13,730
这是多次飞行，这很有意义。 

727
00:32:13,730 --> 00:32:18,393
一个机场有多个前往的航班。 

728
00:32:19,560 --> 00:32:22,080
这个var的类型是什么， 

729
00:32:22,080 --> 00:32:23,740
这个var flightTo 

730
00:32:23,740 --> 00:32:27,860
它的类型将是一组飞行。 

731
00:32:27,860 --> 00:32:30,870
不幸的是，这不是快速的航班。 

732
00:32:30,870 --> 00:32:34,120
这是旧的Objective-C飞行套件。 

733
00:32:34,120 --> 00:32:36,520
所以，您将看到我们不得不再做一点

734
00:32:36,520 --> 00:32:41,132
清理，语法糖，计算出的var使其变成

735
00:32:41,132 --> 00:32:44,800
就是我们想要的，我们真的希望它是一个Swift Set 

736
00:32:44,800 --> 00:32:48,000
的航班数，而不是Objective-C的航班数。 

737
00:32:48,000 --> 00:32:50,400
这是Objective-C泄漏的少数几个地方之一

738
00:32:50,400 --> 00:32:54,550
不幸的是，通过Core Data进行操作很容易，但是很容易解决。 

739
00:32:54,550 --> 00:32:58,320
现在我要从这里的Flight up进行另一个控制拖动， 

740
00:32:58,320 --> 00:33:00,120
始发机场。 

741
00:33:00,120 --> 00:33:03,870
所以这里的新关系是起源，起源

742
00:33:05,020 --> 00:33:07,810
在这里，这是这边的关系

743
00:33:07,810 --> 00:33:11,840
是flightFrom，而这个flightFrom， 

744
00:33:11,840 --> 00:33:14,190
也是“多对多”的关系。 

745
00:33:14,190 --> 00:33:17,130
因此，这两个都是“多对多”关系。 

746
00:33:17,130 --> 00:33:18,240
和航空公司一样

747
00:33:18,240 --> 00:33:21,150
当然，每次飞行都由一名

748
00:33:21,150 --> 00:33:23,174
Firline，所以我们在这里有关系， 

749
00:33:23,174 --> 00:33:25,410
在这边叫航空公司。 

750
00:33:25,410 --> 00:33:27,560
和这里类似，这是航班。 

751
00:33:27,560 --> 00:33:32,020
这些是此航空公司运营的所有航班。 

752
00:33:32,020 --> 00:33:34,423
这就是“多对多”的关系。 

753
00:33:35,450 --> 00:33:38,190
现在，我们在这里所做的所有工作将这些连接起来

754
00:33:38,190 --> 00:33:40,750
并创建这些小关系变量

755
00:33:40,750 --> 00:33:43,830
我们可以在这里以普通的编辑器样式看到它。 

756
00:33:43,830 --> 00:33:44,900
这是航空公司。 

757
00:33:44,900 --> 00:33:48,550
它有航班，机场有航班往返

758
00:33:48,550 --> 00:33:51,743
航班有目的地，始发地和航空公司。 

759
00:33:53,120 --> 00:33:54,120
就是这样了。 

760
00:33:54,120 --> 00:33:58,920
这就是我们在这里构建对象模型的方式。 

761
00:33:58,920 --> 00:34:02,870
使这些对象存在所需的所有代码，以及

762
00:34:02,870 --> 00:34:07,507
所有这些变量都存在，这完全由Xcode为我们完成。 

763
00:34:07,507 --> 00:34:09,330
我们只是在这里建立。 

764
00:34:09,330 --> 00:34:11,820
它经历并创建所有代码

765
00:34:11,820 --> 00:34:13,950
这是使该工作必不可少的。 

766
00:34:13,950 --> 00:34:17,190
我们要添加的唯一代码是扩展。 

767
00:34:17,190 --> 00:34:20,490
因此，我们将在此处的扩展中添加一些代码。 

768
00:34:20,490 --> 00:34:21,970
这是面向对象的编程， 

769
00:34:21,970 --> 00:34:24,830
当然，我们希望我们的对象要做的不只是拥有

770
00:34:24,830 --> 00:34:28,430
这些变量，我们希望它也具有某些行为。 

771
00:34:28,430 --> 00:34:31,313
我们将使用扩展名添加该行为。 

772
00:34:32,310 --> 00:34:33,510
让我们现在回去。 

773
00:34:33,510 --> 00:34:35,620
现在我们有了整个对象模型， 

774
00:34:35,620 --> 00:34:37,510
我们拥有了想要创建的所有对象， 

775
00:34:37,510 --> 00:34:40,260
让我们在用户界面中使用它们。 

776
00:34:40,260 --> 00:34:43,500
这是我们上次构建的UI代码， 

777
00:34:43,500 --> 00:34:46,860
它仍然基于FlightFetcher机制， 

778
00:34:46,860 --> 00:34:49,270
我们将完全取代FlightFetcher。 

779
00:34:49,270 --> 00:34:52,560
我最终将完全注释FlightFetcher。 

780
00:34:52,560 --> 00:34:55,790
相反，我们将使用面向对象的方法

781
00:34:55,790 --> 00:34:56,853
建立用户界面。 

782
00:34:58,060 --> 00:35:00,580
顺便说一下，在我们开始之前， 

783
00:35:00,580 --> 00:35:02,070
看一下这个文件的顶部， 

784
00:35:02,070 --> 00:35:04,100
您会看到导入核心数据。 

785
00:35:04,100 --> 00:35:06,490
您想确保以任何方式导入核心数据

786
00:35:06,490 --> 00:35:08,990
您将要在其中执行核心数据的文件， 

787
00:35:08,990 --> 00:35:11,200
否则像NSManagedObjectContext这样的符号是

788
00:35:12,690 --> 00:35:15,153
不会被定义。 

789
00:35:16,050 --> 00:35:18,900
现在，我将从这个非常重要的结构开始

790
00:35:18,900 --> 00:35:20,270
就在这里，FlightSearch， 

791
00:35:20,270 --> 00:35:24,260
目前正在按其代码查询机场

792
00:35:24,260 --> 00:35:26,530
和航空公司的代码。 

793
00:35:26,530 --> 00:35:28,750
我将其切换为面向对象。 

794
00:35:28,750 --> 00:35:31,740
我的目的地不是像“ KPAO”这样的字符串， 

795
00:35:31,740 --> 00:35:34,120
这将是一个机场。 

796
00:35:34,120 --> 00:35:34,980
还有同样的事情。 

797
00:35:34,980 --> 00:35:38,210
我的原籍将是一个可选机场， 

798
00:35:38,210 --> 00:35:41,500
我的航空公司将成为一家航空公司。 

799
00:35:41,500 --> 00:35:46,100
所以这将完全改变我们所有的代码

800
00:35:46,100 --> 00:35:48,193
面向对象。 

801
00:35:49,190 --> 00:35:54,190
顺便说一句，有时候在构建对象模型时， 

802
00:35:54,515 --> 00:35:57,860
您的其余代码将不会得到有关它的消息。 

803
00:35:57,860 --> 00:36:00,510
就像我们仍然未宣布机场一样， 

804
00:36:00,510 --> 00:36:03,510
因为Xcode可以在后台为我们构建它。 

805
00:36:03,510 --> 00:36:05,160
我通常会尝试在这里建造

806
00:36:05,160 --> 00:36:06,913
有时会解决。 

807
00:36:08,480 --> 00:36:09,313
是的，那还不是很清楚。 

808
00:36:09,313 --> 00:36:13,060
另一个要做的就是在这里回到您的模型

809
00:36:13,060 --> 00:36:16,800
并进行构建，有时会成功

810
00:36:16,800 --> 00:36:18,350
看看是否在这里解决了。 

811
00:36:20,199 --> 00:36:22,080
看起来确实如此。 

812
00:36:22,080 --> 00:36:23,740
因此lemme看看我们遇到了什么样的错误。 

813
00:36:23,740 --> 00:36:25,660
所以我们显然仍然有很多错误

814
00:36:25,660 --> 00:36:29,180
我们有整个代码是基于String的。 

815
00:36:29,180 --> 00:36:31,040
而且这些不再是字符串。 

816
00:36:31,040 --> 00:36:34,270
因此，让我们通过解决我们遇到的问题来解决问题

817
00:36:34,270 --> 00:36:36,880
通过将其更改为面向对象而引入

818
00:36:36,880 --> 00:36:37,940
并一一修复。 

819
00:36:37,940 --> 00:36:40,330
在此过程中，我们将学到很多有关如何

820
00:36:40,330 --> 00:36:42,390
在数据库中创建这些对象， 

821
00:36:42,390 --> 00:36:45,860
如何查找它们并在数据库中找到它们。 

822
00:36:45,860 --> 00:36:49,030
这就是使用Core Data的全部内容

823
00:36:49,030 --> 00:36:51,420
使这些东西面向对象。 

824
00:36:51,420 --> 00:36:52,640
因此，让我们从第一个开始。 

825
00:36:52,640 --> 00:36:55,701
它说这里，不能将值类型字符串转换为预期

826
00:36:55,701 --> 00:36:57,840
输入参数Airport。 

827
00:36:57,840 --> 00:37:01,320
好的，我们已经在这里看到一种使用字符串的情况

828
00:37:01,320 --> 00:37:03,060
代替机场对象。 

829
00:37:03,060 --> 00:37:06,363
因此，让我们单击它，将我们带到SceneDelegate， 

830
00:37:07,380 --> 00:37:09,670
确实，在这里，我们正在尝试创建一个

831
00:37:09,670 --> 00:37:13,600
带有字符串的FlightSearch，再次应用了目的地

832
00:37:13,600 --> 00:37:16,560
搜索曾经是一个字符串，我们只是将其更改为Airport。 

833
00:37:16,560 --> 00:37:18,870
因此，让我们创建一个局部变量

834
00:37:18,870 --> 00:37:20,003
成为我们这里的机场。 

835
00:37:20,003 --> 00:37:24,000
我要说的是，让机场相等。 

836
00:37:24,000 --> 00:37:28,270
这个机场必须是某种机场对象。 

837
00:37:28,270 --> 00:37:33,210
现在可以使用此方法直接创建对象

838
00:37:33,210 --> 00:37:35,300
所谓的上下文，对不对？ 

839
00:37:35,300 --> 00:37:39,590
我们讨论的上下文是进入数据库的窗口

840
00:37:39,590 --> 00:37:42,350
我们从很少使用核心数据中得到的

841
00:37:42,350 --> 00:37:43,183
按钮就在这里。 

842
00:37:43,183 --> 00:37:44,840
而且这种情况非常重要。 

843
00:37:44,840 --> 00:37:48,170
我们所做的一切都是通过它的窗口， 

844
00:37:48,170 --> 00:37:49,030
到数据库。 

845
00:37:49,030 --> 00:37:51,750
这就是我们在数据库中进行所有操作的方式， 

846
00:37:51,750 --> 00:37:55,690
但我们不会在这里这样做，因为这很可能是

847
00:37:55,690 --> 00:37:57,860
我要在这里建立的这个机场

848
00:37:57,860 --> 00:37:59,870
我实质上是在尝试创建机场

849
00:37:59,870 --> 00:38:04,870
KSFO对，这个机场可能已经在数据库中。 

850
00:38:05,600 --> 00:38:07,570
所以我这里需要一些功能， 

851
00:38:07,570 --> 00:38:12,480
我要用ICAO来调用，它需要这个字符串

852
00:38:12,480 --> 00:38:15,910
并在数据库中查找，如果找到了机场

853
00:38:15,910 --> 00:38:17,950
对象，它给了我。 

854
00:38:17,950 --> 00:38:20,350
如果没有，那么它就变成了一个， 

855
00:38:20,350 --> 00:38:22,050
不仅制造一个，而且去取它

856
00:38:22,050 --> 00:38:23,830
也来自FlightAware。 

857
00:38:23,830 --> 00:38:25,640
这就是这个小功能要做的。 

858
00:38:25,640 --> 00:38:28,970
现在，我们如何向机场对象添加函数

859
00:38:28,970 --> 00:38:30,470
Xcode为我们创建的？ 

860
00:38:30,470 --> 00:38:33,040
我们将扩展它。 

861
00:38:33,040 --> 00:38:35,450
而且我们只是要扩展这堂课， 

862
00:38:35,450 --> 00:38:38,160
这个面向对象的类机场，要有这个静态

863
00:38:38,160 --> 00:38:41,590
功能，使我们可以按名称查找机场。 

864
00:38:41,590 --> 00:38:42,990
因此，让我们开始吧。 

865
00:38:42,990 --> 00:38:45,520
我实际上是在这里创建该文件的

866
00:38:45,520 --> 00:38:48,390
目前为机场和空白文件。 

867
00:38:48,390 --> 00:38:52,319
我要说机场的延伸

868
00:38:52,319 --> 00:38:55,730
在这里，我将使用ICAO进行此静态功能。 

869
00:38:57,021 --> 00:38:59,060
这将采用我当时的一些特殊代码

870
00:38:59,060 --> 00:39:02,960
告诉你，它将返回一个机场。 

871
00:39:02,960 --> 00:39:07,960
这将只是在核心数据中查找国际民航组织。 

872
00:39:08,630 --> 00:39:11,893
如果找到了，将其退回， 

873
00:39:12,920 --> 00:39:17,050
如果没有，那么我们将创建一个

874
00:39:17,050 --> 00:39:20,330
并从FlightAware获取。 

875
00:39:20,330 --> 00:39:23,680
这就是该功能要执行的操作。 

876
00:39:23,680 --> 00:39:26,420
因此，让我们从此开始，向上看， 

877
00:39:26,420 --> 00:39:27,440
仍在抱怨

878
00:39:27,440 --> 00:39:29,430
我们暂时不用担心。 

879
00:39:29,430 --> 00:39:33,090
我们想在核心数据中查找此代码。 

880
00:39:33,090 --> 00:39:35,430
那么我们如何在核心数据中查找数据

881
00:39:35,430 --> 00:39:37,510
看看那里有东西吗？ 

882
00:39:37,510 --> 00:39:39,630
我们通过一个非常重要的对象

883
00:39:39,630 --> 00:39:41,333
FetchRequest，NSFetchRequest。 

884
00:39:42,580 --> 00:39:47,120
实际上，所以我要让请求等于NSFetchRequest 

885
00:39:47,120 --> 00:39:50,680
现在，NSFetchRequest是通用的，它不在乎， 

886
00:39:50,680 --> 00:39:54,523
这是您要获取的对象。 

887
00:39:55,940 --> 00:40:00,210
然后，您将实体名称指定为字符串。 

888
00:40:00,210 --> 00:40:03,787
这个字符串就是你放的任何东西

889
00:40:03,787 --> 00:40:07,260
这里是您实体的名称。 

890
00:40:07,260 --> 00:40:09,213
因此，“航空公司”，“机场”或“航班”。 

891
00:40:10,460 --> 00:40:12,520
因此，这就是创建FetchRequest的方式。 

892
00:40:12,520 --> 00:40:16,130
现在FetchRequest本质上是一个指南

893
00:40:16,130 --> 00:40:19,210
我们将用来拥有数据库， 

894
00:40:19,210 --> 00:40:22,730
知道我们想要的机场或可能的机场

895
00:40:22,730 --> 00:40:24,240
寻找多个机场。 

896
00:40:24,240 --> 00:40:26,240
我们可能会按时区寻找机场， 

897
00:40:26,240 --> 00:40:27,877
这样我们可以在这里获得多个机场

898
00:40:27,877 --> 00:40:30,230
这个要求让我们指定

899
00:40:30,230 --> 00:40:32,570
我们想要哪些。 

900
00:40:32,570 --> 00:40:36,220
因此，请求包含两个非常重要的部分。 

901
00:40:36,220 --> 00:40:39,490
一个叫做它的谓词， 

902
00:40:39,490 --> 00:40:42,500
它的谓词是，您想要哪个？ 

903
00:40:42,500 --> 00:40:46,000
然后使用称为NSPredicate的对象创建该对象。 

904
00:40:46,000 --> 00:40:50,160
有点儿像printf的感觉， 

905
00:40:50,160 --> 00:40:52,860
在其中为您要搜索的内容提供格式

906
00:40:52,860 --> 00:40:54,720
然后是所有适合的参数。 

907
00:40:54,720 --> 00:40:56,770
因此，它又是Swift之前的版本。 

908
00:40:56,770 --> 00:41:01,040
所以它不会感觉超级Swift-y，因为它是printf-y， 

909
00:41:01,040 --> 00:41:03,550
但您会非常轻松地习惯它。 

910
00:41:03,550 --> 00:41:04,610
举例来说， 

911
00:41:04,610 --> 00:41:09,250
我们希望国际民航组织等于某件事。 

912
00:41:09,250 --> 00:41:10,930
那是什么东西？ 

913
00:41:10,930 --> 00:41:14,150
在这里传递给我们的国际民航组织，对吗？ 

914
00:41:14,150 --> 00:41:17,750
我希望我的谓语是ICAO， 

915
00:41:17,750 --> 00:41:22,750
请使用此值在数据库中查找此变量。 

916
00:41:22,830 --> 00:41:26,700
然后，您可以做类似的事情，然后再做另一件事，或者

917
00:41:26,700 --> 00:41:29,150
或其他等于其他。 

918
00:41:29,150 --> 00:41:31,990
还有更强大的功能可供您选择

919
00:41:31,990 --> 00:41:35,900
模式匹配并开始于各种事物。 

920
00:41:35,900 --> 00:41:38,940
这个谓词对象，很明显，如果您要执行此操作

921
00:41:38,940 --> 00:41:41,060
您将需要查找的核心数据

922
00:41:41,060 --> 00:41:43,160
在文档中并了解所有强大的功能

923
00:41:43,160 --> 00:41:46,090
你可以做的事情找出哪些对象

924
00:41:46,090 --> 00:41:47,563
您要从数据库中获取。 

925
00:41:48,820 --> 00:41:51,360
我们想在这里知道的另一件事

926
00:41:51,360 --> 00:41:54,400
是sortDescriptors。 

927
00:41:54,400 --> 00:41:58,360
现在，sortDescriptors是这些东西的数组

928
00:41:58,360 --> 00:41:59,560
称为NSSortDescriptor， 

929
00:42:01,460 --> 00:42:03,130
和SortDescriptor有两件事。 

930
00:42:03,130 --> 00:42:06,550
一个是您要排序的var的名称， 

931
00:42:06,550 --> 00:42:08,070
那么实际上，如果我正在寻找机场， 

932
00:42:08,070 --> 00:42:10,080
我要按位置对它们进行排序

933
00:42:10,080 --> 00:42:11,910
他们所在的城市。 

934
00:42:11,910 --> 00:42:13,840
然后第二件事是您是否想要它们

935
00:42:13,840 --> 00:42:16,350
按顺序升序或降序。 

936
00:42:16,350 --> 00:42:18,790
我确实希望这种提升。 

937
00:42:18,790 --> 00:42:20,490
现在，为什么拥有这个很重要

938
00:42:20,490 --> 00:42:22,300
sortDescriptors在这里？ 

939
00:42:22,300 --> 00:42:24,640
那是因为当我们在数据库中查找对象时， 

940
00:42:24,640 --> 00:42:28,180
他们将以数组而不是集合的形式返回

941
00:42:28,180 --> 00:42:29,750
但作为一个数组。 

942
00:42:29,750 --> 00:42:31,850
这是一个数组，因为它们是有序的， 

943
00:42:31,850 --> 00:42:33,780
它们按此顺序放置。 

944
00:42:33,780 --> 00:42:35,120
为什么我们要这样做？ 

945
00:42:35,120 --> 00:42:38,100
为什么我们不只获取Set而不是Array？ 

946
00:42:38,100 --> 00:42:41,660
好吧，因为这样的排序可能会在数据库上发生

947
00:42:41,660 --> 00:42:45,040
方面非常非常有效，并注意到这是一个数组

948
00:42:45,040 --> 00:42:47,680
SortDescriptor，所以如果您在这里有人

949
00:42:47,680 --> 00:42:50,360
名和姓，您可以使用SortDescriptor 

950
00:42:50,360 --> 00:42:52,473
按姓氏排序，然后按另一个SortDescriptor排序

951
00:42:52,473 --> 00:42:54,910
按名字排序。 

952
00:42:54,910 --> 00:42:57,563
这就是为什么这是一个SortDescriptors数组。 

953
00:42:58,650 --> 00:43:00,760
这就是我们创建此FetchRequest所需要做的全部工作。 

954
00:43:00,760 --> 00:43:04,210
这是在描述我们要从数据库中获取的内容。 

955
00:43:04,210 --> 00:43:06,800
那么，如何从数据库中获取它呢？ 

956
00:43:06,800 --> 00:43:08,230
我们使用这个小功能， 

957
00:43:08,230 --> 00:43:13,230
让机场= context.fetch（请求）。 

958
00:43:14,910 --> 00:43:19,409
现在，上下文是这里的事情之一， 

959
00:43:19,409 --> 00:43:23,310
我们在环境中传递的上下文

960
00:43:23,310 --> 00:43:26,250
这里的上下文，即数据库上的窗口。 

961
00:43:26,250 --> 00:43:28,230
如果我们想从数据库中获取信息， 

962
00:43:28,230 --> 00:43:29,900
我们需要那种背景。 

963
00:43:29,900 --> 00:43:33,797
因此，我们将不得不将其与ICAO一起传递。 

964
00:43:33,797 --> 00:43:37,020
我要在这里说，上下文，上下文， 

965
00:43:37,020 --> 00:43:39,790
然后在ICAO中，我将不得不再做一个

966
00:43:39,790 --> 00:43:41,737
这里的论点，上下文。 

967
00:43:41,737 --> 00:43:45,260
并且此上下文的类型为NSManagedObjectContext。 

968
00:43:47,704 --> 00:43:51,290
这种获取方法还有另外一件有趣的事情是

969
00:43:51,290 --> 00:43:54,920
您必须尝试一下，因为它可能会失败， 

970
00:43:54,920 --> 00:43:58,040
没有连接到数据库或类似的东西， 

971
00:43:58,040 --> 00:44:00,010
因此很可能会失败。 

972
00:44:00,010 --> 00:44:03,842
现在，如果您还记得，如果我们尝试，我们可以做， 

973
00:44:03,842 --> 00:44:05,460
在那里抓捕并尝试， 

974
00:44:05,460 --> 00:44:08,330
并捕获错误并查看错误是什么，然后执行操作。 

975
00:44:08,330 --> 00:44:11,500
在这里，如果我尝试执行此操作但失败了， 

976
00:44:11,500 --> 00:44:14,180
我只是让整个事情归零， 

977
00:44:14,180 --> 00:44:16,930
那是什么尝试？希望你记得

978
00:44:16,930 --> 00:44:19,230
阅读有关错误处理的内容。 

979
00:44:19,230 --> 00:44:20,930
这就是它的作用。 

980
00:44:20,930 --> 00:44:22,210
所以这将是零。 

981
00:44:22,210 --> 00:44:24,090
现在，如果这没有失败， 

982
00:44:24,090 --> 00:44:27,350
但没有与此相匹配的机场， 

983
00:44:27,350 --> 00:44:30,480
那么这将不会返回nil或失败。 

984
00:44:30,480 --> 00:44:33,100
它会返回空数组。 

985
00:44:33,100 --> 00:44:36,470
因此调用fetch并返回一个空数组， 

986
00:44:36,470 --> 00:44:38,820
表示我找不到它。 

987
00:44:38,820 --> 00:44:40,010
不同于零

988
00:44:40,010 --> 00:44:43,270
这意味着我在尝试获取此错误。 

989
00:44:43,270 --> 00:44:45,500
现在，如果找到了， 

990
00:44:45,500 --> 00:44:48,720
然后这将返回一个包含所有机场的数组

991
00:44:48,720 --> 00:44:51,690
匹配的对象。 

992
00:44:51,690 --> 00:44:54,100
这是针对机场的FetchRequest， 

993
00:44:54,100 --> 00:44:56,650
所以这将返回一系列机场。 

994
00:44:56,650 --> 00:44:59,300
希望这不会返回一个以上的机场

995
00:44:59,300 --> 00:45:03,890
因为国际民航组织就像KSFO，应该只有一个

996
00:45:03,890 --> 00:45:04,840
在整个数据库中。 

997
00:45:04,840 --> 00:45:07,460
这就是为什么我们要先进行查找的原因， 

998
00:45:07,460 --> 00:45:08,803
在我们创建它之前。 

999
00:45:10,140 --> 00:45:13,220
所以我在这里要做的就是忽略这些错误。 

1000
00:45:13,220 --> 00:45:14,800
如果返回零， 

1001
00:45:14,800 --> 00:45:18,890
那么我将默认将其默认为空数组。 

1002
00:45:18,890 --> 00:45:20,880
如果我将其作为真实应用发布， 

1003
00:45:20,880 --> 00:45:23,100
可能会在这里捕获此错误并尝试计算

1004
00:45:23,100 --> 00:45:26,530
我要做什么，因为我去了这个机场， 

1005
00:45:26,530 --> 00:45:29,870
它失败了，但是可能如果获取失败了， 

1006
00:45:29,870 --> 00:45:32,219
您所有的核心数据资料都会开始失败，因此

1007
00:45:32,219 --> 00:45:35,250
你知道，那将是顶级失败

1008
00:45:35,250 --> 00:45:36,900
无论如何都必须处理。 

1009
00:45:38,010 --> 00:45:39,910
所以现在这将是一个数组。 

1010
00:45:39,910 --> 00:45:41,430
它要么是一个空数组， 

1011
00:45:41,430 --> 00:45:43,680
如果出现故障或找不到， 

1012
00:45:43,680 --> 00:45:46,120
否则它将只是一堆东西， 

1013
00:45:46,120 --> 00:45:48,380
这是我们放入其中的机场对象

1014
00:45:48,380 --> 00:45:50,630
在过去的事情。 

1015
00:45:50,630 --> 00:45:51,930
因此，让我们检查一下这些情况。 

1016
00:45:51,930 --> 00:45:55,970
首先我要说的是，如果我可以让机场

1017
00:45:55,970 --> 00:46:00,970
平等的机场。第一，机场的第一要素， 

1018
00:46:03,020 --> 00:46:04,780
然后我找到了一个。 

1019
00:46:04,780 --> 00:46:08,970
因此，我将把它退回很容易。 

1020
00:46:08,970 --> 00:46:10,945
这是此查找的第一部分

1021
00:46:10,945 --> 00:46:12,177
它做到了。 

1022
00:46:12,177 --> 00:46:16,270
现在，如果找到了，将其退回， 

1023
00:46:16,270 --> 00:46:18,810
否则我们在这里

1024
00:46:18,810 --> 00:46:20,830
我们找不到的地方

1025
00:46:20,830 --> 00:46:23,720
现在我们需要创建这些东西之一

1026
00:46:23,720 --> 00:46:26,560
然后从FlightAware获取它。 

1027
00:46:26,560 --> 00:46:29,280
我们如何做到这一点？ 

1028
00:46:29,280 --> 00:46:33,920
我将首先使用该国际民航组织创建机场， 

1029
00:46:33,920 --> 00:46:36,140
我已经有了这些信息，我不必获取

1030
00:46:36,140 --> 00:46:38,670
来自FlightAware的信息在这里传递给了我。 

1031
00:46:38,670 --> 00:46:39,943
因此，让我们创建机场。 

1032
00:46:39,943 --> 00:46:43,830
您可以说，让airport = Airport。 

1033
00:46:43,830 --> 00:46:46,370
当然，我们必须传递这种情况，因为我们有

1034
00:46:46,370 --> 00:46:50,390
真正告诉系统创建哪个数据库

1035
00:46:50,390 --> 00:46:53,437
机场，但这会创建一个机场， 

1036
00:46:53,437 --> 00:46:57,920
然后我要设置机场的icao var。 

1037
00:46:57,920 --> 00:47:01,670
这个，我们的机场在这里有一个icao var， 

1038
00:47:01,670 --> 00:47:03,900
如何设置此变量？ 

1039
00:47:03,900 --> 00:47:08,720
令人惊奇的是，.icao = icao。 

1040
00:47:08,720 --> 00:47:13,720
再说一次，Xcode在此基础上构建了所​​有代码

1041
00:47:13,760 --> 00:47:16,373
使它成为具有此变量的对象， 

1042
00:47:17,290 --> 00:47:19,760
似乎仍然没有意识到

1043
00:47:21,150 --> 00:47:22,453
我们可以做到这一点。 

1044
00:47:23,870 --> 00:47:26,883
因此，现在我们可以在此处进行编译了。 

1045
00:47:28,070 --> 00:47:30,880
所以现在我们创建了一个机场，它没有任何

1046
00:47:30,880 --> 00:47:34,030
我们在这里想要的其他其他变量，例如纬度， 

1047
00:47:34,030 --> 00:47:35,260
经度等等

1048
00:47:35,260 --> 00:47:37,400
该信息全部来自FlightAware。 

1049
00:47:37,400 --> 00:47:39,730
所以我没办法说

1050
00:47:39,730 --> 00:47:41,670
airport.longitude =这里的东西。 

1051
00:47:41,670 --> 00:47:43,830
所以这将是零。 

1052
00:47:43,830 --> 00:47:45,520
这些值将是nil和数据库。 

1053
00:47:45,520 --> 00:47:48,400
同样，这就是为什么这些var都是Optionals的部分原因， 

1054
00:47:48,400 --> 00:47:50,060
甚至国际民航组织是一个可选的， 

1055
00:47:50,060 --> 00:47:52,630
即使我们总是要在这里设置它， 

1056
00:47:52,630 --> 00:47:55,943
这是可选的，因为可能未在数据库中设置。 

1057
00:47:57,040 --> 00:47:59,680
那么，我们如何从FlightAware中获取资料？ 

1058
00:47:59,680 --> 00:48:02,050
在我这里的FlightAware代码中， 

1059
00:48:02,050 --> 00:48:05,360
我们拥有的一件事就是这里的AirportInfo 

1060
00:48:05,360 --> 00:48:08,660
在AirportInfo中，有一个名为

1061
00:48:08,660 --> 00:48:10,627
AirportInfoRequest。 

1062
00:48:10,627 --> 00:48:15,460
它具有功能fetch，您可以将其提供给想要的ICAO， 

1063
00:48:15,460 --> 00:48:18,290
信息到后，它将稍后给您回电

1064
00:48:18,290 --> 00:48:20,250
从FlightAware返回

1065
00:48:20,250 --> 00:48:22,870
并给您一个AirportInfo对象。 

1066
00:48:22,870 --> 00:48:27,520
所以AirportInfo对象看起来像这样， 

1067
00:48:27,520 --> 00:48:30,290
得到了国际民航组织的经度，纬度

1068
00:48:30,290 --> 00:48:32,320
我们要放入数据库。 

1069
00:48:32,320 --> 00:48:34,360
我要在这里调用一个函数。 

1070
00:48:34,360 --> 00:48:39,360
self.update（来自：airportInfo，上下文：context） 

1071
00:48:43,990 --> 00:48:47,670
还有我们要做的这个静态小功能， 

1072
00:48:47,670 --> 00:48:52,670
静态函数更新（来自：airportInfo）。 

1073
00:48:54,740 --> 00:48:57,080
我只在这里称其为info。 

1074
00:48:57,080 --> 00:48:59,980
这是FlightAware的AirportInfo对象。 

1075
00:48:59,980 --> 00:49:01,670
然后我们当然需要上下文

1076
00:49:01,670 --> 00:49:05,370
因为我们要在数据库中做某事。 

1077
00:49:05,370 --> 00:49:07,150
每当我们在数据库中做某事时， 

1078
00:49:07,150 --> 00:49:10,000
我们需要上下文来知道哪个数据库。 

1079
00:49:10,000 --> 00:49:13,070
因此，顺便说一下，在此更新中，一旦执行此操作， 

1080
00:49:13,070 --> 00:49:15,650
我要马上返回这个机场。 

1081
00:49:15,650 --> 00:49:17,790
现在，当我第一次返回这个机场时， 

1082
00:49:17,790 --> 00:49:19,860
只会有国际民航组织。 

1083
00:49:19,860 --> 00:49:20,900
它不会拥有所有这些。 

1084
00:49:20,900 --> 00:49:23,430
这是异步的，稍后会发生。 

1085
00:49:23,430 --> 00:49:26,570
因此，当有人说时，请带国际民航组织给我机场

1086
00:49:26,570 --> 00:49:27,810
我以前从未见过

1087
00:49:27,810 --> 00:49:30,380
我要给他们一个几乎是空的

1088
00:49:30,380 --> 00:49:31,813
只是国际民航组织。 

1089
00:49:32,750 --> 00:49:34,370
所以我不应该

1090
00:49:34,370 --> 00:49:37,180
我将不得不让我的机场宽容。 

1091
00:49:37,180 --> 00:49:39,360
我所有的代码都将容忍其他所有代码

1092
00:49:39,360 --> 00:49:42,150
字段为零，这很好，他们只需要

1093
00:49:42,150 --> 00:49:43,573
检查它们是否为零。 

1094
00:49:44,700 --> 00:49:47,620
但是我们几乎总是可以指望这一点不存在

1095
00:49:47,620 --> 00:49:49,050
零，我们要谈谈如何处理

1096
00:49:49,050 --> 00:49:50,443
一秒钟。 

1097
00:49:52,080 --> 00:49:54,420
所以更新，我们如何在这里进行此更新？ 

1098
00:49:54,420 --> 00:49:56,923
所以这发生在一段时间之后，又回来了。 

1099
00:49:56,923 --> 00:50:01,923
让我看看是否可以让国际民航组织等于该信息的国际民航组织。 

1100
00:50:03,420 --> 00:50:05,490
这是来自FlightAware的信息， 

1101
00:50:05,490 --> 00:50:08,270
我要看看我是否可以从那里得到国际民航组织的支持， 

1102
00:50:08,270 --> 00:50:10,340
我应该能够做到的。 

1103
00:50:10,340 --> 00:50:14,060
然后我要去看这个机场

1104
00:50:14,060 --> 00:50:18,917
通过在这种情况下调用我自己的withICAO函数， 

1105
00:50:21,850 --> 00:50:24,570
因为这是以后发生的事，对吧？ 

1106
00:50:24,570 --> 00:50:25,557
这种关闭发生在某个时间之后， 

1107
00:50:25,557 --> 00:50:28,580
所以现在我要回去再次打电话

1108
00:50:28,580 --> 00:50:31,530
得到我之前创建的这个机场

1109
00:50:31,530 --> 00:50:34,530
刚有国际民航组织的那个我要回去

1110
00:50:34,530 --> 00:50:37,160
并得到它，因为这一切都将在以后发生。 

1111
00:50:37,160 --> 00:50:39,690
然后，我将设置所有字段。 

1112
00:50:39,690 --> 00:50:44,690
纬度= info.latitude和经度， 

1113
00:50:49,010 --> 00:50:51,310
经度，您必须输入所有这些字段。 

1114
00:50:53,600 --> 00:50:58,150
我想在这里采取的下一步是保存此信息

1115
00:50:58,150 --> 00:50:59,913
进入数据库。 

1116
00:51:00,800 --> 00:51:05,193
现在可以通过要求上下文进行保存来完成。 

1117
00:51:06,310 --> 00:51:09,390
但是您可以在这里看到上下文保存抛出异常， 

1118
00:51:09,390 --> 00:51:11,210
看看那里说扔在那里。 

1119
00:51:11,210 --> 00:51:12,470
每当你看到抛出

1120
00:51:12,470 --> 00:51:17,110
这意味着这是您必须尝试的功能。 

1121
00:51:17,110 --> 00:51:18,690
我很高兴尝试这个。 

1122
00:51:18,690 --> 00:51:20,623
如果失败，则什么也不做。 

1123
00:51:21,800 --> 00:51:25,890
现在，这不是我机场上的所有var。 

1124
00:51:25,890 --> 00:51:27,870
如果我回去看看我的机场， 

1125
00:51:27,870 --> 00:51:31,100
我拥有所有这些var，但是这些呢？ 

1126
00:51:31,100 --> 00:51:32,583
航班从航班到？ 

1127
00:51:33,620 --> 00:51:37,550
可以从任一侧设置良好的flightFrom和flightTo 

1128
00:51:37,550 --> 00:51:41,090
您可以通过设置航班的目的地来进行设置

1129
00:51:41,090 --> 00:51:45,050
到机场，这将导致flightToSet， 

1130
00:51:45,050 --> 00:51:47,402
自动添加一个机场。 

1131
00:51:47,402 --> 00:51:48,450
您无需做任何事情。 

1132
00:51:48,450 --> 00:51:49,283
反之亦然。 

1133
00:51:49,283 --> 00:51:52,430
如果您在此排期中添加了一些东西， 

1134
00:51:52,430 --> 00:51:56,350
这将导致Flight指向其他方向。 

1135
00:51:56,350 --> 00:51:57,183
所以这很酷。 

1136
00:51:57,183 --> 00:51:58,913
这是为我们自动管理的。 

1137
00:52:00,910 --> 00:52:03,720
现在，我们想在这里做另一件事。 

1138
00:52:03,720 --> 00:52:05,670
因此，我们创建了这个东西。 

1139
00:52:05,670 --> 00:52:06,960
我们保存了。 

1140
00:52:06,960 --> 00:52:11,960
请记住，这些机场是ObservableObjects。 

1141
00:52:12,160 --> 00:52:14,040
他们是一个小小的ViewModels。 

1142
00:52:14,040 --> 00:52:16,180
因此，我正在这里进行批量更新。 

1143
00:52:16,180 --> 00:52:20,250
我实际上要告诉这个机场开火

1144
00:52:20,250 --> 00:52:22,363
objectWillChange.send（）。 

1145
00:52:24,210 --> 00:52:26,690
这会导致任何查看此内容的视图

1146
00:52:26,690 --> 00:52:30,260
现在就去机场重画自己，并希望接机

1147
00:52:30,260 --> 00:52:32,710
这些新信息（如果它们依赖其中任何一个）。 

1148
00:52:33,623 --> 00:52:34,730
希望我们也可以做另一件事。 

1149
00:52:34,730 --> 00:52:39,100
我要去机场的航班

1150
00:52:39,100 --> 00:52:44,100
我要让他们每个人都做

1151
00:52:44,266 --> 00:52:47,340
objectWillChange.send（）。 

1152
00:52:47,340 --> 00:52:49,540
Lemme对我的flightFrom也做同样的事情。 

1153
00:52:55,070 --> 00:52:59,550
现在，由于我之前所说的，这不起作用

1154
00:52:59,550 --> 00:53:03,110
这些航班往返于我们的NSSet， 

1155
00:53:03,110 --> 00:53:06,030
您会看到NSSet类型的值。 

1156
00:53:06,030 --> 00:53:10,750
因此，您不能在此处告诉NSSet Optional。 

1157
00:53:10,750 --> 00:53:12,570
即使我将其设为非可选， 

1158
00:53:12,570 --> 00:53:14,460
那也不能解决问题， 

1159
00:53:14,460 --> 00:53:18,490
因为它不仅是NSSet，而且是Any的NSSet。 

1160
00:53:18,490 --> 00:53:21,120
因此，它甚至都不知道这些flightTo， 

1161
00:53:21,120 --> 00:53:24,440
实际上是Flights，Flight对象。 

1162
00:53:24,440 --> 00:53:29,440
所以这里的解决方案需要我所说的一点

1163
00:53:29,635 --> 00:53:33,130
编译器未添加的语法糖， 

1164
00:53:33,130 --> 00:53:34,570
但是我们要补充一点。 

1165
00:53:34,570 --> 00:53:37,700
我要进行flightTo和flightFrom， 

1166
00:53:37,700 --> 00:53:41,810
少计算变量，flightsTo， 

1167
00:53:41,810 --> 00:53:46,453
我要去坐飞机，我要去

1168
00:53:47,550 --> 00:53:52,003
集合和flightFrom相同。 

1169
00:53:57,160 --> 00:54:01,090
现在，我该怎么做这个航班

1170
00:54:01,090 --> 00:54:04,970
作为计算变量，因为我已经有flightsTo 

1171
00:54:04,970 --> 00:54:08,315
和航班从这里过来的vars 

1172
00:54:08,315 --> 00:54:10,870
我的机场已经有这些变种，这些是变种。 

1173
00:54:10,870 --> 00:54:13,720
所以我要在这里重命名这些变量

1174
00:54:13,720 --> 00:54:15,673
在他们后面放一些下划线。 

1175
00:54:16,584 --> 00:54:18,220
这只是某种意义上的

1176
00:54:18,220 --> 00:54:22,560
我喜欢在这里有东西摆放时做

1177
00:54:22,560 --> 00:54:24,400
我以后再去做

1178
00:54:24,400 --> 00:54:26,760
数据库中的内容几乎完全正确

1179
00:54:26,760 --> 00:54:28,050
我想要的，但不完全是。 

1180
00:54:28,050 --> 00:54:33,050
所以这是来自Objective-C的所有这些的集合

1181
00:54:33,310 --> 00:54:35,280
这个东西的版本。 

1182
00:54:35,280 --> 00:54:40,280
我要乘飞机去返回

1183
00:54:40,420 --> 00:54:45,420
flightTo_作为一组航班。 

1184
00:54:49,230 --> 00:54:54,230
哦，顺便说一句，如果没有设置， 

1185
00:54:54,230 --> 00:54:56,971
我要归还空机。 

1186
00:54:56,971 --> 00:54:58,880
所以在这里，我有点同时完成了两件事。 

1187
00:54:58,880 --> 00:55:03,110
我已经将flightsTo转换为

1188
00:55:03,110 --> 00:55:05,820
不是NSSet而是飞行集合， 

1189
00:55:05,820 --> 00:55:08,380
而且我还检查了flightsTo可能为零， 

1190
00:55:08,380 --> 00:55:12,133
如果返回的是一个空Set。 

1191
00:55:13,250 --> 00:55:15,370
因此设置也很容易。 

1192
00:55:15,370 --> 00:55:20,370
flightTo_ = newValue作为NSSet。 

1193
00:55:22,660 --> 00:55:26,920
所以Set的Objective-C版本和Swift版本

1194
00:55:26,920 --> 00:55:30,380
可以按原样设置集合，这是类型转换，希望您

1195
00:55:30,380 --> 00:55:32,410
记得再读一次

1196
00:55:32,410 --> 00:55:35,660
它们可以彼此直接配对， 

1197
00:55:35,660 --> 00:55:37,150
这真的是一个很酷的功能， 

1198
00:55:37,150 --> 00:55:41,363
具有很大的兼容性，可以正常工作。 

1199
00:55:42,530 --> 00:55:46,270
因此，我的flightFrom几乎是同一回事。 

1200
00:55:46,270 --> 00:55:48,733
我们正在从这里出发

1201
00:55:49,983 --> 00:55:51,100
和flightFrom。 

1202
00:55:54,180 --> 00:55:55,400
就是这样，每个人都希望能理解， 

1203
00:55:55,400 --> 00:55:59,300
我只是想让我的代码看起来很干净

1204
00:55:59,300 --> 00:56:03,220
通过将其设置为“飞行设定”而不是

1205
00:56:03,220 --> 00:56:06,663
此NSSet为Any，也可能为nil。 

1206
00:56:09,470 --> 00:56:14,470
这就是我想在这里创建机场所要做的全部

1207
00:56:14,580 --> 00:56:16,220
或找到一个现有的。 

1208
00:56:16,220 --> 00:56:20,557
所以，如果我回到这里的SceneDelegate， 

1209
00:56:21,460 --> 00:56:24,020
哦，看看，所有的代码都可以编译

1210
00:56:24,020 --> 00:56:25,350
这里很好。 

1211
00:56:25,350 --> 00:56:29,000
现在我在机场做的这件事， 

1212
00:56:29,000 --> 00:56:32,730
再加上flightTo，不仅要从Set切换到NSSet 

1213
00:56:32,730 --> 00:56:35,480
而且还要检查它是否为零。 

1214
00:56:35,480 --> 00:56:38,650
因此，最糟糕的是，这是一个空集， 

1215
00:56:38,650 --> 00:56:39,810
不为零。 

1216
00:56:39,810 --> 00:56:42,760
我也喜欢和其他所有变量一起做

1217
00:56:42,760 --> 00:56:44,710
那真的不能为零。 

1218
00:56:44,710 --> 00:56:47,007
例如，让我们在这里看机场， 

1219
00:56:47,007 --> 00:56:51,680
看看其中哪一个永远不会或永远不会为零。 

1220
00:56:51,680 --> 00:56:53,790
好吧，实际上，这些都不是零， 

1221
00:56:53,790 --> 00:56:56,590
当我做我的取物的时候，它们都会变成零。 

1222
00:56:56,590 --> 00:57:00,950
除了不是这个以外，icao绝对不应为零。 

1223
00:57:00,950 --> 00:57:04,130
所以我要在它后面加上下划线。 

1224
00:57:04,130 --> 00:57:05,620
然后在我的扩展中， 

1225
00:57:05,620 --> 00:57:08,180
我实际上在这里已对此进行评论

1226
00:57:08,180 --> 00:57:10,370
这样我们才能加快进度。 

1227
00:57:10,370 --> 00:57:14,240
我将创建类似的var 

1228
00:57:14,240 --> 00:57:16,850
这不是在做Set NSSet的事情， 

1229
00:57:16,850 --> 00:57:21,320
但这只是使此东西不再是可选的。 

1230
00:57:21,320 --> 00:57:24,150
因此，它采用的是下划线版本，请使其不为可选。 

1231
00:57:24,150 --> 00:57:27,181
现在我要做的是，您会看到当我的应用发布时， 

1232
00:57:27,181 --> 00:57:29,820
也许我想在这里做别的事情， 

1233
00:57:29,820 --> 00:57:30,870
当这个东西为零时

1234
00:57:30,870 --> 00:57:32,490
因为这确实是一个错误情况。 

1235
00:57:32,490 --> 00:57:35,640
这永远都不会发生，因为当我创建一个机场时， 

1236
00:57:35,640 --> 00:57:37,940
我在下一行要做的第一件事， 

1237
00:57:37,940 --> 00:57:41,420
设置了这个icao这真的不可能发生

1238
00:57:41,420 --> 00:57:42,480
这是零。 

1239
00:57:42,480 --> 00:57:45,650
如果这样做的话，那就是发生了一些错误情况。 

1240
00:57:45,650 --> 00:57:49,160
所以我可能会尝试处理这种错误情况

1241
00:57:49,160 --> 00:57:52,500
比崩溃更胜一筹，因为我们知道惊叹号

1242
00:57:52,500 --> 00:57:54,640
只是崩溃。 

1243
00:57:54,640 --> 00:57:57,350
但是可以肯定的是，对于这个演示，当我在开发中时， 

1244
00:57:57,350 --> 00:57:59,730
也许我希望在开发过程中崩溃。 

1245
00:57:59,730 --> 00:58:02,650
我想看看在什么情况下我可以得到这种

1246
00:58:02,650 --> 00:58:05,560
发生损坏的数据库， 

1247
00:58:05,560 --> 00:58:08,037
如果曾经，可能永远不会发生这种情况。 

1248
00:58:09,278 --> 00:58:10,780
我还在这里添加了其他一些东西， 

1249
00:58:10,780 --> 00:58:12,180
机场的友好名称， 

1250
00:58:12,180 --> 00:58:15,350
只需查看它的名称和位置即可。 

1251
00:58:15,350 --> 00:58:18,090
我还使机场可识别和可比， 

1252
00:58:18,090 --> 00:58:21,250
与Core中的对象一起做通常是一件好事

1253
00:58:21,250 --> 00:58:23,330
数据，因此您可以将其放入字典中

1254
00:58:23,330 --> 00:58:25,033
和布景之类的东西。 

1255
00:58:26,510 --> 00:58:29,080
所以我们在机场做了很多很棒的事情， 

1256
00:58:29,080 --> 00:58:30,700
而且我们已经学到了很多有关核心数据的知识

1257
00:58:30,700 --> 00:58:31,710
只是从机场出发。 

1258
00:58:31,710 --> 00:58:35,990
我们知道如何获取它们，我们知道如何创建新的， 

1259
00:58:35,990 --> 00:58:39,800
我们知道如何做这件小事

1260
00:58:39,800 --> 00:58:44,340
看起来更好一点，我们知道如何掩盖我们的

1261
00:58:44,340 --> 00:58:45,710
可以是可选的。 

1262
00:58:45,710 --> 00:58:48,370
实际上，让我们来做这个小小的可选封面

1263
00:58:48,370 --> 00:58:49,860
也为我们的其他事情。 

1264
00:58:49,860 --> 00:58:51,563
我们这边有航空公司。 

1265
00:58:54,810 --> 00:58:57,130
所以我现在在航空公司做了同样的事情， 

1266
00:58:57,130 --> 00:59:00,764
我想要代码，名称，简称，然后是

1267
00:59:00,764 --> 00:59:03,580
我们将在这里进行飞行。 

1268
00:59:03,580 --> 00:59:05,760
因此，代码，名称，简称，航班号几乎就是全部

1269
00:59:05,760 --> 00:59:08,963
航空公司下面的事情

1270
00:59:10,761 --> 00:59:12,663
为下划线，名称， 

1271
00:59:15,040 --> 00:59:19,990
底线和简称，底线和航班也在这里， 

1272
00:59:19,990 --> 00:59:23,350
它是下档式的，而Flight呢？ 

1273
00:59:23,350 --> 00:59:25,050
所以我对航班也做同样的事情

1274
00:59:25,050 --> 00:59:27,000
我们甚至没有看过Flight。 

1275
00:59:28,300 --> 00:59:29,133
行。 

1276
00:59:29,133 --> 00:59:30,860
所以航班，我到达了， 

1277
00:59:30,860 --> 00:59:34,370
目的地，出发地，机场，航空公司和身份， 

1278
00:59:34,370 --> 00:59:36,840
所有这些事情，不能为零，并且

1279
00:59:36,840 --> 00:59:38,990
然后我添加了这个不错的数字。 

1280
00:59:40,010 --> 00:59:43,370
让我们看一下我们的飞行数据模型

1281
00:59:43,370 --> 00:59:46,480
飞机还可以，到达， 

1282
00:59:46,480 --> 00:59:49,030
使到达时间不能为零。 

1283
00:59:49,030 --> 00:59:52,000
出发时间可以为零，提起时间可以为零， 

1284
00:59:52,000 --> 00:59:54,220
ident不能为nil。 

1285
00:59:54,220 --> 00:59:57,640
然后我们要保护所有这些关系

1286
00:59:57,640 --> 00:59:58,797
他们反对零。 

1287
01:00:02,090 --> 01:00:03,320
这就是我们在那里所做的全部。 

1288
01:00:03,320 --> 01:00:04,810
这只会使我们的代码更好。 

1289
01:00:04,810 --> 01:00:08,510
我们不必经常检查是否存在

1290
01:00:08,510 --> 01:00:10,720
不为零，因为航班的身份

1291
01:00:10,720 --> 01:00:12,650
真的无法复制nil。 

1292
01:00:12,650 --> 01:00:14,160
如果航班没有身分， 

1293
01:00:14,160 --> 01:00:15,723
它甚至根本不存在。 

1294
01:00:15,723 --> 01:00:18,350
和同样的东西到达时间，航班必须至少

1295
01:00:18,350 --> 01:00:20,320
预计到达时间。 

1296
01:00:20,320 --> 01:00:22,050
现在，要注意的一件事

1297
01:00:22,050 --> 01:00:26,500
当您经历并摆脱这种情况时

1298
01:00:26,500 --> 01:00:30,270
可选的事情是，您获取了东西， 

1299
01:00:30,270 --> 01:00:31,970
像这样在这里获取

1300
01:00:31,970 --> 01:00:35,120
它仍然必须使用下划线版本， 

1301
01:00:35,120 --> 01:00:39,160
它不能为此使用下划线版本。 

1302
01:00:39,160 --> 01:00:41,690
您没有底线的东西， 

1303
01:00:41,690 --> 01:00:44,860
这个要求，这个谓词， 

1304
01:00:44,860 --> 01:00:48,300
它正在获取数据库中的字段， 

1305
01:00:48,300 --> 01:00:50,920
在这里的代码中没有vars。 

1306
01:00:50,920 --> 01:00:52,420
它实际上是在数据库中获取。 

1307
01:00:52,420 --> 01:00:54,460
因此，这必须是数据库中的一个字段。 

1308
01:00:54,460 --> 01:00:56,140
与SortDescriptors相同。 

1309
01:00:56,140 --> 01:00:59,420
现在的位置，如果我们回头看机场， 

1310
01:00:59,420 --> 01:01:02,400
这个位置，我们没有强调。 

1311
01:01:02,400 --> 01:01:04,000
所以我们不要在那里的下划线， 

1312
01:01:04,000 --> 01:01:07,050
表示我们也不希望在这里使用下划线。 

1313
01:01:07,050 --> 01:01:11,530
因此，我们解决了最初在这里遇到的所有问题

1314
01:01:11,530 --> 01:01:14,400
在SceneDelegate中，我们尝试在其中创建广告投放

1315
01:01:14,400 --> 01:01:18,170
而是用KSFO搜索，我们只是将自己变成了一个机场

1316
01:01:18,170 --> 01:01:21,242
对象并将其传递给我们，以便我们的FlightSearch 

1317
01:01:21,242 --> 01:01:24,663
现在正在前往机场的目的地。 

1318
01:01:25,890 --> 01:01:29,600
让我们继续追逐我们这里的错误

1319
01:01:29,600 --> 01:01:33,030
通过使所有这些都是面向对象而引入的。 

1320
01:01:33,030 --> 01:01:35,770
这说，String和之间的二进制运算符== 

1321
01:01:35,770 --> 01:01:37,001
当然是机场。 

1322
01:01:37,001 --> 01:01:38,295
其中另一个是在哪里， 

1323
01:01:38,295 --> 01:01:40,280
在FlightFetcher中，所以我点击了

1324
01:01:40,280 --> 01:01:41,860
所以这是私有实现的一部分

1325
01:01:41,860 --> 01:01:43,350
FlightFetcher的

1326
01:01:43,350 --> 01:01:46,660
是的，当然，FlightFetcher都是非面向对象的

1327
01:01:46,660 --> 01:01:49,110
基于字符串和获取字符串。 

1328
01:01:49,110 --> 01:01:51,360
所以FlightFetcher本身就是

1329
01:01:51,360 --> 01:01:53,820
完全没用。 

1330
01:01:53,820 --> 01:01:56,570
因此，让我们回到我们的FlightEnrouteView并开始

1331
01:01:56,570 --> 01:01:58,250
寻找FlightFetcher。 

1332
01:01:58,250 --> 01:02:00,650
这是我们在广告投放列表中使用它的地方。 

1333
01:02:00,650 --> 01:02:03,310
获取航班，显然是在我们的航班列表中， 

1334
01:02:03,310 --> 01:02:04,320
这整个事情是没有用的。 

1335
01:02:04,320 --> 01:02:07,120
我要删除所有的FlightFetcher代码

1336
01:02:07,120 --> 01:02:09,333
因为我们不能再使用它了。 

1337
01:02:10,450 --> 01:02:12,800
那么，我们该怎么做呢？ 

1338
01:02:12,800 --> 01:02:16,960
在核心数据中，我们想获取所有这些数据

1339
01:02:16,960 --> 01:02:19,323
飞行和穿越他们。 

1340
01:02:20,190 --> 01:02:23,027
好吧，Core Data之间的集成非常酷

1341
01:02:23,027 --> 01:02:26,220
和SwiftUI，我实际上要创建一个变量

1342
01:02:26,220 --> 01:02:28,433
那些航班就在这里。 

1343
01:02:29,730 --> 01:02:34,200
我将使用属性包装器执行该变量

1344
01:02:34,200 --> 01:02:36,537
称为@FetchRequest。 

1345
01:02:37,520 --> 01:02:38,690
这需要一些争论

1346
01:02:38,690 --> 01:02:40,610
我们将在稍后讨论。 

1347
01:02:40,610 --> 01:02:44,740
而这个正在使用的东西的返回值

1348
01:02:44,740 --> 01:02:48,520
属性包装器称为FetchedResults， 

1349
01:02:48,520 --> 01:02:49,800
很多时候不在乎

1350
01:02:49,800 --> 01:02:53,990
它正在获取的东西是Flight。 

1351
01:02:53,990 --> 01:02:56,470
所以这次飞行，请记住那是我们的飞行

1352
01:02:56,470 --> 01:02:59,220
从我们的数据库中创建。 

1353
01:02:59,220 --> 01:03:02,840
我们将发出某种FetchRequest 

1354
01:03:02,840 --> 01:03:04,010
得到一些航班。 

1355
01:03:04,010 --> 01:03:07,340
这个变量将是FetchedResults。 

1356
01:03:07,340 --> 01:03:10,200
现在，什么是FetchedResult of Flight？ 

1357
01:03:10,200 --> 01:03:12,570
这不是很多航班， 

1358
01:03:12,570 --> 01:03:14,260
虽然它是一个集合。 

1359
01:03:14,260 --> 01:03:15,827
因此，将其放在此处将是可行的， 

1360
01:03:15,827 --> 01:03:17,870
对于每一个我来说都是值得的， 

1361
01:03:17,870 --> 01:03:20,530
因为这本质上是一个Collection。 

1362
01:03:20,530 --> 01:03:22,520
这就是ForEach所追求的， 

1363
01:03:22,520 --> 01:03:25,750
基本上是可识别对象的集合。 

1364
01:03:25,750 --> 01:03:30,590
这实质上是此FetchRequest作为

1365
01:03:30,590 --> 01:03:33,430
一堆的航班，这正是我们想要的。 

1366
01:03:33,430 --> 01:03:36,260
现在，我们如何在此处指定此FetchRequest？ 

1367
01:03:36,260 --> 01:03:38,940
我们基本上必须为其提供与我们完全相同的信息

1368
01:03:38,940 --> 01:03:42,430
在机场的每个FetchRequests中都做了

1369
01:03:42,430 --> 01:03:45,710
所以我们必须给它一个谓词，这个实体名称是什么， 

1370
01:03:45,710 --> 01:03:48,720
什么是SortDescriptors，您可以做到这一点， 

1371
01:03:48,720 --> 01:03:50,190
我认为这是被称为

1372
01:03:50,190 --> 01:03:53,727
是的，这是实体，你会说

1373
01:03:53,727 --> 01:03:56,850
Flight.entity（），然后是SortDescriptors， 

1374
01:03:56,850 --> 01:03:58,110
你会把那些。 

1375
01:03:58,110 --> 01:04:01,070
然后还有另一个谓词， 

1376
01:04:01,070 --> 01:04:02,120
然后你把那些

1377
01:04:02,120 --> 01:04:05,120
但是我们不会那样做，因为我们真的做不到。 

1378
01:04:05,120 --> 01:04:09,050
问题是，我们要在这里获取什么？ 

1379
01:04:09,050 --> 01:04:13,240
我们正在尝试获取与此航班搜索相匹配的内容。 

1380
01:04:13,240 --> 01:04:16,390
很遗憾，这次航班搜索已传递给我们， 

1381
01:04:16,390 --> 01:04:20,706
我们不能在这里使用它来初始化它

1382
01:04:20,706 --> 01:04:23,220
属性，包装结构。 

1383
01:04:23,220 --> 01:04:25,530
因此，我们将不得不在这里进行操作。 

1384
01:04:25,530 --> 01:04:29,527
而且我们确切地知道如何初始化属性包装器

1385
01:04:29,527 --> 01:04:32,630
结构，我们使用它的下划线版本。 

1386
01:04:32,630 --> 01:04:34,103
所以，_飞行

1387
01:04:34,103 --> 01:04:36,220
有这个Flight的下吧版， 

1388
01:04:36,220 --> 01:04:40,040
这就是这个结构，我将其设置为等于

1389
01:04:40,040 --> 01:04:43,760
一个FetchRequest就是这些结构之一

1390
01:04:43,760 --> 01:04:46,803
使用FetchRequest创建。 

1391
01:04:48,910 --> 01:04:51,010
因此，这是用于创建

1392
01:04:51,010 --> 01:04:53,180
FetchRequest，我告诉过你，这里还有另一个， 

1393
01:04:53,180 --> 01:04:55,300
拿走了实体和所有东西。 

1394
01:04:55,300 --> 01:04:59,650
但是，这里的选择之一也是FetchRequest。 

1395
01:04:59,650 --> 01:05:01,890
所以我要给它一个FetchRequest， 

1396
01:05:01,890 --> 01:05:04,950
而这个FetchRequest我将做完全一样的事情

1397
01:05:04,950 --> 01:05:07,630
当我们检查机场时，我在这里做了， 

1398
01:05:07,630 --> 01:05:11,443
lemme获取此文档并复制并粘贴，如此类似。 

1399
01:05:13,130 --> 01:05:15,350
而这一次，我们不是在查找机场， 

1400
01:05:15,350 --> 01:05:17,163
我们正在查找航班。 

1401
01:05:20,870 --> 01:05:23,850
因此，我们这里不是在查找国际民航组织， 

1402
01:05:23,850 --> 01:05:27,470
我们正在寻找这件事的目的地机场， 

1403
01:05:27,470 --> 01:05:29,270
我们强调了这一点，因为拥有一个

1404
01:05:29,270 --> 01:05:30,480
没有目的地的航班。 

1405
01:05:30,480 --> 01:05:33,650
这就是为什么我们做到这一点，以便永远不会

1406
01:05:33,650 --> 01:05:34,483
可选的。 

1407
01:05:34,483 --> 01:05:36,030
目的地是什么？ 

1408
01:05:36,030 --> 01:05:38,600
我们正在通过的是FlightSearch， 

1409
01:05:38,600 --> 01:05:40,830
它的目的地，这个FlightSearch， 

1410
01:05:40,830 --> 01:05:42,840
这是一个FlightSearch对象，我们对此进行了更改， 

1411
01:05:42,840 --> 01:05:45,000
所以它的目的地是一个机场。 

1412
01:05:45,000 --> 01:05:48,250
所以现在我们在这里寻找

1413
01:05:48,250 --> 01:05:51,840
目的地等于那个机场。 

1414
01:05:51,840 --> 01:05:55,320
现在我们显然还有其他SortDescriptor 

1415
01:05:55,320 --> 01:05:57,690
让我们整理一下，我想我们的到达时间

1416
01:05:58,530 --> 01:06:01,600
可能是对我们的航班进行排序的最佳选择。 

1417
01:06:01,600 --> 01:06:04,500
现在，我们还有其他谓词要搜索

1418
01:06:04,500 --> 01:06:07,480
在目的地以外的地方，例如始发航空公司， 

1419
01:06:07,480 --> 01:06:10,012
inTheAir，但我们会做一点

1420
01:06:10,012 --> 01:06:11,470
当我们启用FilterFlights时。 

1421
01:06:11,470 --> 01:06:13,950
所以现在我们只需要查找所有航班

1422
01:06:13,950 --> 01:06:16,110
到这个目的地。 

1423
01:06:16,110 --> 01:06:19,530
现在您看到我在这里输入了三行代码， 

1424
01:06:19,530 --> 01:06:21,900
我在这里输入了相同的三行代码。 

1425
01:06:21,900 --> 01:06:23,850
它们非常相似。 

1426
01:06:23,850 --> 01:06:26,240
您真的一直在使用它们， 

1427
01:06:26,240 --> 01:06:28,330
因为您一直在搜索对象。 

1428
01:06:28,330 --> 01:06:33,230
我喜欢在扩展程序中做些小功能

1429
01:06:33,230 --> 01:06:36,960
这些为我做这三行代码。 

1430
01:06:36,960 --> 01:06:38,640
因此，与其做这三行代码， 

1431
01:06:38,640 --> 01:06:43,640
我将使用我在此处放置的一些代码来执行此操作。 

1432
01:06:44,570 --> 01:06:46,910
它只是用谓词发出FetchRequest 

1433
01:06:46,910 --> 01:06:49,490
并自动选择正确的SortDescriptor。 

1434
01:06:49,490 --> 01:06:52,330
它做这件事有点创建实体名称

1435
01:06:52,330 --> 01:06:53,360
FetchRequest首先。 

1436
01:06:53,360 --> 01:06:56,357
然后，它只是在您想要的谓词中添加图形。 

1437
01:06:56,357 --> 01:06:59,280
并将这三行代码更改为

1438
01:06:59,280 --> 01:07:03,430
单行代码，让请求等于fetchRequest 

1439
01:07:04,630 --> 01:07:07,110
如果谓词是NSPredicate， 

1440
01:07:07,110 --> 01:07:12,110
我们这里的谓词是“ icao_ =％@” 

1441
01:07:12,120 --> 01:07:14,780
本国际民航组织。 

1442
01:07:14,780 --> 01:07:16,790
所以现在我不必做SortDescriptors 

1443
01:07:16,790 --> 01:07:17,830
还有所有这些东西。 

1444
01:07:17,830 --> 01:07:20,350
它只是使此代码更简单。 

1445
01:07:20,350 --> 01:07:22,400
让我为Flight做同样的事情。 

1446
01:07:25,230 --> 01:07:28,400
有FetchRequest for Flight，按到达时间排序。 

1447
01:07:28,400 --> 01:07:30,520
它有正确的实体，在此命名， 

1448
01:07:30,520 --> 01:07:32,557
我要为航空公司做同样的事情。 

1449
01:07:32,557 --> 01:07:36,340
而且我几乎会为我所有的物体做到这一点

1450
01:07:36,340 --> 01:07:39,410
从核心数据中获得这些简单的一线内容即可

1451
01:07:39,410 --> 01:07:41,870
为他们创建一个FetchRequest， 

1452
01:07:41,870 --> 01:07:44,540
特别是当您几乎总是想要它们时

1453
01:07:44,540 --> 01:07:46,330
按同一件事排序

1454
01:07:46,330 --> 01:07:48,830
和航空公司几乎总是要被排序

1455
01:07:48,830 --> 01:07:49,840
这是名字，还有机场

1456
01:07:49,840 --> 01:07:51,930
几乎总是要被它排序

1457
01:07:51,930 --> 01:07:53,800
位置在这里。 

1458
01:07:53,800 --> 01:07:56,330
飞行几乎总是要

1459
01:07:56,330 --> 01:07:57,920
按到达时间排序。 

1460
01:07:57,920 --> 01:08:00,170
现在，如果您想指定其他SortDescriptor， 

1461
01:08:00,170 --> 01:08:02,440
当然，您可以在此处获取FetchRequest 

1462
01:08:02,440 --> 01:08:05,900
更改SortDescriptors，只是在这里返回var， 

1463
01:08:05,900 --> 01:08:07,073
FetchRequest变量。 

1464
01:08:08,630 --> 01:08:11,550
因此，这使我们的代码更加简单。 

1465
01:08:11,550 --> 01:08:15,280
实际上，我们可以直接在这里使用这个谓词，然后说： 

1466
01:08:15,280 --> 01:08:20,280
让请求等于Flight.fetchRequest， 

1467
01:08:21,380 --> 01:08:23,310
这是谓词

1468
01:08:25,180 --> 01:08:27,713
这样一来，这里就变成了单线。 

1469
01:08:29,770 --> 01:08:34,630
所以现在这个航班var将会一直是

1470
01:08:34,630 --> 01:08:35,820
提取的结果。 

1471
01:08:35,820 --> 01:08:38,480
这是令人惊奇的事情

1472
01:08:38,480 --> 01:08:40,260
属性包装器就在这里。 

1473
01:08:40,260 --> 01:08:43,510
不仅仅是让您指定FetchRequest。 

1474
01:08:43,510 --> 01:08:46,210
它使得这个变种

1475
01:08:46,210 --> 01:08:48,950
始终包含此提取的结果。 

1476
01:08:48,950 --> 01:08:51,530
即使正在添加或删除对象

1477
01:08:51,530 --> 01:08:56,300
与此匹配的数据库，它总是在改变它。 

1478
01:08:56,300 --> 01:08:58,140
这只是不断地更新， 

1479
01:08:58,140 --> 01:09:02,190
该获取结果反映了最新版本。 

1480
01:09:02,190 --> 01:09:06,190
这确实是最好的集成之一

1481
01:09:06,190 --> 01:09:10,060
在SwiftUI和Core Data之间，是这种能力

1482
01:09:10,060 --> 01:09:12,810
这些获取结果变量只是

1483
01:09:12,810 --> 01:09:13,650
始终保持最新。 

1484
01:09:13,650 --> 01:09:14,823
所以这里的每个人

1485
01:09:14,823 --> 01:09:19,016
每次新的航班都会一直在更新

1486
01:09:19,016 --> 01:09:20,060
来自FlightAware等

1487
01:09:20,060 --> 01:09:21,760
它只是自动更新。 

1488
01:09:22,710 --> 01:09:24,660
因此，让我们继续前进。 

1489
01:09:24,660 --> 01:09:25,493
下一个错误是什么

1490
01:09:25,493 --> 01:09:27,220
我们实际上可以在这里看到它。 

1491
01:09:27,220 --> 01:09:29,140
FlightListEntry飞行航班， 

1492
01:09:29,140 --> 01:09:32,190
无法转换Flight Elements的FetchedResults。 

1493
01:09:32,190 --> 01:09:34,832
因此，FlightedResult of Flight的元素

1494
01:09:34,832 --> 01:09:38,310
将会是A Flight（航班），期望有一个论点， 

1495
01:09:38,310 --> 01:09:41,550
当然，FAFlight是因为FlightListEntry， 

1496
01:09:41,550 --> 01:09:45,100
这个东西在这里，它有望获得FAFlight。 

1497
01:09:45,100 --> 01:09:47,600
因为这是这里的旧世界， 

1498
01:09:47,600 --> 01:09:49,150
核心数据之前的世界。 

1499
01:09:49,150 --> 01:09:50,140
因此，让我们修复此问题。 

1500
01:09:50,140 --> 01:09:52,070
该航班不想成为FAFlight， 

1501
01:09:52,070 --> 01:09:53,760
它想成为一个航班。 

1502
01:09:53,760 --> 01:09:55,540
其中一个巨大的优势是

1503
01:09:55,540 --> 01:09:57,627
该航班是一个ObservableObject。 

1504
01:09:57,627 --> 01:10:01,330
所以我要说@ObservedObject Flight。 

1505
01:10:01,330 --> 01:10:03,800
因此，如果数据库中的这次排期发生任何变化， 

1506
01:10:03,800 --> 01:10:05,280
此视图将重绘。 

1507
01:10:05,280 --> 01:10:08,280
这是制作此物体的巨大优势之一- 

1508
01:10:08,280 --> 01:10:10,440
定向，而不是使用字符串， 

1509
01:10:10,440 --> 01:10:12,490
这是一个字符串，没有办法知道， 

1510
01:10:12,490 --> 01:10:14,410
哦，该航班已更新。 

1511
01:10:14,410 --> 01:10:17,720
在FlightListEntry中，我们还有其他对象

1512
01:10:17,720 --> 01:10:20,970
正在获取所有机场和所有航空公司。 

1513
01:10:20,970 --> 01:10:24,690
我们真的不再需要这些了，因为它

1514
01:10:24,690 --> 01:10:28,980
当我们今天有了航空公司时，它们就是对象

1515
01:10:28,980 --> 01:10:31,480
我们可以从中获得我们想要的关于他们的所有信息

1516
01:10:31,480 --> 01:10:34,730
对象，因此我们不需要进行所有的航班飞行

1517
01:10:34,730 --> 01:10:38,850
代码，友好的名称业务，相反，我可以去这里

1518
01:10:38,850 --> 01:10:43,293
并说Flight.airline.friendlyName。 

1519
01:10:45,000 --> 01:10:46,150
同样在这里， 

1520
01:10:46,150 --> 01:10:49,000
我们不需要所有的机场来通过它查找航班

1521
01:10:49,000 --> 01:10:50,990
无论我们说什么， 

1522
01:10:50,990 --> 01:10:53,993
flight.origin.friendlyName。 

1523
01:10:54,890 --> 01:10:58,250
因此，这一切都是面向对象的，这使得

1524
01:10:58,250 --> 01:11:01,590
编写更干净的代码，例如

1525
01:11:01,590 --> 01:11:04,500
friendlyName，flight.number和friendlyName 

1526
01:11:04,500 --> 01:11:08,560
在“发件人”字段中，这里的内容很少

1527
01:11:08,560 --> 01:11:11,363
信息结构和所有这些东西的随机列表。 

1528
01:11:13,230 --> 01:11:15,470
我们仍然在FlightFetcher中拥有所有这些东西，好吧， 

1529
01:11:15,470 --> 01:11:16,760
可怜的FlightFetcher。 

1530
01:11:16,760 --> 01:11:19,730
让我们从上一遍转到FlightFetcher 

1531
01:11:19,730 --> 01:11:22,580
演讲，然后把整个事情都注释掉

1532
01:11:22,580 --> 01:11:27,110
因为我们真的不再需要FlightFetcher。 

1533
01:11:27,110 --> 01:11:30,510
因为我们现在只使用我们的数据库。 

1534
01:11:30,510 --> 01:11:35,360
我们走了，哦，没有更多的错误了。 

1535
01:11:35,360 --> 01:11:38,930
我们固定了一切，将世界变成了整个对象- 

1536
01:11:38,930 --> 01:11:43,930
面向，非常简单，可以修复所有问题。 

1537
01:11:44,320 --> 01:11:48,570
实际上，其中一些代码更具可读性

1538
01:11:48,570 --> 01:11:49,960
并且可以理解。 

1539
01:11:49,960 --> 01:11:51,203
让我们看看它是否有效。 

1540
01:11:54,580 --> 01:11:57,570
确实存在，并且不起作用。 

1541
01:11:57,570 --> 01:11:58,403
为什么？ 

1542
01:11:58,403 --> 01:12:00,400
只是没有信息， 

1543
01:12:00,400 --> 01:12:02,340
但这实际上运行良好。 

1544
01:12:02,340 --> 01:12:05,370
只是我们的数据库中没有数据。 

1545
01:12:05,370 --> 01:12:07,440
因此，我们正在查看一个空数据库。 

1546
01:12:07,440 --> 01:12:10,200
这是我们空数据库中的所有排期。 

1547
01:12:10,200 --> 01:12:14,350
因此，我们显然需要一些代码来加载该数据库

1548
01:12:14,350 --> 01:12:17,733
与飞往目的地机场的航班。 

1549
01:12:18,580 --> 01:12:21,950
因此，让我们这样做，在这里，有新数据， 

1550
01:12:21,950 --> 01:12:24,450
这是我们创建此SFO的地方。 

1551
01:12:24,450 --> 01:12:27,280
让我们在这里创建一个机场功能

1552
01:12:27,280 --> 01:12:30,310
fetchIncomingFlights。 

1553
01:12:30,310 --> 01:12:32,710
这只是要转到FlightAware， 

1554
01:12:32,710 --> 01:12:35,240
提取他们要去这个机场的所有航班

1555
01:12:35,240 --> 01:12:37,470
现在，并将它们放入数据库中。 

1556
01:12:37,470 --> 01:12:39,820
然后一切都将从那里开始

1557
01:12:39,820 --> 01:12:41,680
因为我们其余的代码只是在

1558
01:12:41,680 --> 01:12:45,160
数据库，只是在等待某些事情发生。 

1559
01:12:45,160 --> 01:12:48,640
这个东西就在这里，正坐在那里等待

1560
01:12:48,640 --> 01:12:50,740
这开始给出一些结果。 

1561
01:12:50,740 --> 01:12:54,570
而且它将重新绘制并自动执行。 

1562
01:12:54,570 --> 01:12:56,120
那我们去机场吧

1563
01:12:56,120 --> 01:12:58,460
并执行此操作fetchIncomingFlights。 

1564
01:12:58,460 --> 01:13:00,890
现在，fetchIncomingFlights也将其注释掉， 

1565
01:13:00,890 --> 01:13:03,970
大部分还是关于FlightAware的内容， 

1566
01:13:03,970 --> 01:13:06,720
但我想在这里专注于这条线。 

1567
01:13:06,720 --> 01:13:10,490
此上下文= managedObjectContext。 

1568
01:13:10,490 --> 01:13:12,790
您会注意到，当我们创建此功能时

1569
01:13:12,790 --> 01:13:14,600
fetchIncomingFlights， 

1570
01:13:14,600 --> 01:13:17,880
我们没有传递上下文，数据库上下文

1571
01:13:17,880 --> 01:13:19,020
作为争论。 

1572
01:13:19,020 --> 01:13:21,960
所以您可能想知道我们将如何创建航班， 

1573
01:13:21,960 --> 01:13:23,310
我们正在获取来回的航班， 

1574
01:13:23,310 --> 01:13:24,570
我们如何在数据库中创建它们

1575
01:13:24,570 --> 01:13:26,500
如果没有上下文？ 

1576
01:13:26,500 --> 01:13:29,880
好吧，这个方法fetchIncomingFlights是一个实例

1577
01:13:29,880 --> 01:13:33,520
机场上的方法，结果发现所有对象

1578
01:13:33,520 --> 01:13:36,170
来自核心数据，机场，航空公司， 

1579
01:13:36,170 --> 01:13:37,530
航班，其中任何一个， 

1580
01:13:37,530 --> 01:13:40,080
他们知道他们来自的背景。 

1581
01:13:40,080 --> 01:13:42,350
我们将使用相同的上下文， 

1582
01:13:42,350 --> 01:13:44,180
放我们的航班。 

1583
01:13:44,180 --> 01:13:46,840
所以这行代码，如果让context = managedObjectContext， 

1584
01:13:46,840 --> 01:13:51,640
刚进入机场的一个变种， 

1585
01:13:51,640 --> 01:13:54,150
那是什么，managedObjectContext， 

1586
01:13:54,150 --> 01:13:55,870
你出来的。 

1587
01:13:55,870 --> 01:13:59,330
知道这一点非常重要，因为否则

1588
01:13:59,330 --> 01:14:02,190
您将最终在所有周围传递上下文

1589
01:14:02,190 --> 01:14:05,500
有实例时不必要的时间

1590
01:14:05,500 --> 01:14:08,170
从您手中的数据库中

1591
01:14:08,170 --> 01:14:11,040
您总是可以从数据库中获取上下文并添加

1592
01:14:11,040 --> 01:14:14,373
更多对象或使用该对象获取其他对象。 

1593
01:14:15,560 --> 01:14:19,160
这是当

1594
01:14:19,160 --> 01:14:20,670
信息从FlightAware返回。 

1595
01:14:20,670 --> 01:14:23,600
这与我们在这里所做的非常相似， 

1596
01:14:23,600 --> 01:14:27,470
当此AirportInfoRequest获取机场时， 

1597
01:14:27,470 --> 01:14:29,740
这就是返回结果的地方。 

1598
01:14:29,740 --> 01:14:32,090
我们在这里有完全一样的事情， 

1599
01:14:32,090 --> 01:14:33,340
我们得到的结果。 

1600
01:14:34,360 --> 01:14:36,120
那么，当信息出现时我该怎么办

1601
01:14:36,120 --> 01:14:37,500
从FlightAware回来吗？ 

1602
01:14:37,500 --> 01:14:39,627
嗯，这是一组FAFlight， 

1603
01:14:39,627 --> 01:14:42,040
你们都记得FAFlight在这里

1604
01:14:42,040 --> 01:14:44,430
从FlightAware返回的信息。 

1605
01:14:44,430 --> 01:14:47,740
所以我将经历所有那些FAFlights 

1606
01:14:47,740 --> 01:14:50,740
带有for循环，以便在这些结果中获得乐趣。 

1607
01:14:50,740 --> 01:14:54,080
现在我要在Flight中调用一个函数

1608
01:14:54,080 --> 01:14:56,100
从FAFlight更新。 

1609
01:14:56,100 --> 01:14:59,530
再说一次，就像我从这里开始更新一样， 

1610
01:14:59,530 --> 01:15:02,900
从Airport中的AirportInfo更新， 

1611
01:15:02,900 --> 01:15:07,110
我要把这个方法几乎完全一样

1612
01:15:07,110 --> 01:15:11,010
但所有面向飞行的内容都进入了Flight。 

1613
01:15:11,010 --> 01:15:12,060
因此，让我们去做。 

1614
01:15:12,060 --> 01:15:17,060
这是Flight，您可以看到它在做同样的事情， 

1615
01:15:17,324 --> 01:15:21,800
FetchRequest，通过识别所有这些事物来查找事物。 

1616
01:15:21,800 --> 01:15:26,800
再次可能是，让request = fetchRequest， 

1617
01:15:29,440 --> 01:15:32,810
这个谓词，所以我们可以使

1618
01:15:32,810 --> 01:15:34,620
那里有一个班轮。 

1619
01:15:34,620 --> 01:15:36,870
因此，我们正在通过任何搜索该航班

1620
01:15:36,870 --> 01:15:39,580
ident在FAFlight中。 

1621
01:15:39,580 --> 01:15:42,077
这就是搜索谓词。 

1622
01:15:42,077 --> 01:15:44,190
我们正在做和机场一样的事情， 

1623
01:15:44,190 --> 01:15:46,090
想看看我们是否找到了结果， 

1624
01:15:46,090 --> 01:15:47,880
如果我们找到它的话， 

1625
01:15:47,880 --> 01:15:49,550
航班有所不同，因为它们可以

1626
01:15:49,550 --> 01:15:50,860
随时间更新。 

1627
01:15:50,860 --> 01:15:53,630
因此，如果找不到，我们将使用更新

1628
01:15:53,630 --> 01:15:55,823
任何信息回来。 

1629
01:15:56,810 --> 01:15:59,990
而这只是我们之前看到的东西。 

1630
01:15:59,990 --> 01:16:02,280
这里发生了一些有趣的事情

1631
01:16:02,280 --> 01:16:05,710
在这里，我正在设置一些关系变量。 

1632
01:16:05,710 --> 01:16:08,360
所以这是我的出发地和目的地。 

1633
01:16:08,360 --> 01:16:09,193
看我在做什么

1634
01:16:09,193 --> 01:16:13,330
我正在使用该起点var创建一个机场

1635
01:16:13,330 --> 01:16:15,730
因为FAFlight的原点是字符串。 

1636
01:16:15,730 --> 01:16:20,338
因此，我希望国际民航组织在目前的背景下， 

1637
01:16:20,338 --> 01:16:23,360
我们传递给我们的上下文

1638
01:16:23,360 --> 01:16:24,420
并创建一个机场。 

1639
01:16:24,420 --> 01:16:26,470
目的地机场也一样。 

1640
01:16:26,470 --> 01:16:30,150
对于航空公司来说也是一样，因为在FAFlight中， 

1641
01:16:30,150 --> 01:16:31,520
airlineCode是一个字符串。 

1642
01:16:31,520 --> 01:16:33,050
所以我需要创建一个航空公司。 

1643
01:16:33,050 --> 01:16:36,610
所以在航空公司中，我们需要一点东西来查找它， 

1644
01:16:36,610 --> 01:16:38,690
并找到它，然后返回它，如果没有，它将创建它

1645
01:16:38,690 --> 01:16:39,740
就像我们有一个机场一样。 

1646
01:16:39,740 --> 01:16:41,363
因此，让我们在航空公司中做到这一点， 

1647
01:16:43,450 --> 01:16:47,143
加上代码，看起来和机场非常相似。 

1648
01:16:47,143 --> 01:16:49,530
只是这些都在这里不同。 

1649
01:16:49,530 --> 01:16:51,870
虽然我们在这里仍在执行objectWillChange。 

1650
01:16:51,870 --> 01:16:53,390
航班也是如此。 

1651
01:16:53,390 --> 01:16:56,160
因此，如果此航空公司信息可用

1652
01:16:56,160 --> 01:16:59,110
从FlightAware，我们将要做objectWillChange 

1653
01:16:59,110 --> 01:17:00,233
在所有这些东西上。 

1654
01:17:01,540 --> 01:17:03,890
我想告诉你的一件事是

1655
01:17:03,890 --> 01:17:05,360
当我加载这些航班时， 

1656
01:17:05,360 --> 01:17:07,890
我将向您展示尝试捕捉的样子

1657
01:17:07,890 --> 01:17:10,200
来自上下文保存的错误。 

1658
01:17:10,200 --> 01:17:12,420
只是因为我们还没有真正做到这一点， 

1659
01:17:12,420 --> 01:17:14,620
我们一直在尝试吗？到处， 

1660
01:17:14,620 --> 01:17:18,330
但是如果你只是想抓住那个东西，你想

1661
01:17:18,330 --> 01:17:21,360
尝试，这将引发错误，并且将捕获该错误。 

1662
01:17:21,360 --> 01:17:24,170
然后您可以执行类似打印错误的操作

1663
01:17:24,170 --> 01:17:26,270
localizedDescription或此处的某些内容， 

1664
01:17:26,270 --> 01:17:29,500
在这里我们可以处理错误，尝试保存

1665
01:17:29,500 --> 01:17:31,430
上下文，而我们做不到。 

1666
01:17:31,430 --> 01:17:34,810
如果您的上下文保存失败，则可能会发生一些非常糟糕的情况， 

1667
01:17:34,810 --> 01:17:37,580
也许您的磁盘已满，或者， 

1668
01:17:37,580 --> 01:17:40,754
这里发生了令人发指的事情。 

1669
01:17:40,754 --> 01:17:43,960
因此，通常无法做很多事情来处理失败

1670
01:17:43,960 --> 01:17:47,079
例如，也许尝试在几秒钟之内再次保存， 

1671
01:17:47,079 --> 01:17:49,943
但要从中恢复是一个艰难的过程。 

1672
01:17:51,270 --> 01:17:53,180
因此，这就是在获取传入消息时发生的所有事情

1673
01:17:53,180 --> 01:17:57,010
航班，我们只是用东西加载数据库

1674
01:17:57,010 --> 01:17:59,220
来自FlightAware的信息。 

1675
01:17:59,220 --> 01:18:00,920
这就是我们反复做的所有事情。 

1676
01:18:02,730 --> 01:18:04,033
看看是否可行。 

1677
01:18:06,510 --> 01:18:10,620
好吧，看一下，然后将其加载到数据库中。 

1678
01:18:10,620 --> 01:18:13,760
哇，现在我们的数据显示出很多航班

1679
01:18:13,760 --> 01:18:14,760
他们仍然进来。 

1680
01:18:14,760 --> 01:18:16,750
它正在加载越来越多的航班。 

1681
01:18:16,750 --> 01:18:19,950
而我们在这里看到的是数据库。 

1682
01:18:19,950 --> 01:18:21,820
这纯粹是在看数据库。 

1683
01:18:21,820 --> 01:18:23,410
所有这一切都在发生， 

1684
01:18:23,410 --> 01:18:28,410
与用户界面中发生的情况异步发生。 

1685
01:18:28,730 --> 01:18:31,060
现在浏览左侧的代码， 

1686
01:18:31,060 --> 01:18:33,140
我实际上可以看到，我们忘记了一些东西， 

1687
01:18:33,140 --> 01:18:36,990
这是我们没有让Flight执行其objectWillChange， 

1688
01:18:36,990 --> 01:18:39,350
即使我们可能正在进行重大更新

1689
01:18:39,350 --> 01:18:40,560
去那里的航班。 

1690
01:18:40,560 --> 01:18:43,270
然后我也在顶部看到一个问题

1691
01:18:43,270 --> 01:18:45,789
并不是说飞往KSFO的航班， 

1692
01:18:45,789 --> 01:18:49,340
就是说飞往机场0X的航班。 

1693
01:18:49,340 --> 01:18:52,890
之所以这样，是因为我们正在打印机场

1694
01:18:52,890 --> 01:18:57,040
对象在那里，而不是打印出来的是ICAO代码。 

1695
01:18:57,040 --> 01:18:59,390
因此，让我们解决这两个问题， 

1696
01:18:59,390 --> 01:19:01,170
从这里开始

1697
01:19:01,170 --> 01:19:05,340
我们忘了说我们要飞行

1698
01:19:05,340 --> 01:19:10,000
我们刚刚创建的，以使其具有objectWillChange.send（） 

1699
01:19:10,000 --> 01:19:12,960
发送，因为我们只是更改了很多字段而我们想

1700
01:19:12,960 --> 01:19:17,600
确保我们的用户界面将进行更新。 

1701
01:19:17,600 --> 01:19:21,073
然后我们可以通过机场解决该标题问题， 

1702
01:19:22,070 --> 01:19:26,600
我们在这里通过说反斜杠打开来做

1703
01:19:26,600 --> 01:19:29,640
括号，封闭括号和对象。 

1704
01:19:29,640 --> 01:19:31,260
我们真的不需要这里的对象。 

1705
01:19:31,260 --> 01:19:34,213
我们想要这个目的地的国际民航组织。 

1706
01:19:36,950 --> 01:19:37,783
因此，让我们这样做。 

1707
01:19:37,783 --> 01:19:38,883
解决该问题。 

1708
01:19:43,260 --> 01:19:44,093
在那里。 

1709
01:19:44,093 --> 01:19:44,926
就是国际民航组织。 

1710
01:19:46,940 --> 01:19:47,773
行。 

1711
01:19:47,773 --> 01:19:50,360
我们要做的最后一步是在此处修复过滤器

1712
01:19:50,360 --> 01:19:52,120
因为我们的过滤器lemme向您展示

1713
01:19:52,120 --> 01:19:53,310
他们现在会做什么。 

1714
01:19:53,310 --> 01:19:55,680
它不会起作用，因为此过滤器

1715
01:19:55,680 --> 01:19:57,550
用于字符串。 

1716
01:19:57,550 --> 01:20:00,060
应该是在这里选弦

1717
01:20:00,060 --> 01:20:01,350
此FilterFFlights。 

1718
01:20:01,350 --> 01:20:05,000
您知道，我们已将所有排期更改为对象。 

1719
01:20:05,000 --> 01:20:07,020
所以这需要面向对象

1720
01:20:07,020 --> 01:20:09,070
以及这里的待遇。 

1721
01:20:09,070 --> 01:20:11,880
现在，当我们让人们选择机场和航空公司时， 

1722
01:20:11,880 --> 01:20:14,740
我们实际上确实需要所有机场和所有航空公司

1723
01:20:14,740 --> 01:20:15,790
可用的

1724
01:20:15,790 --> 01:20:20,253
但是我们不会再用这些旧的ViewModel再做一次

1725
01:20:20,253 --> 01:20:23,160
都是机场，所有航空公司， 

1726
01:20:23,160 --> 01:20:24,727
我们要在这里执行FetchRequests 

1727
01:20:24,727 --> 01:20:26,850
这些将是FetchRequests for Airports and 

1728
01:20:26,850 --> 01:20:29,400
航空公司，我要执行FetchRequest， 

1729
01:20:29,400 --> 01:20:34,340
我将在这里将FetchRequest硬连线

1730
01:20:34,340 --> 01:20:39,340
在这里，它将是airport.fetchRequest， 

1731
01:20:39,550 --> 01:20:44,550
谓词实质上是所有的

1732
01:20:45,750 --> 01:20:47,960
我需要我所有的机场。 

1733
01:20:47,960 --> 01:20:51,510
我要用这个FetchRequest来获取一些变量

1734
01:20:51,510 --> 01:20:55,610
这里的机场，这将是我的所有机场。 

1735
01:20:55,610 --> 01:20:59,640
这与我所做的FetchedResults一样

1736
01:20:59,640 --> 01:21:02,300
在这里，但是在这里，我正在根据以下内容执行FetchedResults 

1737
01:21:02,300 --> 01:21:05,401
查找目的地机场，在这种情况下， 

1738
01:21:05,401 --> 01:21:08,310
我要我所有的机场。 

1739
01:21:08,310 --> 01:21:10,270
那么什么样的谓词意味着全部， 

1740
01:21:10,270 --> 01:21:11,510
好吧，这有很大的理由

1741
01:21:11,510 --> 01:21:13,473
称为TRUEPREDICATE。 

1742
01:21:13,473 --> 01:21:15,420
基本上，这意味着评估

1743
01:21:15,420 --> 01:21:17,300
始终为真。 

1744
01:21:17,300 --> 01:21:18,910
这太普遍了。 

1745
01:21:18,910 --> 01:21:21,000
我实际上创建了一个扩展

1746
01:21:21,000 --> 01:21:25,140
调用NSPredicate，然后调用所有方法， 

1747
01:21:25,140 --> 01:21:27,742
没有一个是假的。 

1748
01:21:27,742 --> 01:21:30,200
好像我一直在做谓词， 

1749
01:21:30,200 --> 01:21:32,080
TRUEPREDICATE在我的应用程序中的某处。 

1750
01:21:32,080 --> 01:21:33,840
所以我要全部改变。 

1751
01:21:33,840 --> 01:21:36,270
就是这样，这将获取所有机场。 

1752
01:21:36,270 --> 01:21:39,600
这个机场变数将永远是所有机场， 

1753
01:21:39,600 --> 01:21:42,930
即使添加了机场，它也会自动更新

1754
01:21:42,930 --> 01:21:46,770
我们正在做的这FetchedResults事情

1755
01:21:46,770 --> 01:21:49,260
在我们的捡拾器里面

1756
01:21:49,260 --> 01:21:50,710
将始终被更新。 

1757
01:21:50,710 --> 01:21:54,960
我们将为航空公司做同样的事情。 

1758
01:21:54,960 --> 01:21:57,130
现在我们有了所有的机场和所有的航空公司， 

1759
01:21:57,130 --> 01:22:00,460
我们将在采摘机内部使用它， 

1760
01:22:00,460 --> 01:22:05,140
因为我们的选择器当前正在选择这些代码， 

1761
01:22:05,140 --> 01:22:08,130
但我们希望他们实际拾取物体。 

1762
01:22:08,130 --> 01:22:12,030
我们希望他们选择机场和航空公司的对象。 

1763
01:22:12,030 --> 01:22:14,560
因此，与其在这里没有所有机场代码， 

1764
01:22:14,560 --> 01:22:17,453
这将是我们的机场， 

1765
01:22:18,410 --> 01:22:20,560
然后我要对它们进行排序，排序。 

1766
01:22:20,560 --> 01:22:23,110
如果您还记得我们的机场，当我向您展示机场时

1767
01:22:23,110 --> 01:22:26,370
在这里，我做到了，以便它实现了

1768
01:22:28,180 --> 01:22:29,853
可比较的协议。 

1769
01:22:30,760 --> 01:22:34,600
因此，此可比协议比功能少。 

1770
01:22:34,600 --> 01:22:36,370
如果您实施Comparable， 

1771
01:22:36,370 --> 01:22:40,110
那么您可以拥有机场或数组之类的集合

1772
01:22:40,110 --> 01:22:43,630
事物，通过排序进行自我排序。 

1773
01:22:43,630 --> 01:22:45,230
现在这是面向对象的。 

1774
01:22:45,230 --> 01:22:47,620
所以我们不需要，需要这样查找。 

1775
01:22:47,620 --> 01:22:52,250
我们只能在这里说我们的机场的friendlyName 

1776
01:22:52,250 --> 01:22:55,490
去机场，这永远不会返回nil， 

1777
01:22:55,490 --> 01:22:58,540
因此我们无需选择默认。 

1778
01:22:58,540 --> 01:23:02,300
好，所以这段代码实际上很好地清理了。 

1779
01:23:02,300 --> 01:23:04,000
那我们的血统呢？ 

1780
01:23:04,000 --> 01:23:05,890
相似，除了，当然， 

1781
01:23:05,890 --> 01:23:07,720
这不再是字符串。 

1782
01:23:07,720 --> 01:23:11,950
因此，我们不希望Optional String为Optional nil。 

1783
01:23:11,950 --> 01:23:15,650
我们要机场可选

1784
01:23:15,650 --> 01:23:17,870
就在那儿，这对机场来说一直是零。 

1785
01:23:17,870 --> 01:23:19,500
再说一次，不是全部的airports.codes， 

1786
01:23:19,500 --> 01:23:21,753
我们需要Airports.sorted（）。 

1787
01:23:23,270 --> 01:23:26,110
再说一次，机场已经

1788
01:23:27,410 --> 01:23:30,660
以一种面向对象的方式获得了自己的friendlyName。 

1789
01:23:30,660 --> 01:23:33,840
还是要??任何，因为

1790
01:23:33,840 --> 01:23:37,830
该机场可以为零，并且不是可选的

1791
01:23:37,830 --> 01:23:39,703
字符串，这是可选机场。 

1792
01:23:42,560 --> 01:23:45,670
现在，这是在选择可选机场， 

1793
01:23:45,670 --> 01:23:47,720
就像在接机

1794
01:23:47,720 --> 01:23:50,230
这是这里的航空公司。 

1795
01:23:50,230 --> 01:23:52,730
这可能与此更相似， 

1796
01:23:52,730 --> 01:23:54,230
比这另一件事更重要。 

1797
01:23:54,230 --> 01:23:56,770
因此，如果我在此处复制并粘贴， 

1798
01:23:56,770 --> 01:23:59,190
更改为我们的航空公司。 

1799
01:23:59,190 --> 01:24:03,040
我要搜寻并取代这个机场

1800
01:24:03,040 --> 01:24:04,333
与我们的航空公司

1801
01:24:06,043 --> 01:24:09,180
我们已经将它们转换为使用对象

1802
01:24:09,180 --> 01:24:11,830
而不是它们的字符串。 

1803
01:24:11,830 --> 01:24:14,390
否则，此代码可以保持不变。 

1804
01:24:14,390 --> 01:24:16,420
我想做的最后一件事是， 

1805
01:24:16,420 --> 01:24:18,480
当按下完成按钮时， 

1806
01:24:18,480 --> 01:24:20,550
如果您更改了目的地， 

1807
01:24:20,550 --> 01:24:24,010
我想这样做，fetchIncomingFlights。 

1808
01:24:24,010 --> 01:24:27,280
如果您不考虑SFO， 

1809
01:24:27,280 --> 01:24:29,580
看达拉斯堡值得， 

1810
01:24:29,580 --> 01:24:32,950
我想获取那些传入的航班。 

1811
01:24:32,950 --> 01:24:34,110
所以我只想这样做

1812
01:24:34,110 --> 01:24:36,800
当您实际更改目的地时。 

1813
01:24:36,800 --> 01:24:41,800
所以我要说，如果我的草稿的目的地不相等

1814
01:24:42,890 --> 01:24:47,890
我的航班搜索目的地，然后是self.draft 

1815
01:24:49,750 --> 01:24:53,263
目的地fetchIncomingFlights。 

1816
01:24:55,558 --> 01:24:56,540
让我们来看看。 

1817
01:24:56,540 --> 01:24:57,593
看看是否可行。 

1818
01:25:00,367 --> 01:25:01,342
好吧，我们开始。 

1819
01:25:01,342 --> 01:25:02,192
让我们尝试过滤。 

1820
01:25:03,130 --> 01:25:06,960
哦，不，它崩溃了，它崩溃了，我们讨厌崩溃。 

1821
01:25:06,960 --> 01:25:08,410
到底是怎么回事？ 

1822
01:25:08,410 --> 01:25:10,713
让我们在下面看一下我们的控制台。 

1823
01:25:11,810 --> 01:25:15,110
这是一个非常非常重要的错误

1824
01:25:15,110 --> 01:25:16,550
当您使用核心数据时， 

1825
01:25:16,550 --> 01:25:19,530
了解这是什么。 

1826
01:25:19,530 --> 01:25:23,200
它说，您环境中的上下文未连接到

1827
01:25:23,200 --> 01:25:25,640
持久性存储协调器。 

1828
01:25:25,640 --> 01:25:29,390
如果您还记得这里的SceneDelegate， 

1829
01:25:29,390 --> 01:25:33,570
我们从持久性存储中创建了这个事物上下文， 

1830
01:25:33,570 --> 01:25:35,000
这个持久的容器。 

1831
01:25:35,000 --> 01:25:37,220
这是我们对数据库的查看， 

1832
01:25:37,220 --> 01:25:40,710
然后我们必须将其传递到“途中视图”中

1833
01:25:40,710 --> 01:25:42,490
通过这种环境。 

1834
01:25:42,490 --> 01:25:47,280
但是我们从名誉的观点来看， 

1835
01:25:47,280 --> 01:25:51,500
用FilterFlights和工作表放置工作表

1836
01:25:51,500 --> 01:25:53,070
得到自己的环境。 

1837
01:25:53,070 --> 01:25:55,900
所以我们必须在这里做同样的事情， 

1838
01:25:55,900 --> 01:26:00,440
并传递到这个环境，这个环境中

1839
01:26:00,440 --> 01:26:03,500
现在，这里唯一的问题是什么是上下文？ 

1840
01:26:03,500 --> 01:26:06,480
它说未解析的标识符，上下文在哪里？ 

1841
01:26:06,480 --> 01:26:09,360
好吧，我们将不得不在这里得到我们的背景， 

1842
01:26:09,360 --> 01:26:10,760
这样我们就可以通过这里了

1843
01:26:13,775 --> 01:26:17,430
我们将从我们的环境中得到这一点， 

1844
01:26:17,430 --> 01:26:22,430
一个managedObjectContext，它是一个变量，我们称之为上下文。 

1845
01:26:24,670 --> 01:26:26,687
所以在这里，我要从这里抓取这种情况。 

1846
01:26:26,687 --> 01:26:30,330
我不在我的环境中，而且我正在传递它

1847
01:26:30,330 --> 01:26:32,230
到此工作表的环境。 

1848
01:26:32,230 --> 01:26:34,330
所以这个人有环境。 

1849
01:26:34,330 --> 01:26:37,460
因此，这是一个常见的错误。 

1850
01:26:37,460 --> 01:26:41,220
因此，请务必确保您的大脑在燃烧， 

1851
01:26:41,220 --> 01:26:42,380
这是什么意思

1852
01:26:42,380 --> 01:26:46,410
这只是意味着您需要传递一张纸或其他东西。 

1853
01:26:46,410 --> 01:26:49,140
任何导致此模式弹出窗口的内容， 

1854
01:26:49,140 --> 01:26:51,077
在其中传递此上下文。 

1855
01:26:51,077 --> 01:26:55,520
原因是FetchRequest之类的

1856
01:26:55,520 --> 01:26:57,200
取决于那个上下文。 

1857
01:26:57,200 --> 01:26:59,117
他们还能怎么知道这些机场

1858
01:26:59,117 --> 01:27:00,420
和航空公司呢？ 

1859
01:27:00,420 --> 01:27:03,313
他们需要上下文处于其环境中。 

1860
01:27:06,700 --> 01:27:07,533
哦，是的。 

1861
01:27:07,533 --> 01:27:09,280
所以，我们要在那儿放一个自我点

1862
01:27:09,280 --> 01:27:10,937
现在我们可以做到。 

1863
01:27:13,549 --> 01:27:15,450
好的，我们开始吧，让我们尝试过滤。 

1864
01:27:15,450 --> 01:27:18,490
哦，看起来不错，目的地是旧金山。 

1865
01:27:18,490 --> 01:27:21,542
哇，丹佛遍地都是。 

1866
01:27:21,542 --> 01:27:24,201
现在没有获取，这很好。 

1867
01:27:24,201 --> 01:27:26,170
我还没说完

1868
01:27:26,170 --> 01:27:28,096
因此它没有关闭并在那里进行获取。 

1869
01:27:28,096 --> 01:27:31,880
是的，看起来不错，航空公司， 

1870
01:27:31,880 --> 01:27:34,056
我要说曼联。 

1871
01:27:34,056 --> 01:27:34,889
那个怎么样？ 

1872
01:27:34,889 --> 01:27:36,090
哦，航空公司不工作。 

1873
01:27:36,090 --> 01:27:38,420
看到那家航空公司，没有工作。 

1874
01:27:38,420 --> 01:27:40,700
因此，让我们回头看看航空公司告诉您， 

1875
01:27:40,700 --> 01:27:43,800
我们做错了什么可能是复制和粘贴错误

1876
01:27:43,800 --> 01:27:45,053
我们在那里做的。 

1877
01:27:45,890 --> 01:27:48,283
这就是在FilterFlights中。 

1878
01:27:49,320 --> 01:27:52,550
所以航空公司看到了，哦，看看这个草案。 

1879
01:27:52,550 --> 01:27:57,263
对于航空公司，不，这是draft.airline。 

1880
01:27:58,290 --> 01:27:59,123
试试看

1881
01:28:02,200 --> 01:28:04,040
好的，就这样，这很好。 

1882
01:28:04,040 --> 01:28:07,050
现在，航空公司，看起来已经好多了， 

1883
01:28:07,050 --> 01:28:11,570
曼联，让我们去波士顿，我要完成了， 

1884
01:28:11,570 --> 01:28:14,370
并希望它将再次进行提取。 

1885
01:28:14,370 --> 01:28:16,190
哎呀，那是波士顿。 

1886
01:28:16,190 --> 01:28:18,630
再一次，我们在这里查找数据库， 

1887
01:28:18,630 --> 01:28:20,560
如果我们回到旧金山， 

1888
01:28:20,560 --> 01:28:22,830
您会在这里注意到一些有趣的事情。 

1889
01:28:22,830 --> 01:28:24,070
密切关注。 

1890
01:28:24,070 --> 01:28:25,720
好吧，那里有很多机场。 

1891
01:28:26,820 --> 01:28:28,810
我认为它就走了，就在这里。 

1892
01:28:28,810 --> 01:28:31,500
看我什么时候打完

1893
01:28:31,500 --> 01:28:33,750
糟糕，SFO加载速度有多快， 

1894
01:28:33,750 --> 01:28:37,326
因为它向我显示了数据库中的内容， 

1895
01:28:37,326 --> 01:28:39,380
并且正在不断更新它们， 

1896
01:28:39,380 --> 01:28:42,810
但是我们从数据库中得到了即时响应， 

1897
01:28:42,810 --> 01:28:45,350
这是移动此方法的另一种巨大的副作用

1898
01:28:45,350 --> 01:28:46,623
数据库中的内容。 

1899
01:28:48,680 --> 01:28:53,120
现在还不太正确，因为我更改了

1900
01:28:53,120 --> 01:28:56,320
如果您还记得，以曼联为我的航空公司， 

1901
01:28:56,320 --> 01:29:00,600
但这给了我除了曼联以外的其他航空公司，对吗？ 

1902
01:29:00,600 --> 01:29:04,150
那是因为在我们的FlightEnroute中， 

1903
01:29:04,150 --> 01:29:06,270
当我们查看航班时， 

1904
01:29:06,270 --> 01:29:09,543
我们的谓词只是目的地而已。 

1905
01:29:10,570 --> 01:29:15,013
这不是看航空公司，而是类似的事情。 

1906
01:29:15,013 --> 01:29:16,720
它只是目的地。 

1907
01:29:16,720 --> 01:29:21,560
所以我们这里需要这个谓词，作为一些谓词， 

1908
01:29:21,560 --> 01:29:26,560
说谓词相等，则日期基于此FlightSearch 

1909
01:29:27,040 --> 01:29:30,350
还有所有的东西，而不仅仅是目的地。 

1910
01:29:30,350 --> 01:29:34,080
所以我在这里对FlightSearch做了一些扩展

1911
01:29:34,080 --> 01:29:35,143
要做到这一点。 

1912
01:29:36,260 --> 01:29:38,170
让我们一直移动

1913
01:29:38,170 --> 01:29:40,910
到此处的文件顶部。 

1914
01:29:40,910 --> 01:29:44,210
我添加的这个FlightSearch扩展名是添加一个

1915
01:29:44,210 --> 01:29:45,880
var称为谓词。 

1916
01:29:45,880 --> 01:29:48,150
那就是我们的隐含搜索，对吧？ 

1917
01:29:48,150 --> 01:29:49,740
所以它只是看所有这些东西， 

1918
01:29:49,740 --> 01:29:53,340
并建立一个NSPredicate对象， 

1919
01:29:53,340 --> 01:29:56,960
使用越来越多的格式的东西， 

1920
01:29:56,960 --> 01:29:58,890
您会看到其格式为目的地。 

1921
01:29:58,890 --> 01:30:01,893
然后，如果有原点，我添加和原点。 

1922
01:30:03,090 --> 01:30:06,130
如果有航空公司，我要补充，然后是航空公司。 

1923
01:30:06,130 --> 01:30:08,470
一路上，我有这个参数

1924
01:30:08,470 --> 01:30:10,543
这是一个NSManagedObject数组。 

1925
01:30:11,890 --> 01:30:14,470
现在，什么是NSManagedObject？ 

1926
01:30:14,470 --> 01:30:19,470
这是航班，机场和航空公司的超类。 

1927
01:30:19,550 --> 01:30:22,910
因此，如果我想创建一个可以包含Flights的数组， 

1928
01:30:22,910 --> 01:30:25,460
或机场或航空公司， 

1929
01:30:25,460 --> 01:30:28,980
然后我可以制作一个NSManagedObject数组， 

1930
01:30:28,980 --> 01:30:31,850
因为那些都是从那里继承的，所以这行得通。 

1931
01:30:31,850 --> 01:30:34,100
这就是args，所以到达目的地

1932
01:30:34,100 --> 01:30:36,450
在那里开始，然后如果有一个起源

1933
01:30:36,450 --> 01:30:38,957
它放在那里，如果有航空公司，它放在那里

1934
01:30:38,957 --> 01:30:41,600
那里，然后我们只是说NSPredicate格式， 

1935
01:30:41,600 --> 01:30:44,710
我们建立的这个String和参数Array， 

1936
01:30:44,710 --> 01:30:47,969
是我建立的这些参数。 

1937
01:30:47,969 --> 01:30:51,310
这就是您的方式，可以建立一个程序化的方式

1938
01:30:51,310 --> 01:30:53,820
基于决策的谓词， 

1939
01:30:53,820 --> 01:30:55,473
像这个结构中的内容。 

1940
01:30:56,660 --> 01:30:58,830
所以我要在这里使用这个谓词var 

1941
01:30:58,830 --> 01:31:02,510
再说一下flightSearch.predicate。 

1942
01:31:02,510 --> 01:31:04,780
给我这个FlightSearch的谓词。 

1943
01:31:04,780 --> 01:31:06,663
我将用它来搜索。 

1944
01:31:07,800 --> 01:31:09,473
我们不再需要了。 

1945
01:31:11,490 --> 01:31:13,030
更简单，实际上，这是如此简单， 

1946
01:31:13,030 --> 01:31:15,713
我们可以像这样把它放在这里。 

1947
01:31:18,828 --> 01:31:19,853
看看是否可行。 

1948
01:31:22,820 --> 01:31:26,200
请注意，SFO立即向我们显示了数据库中的数据， 

1949
01:31:26,200 --> 01:31:29,390
仍然有效的数据，以向我们展示， 

1950
01:31:29,390 --> 01:31:32,550
让我们去这里的飞机场，然后去曼联， 

1951
01:31:32,550 --> 01:31:33,880
那是旧金山的枢纽。 

1952
01:31:33,880 --> 01:31:35,490
因此，应该有飞行和搅动。 

1953
01:31:35,490 --> 01:31:39,660
就是这样，它在起作用，我们可以开始尝试。 

1954
01:31:39,660 --> 01:31:41,370
那里的起源是什么？ 

1955
01:31:41,370 --> 01:31:43,390
波士顿，我们可以找到波士顿。 

1956
01:31:43,390 --> 01:31:46,810
我们知道波士顿就在那，波士顿的洛根机场。 

1957
01:31:46,810 --> 01:31:50,260
所以现在我们要看波士顿和曼联， 

1958
01:31:50,260 --> 01:31:51,460
发现，那很好。 

1959
01:31:53,540 --> 01:31:56,030
而且，我们应该回到说，告诉我们任何飞机

1960
01:31:56,030 --> 01:31:58,280
来自波士顿，在这趟航班上

1961
01:31:58,280 --> 01:32:01,800
莱姆回到这里说，表明有航空公司， 

1962
01:32:01,800 --> 01:32:03,593
在任何地方，它们在这里。 

1963
01:32:05,770 --> 01:32:06,900
好的。 

1964
01:32:06,900 --> 01:32:09,620
因此，该演示中有很多代码。 

1965
01:32:09,620 --> 01:32:11,460
很高兴向您展示， 

1966
01:32:11,460 --> 01:32:16,340
但希望您对我们如何建立自己的产品有很好的感觉

1967
01:32:16,340 --> 01:32:18,920
UI中数据库中的数据不足， 

1968
01:32:18,920 --> 01:32:23,705
特别是我们执行这些FetchRequests的方式

1969
01:32:23,705 --> 01:32:26,850
重复出现的结果，它们只是不断更新

1970
01:32:26,850 --> 01:32:28,700
随着我们改变事物。 

1971
01:32:28,700 --> 01:32:31,760
这样就可以处理其余的代码了。 

1972
01:32:31,760 --> 01:32:34,720
那时并不需要很多，情况会发生变化， 

1973
01:32:34,720 --> 01:32:36,090
这个，那个和另一件事， 

1974
01:32:36,090 --> 01:32:37,050
它只是找到他们。 

1975
01:32:37,050 --> 01:32:38,500
并请注意，在核心数据中， 

1976
01:32:38,500 --> 01:32:42,130
大多使用这些FetchedResults进行更改。 

1977
01:32:42,130 --> 01:32:45,890
即使我们也可以在单个对象上使用ObservedObjects 

1978
01:32:45,890 --> 01:32:48,370
航班，航空公司，对的，如果这是我们在这里使用的

1979
01:32:48,370 --> 01:32:51,040
航班确实发生了变化，因为我们做了

1980
01:32:51,040 --> 01:32:53,290
objectWillChange.send（）在那里。 

1981
01:32:53,290 --> 01:32:54,123
它会更新， 

1982
01:32:54,123 --> 01:32:58,980
但这比执行这些FetchedResults更为罕见， 

1983
01:32:58,980 --> 01:33:01,760
真正的FetchedResults并始终保持动态

1984
01:33:01,760 --> 01:33:02,810
显示数据库中的内容， 

1985
01:33:02,810 --> 01:33:05,590
那才是SwiftUI的核心

1986
01:33:05,590 --> 01:33:07,493
到核心数据集成。 

1987
01:33:09,100 --> 01:33:09,933
行。 

1988
01:33:09,933 --> 01:33:11,640
我真的很想见你们中的一些

1989
01:33:11,640 --> 01:33:13,690
在您的最终项目中执行此操作。 

1990
01:33:13,690 --> 01:33:15,840
当然，很多不同的需求

1991
01:33:15,840 --> 01:33:18,990
项目构想，用于永久存储。 

1992
01:33:18,990 --> 01:33:23,460
这比执行UserDefaults强大得多。 

1993
01:33:23,460 --> 01:33:26,303
所以我希望你们能解决这个问题。 

1994
01:33:27,260 --> 01:33:30,513
-[Animaker语音]有关更多信息，请访问我们@ stanford.edu。 

