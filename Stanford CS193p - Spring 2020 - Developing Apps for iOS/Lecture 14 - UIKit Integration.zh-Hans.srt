1
00:00:00,000 --> 00:00:02,417
（轻柔的音乐） 

2
00:00:04,477 --> 00:00:06,323
-[女人]斯坦福大学。 

3
00:00:07,710 --> 00:00:10,909
-[讲师]欢迎大家参加最后的演讲， 

4
00:00:10,909 --> 00:00:14,797
斯坦福CS193p的第14讲课

5
00:00:14,797 --> 00:00:18,053
2020年春季季度。 

6
00:00:18,939 --> 00:00:21,054
对你们所有人来说，这都是最后的项目

7
00:00:21,054 --> 00:00:22,471
所有其他方式。 

8
00:00:22,471 --> 00:00:27,085
但是，我确实想谈谈SwiftUI的最后一项功能

9
00:00:27,085 --> 00:00:29,786
这是与UIKit的集成。 

10
00:00:29,786 --> 00:00:32,390
请记住，UIKit是老方法

11
00:00:32,390 --> 00:00:35,234
为iOS开发应用程序。 

12
00:00:35,234 --> 00:00:38,610
当SwiftUI几个月前问世时， 

13
00:00:38,610 --> 00:00:41,450
它几乎完成了UIKit的所有工作

14
00:00:41,450 --> 00:00:43,860
但是那里有一些UIKit功能

15
00:00:43,860 --> 00:00:44,960
在SwiftUI中没有

16
00:00:44,960 --> 00:00:47,161
并且您希望能够使用它们， 

17
00:00:47,161 --> 00:00:49,976
因此，使用此API确实很容易做到这一点。 

18
00:00:49,976 --> 00:00:53,656
您也可能是iOS应用程序的现有开发人员

19
00:00:53,656 --> 00:00:55,755
而且您有一堆UIKit代码， 

20
00:00:55,755 --> 00:00:56,960
当然你想用那个

21
00:00:56,960 --> 00:00:59,200
当您过渡到SwiftUI时， 

22
00:00:59,200 --> 00:01:02,712
这样您也可以做到这一点。 

23
00:01:02,712 --> 00:01:04,853
现在让我来谈谈这个功能

24
00:01:04,853 --> 00:01:07,757
我必须解释一下UIKit的工作原理。 

25
00:01:07,757 --> 00:01:10,539
我不会教你任何UIKit本身， 

26
00:01:10,539 --> 00:01:12,584
但从概念上讲，这很重要

27
00:01:12,584 --> 00:01:15,230
了解一些基本知识。 

28
00:01:15,230 --> 00:01:18,663
一件事是UIKit中没有MVVM， 

29
00:01:18,663 --> 00:01:22,880
取而代之的是所谓的MVC，即模型视图控制器。 

30
00:01:22,880 --> 00:01:25,233
在Model-View-Controller架构中

31
00:01:25,233 --> 00:01:27,446
视图有点组合在一起

32
00:01:27,446 --> 00:01:31,166
并由称为控制器的东西控制。 

33
00:01:31,166 --> 00:01:34,784
这个控制器有点粒度

34
00:01:34,784 --> 00:01:37,171
在屏幕上显示视图。 

35
00:01:37,171 --> 00:01:40,739
通过呈现，我的意思是像SwiftUI工作表

36
00:01:40,739 --> 00:01:43,864
或弹出框或NavigationLink的目标。 

37
00:01:43,864 --> 00:01:46,166
这些正在屏幕上呈现视图。 

38
00:01:46,166 --> 00:01:48,521
好吧，在SwiftUI中没有区别。 

39
00:01:48,521 --> 00:01:51,820
我们没有任何控制器，因此视图只是视图， 

40
00:01:51,820 --> 00:01:53,610
我们随时随地展示它们。 

41
00:01:53,610 --> 00:01:54,951
很好

42
00:01:54,951 --> 00:01:57,357
但是在UIKit中，情况有所不同

43
00:01:57,357 --> 00:01:59,268
当您将“视图”显示在屏幕上时。 

44
00:01:59,268 --> 00:02:01,917
您必须实质上提出一个控制器， 

45
00:02:01,917 --> 00:02:05,114
控制器控制视图。 

46
00:02:05,114 --> 00:02:06,498
现在因为这个， 

47
00:02:06,498 --> 00:02:08,343
因为您已经具备了Controller的功能， 

48
00:02:08,343 --> 00:02:11,895
SwiftUI和UIKit的集成

49
00:02:11,895 --> 00:02:14,285
确实需要两个集成点。 

50
00:02:14,285 --> 00:02:16,534
现在，这两个集成点非常相似， 

51
00:02:16,534 --> 00:02:19,296
但其中一个是UIViewRepresentable， 

52
00:02:19,296 --> 00:02:23,419
这是一个表示UIKit视图的SwiftUI视图， 

53
00:02:23,419 --> 00:02:27,752
然后还有UIViewControllerRepresentable， 

54
00:02:27,752 --> 00:02:31,046
代表这些控制器之一的SwiftUI视图

55
00:02:31,046 --> 00:02:34,835
以及Controller控制的所有视图。 

56
00:02:34,835 --> 00:02:36,677
我们可以看到这些看起来一样

57
00:02:36,677 --> 00:02:38,880
但只需要同时拥有

58
00:02:38,880 --> 00:02:42,600
由于UIKit在其视图之间存在潜在的二分法

59
00:02:42,600 --> 00:02:44,731
例如Buttons和TextFields，它们是Views， 

60
00:02:44,731 --> 00:02:46,277
和他们的ViewController 

61
00:02:46,277 --> 00:02:49,074
这些是视图的分组。 

62
00:02:49,074 --> 00:02:50,538
以及涉及的主要工作

63
00:02:50,538 --> 00:02:53,576
实施这两个代表中的任何一个

64
00:02:53,576 --> 00:02:56,400
正在处理var的设置

65
00:02:56,400 --> 00:02:58,973
配置View或ViewController。 

66
00:02:58,973 --> 00:03:01,070
特别是对于ViewControllers， 

67
00:03:01,070 --> 00:03:03,431
他们经常想给您回电

68
00:03:03,431 --> 00:03:05,906
并说这发生在我的ViewController中

69
00:03:05,906 --> 00:03:08,936
以及我应该怎么做以及类似的事情。 

70
00:03:08,936 --> 00:03:12,398
我在这里说，是幻灯片上的“回调函数”， 

71
00:03:12,398 --> 00:03:15,559
但这并不是回调函数本身。 

72
00:03:15,559 --> 00:03:17,823
我现在要进一步探讨

73
00:03:17,823 --> 00:03:18,994
这样你就可以了解

74
00:03:18,994 --> 00:03:23,056
屏幕上的视图机制如何显示

75
00:03:23,056 --> 00:03:25,233
或ViewController是一回事而正在发生， 

76
00:03:25,233 --> 00:03:29,133
我们如何与之交互，可以在UIKit中使用。 

77
00:03:29,986 --> 00:03:33,147
您需要了解的主要概念

78
00:03:33,147 --> 00:03:35,451
是所谓的委托。 

79
00:03:35,451 --> 00:03:37,919
还记得UIKit是面向对象的吗？ 

80
00:03:37,919 --> 00:03:40,600
不是函数式编程，而是面向对象的。 

81
00:03:40,600 --> 00:03:41,433
所以这是非常不同的。 

82
00:03:41,433 --> 00:03:43,486
它不是声明性的，不是反应性的， 

83
00:03:43,486 --> 00:03:44,845
这些都不是。 

84
00:03:44,845 --> 00:03:49,264
它大量使用了称为委托的概念。 

85
00:03:49,264 --> 00:03:52,214
在谈论FileManager时，我们简要提到了这一点。 

86
00:03:52,214 --> 00:03:53,926
FileManager有一个委托。 

87
00:03:53,926 --> 00:03:56,981
但是这些对象，这些控制器及其视图， 

88
00:03:56,981 --> 00:04:00,945
有他们真正委托的代表

89
00:04:00,945 --> 00:04:02,549
功能。 

90
00:04:02,549 --> 00:04:05,042
Views和ViewController的某些功能， 

91
00:04:05,042 --> 00:04:08,871
他们提出允许其他一些对象来控制它。 

92
00:04:08,871 --> 00:04:11,634
现在，他们通过自己拥有一个var来做到这一点。 

93
00:04:11,634 --> 00:04:13,150
Views或ViewControllers 

94
00:04:13,150 --> 00:04:15,321
本身有一个变种，称为委托。 

95
00:04:15,321 --> 00:04:19,780
这个委托变量的类型是某种协议。 

96
00:04:19,780 --> 00:04:22,270
现在我们当然知道协议了

97
00:04:22,270 --> 00:04:24,020
作为功​​能程序员。 

98
00:04:24,020 --> 00:04:24,913
在面向对象的编程中

99
00:04:24,913 --> 00:04:26,910
协议使用不多

100
00:04:26,910 --> 00:04:28,680
协议略有不同

101
00:04:28,680 --> 00:04:31,522
协议中的方法和变量

102
00:04:31,522 --> 00:04:33,717
其中一些可以是可选的。 

103
00:04:33,717 --> 00:04:35,786
不像枚举Optional是可选的， 

104
00:04:35,786 --> 00:04:39,100
但是可选，例如您不必实现它们。 

105
00:04:39,100 --> 00:04:40,838
您会看到我们今天进行演示的时候， 

106
00:04:40,838 --> 00:04:44,286
我们将要做几个不同的委托协议

107
00:04:44,286 --> 00:04:45,560
而且我们只会实施

108
00:04:45,560 --> 00:04:47,584
每种都使用一种或两种方法

109
00:04:47,584 --> 00:04:51,526
即使可能有10或15种方法可用。 

110
00:04:51,526 --> 00:04:53,864
您可能不需要全部使用它们。 

111
00:04:53,864 --> 00:04:56,356
这个委托变量有这个对象

112
00:04:56,356 --> 00:04:58,233
这几乎可以是任何东西

113
00:04:58,233 --> 00:05:00,750
只要它实现此协议。 

114
00:05:00,750 --> 00:05:02,700
这个协议里面有很多东西

115
00:05:02,700 --> 00:05:06,071
就像我会这样做，我应该这样做

116
00:05:06,071 --> 00:05:07,546
我就是这么做的

117
00:05:07,546 --> 00:05:09,871
这类通知正在发生

118
00:05:09,871 --> 00:05:12,809
在View或ViewController和此委托之间。 

119
00:05:12,809 --> 00:05:16,478
因此，当我们在SwiftUI和UIKit之间进行集成时， 

120
00:05:16,478 --> 00:05:19,721
我们必须以某种方式提供这位代表

121
00:05:19,721 --> 00:05:22,434
这样此View或ViewController可以运行

122
00:05:22,434 --> 00:05:24,312
因为很多时候他们需要那个代表

123
00:05:24,312 --> 00:05:27,930
做任何实质的事情。 

124
00:05:27,930 --> 00:05:30,251
所以我决定在今天进行的两个演示中

125
00:05:30,251 --> 00:05:32,521
我要做一个ViewRepresentable演示

126
00:05:32,521 --> 00:05:34,552
和一个ViewControllerRepresentable。 

127
00:05:34,552 --> 00:05:36,720
他们两个都将有一名代表

128
00:05:36,720 --> 00:05:39,163
这样您就可以看到它们是如何集成的。 

129
00:05:40,672 --> 00:05:45,058
因此，让我们来谈谈这两个Representables 

130
00:05:45,058 --> 00:05:48,525
SwiftUI视图，UIViewRepresentable和

131
00:05:48,525 --> 00:05:49,685
UIViewControllerRepresentable，它们超级相似

132
00:05:49,685 --> 00:05:53,013
他们都有这五个主要组成部分。 

133
00:05:53,013 --> 00:05:56,260
第一个只是一个使

134
00:05:56,260 --> 00:05:59,727
创建基础的View或ViewController， 

135
00:05:59,727 --> 00:06:02,980
所谓的makeUIView或makeUIViewController。 

136
00:06:02,980 --> 00:06:04,303
然后您通过此上下文

137
00:06:04,303 --> 00:06:05,536
我会在稍后讨论

138
00:06:05,536 --> 00:06:08,346
然后您只返回View或ViewController 

139
00:06:08,346 --> 00:06:13,346
可以代表，基本上代表

140
00:06:13,410 --> 00:06:14,243
一些SwiftUI视图。 

141
00:06:14,243 --> 00:06:16,169
所以很明显，我们需要这样做。 

142
00:06:16,169 --> 00:06:21,084
我们需要的另一件明显的事情是获得此UIKit的东西

143
00:06:21,084 --> 00:06:26,084
参与SwiftUI的反应性吧？ 

144
00:06:26,595 --> 00:06:30,358
当绑定更改或ObservableObject更改时

145
00:06:30,358 --> 00:06:32,905
或某些内部状态变化，诸如此类， 

146
00:06:32,905 --> 00:06:36,524
我们做了一些意图，改变了我们的模型， 

147
00:06:36,524 --> 00:06:39,918
它会波及我们，并在用户界面中重新绘制， 

148
00:06:39,918 --> 00:06:41,522
我们正在重画我们的观点， 

149
00:06:41,522 --> 00:06:44,861
一直在SwiftUI中更新它们。 

150
00:06:44,861 --> 00:06:47,096
这在UIKit中实际上并不存在。 

151
00:06:47,096 --> 00:06:49,475
因此，在您的代表人中，您必须实施

152
00:06:49,475 --> 00:06:53,234
一个名为updateUIView或updateUIViewController的函数， 

153
00:06:53,234 --> 00:06:54,067
它将通过ViewController 

154
00:06:55,023 --> 00:06:56,890
用makeUIView创建的

155
00:06:56,890 --> 00:06:59,030
在这种情况下再次回到你身边

156
00:06:59,030 --> 00:07:00,180
我将在稍后讨论

157
00:07:00,180 --> 00:07:03,269
现在您更新了该UIView。 

158
00:07:03,269 --> 00:07:07,506
所以每当您的SwiftUI视图被调用时

159
00:07:07,506 --> 00:07:11,640
是更新过程的一部分，对，它正在被更新， 

160
00:07:11,640 --> 00:07:14,517
因此您必须能够更新视图。 

161
00:07:14,517 --> 00:07:15,740
您可以设置vars， 

162
00:07:15,740 --> 00:07:19,281
您可能会传递值，无论在那里， 

163
00:07:19,281 --> 00:07:20,413
你可以有绑定。 

164
00:07:20,413 --> 00:07:21,650
我的意思是UIViewRepresentable 

165
00:07:21,650 --> 00:07:23,438
和UIViewControllerRepresentable， 

166
00:07:23,438 --> 00:07:24,955
它们是SwiftUI视图， 

167
00:07:24,955 --> 00:07:26,573
当然他们可以有@Bindings 

168
00:07:26,573 --> 00:07:29,220
也许您从这些事情中获得了一些价值

169
00:07:29,220 --> 00:07:31,731
绑定回您的其他SwiftUI视图

170
00:07:31,731 --> 00:07:34,080
并在UIKit视图中进行设置。 

171
00:07:34,080 --> 00:07:36,587
这就是这里正在发生的事情。 

172
00:07:36,587 --> 00:07:39,830
现在这第三件事是一个叫做makeCoordinator的函数

173
00:07:39,830 --> 00:07:43,361
这将返回所谓的协调器。 

174
00:07:43,361 --> 00:07:45,090
现在，协调器不再需要。 

175
00:07:45,090 --> 00:07:47,127
可以是您想要的任何东西，对吗？ 

176
00:07:47,127 --> 00:07:49,337
它对此没有要求。 

177
00:07:49,337 --> 00:07:52,262
我什至不确定它是否有任何限制和收获。 

178
00:07:52,262 --> 00:07:55,454
关于这个协调员的主要事情是

179
00:07:55,454 --> 00:07:57,178
这是将要通过的东西

180
00:07:57,178 --> 00:08:00,676
通过上面的上下文返回给您。 

181
00:08:00,676 --> 00:08:02,963
好了，这就是协调员

182
00:08:02,963 --> 00:08:05,334
那将作为代表

183
00:08:05,334 --> 00:08:09,139
我们的UIView或UIViewController（如果需要）。 

184
00:08:09,139 --> 00:08:12,486
其实无非就是收藏

185
00:08:12,486 --> 00:08:16,013
委托中需要的功能

186
00:08:16,013 --> 00:08:20,060
使您的View或ViewController工作。 

187
00:08:20,060 --> 00:08:21,850
真的整个UIView 

188
00:08:21,850 --> 00:08:23,693
和UIViewControllerRepresentable系统

189
00:08:23,693 --> 00:08:25,468
甚至都不在乎这个东西是什么。 

190
00:08:25,468 --> 00:08:27,620
它只是想给你一个机会

191
00:08:27,620 --> 00:08:31,123
有一些对象是委托。 

192
00:08:32,004 --> 00:08:34,854
现在，在这种情况下，我在这里继续谈论

193
00:08:34,854 --> 00:08:37,243
传递给makeUIView和updateUIView， 

194
00:08:38,609 --> 00:08:40,196
它包含三件事。 

195
00:08:40,196 --> 00:08:42,430
一个是您创建的协调员， 

196
00:08:42,430 --> 00:08:43,977
将会成为代表的事情

197
00:08:43,977 --> 00:08:45,360
为您的View或ViewController。 

198
00:08:45,360 --> 00:08:48,345
它还包括您的SwiftUI的环境

199
00:08:48,345 --> 00:08:51,177
就像你在黑暗模式下一样。 

200
00:08:51,177 --> 00:08:53,534
它包含一个事务。 

201
00:08:53,534 --> 00:08:55,104
所以这是一个动画交易。 

202
00:08:55,104 --> 00:08:56,780
我在本季度初告诉你

203
00:08:56,780 --> 00:08:59,272
我们真的不会谈论交易， 

204
00:08:59,272 --> 00:09:01,115
但实际上是封装

205
00:09:01,115 --> 00:09:04,751
什么样的动画环境正在发生

206
00:09:04,751 --> 00:09:08,778
在makeUIView或updateUIView发生时。 

207
00:09:08,778 --> 00:09:10,410
那么这是什么背景。 

208
00:09:10,410 --> 00:09:11,524
大多数情况下， 

209
00:09:11,524 --> 00:09:13,867
你会抢环境的东西

210
00:09:13,867 --> 00:09:15,335
否则你会得到你的协调员

211
00:09:15,335 --> 00:09:17,670
这样您就可以与代表交谈

212
00:09:17,670 --> 00:09:19,977
基本上是您的View和ViewController。 

213
00:09:19,977 --> 00:09:21,200
我不想让它听起来像

214
00:09:21,200 --> 00:09:22,473
您的协调员只能是代表， 

215
00:09:22,473 --> 00:09:25,740
但这是主要的，可能是主要的

216
00:09:25,740 --> 00:09:28,055
您将使用协调器。 

217
00:09:28,055 --> 00:09:30,480
最后是拆卸阶段

218
00:09:30,480 --> 00:09:33,041
当您的SwiftUI视图消失时。 

219
00:09:33,041 --> 00:09:34,503
当然你想清理

220
00:09:34,503 --> 00:09:37,954
您的ViewController或View刚传回给您

221
00:09:37,954 --> 00:09:40,690
与您的协调员，您的代表或任何其他人一起

222
00:09:40,690 --> 00:09:43,220
因此您也可以根据需要进行清理。 

223
00:09:43,220 --> 00:09:45,517
您可以在那里做任何必要的事情。 

224
00:09:45,517 --> 00:09:46,592
而已。 

225
00:09:46,592 --> 00:09:48,128
差不多就是您做到的方式

226
00:09:48,128 --> 00:09:50,859
您会在通行证发生时进行更新， 

227
00:09:50,859 --> 00:09:52,036
你有一个小协调员， 

228
00:09:52,036 --> 00:09:53,572
你可以请你的代表

229
00:09:53,572 --> 00:09:56,903
然后您可以在完成所有操作后将其拆除。 

230
00:09:58,539 --> 00:10:01,090
我今天要做的演示，两个演示， 

231
00:10:01,090 --> 00:10:02,719
一，我们要回到途中

232
00:10:02,719 --> 00:10:04,478
在FilterFlights中

233
00:10:04,478 --> 00:10:07,990
我们现在从选择器中选择目标机场， 

234
00:10:07,990 --> 00:10:09,720
我们会做到的，所以我们可以选择

235
00:10:09,720 --> 00:10:11,708
从地图上看到那个目的地机场

236
00:10:11,708 --> 00:10:15,450
实际地图或类似Apple Maps的东西。 

237
00:10:15,450 --> 00:10:19,574
在我们的用户界面中，我们可以以这种方式选择机场。 

238
00:10:19,574 --> 00:10:24,097
从本质上讲，这将是一个UIViewRepresentable 

239
00:10:24,097 --> 00:10:25,874
因为地图，它将成为

240
00:10:25,874 --> 00:10:28,916
一个称为MKMapView的UIKit映射。 

241
00:10:28,916 --> 00:10:30,751
实际上，甚至在UIKit中也没有。 

242
00:10:30,751 --> 00:10:32,287
它在称为MapKit的东西中

243
00:10:32,287 --> 00:10:37,069
这实际上是整个UIKit生态系统的一部分。 

244
00:10:37,069 --> 00:10:39,117
然后我们要做的第二个功能

245
00:10:39,117 --> 00:10:40,626
我们要去表情符号艺术吗

246
00:10:40,626 --> 00:10:42,879
并使其成为背景图像

247
00:10:42,879 --> 00:10:45,930
而不是被拖入或复制粘贴， 

248
00:10:45,930 --> 00:10:47,799
我们将添加另一种方法来做到这一点

249
00:10:47,799 --> 00:10:49,386
你可以用相机拍照

250
00:10:49,386 --> 00:10:51,912
或者只是从照片库中取出照片

251
00:10:51,912 --> 00:10:53,840
并以此为背景。 

252
00:10:53,840 --> 00:10:58,602
现在，将使用UIViewControllerRepresentable 

253
00:10:58,602 --> 00:11:01,040
因为从相机获取图片

254
00:11:01,040 --> 00:11:03,722
涉及这些MVC之一， 

255
00:11:03,722 --> 00:11:06,401
这些控制所有视图的控制器

256
00:11:06,401 --> 00:11:09,268
从相机获取图片的用户界面中

257
00:11:09,268 --> 00:11:11,500
和照片库一样。 

258
00:11:11,500 --> 00:11:14,685
因此，这是一种稍微不同的集成方式， 

259
00:11:14,685 --> 00:11:17,467
此ViewController集成。 

260
00:11:17,467 --> 00:11:20,520
现在，我将在开始此演示之前做一个警告。 

261
00:11:20,520 --> 00:11:22,785
我可能会在演示本身中再次提及。 

262
00:11:22,785 --> 00:11:25,173
这不是一个很棒的实现

263
00:11:25,173 --> 00:11:26,743
EmojiArt中为我们提供的功能

264
00:11:26,743 --> 00:11:28,006
因为我们拍照

265
00:11:28,006 --> 00:11:30,047
从相机或照片库

266
00:11:30,047 --> 00:11:32,928
然后将其放入文件系统

267
00:11:32,928 --> 00:11:35,468
并将其作为URL存储在我们的EmojiArt中

268
00:11:35,468 --> 00:11:37,739
就像我们到目前为止所做的那样。 

269
00:11:37,739 --> 00:11:39,467
在这里，这实际上是不合适的。 

270
00:11:39,467 --> 00:11:41,770
您可能想放图片本身， 

271
00:11:41,770 --> 00:11:44,792
实际的JPEG或任何图像数据

272
00:11:44,792 --> 00:11:47,382
进入您的EmojiArt模型，对吗？ 

273
00:11:47,382 --> 00:11:49,420
存放在那里，以便您拿走

274
00:11:49,420 --> 00:11:50,473
那个表情符号文件

275
00:11:50,473 --> 00:11:51,890
然后将其移至另一台设备， 

276
00:11:51,890 --> 00:11:53,001
它实际上会工作， 

277
00:11:53,001 --> 00:11:54,861
而实际上我们有解决方案

278
00:11:54,861 --> 00:11:56,316
我们只是将其放在文件系统中

279
00:11:56,316 --> 00:11:58,700
并获取一个URL， 

280
00:11:58,700 --> 00:11:59,901
显然是指向某个东西

281
00:11:59,901 --> 00:12:04,412
在这个应用的沙盒中，那真是假。 

282
00:12:04,412 --> 00:12:06,910
但是我们并不担心

283
00:12:06,910 --> 00:12:08,502
我们不担心背景。 

284
00:12:08,502 --> 00:12:11,443
我们担心如何放置UIKit UI， 

285
00:12:12,660 --> 00:12:16,640
从摄像机获取图像的控制器

286
00:12:16,640 --> 00:12:17,473
或照片库， 

287
00:12:17,473 --> 00:12:19,780
我们如何在SwiftUI中使用它

288
00:12:19,780 --> 00:12:21,563
这样我们就可以得到图像。 

289
00:12:22,648 --> 00:12:23,674
就是这样了。 

290
00:12:23,674 --> 00:12:25,927
因此，让我们直接进入。 

291
00:12:25,927 --> 00:12:30,063
享受今年的最后一个演示。 

292
00:12:31,478 --> 00:12:34,173
这里的两个演示中的第一个将展示

293
00:12:34,173 --> 00:12:38,953
如何将UIKit视图集成到SwiftUI视图中。 

294
00:12:38,953 --> 00:12:42,230
我们要做的UIKit View是MapView。 

295
00:12:42,230 --> 00:12:46,504
实际上，它在自己的称为MapKit的小框架中， 

296
00:12:46,504 --> 00:12:49,970
但它是UIKit样式的视图。 

297
00:12:49,970 --> 00:12:53,408
我本质上想做的是在我的FilterFlights中

298
00:12:53,408 --> 00:12:55,253
我们选择目的地的地方

299
00:12:55,253 --> 00:12:57,542
起源，以及我们的航空公司等等

300
00:12:57,542 --> 00:12:58,687
去目的地

301
00:12:58,687 --> 00:12:59,579
我还是会允许你

302
00:12:59,579 --> 00:13:01,318
通过Picker选择目的地

303
00:13:01,318 --> 00:13:05,701
但我也希望您能够通过MapView进行选择

304
00:13:05,701 --> 00:13:09,570
我们通过使用UIKit MapView创建的。 

305
00:13:10,466 --> 00:13:13,579
让我们在这里将其放在自己的部分中。 

306
00:13:13,579 --> 00:13:16,483
我们将其他内容放在自己的部分中。 

307
00:13:16,483 --> 00:13:19,180
我可以轻易想象

308
00:13:19,180 --> 00:13:22,303
希望以后也将此地图用于原点。 

309
00:13:22,303 --> 00:13:23,940
我们将专注于做到这一点

310
00:13:23,940 --> 00:13:25,723
该演示的目的地。 

311
00:13:26,723 --> 00:13:30,338
那么，这里的MapView是什么？ 

312
00:13:30,338 --> 00:13:32,151
这将是其中之一

313
00:13:32,151 --> 00:13:34,489
我们讨论过的UIViewRepresentables。 

314
00:13:34,489 --> 00:13:35,930
让我们去创建它。 

315
00:13:35,930 --> 00:13:37,463
文件，新建，文件。 

316
00:13:38,542 --> 00:13:40,296
这是一个SwiftUI视图

317
00:13:40,296 --> 00:13:43,208
但由于它将是UIViewRepresentable， 

318
00:13:43,208 --> 00:13:44,727
它不会有变身， 

319
00:13:44,727 --> 00:13:49,158
UIViewRepresentable将为我们实现该功能。 

320
00:13:49,158 --> 00:13:49,991
我们去这吧

321
00:13:49,991 --> 00:13:51,650
我将其称为我的MapView。 

322
00:13:54,229 --> 00:13:56,304
当我们执行MapView时， 

323
00:13:56,304 --> 00:14:00,847
我们将不仅需要导入SwiftUI， 

324
00:14:00,847 --> 00:14:03,799
我们还必须导入UIKit 

325
00:14:03,799 --> 00:14:06,447
并导入MapKit。 

326
00:14:07,667 --> 00:14:10,573
有很多进口货要做。 

327
00:14:11,541 --> 00:14:14,562
这个结构称为MapView， 

328
00:14:14,562 --> 00:14:18,361
它是一个视图，但不仅仅是一个视图， 

329
00:14:18,361 --> 00:14:19,713
这是一个UIViewRepresentable。 

330
00:14:20,989 --> 00:14:23,976
这是一个不同的协议

331
00:14:23,976 --> 00:14:25,734
从View协议继承的

332
00:14:25,734 --> 00:14:27,605
但是里面还有很多其他的东西

333
00:14:27,605 --> 00:14:31,562
显然，这使我们可以与UIKit集成。 

334
00:14:31,562 --> 00:14:34,088
而且我们发现我们不符合

335
00:14:34,088 --> 00:14:36,290
到协议UIViewRepresentable 

336
00:14:36,290 --> 00:14:37,947
因为我们必须放置这些功能

337
00:14:37,947 --> 00:14:40,960
我在幻灯片中向您展示

338
00:14:40,960 --> 00:14:45,960
像func makeUIView给定的上下文

339
00:14:47,319 --> 00:14:51,338
返回我们要执行的UIKit视图。 

340
00:14:51,338 --> 00:14:52,393
我们在这里做什么？ 

341
00:14:52,393 --> 00:14:54,203
我们正在做MKMapView。 

342
00:14:55,144 --> 00:14:59,036
这是我们要构建的UIKit视图。 

343
00:14:59,036 --> 00:15:01,162
事实上，我要在这里建造它。 

344
00:15:01,162 --> 00:15:03,863
好的，该视图等于MKMapView。 

345
00:15:05,508 --> 00:15:07,508
然后我要返回mkMapView。 

346
00:15:09,407 --> 00:15:11,834
我将做更多的工作来在一秒钟内创建它。 

347
00:15:11,834 --> 00:15:15,647
而且我们还有那个func updateUIView 

348
00:15:15,647 --> 00:15:18,663
这给了我们UIView 

349
00:15:18,663 --> 00:15:23,663
这个MKMapView以及那个上下文。 

350
00:15:24,030 --> 00:15:26,970
在这里，我们可以做我们需要做的一切

351
00:15:26,970 --> 00:15:28,824
使此MapView保持最新

352
00:15:28,824 --> 00:15:30,960
当我们的SwiftUI通过

353
00:15:30,960 --> 00:15:35,073
其正常的反应式重绘机制。 

354
00:15:35,073 --> 00:15:38,842
然后我们有了这个func makeCoordinator 

355
00:15:38,842 --> 00:15:41,873
会返回无关紧要的东西

356
00:15:41,873 --> 00:15:45,167
我将其称为协调器，就在这里。 

357
00:15:45,167 --> 00:15:47,301
我要讲一点嵌套课程

358
00:15:47,301 --> 00:15:51,089
在我的结构中称为协调器。 

359
00:15:51,089 --> 00:15:54,415
这将是我的MapView的代表。 

360
00:15:54,415 --> 00:15:56,750
这个MapView有其中之一

361
00:15:56,750 --> 00:15:57,958
我们在谈论，一位代表。 

362
00:15:57,958 --> 00:16:01,660
因此，要成为代表，还必须是NSObject， 

363
00:16:01,660 --> 00:16:06,660
并且必须实现MKMapViewDelegate协议。 

364
00:16:07,631 --> 00:16:12,350
UIKit中的所有委托始终是类

365
00:16:12,350 --> 00:16:15,276
从此基类NSObject继承的对象。 

366
00:16:15,276 --> 00:16:17,514
所以我要在这里做同样的事情

367
00:16:17,514 --> 00:16:19,775
在我们的SwiftUI兼容性中

368
00:16:19,775 --> 00:16:22,890
就像在普通的UIKit中一样

369
00:16:22,890 --> 00:16:25,544
制作从NSObject继承的委托

370
00:16:25,544 --> 00:16:26,755
并实现这些方法。 

371
00:16:26,755 --> 00:16:30,299
现在发现这里不需要任何方法， 

372
00:16:30,299 --> 00:16:32,730
但我们实际上需要

373
00:16:32,730 --> 00:16:34,139
他们中的几个使这项工作， 

374
00:16:34,139 --> 00:16:36,530
但这就是为什么我在这里没有任何抱怨

375
00:16:36,530 --> 00:16:38,927
该协议未实现或类似的东西

376
00:16:38,927 --> 00:16:41,505
因为它有10或12种方法

377
00:16:41,505 --> 00:16:43,654
所有这些都不是必需的。 

378
00:16:43,654 --> 00:16:45,490
那么我们该如何安排我们的协调员？ 

379
00:16:45,490 --> 00:16:46,813
我只是从字面上说

380
00:16:46,813 --> 00:16:48,501
让我成为这些协调员之一

381
00:16:48,501 --> 00:16:50,830
我刚刚在这里定义的。 

382
00:16:50,830 --> 00:16:51,663
这只是一堂课。 

383
00:16:51,663 --> 00:16:55,030
我正在上一堂课，然后在这里归还。 

384
00:16:55,030 --> 00:16:59,229
您不必说退货，但这就是我在做的事情。 

385
00:16:59,229 --> 00:17:01,652
这是基本结构

386
00:17:01,652 --> 00:17:05,523
UIViewRepresentable的图片。 

387
00:17:05,523 --> 00:17:08,616
唯一的事情是我们想联系我们的协调员

388
00:17:08,616 --> 00:17:11,346
这是我们MapView的委托。 

389
00:17:11,346 --> 00:17:14,231
我们要在这里说mkMapView， 

390
00:17:14,231 --> 00:17:17,387
您的代表是我们的协调员。 

391
00:17:17,387 --> 00:17:19,883
我们使协调员脱离了上下文。 

392
00:17:19,883 --> 00:17:22,060
这不是我们创建协调器的地方。 

393
00:17:22,060 --> 00:17:24,520
它是在此内部创建的。 

394
00:17:24,520 --> 00:17:29,043
因此，如果需要，我们只说context.coordinator。 

395
00:17:31,482 --> 00:17:32,660
让我们回到我们的FilterFlights。 

396
00:17:32,660 --> 00:17:37,101
如果我们实际进行构建，则此操作成功。 

397
00:17:37,101 --> 00:17:40,720
之所以能够构建，是因为我们做了一个叫做MapView的东西。 

398
00:17:40,720 --> 00:17:45,557
这是一个正常的SwiftUI视图，称为MapView。 

399
00:17:45,557 --> 00:17:46,853
如果我们跑步， 

400
00:17:48,294 --> 00:17:50,602
去我们的过滤器， 

401
00:17:50,602 --> 00:17:51,489
在那里

402
00:17:51,489 --> 00:17:53,100
那里有我们的地图。 

403
00:17:53,100 --> 00:17:54,680
你看不到什么。 

404
00:17:54,680 --> 00:17:55,681
它仍然太小。 

405
00:17:55,681 --> 00:17:58,378
那么，为什么不做更大的事情呢？ 

406
00:17:58,378 --> 00:18:01,720
也许有，我的意思是至少

407
00:18:01,720 --> 00:18:04,095
也许高三点或四百点。 

408
00:18:04,095 --> 00:18:06,058
宽度还可以，但是您要确保

409
00:18:06,058 --> 00:18:08,001
至少高三或四百点

410
00:18:08,001 --> 00:18:10,937
所以我要去这里说.frame（minHeight：400）。 

411
00:18:13,930 --> 00:18:16,373
让我们看看它是什么样的。 

412
00:18:17,665 --> 00:18:18,746
转到过滤器。 

413
00:18:18,746 --> 00:18:19,851
哇！ 

414
00:18:19,851 --> 00:18:22,260
当您看到它时看起来好多了。 

415
00:18:22,260 --> 00:18:23,565
还有我们的地图。 

416
00:18:23,565 --> 00:18:25,835
现在当然这些机场都没有

417
00:18:25,835 --> 00:18:28,365
我们在这里出现在地图上， 

418
00:18:28,365 --> 00:18:30,697
没有任何标记或任何东西。 

419
00:18:30,697 --> 00:18:34,677
那是因为我们什么也没做就把它们放在那里。 

420
00:18:34,677 --> 00:18:37,333
因此，让我们学习一下有关MapKit的知识。 

421
00:18:37,333 --> 00:18:41,003
一个人如何在这里标记

422
00:18:41,003 --> 00:18:42,590
代表这些机场？ 

423
00:18:42,590 --> 00:18:45,287
好吧，MapKit实际上非常灵活

424
00:18:45,287 --> 00:18:47,020
它使用协议。 

425
00:18:47,020 --> 00:18:49,433
它有一个称为MKAnnotation的协议。 

426
00:18:50,320 --> 00:18:54,014
以及任何实现MKAnnotation的对象

427
00:18:54,014 --> 00:18:55,616
可以放在地图上

428
00:18:55,616 --> 00:18:58,731
所以您要做的就是在地图上放置一个物体

429
00:18:58,731 --> 00:19:01,990
为该对象实现MKAnnotation。 

430
00:19:01,990 --> 00:19:05,506
那么，我们在这里想要在地图上显示哪种对象？ 

431
00:19:05,506 --> 00:19:08,015
好吧，我们要机场。 

432
00:19:08,015 --> 00:19:09,261
这是我们的机场。 

433
00:19:09,261 --> 00:19:11,852
这是我们负责机场的核心数据对象。 

434
00:19:11,852 --> 00:19:15,916
我只是要添加一个扩展名

435
00:19:15,916 --> 00:19:19,931
实施此MKAnnotation协议。 

436
00:19:19,931 --> 00:19:22,178
我们需要在这里导入MapKit 

437
00:19:22,178 --> 00:19:26,070
因为MKAnnotation在MapKit内部。 

438
00:19:26,070 --> 00:19:30,451
现在，此MKAnnotation协议需要什么？ 

439
00:19:30,451 --> 00:19:33,070
让我们继续，甚至在这里使用“修复”。 

440
00:19:33,070 --> 00:19:35,313
我们可以看到类型的机场不确认。 

441
00:19:35,313 --> 00:19:37,396
但是我们可以添加协议存根

442
00:19:37,396 --> 00:19:40,779
这将在此处添加所需的方法“修复”。 

443
00:19:40,779 --> 00:19:41,830
在那里。 

444
00:19:41,830 --> 00:19:42,708
只是这个变种。 

445
00:19:42,708 --> 00:19:44,562
如果您仅实现一个变体， 

446
00:19:44,562 --> 00:19:48,101
那么您也可以成为MKA注释。 

447
00:19:48,101 --> 00:19:50,777
什么是var坐标？ 

448
00:19:50,777 --> 00:19:51,900
它是什么类型？ 

449
00:19:51,900 --> 00:19:52,754
回来什么？ 

450
00:19:52,754 --> 00:19:55,240
这是CLLocationCoordinate2D。 

451
00:19:55,240 --> 00:19:58,056
这是经度和纬度。 

452
00:19:58,056 --> 00:20:03,056
幸运的是，机场，我们在这里查看数据模型。 

453
00:20:03,360 --> 00:20:05,827
让我们在这里做版本。 

454
00:20:05,827 --> 00:20:08,200
您可以看到我们有一个经度和纬度

455
00:20:08,200 --> 00:20:09,970
是从FlightAware获得的。 

456
00:20:09,970 --> 00:20:13,750
因此，我们绝对准备在这里成为其中之一。 

457
00:20:13,750 --> 00:20:17,060
我将返回，创建一个CLLocationCoordinate2D 

458
00:20:19,536 --> 00:20:22,676
从我们的纬度出发

459
00:20:22,676 --> 00:20:25,047
这只是数据库中的一个变量， 

460
00:20:25,047 --> 00:20:28,477
和经度，这是我们的另一个变量。 

461
00:20:28,477 --> 00:20:29,433
而已。 

462
00:20:29,433 --> 00:20:33,055
看，它编译并允许我们成为MKA注释。 

463
00:20:33,055 --> 00:20:34,455
现在是MKA注释

464
00:20:34,455 --> 00:20:39,455
再次是协议的Objective-C版本。 

465
00:20:39,571 --> 00:20:41,323
这是唯一需要的变量

466
00:20:41,323 --> 00:20:44,081
但是我要在这里扔几个其他变量。 

467
00:20:44,081 --> 00:20:47,034
这些变量之一称为title。 

468
00:20:47,034 --> 00:20:49,030
这是一个可选的字符串。 

469
00:20:49,030 --> 00:20:50,106
这是

470
00:20:50,106 --> 00:20:51,861
如果您点击地图上的某物， 

471
00:20:51,861 --> 00:20:53,740
它会告诉你这个标题。 

472
00:20:53,740 --> 00:20:55,891
所以我要以这个名字为机场。 

473
00:20:55,891 --> 00:20:59,646
如果没有设置，我们将使用KSFO或其他方法。 

474
00:20:59,646 --> 00:21:02,012
然后它还有另一个叫做字幕

475
00:21:02,012 --> 00:21:03,729
它也会在标注中显示

476
00:21:03,729 --> 00:21:05,709
如果您单击某些东西，就会出现。 

477
00:21:05,709 --> 00:21:06,853
然后我们将位置

478
00:21:06,853 --> 00:21:09,913
例如加利福尼亚州的圣何塞或那里的任何地方。 

479
00:21:10,920 --> 00:21:13,380
所以机场现在是MKA注释， 

480
00:21:13,380 --> 00:21:17,870
这意味着它们可以放在地图上的任何地方。 

481
00:21:17,870 --> 00:21:20,533
如果我们在此地图上放置机场， 

482
00:21:20,533 --> 00:21:23,317
它会有某种形式的代表。 

483
00:21:23,317 --> 00:21:26,763
我还要告诉你如何做到这一点。 

484
00:21:28,351 --> 00:21:31,505
我们需要在这里拥有MapView 

485
00:21:31,505 --> 00:21:34,478
有一些您可以传递给它的变量。 

486
00:21:34,478 --> 00:21:39,168
我要让它成为批注。 

487
00:21:39,168 --> 00:21:42,500
这只是这些MKAnnotation事物的数组。 

488
00:21:42,500 --> 00:21:43,644
所以这可能是机场

489
00:21:43,644 --> 00:21:46,352
其他实现MKAnnotation的东西。 

490
00:21:46,352 --> 00:21:48,178
当我们发表观点时， 

491
00:21:48,178 --> 00:21:50,482
除了在这里设置代表之外， 

492
00:21:50,482 --> 00:21:55,423
我将这些注释添加到地图中。 

493
00:21:57,425 --> 00:21:58,390
而已。 

494
00:21:58,390 --> 00:22:01,200
我们要做的就是使它们出现在地图上。 

495
00:22:01,200 --> 00:22:03,077
现在唯一的问题是地图

496
00:22:03,077 --> 00:22:04,982
它不知道如何绘制它们。 

497
00:22:04,982 --> 00:22:07,559
不知道你在画图钉吗

498
00:22:07,559 --> 00:22:10,369
或某种标记或自定义视图

499
00:22:10,369 --> 00:22:12,414
或您正在画它吗？ 

500
00:22:12,414 --> 00:22:15,430
以及这些注释如何在地图上绘制

501
00:22:15,430 --> 00:22:17,428
实际上是由该代表控制的。 

502
00:22:17,428 --> 00:22:19,542
所以我们将要看到我们的第一个

503
00:22:19,542 --> 00:22:21,150
UIKit中的委托方法。 

504
00:22:21,150 --> 00:22:23,930
我们想要的一个叫做

505
00:22:23,930 --> 00:22:26,145
mapView ViewFor批注。 

506
00:22:26,145 --> 00:22:27,003
让我们看看是否可以找到它。 

507
00:22:27,003 --> 00:22:28,106
看所有这些。 

508
00:22:28,106 --> 00:22:31,170
这些都是MapView委托函数， 

509
00:22:31,170 --> 00:22:33,259
didSelect东西，didDeselect， 

510
00:22:33,259 --> 00:22:35,875
我们在地图上显示的区域发生了变化。 

511
00:22:35,875 --> 00:22:39,679
我正在寻找的是ViewFor批注。 

512
00:22:39,679 --> 00:22:41,079
就在这里

513
00:22:41,079 --> 00:22:42,622
而这只是回来

514
00:22:42,622 --> 00:22:44,424
称为MKAnnotationView的东西

515
00:22:44,424 --> 00:22:48,264
这是一个显示注解的UIKit视图。 

516
00:22:48,264 --> 00:22:51,057
它所做的就是找到正确的

517
00:22:51,057 --> 00:22:52,627
对于给定的注释， 

518
00:22:52,627 --> 00:22:54,189
在我们的例子中是机场

519
00:22:54,189 --> 00:22:56,870
因此只需为机场创建一个视图。 

520
00:22:56,870 --> 00:22:59,942
现在我们不在这里学习MapKit 

521
00:22:59,942 --> 00:23:01,570
所以我要告诉你

522
00:23:01,570 --> 00:23:04,912
如何创建这个小视图。 

523
00:23:04,912 --> 00:23:06,570
我要用别针。 

524
00:23:06,570 --> 00:23:07,961
我也可以做标记

525
00:23:07,961 --> 00:23:10,436
这是地图的一种新外观。 

526
00:23:10,436 --> 00:23:15,317
您要求mapView出列ReusableAnnotationView 

527
00:23:15,317 --> 00:23:17,141
与标识符， 

528
00:23:17,141 --> 00:23:18,950
我们可以在这里使用我们想要的任何标识符， 

529
00:23:18,950 --> 00:23:21,513
我要叫我“ MapViewAnnotation”。 

530
00:23:22,922 --> 00:23:25,754
如果返回的结果为零，我将无法重用。 

531
00:23:25,754 --> 00:23:29,203
这正在重复使用这些引脚之一或其他引脚。 

532
00:23:29,203 --> 00:23:31,773
现在，我将创建自己的MKPinAnnotationView。 

533
00:23:33,450 --> 00:23:34,700
那是一个看起来像别针的东西。 

534
00:23:34,700 --> 00:23:38,370
它需要像我们的机场之类的注释

535
00:23:38,370 --> 00:23:41,550
而且它也想要再次使用Identifier 

536
00:23:41,550 --> 00:23:42,533
这里也是一样。 

537
00:23:42,533 --> 00:23:44,182
我可能应该为此创建一个常量

538
00:23:44,182 --> 00:23:46,759
但我将在此处快速输入。 

539
00:23:46,759 --> 00:23:50,708
这就是创建一个小的PinAnnotationView。 

540
00:23:50,708 --> 00:23:53,180
较新的一个称为MarkerAnnotationView。 

541
00:23:53,180 --> 00:23:55,022
我们可以用它，但我要用别针。 

542
00:23:55,022 --> 00:23:56,918
我有点喜欢图钉上的标注。 

543
00:23:56,918 --> 00:23:58,980
说到这我也要打电话

544
00:23:58,980 --> 00:24:01,758
该视图上的某个东西叫做canShowCallout， 

545
00:24:01,758 --> 00:24:03,440
将其设置为真实。 

546
00:24:03,440 --> 00:24:05,240
我将返回此视图。 

547
00:24:05,240 --> 00:24:08,734
这就是MapView知道什么View的方式

548
00:24:08,734 --> 00:24:12,833
我应该用来绘制某些注释吗？ 

549
00:24:14,377 --> 00:24:16,578
现在我们当然要做的最后一件事是

550
00:24:16,578 --> 00:24:18,148
当我们创建MapView时， 

551
00:24:18,148 --> 00:24:21,967
我们需要传递想要的注释， 

552
00:24:21,967 --> 00:24:26,200
这必须是MKA注释数组。 

553
00:24:26,200 --> 00:24:28,226
嗯，机场是MKA注释， 

554
00:24:28,226 --> 00:24:31,326
所以这可能是一些机场，对吗？ 

555
00:24:31,326 --> 00:24:35,523
因此，让我们来进行airport.sorted。 

556
00:24:35,523 --> 00:24:39,515
机场是我们要拿走的所有东西。 

557
00:24:39,515 --> 00:24:41,100
在这里，我们得到了一个FetchedResults。 

558
00:24:41,100 --> 00:24:44,509
我只是将这些FetchedResults进行排序

559
00:24:44,509 --> 00:24:46,492
这样我们就可以对注释进行排序。 

560
00:24:46,492 --> 00:24:47,714
真的没关系。 

561
00:24:47,714 --> 00:24:50,240
我也可以说Array（airports）。 

562
00:24:50,240 --> 00:24:52,866
我这样做是因为这需要一个数组， 

563
00:24:52,866 --> 00:24:55,230
机场是FetchedResult， 

564
00:24:55,230 --> 00:24:58,347
同样，这是一个集合，但不是一个数组。 

565
00:24:58,347 --> 00:25:01,350
因此，仅对它们进行排序就会将它们变成数组。 

566
00:25:01,350 --> 00:25:05,434
我也可以说Array（airports）。 

567
00:25:05,434 --> 00:25:08,653
因此，让我们看看这是否有效。 

568
00:25:08,653 --> 00:25:11,984
希望现在当我们进入过滤器时，哇！ 

569
00:25:11,984 --> 00:25:15,343
我现在在这里看到所有这些机场。 

570
00:25:15,343 --> 00:25:17,095
您可以在海外看到它们。 

571
00:25:17,095 --> 00:25:18,340
他们真的很酷， 

572
00:25:18,340 --> 00:25:20,443
如果您点击这些针脚， 

573
00:25:20,443 --> 00:25:23,646
它向您显示了我们设置的标题和子标题。 

574
00:25:23,646 --> 00:25:25,590
标题和副标题。 

575
00:25:25,590 --> 00:25:27,434
标题和副标题。 

576
00:25:27,434 --> 00:25:31,150
那里已经有了很大的进步。 

577
00:25:31,150 --> 00:25:35,540
唯一的一件事情是当我选择波士顿时

578
00:25:35,540 --> 00:25:38,471
我希望这可以放大波士顿。 

579
00:25:38,471 --> 00:25:43,044
而且如果我要点击德克萨斯州的休斯顿， 

580
00:25:43,044 --> 00:25:45,294
我希望将此更改为休斯顿。 

581
00:25:45,294 --> 00:25:47,267
所以我们要做一些工作

582
00:25:47,267 --> 00:25:49,723
在这里把这个选择挂钩

583
00:25:49,723 --> 00:25:52,586
到所选内容并放大

584
00:25:52,586 --> 00:25:54,737
在这里的地图上

585
00:25:54,737 --> 00:25:56,528
因此，让我们开始进行放大。 

586
00:25:56,528 --> 00:25:59,498
我要如何放大此处选择的内容？ 

587
00:25:59,498 --> 00:26:02,655
实际上，这很简单。 

588
00:26:02,655 --> 00:26:07,655
请记住，每次我们的SwiftUI更新通过时， 

589
00:26:07,741 --> 00:26:09,885
我们有机会更新此视图。 

590
00:26:09,885 --> 00:26:13,484
所以我要在这里放一个小变种

591
00:26:13,484 --> 00:26:14,810
这将是一个MKA注释。 

592
00:26:14,810 --> 00:26:16,516
我将其设为可选

593
00:26:16,516 --> 00:26:19,172
因为您无需选择注释。 

594
00:26:19,172 --> 00:26:21,838
但是，如果您这样做，那么当我进行更新时， 

595
00:26:21,838 --> 00:26:26,838
每次绘画时，我都会放大以显示此选择。 

596
00:26:27,112 --> 00:26:31,660
在这里说，如果我可以让注释等于选择， 

597
00:26:31,660 --> 00:26:33,727
所以你选择了一个

598
00:26:33,727 --> 00:26:35,245
那我去做这件事

599
00:26:35,245 --> 00:26:39,386
在MapView中称为setRegion。 

600
00:26:39,386 --> 00:26:41,923
并且setRegion采用MKCoordinateRegion。 

601
00:26:44,332 --> 00:26:46,784
MKCoordinateRegion以中心

602
00:26:46,784 --> 00:26:50,504
注释的坐标是哪个，对不对？ 

603
00:26:50,504 --> 00:26:52,880
这就是我们在这里实现的东西

604
00:26:52,880 --> 00:26:55,453
机场到CLLocationCoordinate2D。 

605
00:26:55,453 --> 00:26:58,594
就是说这个注释在哪里？ 

606
00:26:58,594 --> 00:27:01,134
那就是那里的选择。 

607
00:27:01,134 --> 00:27:03,645
而且还需要跨度

608
00:27:03,645 --> 00:27:06,240
而这个跨度是我们要创建的对象。 

609
00:27:06,240 --> 00:27:09,585
这实际上是放大多少。 

610
00:27:09,585 --> 00:27:13,647
我们也可以说是的，我们也希望它具有动画效果。 

611
00:27:13,647 --> 00:27:15,439
那么这个跨度是多少？ 

612
00:27:15,439 --> 00:27:17,630
当我放大某些东西时， 

613
00:27:17,630 --> 00:27:20,780
我希望它像一个城镇大小的视图。 

614
00:27:20,780 --> 00:27:23,990
所以我要称这个跨度城镇。 

615
00:27:23,990 --> 00:27:26,306
这将是大约一个城镇的跨度。 

616
00:27:26,306 --> 00:27:29,514
那么，大约一个城镇的跨度是多少？ 

617
00:27:29,514 --> 00:27:31,060
好吧，这是MKCoordinateSpan 

618
00:27:32,727 --> 00:27:35,500
只是指定了latitudeDelta， 

619
00:27:35,500 --> 00:27:37,278
我们要做.1度， 

620
00:27:37,278 --> 00:27:39,507
经度.1。 

621
00:27:39,507 --> 00:27:41,966
所以.1的经度和纬度

622
00:27:41,966 --> 00:27:44,317
大约是一个城镇的大小。 

623
00:27:44,317 --> 00:27:46,199
比城市小一点

624
00:27:46,199 --> 00:27:48,656
但它比一个小邻居更大。 

625
00:27:48,656 --> 00:27:50,800
这是一个不错的尺寸，可以放大

626
00:27:50,800 --> 00:27:54,828
如果您要放大某些注释。 

627
00:27:54,828 --> 00:27:56,910
每次都会发生

628
00:27:56,910 --> 00:28:00,665
该MapView在SwiftUI中得到更新， 

629
00:28:00,665 --> 00:28:03,438
反应式用户界面更新阶段。 

630
00:28:03,438 --> 00:28:07,122
我们将重新缩放以显示我们的选择。 

631
00:28:07,122 --> 00:28:09,137
因此，让我们在这里进行设置。 

632
00:28:09,137 --> 00:28:10,826
这是我们创建MapView的地方。 

633
00:28:10,826 --> 00:28:13,240
我们将添加这个额外的参数，即选择。 

634
00:28:13,240 --> 00:28:14,738
选什么呢？ 

635
00:28:14,738 --> 00:28:18,169
好吧，这只是我们草稿的目的地，对吧？ 

636
00:28:18,169 --> 00:28:20,371
该草案是我们的FlightSearch。 

637
00:28:20,371 --> 00:28:22,918
这就是我们要过滤的内容。 

638
00:28:22,918 --> 00:28:26,173
目的地是草稿中的目的地机场。 

639
00:28:26,173 --> 00:28:27,006
完全一样

640
00:28:27,006 --> 00:28:30,120
我们在这里将其显示为Pickers。 

641
00:28:30,120 --> 00:28:31,823
让我们来看看。 

642
00:28:34,790 --> 00:28:35,821
点击过滤器。 

643
00:28:35,821 --> 00:28:37,186
希望是的！ 

644
00:28:37,186 --> 00:28:38,176
旧金山。 

645
00:28:38,176 --> 00:28:40,410
这是旧金山国际。 

646
00:28:40,410 --> 00:28:41,260
让我们选择其他东西。 

647
00:28:41,260 --> 00:28:42,401
波士顿呢？ 

648
00:28:42,401 --> 00:28:44,957
糟糕，放大一下，那里是波士顿。 

649
00:28:44,957 --> 00:28:47,197
也许选择伯班克的鲍勃·霍普（Bob Hope）。 

650
00:28:47,197 --> 00:28:49,177
回到鲍勃·霍普，就在那里。 

651
00:28:49,177 --> 00:28:51,679
现在我们仍然可以在此处缩小

652
00:28:51,679 --> 00:28:53,625
并选择其他机场。 

653
00:28:53,625 --> 00:28:55,690
问题是，当我们选择它们时， 

654
00:28:55,690 --> 00:28:57,643
这里没有更新。 

655
00:28:57,643 --> 00:28:59,001
当我选择它时，这很好。 

656
00:28:59,001 --> 00:29:00,844
告诉我是圣地亚哥国际机场。 

657
00:29:00,844 --> 00:29:02,175
但是当我在这里挑选时

658
00:29:02,175 --> 00:29:06,688
我的意思是选择这个，去那个地方。 

659
00:29:06,688 --> 00:29:09,730
现在，我们如何才能做到这一点呢？ 

660
00:29:09,730 --> 00:29:13,365
当我们选择波士顿时，这很好用。 

661
00:29:13,365 --> 00:29:16,162
它进入此处并设置地图。 

662
00:29:16,162 --> 00:29:18,246
但是我们如何使之工作

663
00:29:18,246 --> 00:29:22,421
当我们在纽瓦克或任何其他地方单击此处时， 

664
00:29:22,421 --> 00:29:24,002
康涅狄格机场， 

665
00:29:24,002 --> 00:29:27,494
这就是我们的目的地吗？ 

666
00:29:27,494 --> 00:29:30,871
好吧，我们一般如何在Views中做到这一点，对吧？ 

667
00:29:30,871 --> 00:29:33,127
如果我们有一个View并可以与其交互

668
00:29:33,127 --> 00:29:35,319
它想传达信息

669
00:29:35,319 --> 00:29:37,094
回到其他视图， 

670
00:29:37,094 --> 00:29:38,242
我们做什么？ 

671
00:29:38,242 --> 00:29:40,630
我们使用绑定。 

672
00:29:40,630 --> 00:29:44,232
而且这个MapView即使是UIViewRepresentable， 

673
00:29:44,232 --> 00:29:48,140
这是一个View，因此我们可以将其作为Binding。 

674
00:29:48,140 --> 00:29:50,913
现在这是对选择的绑定。 

675
00:29:52,052 --> 00:29:54,840
现在我们将在这里继续前进

676
00:29:54,840 --> 00:29:57,512
并更新我们的选择等等。 

677
00:29:57,512 --> 00:30:00,162
但是首先有一点问题是

678
00:30:00,162 --> 00:30:04,333
在这里，我们正在通过我们的机场选择。 

679
00:30:04,333 --> 00:30:08,532
所以这不是对MKA注释的绑定，对吗？ 

680
00:30:08,532 --> 00:30:11,353
这就是说，绑定到MKAnnotation。 

681
00:30:11,353 --> 00:30:14,178
这是机场。 

682
00:30:14,178 --> 00:30:16,155
那么我们该怎么做呢？ 

683
00:30:16,155 --> 00:30:19,531
我们可以在那里做美元符号吗？ 

684
00:30:19,531 --> 00:30:23,677
不，我们不能，因为草稿是@State。 

685
00:30:23,677 --> 00:30:27,357
如果草稿是ObservedObject，我们可以这样做。 

686
00:30:27,357 --> 00:30:29,519
如果这是一个ObservedObject，这将起作用。 

687
00:30:29,519 --> 00:30:32,027
但是草案不是，草案是国家。 

688
00:30:32,027 --> 00:30:35,150
以及具有约束力的国家的美元符号

689
00:30:35,150 --> 00:30:37,055
绑定到整个结构。 

690
00:30:37,055 --> 00:30:40,834
您不能将其绑定到结构内部的变量。 

691
00:30:40,834 --> 00:30:44,833
那么我们该如何通过绑定

692
00:30:44,833 --> 00:30:48,634
到这个州内的这个机场？ 

693
00:30:48,634 --> 00:30:52,600
好吧，让我们创建一个称为目标的变量。 

694
00:30:52,600 --> 00:30:56,673
这将是绑定到MKAnnotation的类型。 

695
00:30:58,665 --> 00:31:01,102
现在，我在这里开始使用MKAnnotation 

696
00:31:01,102 --> 00:31:03,790
最好在这里说import MapKit 

697
00:31:03,790 --> 00:31:08,790
否则编译器不会知道我们在做什么。 

698
00:31:08,888 --> 00:31:09,920
这就是目标Binding。 

699
00:31:09,920 --> 00:31:13,867
我们如何在这里使用此绑定？ 

700
00:31:13,867 --> 00:31:17,056
只需说通过目的地即可。 

701
00:31:17,056 --> 00:31:21,583
而当我编译时，它将在这里工作。 

702
00:31:21,583 --> 00:31:25,546
看，我们不再拥有这个东西

703
00:31:25,546 --> 00:31:27,904
无法推断或此处有任何错误的地方

704
00:31:27,904 --> 00:31:31,362
因为我正在传递对MKA注释的绑定

705
00:31:31,362 --> 00:31:34,093
这正是这个东西想要的， 

706
00:31:34,093 --> 00:31:36,192
与MKA注释的绑定。 

707
00:31:36,192 --> 00:31:37,472
我们要做的只是

708
00:31:37,472 --> 00:31:40,009
找出并实现此变量。 

709
00:31:40,009 --> 00:31:45,009
我们如何在这里返回对MKAnnotation的绑定？ 

710
00:31:45,470 --> 00:31:48,491
我们需要以某种方式进行MKA注释

711
00:31:48,491 --> 00:31:51,414
连接到该草稿的目的地。 

712
00:31:51,414 --> 00:31:52,960
我们该怎么做？ 

713
00:31:52,960 --> 00:31:56,246
好吧，我们将只使用Binding的构造函数之一。 

714
00:31:56,246 --> 00:31:57,573
您可以看到这里有一些。 

715
00:31:57,573 --> 00:31:59,115
我要用这个。 

716
00:31:59,115 --> 00:32:02,904
这几乎是一种原始的绑定

717
00:32:02,904 --> 00:32:05,185
它只允许您指定一个闭包

718
00:32:05,185 --> 00:32:06,977
获得绑定的值

719
00:32:06,977 --> 00:32:10,216
和一个用于设置Binding值的闭包

720
00:32:10,216 --> 00:32:12,131
这真的很重要

721
00:32:12,131 --> 00:32:13,681
绑定是如何工作的，对不对？ 

722
00:32:13,681 --> 00:32:15,612
绑定只是获取和设置

723
00:32:15,612 --> 00:32:17,702
其他一些其他值。 

724
00:32:17,702 --> 00:32:20,059
因此，完全有意义的是有一个绑定版本

725
00:32:20,059 --> 00:32:23,675
这只是要获得的闭包和设置的闭包。 

726
00:32:23,675 --> 00:32:27,175
现在我们要做的就是实现这些以获取并设置

727
00:32:27,175 --> 00:32:30,756
目的地价值在我们的国家草案中。 

728
00:32:30,756 --> 00:32:32,439
不可能简单，所以让我们

729
00:32:32,439 --> 00:32:33,680
快去做

730
00:32:33,680 --> 00:32:35,159
看起来更容易一点

731
00:32:35,159 --> 00:32:37,700
在执行此操作之前发生了什么。 

732
00:32:37,700 --> 00:32:39,703
让我们先做吧。 

733
00:32:39,703 --> 00:32:42,843
得到的是说这是没有争议的

734
00:32:42,843 --> 00:32:45,246
并返回一个MKAnnotation。 

735
00:32:45,246 --> 00:32:47,946
当然，因为这是对MKA注释的绑定

736
00:32:48,980 --> 00:32:50,530
因此我们将无法到达那里。 

737
00:32:50,530 --> 00:32:51,448
因此，让我们这样做。 

738
00:32:51,448 --> 00:32:52,724
这里很简单。 

739
00:32:52,724 --> 00:32:56,820
我们将返回草稿的目的地。 

740
00:32:56,820 --> 00:32:58,680
现在是机场

741
00:32:58,680 --> 00:33:01,871
机场绝对是一个MKA注释， 

742
00:33:01,871 --> 00:33:04,313
所以这是完全合法的。 

743
00:33:04,313 --> 00:33:05,800
我也要把自己放在这里。 

744
00:33:05,800 --> 00:33:09,325
您可以返回此值。 

745
00:33:09,325 --> 00:33:11,052
那很简单。 

746
00:33:11,052 --> 00:33:12,486
那方面呢？ 

747
00:33:12,486 --> 00:33:15,575
该集合是一个带有MKA注释的闭包， 

748
00:33:15,575 --> 00:33:17,110
可选的MKAnnotation。 

749
00:33:17,110 --> 00:33:18,439
它不返回任何东西。 

750
00:33:18,439 --> 00:33:20,695
它只是设置值。 

751
00:33:20,695 --> 00:33:23,596
让我们有它需要的注释

752
00:33:23,596 --> 00:33:25,781
就在这里。 

753
00:33:25,781 --> 00:33:27,754
我们想说些类似的话

754
00:33:27,754 --> 00:33:32,277
self.draft.destination等于该注释。 

755
00:33:32,277 --> 00:33:33,390
呜呜，我们完成了！ 

756
00:33:33,390 --> 00:33:35,885
我们只会做相反的事情。 

757
00:33:35,885 --> 00:33:37,937
但这是行不通的。 

758
00:33:37,937 --> 00:33:38,855
而且这不起作用的原因

759
00:33:38,855 --> 00:33:42,576
是这个的类型是MKAnnotation， 

760
00:33:42,576 --> 00:33:43,887
可选的MKA注释。 

761
00:33:43,887 --> 00:33:45,850
这就是它的类型。 

762
00:33:45,850 --> 00:33:48,786
所以在这里我们试图建立一个机场

763
00:33:48,786 --> 00:33:51,069
等于MKA注释。 

764
00:33:51,069 --> 00:33:52,609
那行不通

765
00:33:52,609 --> 00:33:55,510
因为机场是MKA注释

766
00:33:55,510 --> 00:33:58,735
但并非所有的MKA注释都是机场。 

767
00:33:58,735 --> 00:34:01,652
因此，您不能只在此处进行此作业。 

768
00:34:01,652 --> 00:34:04,180
这是我们必须要做的

769
00:34:04,180 --> 00:34:06,209
您读过的类型转换

770
00:34:06,209 --> 00:34:08,844
我们已经简短地谈论了几次

771
00:34:08,844 --> 00:34:10,534
也许是在谈论的背景下

772
00:34:10,534 --> 00:34:13,827
旧的Objective-C任何类型。 

773
00:34:13,827 --> 00:34:17,841
所以我需要捕捉一下，我要说是否可以让机场

774
00:34:17,841 --> 00:34:22,253
等于此注释为机场， 

775
00:34:22,253 --> 00:34:26,588
这是有条件的尝试查看此MKAnnotation 

776
00:34:26,588 --> 00:34:29,507
实际上是一个机场，而不是其他

777
00:34:29,507 --> 00:34:31,845
我们实现了MKAnnotation。 

778
00:34:31,845 --> 00:34:32,901
如果是真的， 

779
00:34:32,901 --> 00:34:36,283
然后我可以将目的地设置为这个机场。 

780
00:34:39,678 --> 00:34:42,686
因此，通过这种方式，我们正在创建绑定

781
00:34:42,686 --> 00:34:47,227
与我们的草稿目的地绑定或绑定。 

782
00:34:47,227 --> 00:34:48,455
我们通过绑定

783
00:34:48,455 --> 00:34:52,256
就在这里访问我们的MapView。 

784
00:34:52,256 --> 00:34:54,684
到目前为止，我们的MapView并未执行任何操作

785
00:34:54,684 --> 00:34:55,827
设置选择。 

786
00:34:55,827 --> 00:34:57,466
它仍然只是在看选择。 

787
00:34:57,466 --> 00:34:59,224
但是，请确保我们没有破坏任何东西。 

788
00:34:59,224 --> 00:35:01,540
我们不应该因为我们仍然具有约束力

789
00:35:01,540 --> 00:35:02,449
到我们的汇票目的地。 

790
00:35:02,449 --> 00:35:03,692
所以当我们经过这里时

791
00:35:03,692 --> 00:35:05,573
看，它仍然是旧金山。 

792
00:35:05,573 --> 00:35:07,343
如果我们改成波士顿

793
00:35:07,343 --> 00:35:11,700
整个SwiftUI View更新发生

794
00:35:11,700 --> 00:35:12,941
然后我们去看波士顿

795
00:35:12,941 --> 00:35:13,951
这样就可以了。 

796
00:35:13,951 --> 00:35:16,308
但是我们还没有做任何事情

797
00:35:16,308 --> 00:35:18,120
在装订的另一边

798
00:35:18,120 --> 00:35:20,199
这样我们在这里选择机场时

799
00:35:20,199 --> 00:35:22,810
它设置选择。 

800
00:35:22,810 --> 00:35:25,877
因此，我们需要让MapView设置选择。 

801
00:35:25,877 --> 00:35:29,810
我们如何知道何时触针？ 

802
00:35:29,810 --> 00:35:33,096
在MapView中，我们使用委托进行此操作。 

803
00:35:33,096 --> 00:35:35,161
所以这里还有另一个委托方法

804
00:35:35,161 --> 00:35:38,336
mapView didSelect，在哪里？ 

805
00:35:38,336 --> 00:35:40,979
在那里，mapView didSelect。 

806
00:35:40,979 --> 00:35:42,824
该委托方法称为

807
00:35:42,824 --> 00:35:46,937
只要触摸了其中一个固定视图。 

808
00:35:46,937 --> 00:35:48,985
这是在此处触及的固定视图

809
00:35:48,985 --> 00:35:53,621
MKAnnotationView，在这种情况下，它是图钉注释。 

810
00:35:53,621 --> 00:35:56,198
这样我们就可以得到被点击的注释

811
00:35:56,198 --> 00:35:58,973
只问注释视图

812
00:35:58,973 --> 00:36:01,243
你有什么注释？ 

813
00:36:01,243 --> 00:36:04,637
问这个别针什么是您的注释？ 

814
00:36:04,637 --> 00:36:06,226
现在我们有了注释， 

815
00:36:06,226 --> 00:36:08,989
我们有点想做点什么

816
00:36:08,989 --> 00:36:13,989
self.selection等于该注释

817
00:36:14,719 --> 00:36:19,342
除了self.selection不在我们的协调器中。 

818
00:36:19,342 --> 00:36:22,706
在我们的UIViewRepresentable中。 

819
00:36:22,706 --> 00:36:25,464
这是嵌套类，但看不到vars 

820
00:36:25,464 --> 00:36:27,657
这个外部阶级的人。 

821
00:36:27,657 --> 00:36:31,773
所以我们必须从这里绑定此选择

822
00:36:31,773 --> 00:36:34,799
绑定到这里。 

823
00:36:34,799 --> 00:36:38,326
因此，让我们在此处创建另一个绑定， 

824
00:36:38,326 --> 00:36:40,913
var选择，这是MKA注释。 

825
00:36:42,610 --> 00:36:44,453
然后，当我们创建协调器时， 

826
00:36:44,453 --> 00:36:48,754
让我们传递选择，$ selection 

827
00:36:48,754 --> 00:36:52,537
这是我们绑定的美元符号版本， 

828
00:36:52,537 --> 00:36:55,768
我们知道绑定的美元就是绑定本身

829
00:36:55,768 --> 00:36:59,619
或绑定到绑定所绑定的同一事物。 

830
00:36:59,619 --> 00:37:00,980
但这不太有效

831
00:37:00,980 --> 00:37:03,561
因为这是一个类，而不是一个结构， 

832
00:37:03,561 --> 00:37:06,313
所以我们没有免费的构造函数。 

833
00:37:06,313 --> 00:37:09,074
我们必须创建自己的初始化选择

834
00:37:09,074 --> 00:37:13,677
需要绑定到MKAnnotation可选。 

835
00:37:15,986 --> 00:37:20,212
再说一次，我们不能说self.selection等于选择。 

836
00:37:20,212 --> 00:37:22,052
这是一个@Binding， 

837
00:37:22,052 --> 00:37:24,479
所以我们不得不说_selection。 

838
00:37:24,479 --> 00:37:27,670
实际的结构是这里传递的东西。 

839
00:37:27,670 --> 00:37:30,196
因此，现在我们的选择将双向绑定。 

840
00:37:30,196 --> 00:37:33,639
当代表注意到有人点击了该按钮时， 

841
00:37:33,639 --> 00:37:36,129
它在选择绑定这里设置它

842
00:37:36,129 --> 00:37:38,602
在这里绑定到此选择

843
00:37:38,602 --> 00:37:42,413
绑定回此绑定此处， 

844
00:37:42,413 --> 00:37:45,610
这将设定我们的草案目的地。 

845
00:37:45,610 --> 00:37:48,027
让我们看看实际情况。 

846
00:37:50,080 --> 00:37:51,807
转到我们的过滤器。 

847
00:37:51,807 --> 00:37:53,172
这样正确地绑定， 

848
00:37:53,172 --> 00:37:54,832
我们到了旧金山。 

849
00:37:54,832 --> 00:37:57,067
让我们去寻找另一个机场。 

850
00:37:57,067 --> 00:37:59,194
奥克兰在那里呢？ 

851
00:37:59,194 --> 00:38:00,287
！ 

852
00:38:00,287 --> 00:38:01,250
看那个！ 

853
00:38:01,250 --> 00:38:04,058
它放大了它，然后在这里拿起了它。 

854
00:38:04,058 --> 00:38:05,680
它可以选择其他方式。 

855
00:38:05,680 --> 00:38:07,881
我们去波士顿吧。 

856
00:38:07,881 --> 00:38:09,271
这是波士顿。 

857
00:38:09,271 --> 00:38:11,199
再次缩小。 

858
00:38:11,199 --> 00:38:12,906
在这里到纽瓦克。 

859
00:38:12,906 --> 00:38:14,288
哇，又做了一次。 

860
00:38:14,288 --> 00:38:15,415
如果单击完成， 

861
00:38:15,415 --> 00:38:18,200
它选择了这个纽瓦克。 

862
00:38:18,200 --> 00:38:19,759
我们可以看到纽瓦克机场。 

863
00:38:19,759 --> 00:38:20,921
就是这样。 

864
00:38:20,921 --> 00:38:22,284
这就是我想给你看的

865
00:38:22,284 --> 00:38:25,631
在此ViewRepresentable方面。 

866
00:38:25,631 --> 00:38:26,587
我们将要进行的下一个演示

867
00:38:26,587 --> 00:38:28,686
是ViewControllerRepresentable。 

868
00:38:28,686 --> 00:38:32,131
但这真的向您展示了所有事情

869
00:38:32,131 --> 00:38:34,967
您需要了解有关绑定到UIKit视图的信息

870
00:38:34,967 --> 00:38:38,431
包括（如果需要）构建自己的自定义绑定

871
00:38:38,431 --> 00:38:40,981
使用get和set可以绑定到那里。 

872
00:38:40,981 --> 00:38:43,176
但在其他所有时间，您甚至都不需要自定义绑定。 

873
00:38:43,176 --> 00:38:45,665
您将拥有一个可以绑定到的ObservedObject 

874
00:38:45,665 --> 00:38:48,740
或者您可以直接绑定到一个国家或任何其他国家

875
00:38:48,740 --> 00:38:52,204
然后您可以了解这里发生的情况。 

876
00:38:52,204 --> 00:38:55,072
您可能必须将其传递给委托人并返回

877
00:38:55,072 --> 00:38:57,649
就像我们在这里，因为代表通常是一个

878
00:38:57,649 --> 00:39:01,619
处理UIKit视图中正在进行的大部分活动。 

879
00:39:01,619 --> 00:39:03,838
好了，就在Enroute 

880
00:39:03,838 --> 00:39:05,510
和ViewRepresentable。 

881
00:39:05,510 --> 00:39:10,510
让我们转到另一个演示程序，即EmojiArt演示程序。 

882
00:39:12,655 --> 00:39:15,038
所以在这个演示中，我们将包装

883
00:39:15,038 --> 00:39:16,283
一堆意见， 

884
00:39:16,283 --> 00:39:19,337
一个控制所有视图的控制器

885
00:39:19,337 --> 00:39:22,101
我们要用一张纸来展示， 

886
00:39:22,101 --> 00:39:24,271
这是我们要介绍的表格

887
00:39:24,271 --> 00:39:25,618
让您从相机拍摄照片

888
00:39:25,618 --> 00:39:27,011
或照片库。 

889
00:39:27,011 --> 00:39:28,835
我们将从这里的图片库开始

890
00:39:28,835 --> 00:39:31,600
并将其用作EmojiArt的背景图片， 

891
00:39:31,600 --> 00:39:33,445
然后我们继续摄影

892
00:39:33,445 --> 00:39:34,759
因为有几件事要考虑

893
00:39:34,759 --> 00:39:36,460
与相机有些不同。 

894
00:39:36,460 --> 00:39:38,514
那么我们要把UI放在哪里

895
00:39:38,514 --> 00:39:42,388
让我们拍摄一张照片并将其作为背景

896
00:39:42,388 --> 00:39:45,662
然后将其直接放到navigationBarItems中？ 

897
00:39:45,662 --> 00:39:47,447
我们已经在那里了

898
00:39:47,447 --> 00:39:49,768
右边的粘贴板按钮。 

899
00:39:49,768 --> 00:39:53,045
因此，让我们放在另一侧，即领先者， 

900
00:39:53,045 --> 00:39:56,437
一些按钮或让我们选择这些东西的东西。 

901
00:39:56,437 --> 00:39:59,397
我们将其称为我的pickImage。 

902
00:40:00,394 --> 00:40:04,661
我的pickImage在这里会有点变

903
00:40:04,661 --> 00:40:07,740
pickImage，一些视图。 

904
00:40:07,740 --> 00:40:11,513
我们甚至可以将其设为私人

905
00:40:11,513 --> 00:40:12,346
然后选择pickImage。 

906
00:40:12,346 --> 00:40:16,165
让我们将其设为Image，systemName。 

907
00:40:16,165 --> 00:40:18,214
图像“照片”怎么样？ 

908
00:40:18,214 --> 00:40:22,786
我认为这是在此处选择照片的良好系统图像。 

909
00:40:22,786 --> 00:40:24,423
我要把这个扩大。 

910
00:40:24,423 --> 00:40:25,382
我不太确定

911
00:40:25,382 --> 00:40:27,685
我们是否应该在那里扩大规模

912
00:40:27,685 --> 00:40:28,754
但这对演示很好

913
00:40:28,754 --> 00:40:30,710
很容易看到那里发生了什么。 

914
00:40:30,710 --> 00:40:33,663
而且我还要将颜色设置为.accentColor， 

915
00:40:33,663 --> 00:40:35,216
Button会使用相同的东西。 

916
00:40:35,216 --> 00:40:37,194
实际上，我可以在此处使用一个按钮

917
00:40:37,194 --> 00:40:41,275
但是仅出于多样性，我们来做一个onTapGesture。 

918
00:40:41,275 --> 00:40:44,125
该图像将出现在我们的用户界面中。 

919
00:40:44,125 --> 00:40:45,543
让我们来看看它。 

920
00:40:49,552 --> 00:40:50,730
那里就在那里。 

921
00:40:50,730 --> 00:40:52,453
当我点击这个

922
00:40:52,453 --> 00:40:56,515
我希望它调出这个UIKit UI 

923
00:40:56,515 --> 00:40:59,826
这样我们就可以从图片库中进行选择。 

924
00:40:59,826 --> 00:41:02,895
然后，我们将为相机添加另一个按钮。 

925
00:41:02,895 --> 00:41:06,409
那么如何使工作表出现？ 

926
00:41:06,409 --> 00:41:08,408
我们确切地知道该怎么做，对吗？ 

927
00:41:08,408 --> 00:41:12,077
我们只是设置了某种布尔变量。 

928
00:41:12,077 --> 00:41:14,189
我要称呼我的布尔变量

929
00:41:14,189 --> 00:41:17,724
showImagePicker = true。 

930
00:41:17,724 --> 00:41:21,406
为此，我需要一个私人@State。 

931
00:41:21,406 --> 00:41:23,620
我们当然会以错误为开端。 

932
00:41:23,620 --> 00:41:27,693
然后我们要转到.sheet isPresented， 

933
00:41:28,600 --> 00:41:32,232
在那个showImagePicker上放置一个Binding， 

934
00:41:32,232 --> 00:41:35,213
然后我们将不得不提供

935
00:41:35,213 --> 00:41:38,726
无论我们呈现什么表。 

936
00:41:38,726 --> 00:41:42,688
在这种情况下，它将是ImagePicker。 

937
00:41:42,688 --> 00:41:46,115
这将是一个UIViewControllerRepresentable 

938
00:41:46,115 --> 00:41:49,495
放置照片选择器。 

939
00:41:49,495 --> 00:41:52,433
让我们继续执行此操作，File，New。 

940
00:41:52,433 --> 00:41:54,225
再次是SwiftUI视图， 

941
00:41:54,225 --> 00:41:55,983
但由于它是可代表的， 

942
00:41:55,983 --> 00:41:58,070
我们不需要var主体以及所有其他东西。 

943
00:41:58,070 --> 00:42:00,383
我们将其称为我的ImagePicker。 

944
00:42:03,540 --> 00:42:04,373
在这里。 

945
00:42:04,373 --> 00:42:06,172
和往常一样，我们正在做整合

946
00:42:06,172 --> 00:42:08,423
我们需要SwiftUI和UIKit。 

947
00:42:10,432 --> 00:42:13,180
这只是一个名为ImagePicker的结构

948
00:42:13,180 --> 00:42:15,230
这是一个UIViewControllerRepresentable。 

949
00:42:19,921 --> 00:42:22,601
它具有完全相同的功能

950
00:42:22,601 --> 00:42:23,590
就像我们其他人一样

951
00:42:23,590 --> 00:42:25,041
所以让我们直接输入

952
00:42:25,041 --> 00:42:26,656
因为我们已经知道如何做到这一点。 

953
00:42:26,656 --> 00:42:31,656
有带有上下文的makeUIViewController。 

954
00:42:31,840 --> 00:42:33,688
现在那种ViewController 

955
00:42:33,688 --> 00:42:35,462
我们要在这里做

956
00:42:35,462 --> 00:42:37,293
被称为UIImagePickerController。 

957
00:42:39,473 --> 00:42:40,650
这只是一个MVC，UIKit中的一个控制器

958
00:42:43,885 --> 00:42:45,952
我们可以用来选择照片

959
00:42:45,952 --> 00:42:48,632
从我们的图片库或相机中获取。 

960
00:42:48,632 --> 00:42:51,567
让我们选择器等于其中之一。 

961
00:42:51,567 --> 00:42:53,133
我要创建一个。 

962
00:42:54,114 --> 00:42:55,693
然后退货。 

963
00:42:56,577 --> 00:42:58,432
我们将不得不对其进行配置

964
00:42:58,432 --> 00:43:00,190
在这里一点点。 

965
00:43:00,190 --> 00:43:02,136
因此，我们将为此留出空间。 

966
00:43:02,136 --> 00:43:05,850
然后，当然我们有了updateUIViewController。 

967
00:43:05,850 --> 00:43:07,825
这需要一个ImagePickerController。 

968
00:43:07,825 --> 00:43:09,210
这是我们要更新的地方。 

969
00:43:09,210 --> 00:43:11,958
我实际上不认为我们需要进行任何更新

970
00:43:11,958 --> 00:43:14,362
因为我们只是展示了这个ViewController 

971
00:43:14,362 --> 00:43:16,526
我们要有一个代表

972
00:43:16,526 --> 00:43:19,256
但是否则它会去做的。 

973
00:43:19,256 --> 00:43:22,047
我们当然需要makeCoordinator。 

974
00:43:23,362 --> 00:43:25,033
我们将做完全相同的事情， 

975
00:43:25,033 --> 00:43:27,905
我们称它为协调员

976
00:43:27,905 --> 00:43:32,905
我们将它作为一个嵌套的类协调器。 

977
00:43:33,350 --> 00:43:35,447
它是一个NSObject，因为它将

978
00:43:35,447 --> 00:43:39,713
UIImagePickerController的委托。 

979
00:43:39,713 --> 00:43:41,507
而且只是为了好措施， 

980
00:43:41,507 --> 00:43:42,957
我不会解释为什么

981
00:43:42,957 --> 00:43:44,784
因为我们不是那么多

982
00:43:44,784 --> 00:43:46,763
了解UIImagePickerController 

983
00:43:46,763 --> 00:43:49,443
尽管这样做会学到很多东西， 

984
00:43:49,443 --> 00:43:52,395
它也必须在这里实现另一个协议

985
00:43:52,395 --> 00:43:54,295
称为UINavigationControllerDelegate。 

986
00:43:56,986 --> 00:44:00,894
这只是该ImagePicker的协议

987
00:44:00,894 --> 00:44:03,001
需要其委托人执行。 

988
00:44:03,001 --> 00:44:04,964
我们不会使用任何方法

989
00:44:04,964 --> 00:44:07,216
但是我们仍然必须把它放在那里。 

990
00:44:07,216 --> 00:44:08,974
这里有几种方法， 

991
00:44:08,974 --> 00:44:10,766
我们真的都需要它们

992
00:44:10,766 --> 00:44:14,965
一种是imagePickerController didCancel 

993
00:44:14,965 --> 00:44:17,098
另一个是imagePickerController 

994
00:44:17,098 --> 00:44:20,627
didFinishPickingMedia。 

995
00:44:20,627 --> 00:44:22,763
因此，让我们将它们都放在这里。 

996
00:44:24,164 --> 00:44:26,588
这个取消的权利在这里叫做

997
00:44:26,588 --> 00:44:29,263
当该人当然取消控制器时。 

998
00:44:29,263 --> 00:44:32,057
记住，我们在这里放置了整个工作表的UI 

999
00:44:32,057 --> 00:44:33,977
并且上面会有一个“取消”按钮。 

1000
00:44:33,977 --> 00:44:36,844
这是我们实际选择图像的地方

1001
00:44:36,844 --> 00:44:39,694
从相机或从照片库。 

1002
00:44:39,694 --> 00:44:40,872
所以这是行动

1003
00:44:40,872 --> 00:44:42,743
确实发生在我们的代表中

1004
00:44:42,743 --> 00:44:45,269
这是我们的PickerControllerDelegate， 

1005
00:44:45,269 --> 00:44:48,470
因此，让我们设置选择器的代表

1006
00:44:48,470 --> 00:44:52,202
成为我们的context.coordinator，对吗？ 

1007
00:44:52,202 --> 00:44:55,626
我们正在设置要创建的实例。 

1008
00:44:55,626 --> 00:44:57,589
我们将在这里创建协调器。 

1009
00:44:57,589 --> 00:45:01,156
无论如何，它并不需要任何参数。 

1010
00:45:01,156 --> 00:45:02,640
现在我们完成了所有设置。 

1011
00:45:02,640 --> 00:45:04,955
就像我们设置MapView一样。 

1012
00:45:04,955 --> 00:45:06,969
我们得到了代表以及所有这些。 

1013
00:45:06,969 --> 00:45:09,715
但是我们想在这里进行配置的另一件事， 

1014
00:45:09,715 --> 00:45:13,104
首先，我要设置选择器的源类型

1015
00:45:13,104 --> 00:45:14,946
成为照片库。 

1016
00:45:14,946 --> 00:45:17,588
因此，选择器将尝试选择图像

1017
00:45:17,588 --> 00:45:19,467
从照片库开始。 

1018
00:45:19,467 --> 00:45:21,121
最终，我们会做相机

1019
00:45:21,121 --> 00:45:24,350
但现在只是照片库。 

1020
00:45:24,350 --> 00:45:26,831
好了，我们回到这里的DocumentView。 

1021
00:45:26,831 --> 00:45:29,254
我们有我们的ImagePicker。 

1022
00:45:29,254 --> 00:45:31,520
它应该现在编译。 

1023
00:45:31,520 --> 00:45:36,026
让我们跑到我们的“房子”。 

1024
00:45:36,026 --> 00:45:38,749
现在，当我们点击一​​个onTapGesture时， 

1025
00:45:38,749 --> 00:45:40,248
希望它将成立

1026
00:45:40,248 --> 00:45:43,623
我们漂亮的照片库用户界面。 

1027
00:45:44,824 --> 00:45:46,136
在那里。 

1028
00:45:46,136 --> 00:45:47,179
呜呜！ 

1029
00:45:47,179 --> 00:45:48,674
好的，有我们的照片。 

1030
00:45:48,674 --> 00:45:53,157
现在，如果我在这里选一个这样的东西，什么都不会发生

1031
00:45:53,157 --> 00:45:55,520
但是如果我点击“取消”，则什么也不会发生。 

1032
00:45:55,520 --> 00:46:00,060
那是因为回到我们这里的pickImage中， 

1033
00:46:00,060 --> 00:46:02,604
我们把这张纸放起来，把ImagePicker放起来， 

1034
00:46:02,604 --> 00:46:06,018
但是当取消或选择它时，我们什么也不做， 

1035
00:46:06,018 --> 00:46:09,585
所以这东西当然永远不会被丢弃

1036
00:46:09,585 --> 00:46:11,783
这个showImagePicker永远不会设置为false， 

1037
00:46:11,783 --> 00:46:14,422
很明显，我们没有抓住图像。 

1038
00:46:14,422 --> 00:46:16,167
但是我们已经呈现了这个东西， 

1039
00:46:16,167 --> 00:46:18,842
所以现在让我们做一点工作

1040
00:46:18,842 --> 00:46:21,127
才能从此处获得该图像。 

1041
00:46:21,127 --> 00:46:24,069
现在，我该如何从这里获取该图像？ 

1042
00:46:24,069 --> 00:46:26,922
一种方法是与我们制作MapView的方法相同， 

1043
00:46:26,922 --> 00:46:30,952
在此处放置@Binding并绑定到图像

1044
00:46:30,952 --> 00:46:33,036
然后将选择图像

1045
00:46:33,036 --> 00:46:36,296
我们必须将其传递给代表， 

1046
00:46:36,296 --> 00:46:38,088
它可以在这里设置绑定

1047
00:46:38,088 --> 00:46:39,549
它会运回去。 

1048
00:46:39,549 --> 00:46:41,017
那是做到这一点的一种方法。 

1049
00:46:41,017 --> 00:46:43,799
只是为了向您展示其他做事方式， 

1050
00:46:43,799 --> 00:46:46,137
我会做一些不同的事情。 

1051
00:46:46,137 --> 00:46:51,137
我要在此处将var添加到我的Representable 

1052
00:46:51,954 --> 00:46:53,893
这叫做handlePickedImage， 

1053
00:46:56,475 --> 00:47:00,874
这将是闭包，UIImage，返回void。 

1054
00:47:00,874 --> 00:47:05,416
当您选择图像时，我将称此关闭。 

1055
00:47:05,416 --> 00:47:08,410
现在，如果您取消，我要给您零

1056
00:47:08,410 --> 00:47:10,243
或由于某些原因我无法获得图像。 

1057
00:47:10,243 --> 00:47:14,189
如果您确实选择了它，我会给您一个图像。 

1058
00:47:14,189 --> 00:47:16,510
现在我们知道这个handlePickedImage 

1059
00:47:16,510 --> 00:47:18,383
实际上发生在这里。 

1060
00:47:18,383 --> 00:47:20,469
因此，我们必须做与地图相同的操作， 

1061
00:47:20,469 --> 00:47:22,309
这是很常见的事情， 

1062
00:47:22,309 --> 00:47:24,811
我们将不得不执行相同的功能

1063
00:47:24,811 --> 00:47:27,456
在我们的协调员那里， 

1064
00:47:27,456 --> 00:47:32,456
var handlePickedImage UIImage和Void， 

1065
00:47:34,964 --> 00:47:37,337
并将其传递给我们的协调员， 

1066
00:47:37,337 --> 00:47:42,299
handlePickedImage，调用handlePickedImage。 

1067
00:47:42,299 --> 00:47:43,941
这又是一堂课

1068
00:47:43,941 --> 00:47:46,137
所以我们这里没有免费的构造函数， 

1069
00:47:46,137 --> 00:47:50,284
所以我们不得不说init handlePickedImage 

1070
00:47:50,284 --> 00:47:55,284
使用此UIImage返回Void， 

1071
00:47:55,557 --> 00:48:00,472
self.handlePickedImage等于handlePickedImage。 

1072
00:48:00,472 --> 00:48:03,227
我真的已经习惯了输入handlePickedImage。 

1073
00:48:03,227 --> 00:48:06,303
当然，我们正在坚持并坚持下去

1074
00:48:06,303 --> 00:48:09,972
因此，这必须是@转义。 

1075
00:48:09,972 --> 00:48:12,893
我们知道，只要我们有传入的函数， 

1076
00:48:12,893 --> 00:48:14,990
当我们坚持下去时，我们必须让人们知道

1077
00:48:14,990 --> 00:48:16,260
那就是我们正在做的

1078
00:48:16,260 --> 00:48:18,010
我们正在那里抓住它。 

1079
00:48:18,881 --> 00:48:21,403
现在我们有了这个handlePickedImage， 

1080
00:48:21,403 --> 00:48:23,232
只是，当我们取消时， 

1081
00:48:23,232 --> 00:48:26,902
调用我们的handlePickedImage（nil） 

1082
00:48:26,902 --> 00:48:28,131
因此我们知道您已取消。 

1083
00:48:28,131 --> 00:48:32,415
在这里，我将使用图像处理handlePickedImage。 

1084
00:48:32,415 --> 00:48:34,241
现在如何获取图像？ 

1085
00:48:34,241 --> 00:48:36,897
当imagePickerControllerDelegate被调用时， 

1086
00:48:36,897 --> 00:48:39,747
这做了FinishPickingMediaWithInfo， 

1087
00:48:39,747 --> 00:48:41,386
我们得到这本字典， 

1088
00:48:41,386 --> 00:48:45,004
这本词典中的信息有多大

1089
00:48:45,004 --> 00:48:47,222
以及实际的图像是什么。 

1090
00:48:47,222 --> 00:48:49,179
这个词典有很多键。 

1091
00:48:49,179 --> 00:48:52,814
信息键之一是.originalImage， 

1092
00:48:52,814 --> 00:48:55,732
这样就可以将原始图像作为UIImage。 

1093
00:48:55,732 --> 00:48:58,838
当然，此词典将“任何”作为值。 

1094
00:48:58,838 --> 00:49:01,942
这是旧的Objective-C API。 

1095
00:49:01,942 --> 00:49:06,096
所以我们需要说成？ UIImage，看看是否可以投射它。 

1096
00:49:06,096 --> 00:49:07,608
而我们正在这样做吗？ 

1097
00:49:07,608 --> 00:49:10,199
如果出于某种原因，它将返回nil 

1098
00:49:10,199 --> 00:49:12,182
这不是UIImage， 

1099
00:49:12,182 --> 00:49:14,845
没关系，因为handlePickedImage将为nil 

1100
00:49:14,845 --> 00:49:16,870
就像取消一样

1101
00:49:16,870 --> 00:49:18,988
与取消无异。 

1102
00:49:18,988 --> 00:49:21,123
现在我们在这里要做的一件事， 

1103
00:49:21,123 --> 00:49:23,252
我不认为我们整个季度都这样做， 

1104
00:49:23,252 --> 00:49:25,441
这是typealiasing。 

1105
00:49:25,441 --> 00:49:29,633
我不得不在这里多次键入此类型。 

1106
00:49:29,633 --> 00:49:32,125
当你有一个复杂的类型

1107
00:49:32,125 --> 00:49:35,870
而不是字符串或结构的名称， 

1108
00:49:35,870 --> 00:49:38,636
很多时候，我们将创建一个typealias。 

1109
00:49:38,636 --> 00:49:43,397
例如，我可能将此东西称为PickedImageHandler 

1110
00:49:43,397 --> 00:49:47,832
它等于UIImage返回Void。 

1111
00:49:47,832 --> 00:49:51,094
然后在任何我使用它的地方

1112
00:49:51,094 --> 00:49:53,583
我要改成这个。 

1113
00:49:53,583 --> 00:49:56,380
所以这里，这里，这里。 

1114
00:49:56,380 --> 00:49:57,543
我不能那样说。 

1115
00:49:57,543 --> 00:49:59,223
对我的API来说有点好。 

1116
00:49:59,223 --> 00:50:02,714
它更多地描述了此功能是什么， 

1117
00:50:02,714 --> 00:50:04,166
它也可以清理东西

1118
00:50:04,166 --> 00:50:06,214
而且我不必担心一遍又一遍地输入， 

1119
00:50:06,214 --> 00:50:07,818
我可能会犯一个错误

1120
00:50:07,818 --> 00:50:09,770
当我反复输入时， 

1121
00:50:09,770 --> 00:50:11,606
就像我可能会忘记我的问号

1122
00:50:11,606 --> 00:50:12,596
或类似的东西， 

1123
00:50:12,596 --> 00:50:14,796
这也可以防止这种情况。 

1124
00:50:14,796 --> 00:50:17,187
进行类型别名很常见

1125
00:50:17,187 --> 00:50:18,553
对于函数参数

1126
00:50:18,553 --> 00:50:21,833
尤其是当他们经过很多地方时。 

1127
00:50:22,922 --> 00:50:25,925
现在我们要做的就是设置这个handlePickedImage 

1128
00:50:25,925 --> 00:50:28,042
当我们在这里进行ImagePicker时。 

1129
00:50:28,042 --> 00:50:29,360
这是我们的ImagePicker。 

1130
00:50:29,360 --> 00:50:30,589
我们开始做吧。 

1131
00:50:30,589 --> 00:50:34,018
在这里给我们的图像。 

1132
00:50:34,018 --> 00:50:36,254
现在我们知道我们必须检查看看

1133
00:50:36,254 --> 00:50:38,097
如果图片不等于nil， 

1134
00:50:38,097 --> 00:50:39,354
如果不等于零， 

1135
00:50:39,354 --> 00:50:42,033
那么我们必须实际使用它作为背景。 

1136
00:50:42,033 --> 00:50:43,311
而且无论如何

1137
00:50:43,311 --> 00:50:45,888
我们将把showImagePicker设置为false。 

1138
00:50:45,888 --> 00:50:50,291
我们想解散我们介绍的这张纸。 

1139
00:50:50,291 --> 00:50:52,732
现在，如果图像不为零，我们该怎么办？ 

1140
00:50:52,732 --> 00:50:55,650
这是我们要做假的地方

1141
00:50:55,650 --> 00:50:57,186
我在那儿谈论

1142
00:50:57,186 --> 00:51:00,415
我们要把这个东西扔进文件系统， 

1143
00:51:00,415 --> 00:51:03,580
将此图像放入文件系统并获取一个URL 

1144
00:51:03,580 --> 00:51:05,093
并将其设置为我们的背景网址。 

1145
00:51:05,093 --> 00:51:08,402
同样，这将绑住整个事情， 

1146
00:51:08,402 --> 00:51:11,306
我们正在为此设备创建的此文档

1147
00:51:11,306 --> 00:51:13,831
因为我们要指向它自己的沙箱。 

1148
00:51:13,831 --> 00:51:17,228
顺便说一句，我不得不回到我的EmojiArt扩展程序中

1149
00:51:17,228 --> 00:51:19,771
并使用此图像网址播放一点。 

1150
00:51:19,771 --> 00:51:21,665
我必须实际检查文件URL 

1151
00:51:21,665 --> 00:51:25,407
因为要注意的一件事就是， 

1152
00:51:25,407 --> 00:51:27,557
特别是你的发展

1153
00:51:27,557 --> 00:51:29,418
并运行新版本的应用， 

1154
00:51:29,418 --> 00:51:31,412
应用程序支持目录

1155
00:51:31,412 --> 00:51:34,619
这就是我决定放这东西，这张图片的地方

1156
00:51:34,619 --> 00:51:38,457
它更改了URL，并在启动之间变化。 

1157
00:51:38,457 --> 00:51:40,419
所以我在这里有一个东西

1158
00:51:40,419 --> 00:51:43,679
每当我看到文件网址作为背景图片时， 

1159
00:51:43,679 --> 00:51:47,092
我打算在“应用程序支持”中重新查找它

1160
00:51:47,092 --> 00:51:48,349
获得新版本。 

1161
00:51:48,349 --> 00:51:49,981
所以这有点烦人。 

1162
00:51:49,981 --> 00:51:52,131
我想我也必须在我们的文档中仔细阅读

1163
00:51:52,131 --> 00:51:54,176
并确保每当我获取

1164
00:51:54,176 --> 00:51:55,450
背景图像数据， 

1165
00:51:55,450 --> 00:51:57,498
我再次调用该图像URL。 

1166
00:51:57,498 --> 00:51:59,853
我最初只是在设置电话时打电话给我， 

1167
00:51:59,853 --> 00:52:01,355
但是现在我每次都打电话

1168
00:52:01,355 --> 00:52:04,321
以确保正确设置此文件的URL。 

1169
00:52:04,321 --> 00:52:07,465
所以这只是种烦恼

1170
00:52:07,465 --> 00:52:09,919
使这个演示非常顺利

1171
00:52:09,919 --> 00:52:12,858
因为我现在可以在此处键入这一行代码

1172
00:52:12,858 --> 00:52:17,685
这是self.document.backgroundURL 

1173
00:52:17,685 --> 00:52:22,603
等于该图像storeInFilesystem， 

1174
00:52:22,603 --> 00:52:24,480
并存储在文件系统中

1175
00:52:24,480 --> 00:52:27,537
只是我在这里写的这个扩展名。 

1176
00:52:27,537 --> 00:52:30,174
在上一堂课之后，您知道现在该怎么做， 

1177
00:52:30,174 --> 00:52:33,093
获取目录，appendingPathComponent。 

1178
00:52:33,093 --> 00:52:37,016
我在UIImage上使用此jpegData函数获取数据

1179
00:52:37,016 --> 00:52:41,017
然后我写那个URL，放入文件系统， 

1180
00:52:41,017 --> 00:52:44,578
然后返回写给它的URL。 

1181
00:52:44,578 --> 00:52:47,514
真的很简单，在这里使其成为一线。 

1182
00:52:47,514 --> 00:52:49,528
我要在这里做的另一件事

1183
00:52:49,528 --> 00:52:52,446
我们也没有谈论过

1184
00:52:52,446 --> 00:52:56,013
我有点担心这种关闭

1185
00:52:56,013 --> 00:52:58,521
可能会在不合时宜的时候被调用。 

1186
00:52:58,521 --> 00:53:00,552
例如，我实际上是不允许的

1187
00:53:00,552 --> 00:53:04,325
将自己修改为视图

1188
00:53:04,325 --> 00:53:08,240
而我正在处理事件。 

1189
00:53:08,240 --> 00:53:10,955
您还必须等待一切恢复稳定。 

1190
00:53:10,955 --> 00:53:13,600
为了安全起见，此处关闭

1191
00:53:13,600 --> 00:53:15,665
我不会做这个backgroundURL 

1192
00:53:15,665 --> 00:53:17,918
我知道会更新我的用户界面。 

1193
00:53:17,918 --> 00:53:22,918
我将在DispatchQueue.main.async中执行此操作。 

1194
00:53:23,842 --> 00:53:25,139
现在我为什么要这样做？ 

1195
00:53:25,139 --> 00:53:28,210
多线程在这里没有问题。 

1196
00:53:28,210 --> 00:53:30,345
所有这些都不在后台线程上发生。 

1197
00:53:30,345 --> 00:53:33,261
这实际上与多线程无关。 

1198
00:53:33,261 --> 00:53:37,274
只是如果我要我的主队列去做这个关闭， 

1199
00:53:37,274 --> 00:53:38,656
它会放在清单上

1200
00:53:38,656 --> 00:53:41,130
即使我在这里在主队列中运行， 

1201
00:53:41,130 --> 00:53:43,070
它会完成这里所做的所有事情， 

1202
00:53:43,070 --> 00:53:44,504
也许更新我的观点， 

1203
00:53:44,504 --> 00:53:45,477
当完成时， 

1204
00:53:45,477 --> 00:53:48,549
它要去排队抢下一个

1205
00:53:48,549 --> 00:53:51,051
希望是我的并执行它。 

1206
00:53:51,051 --> 00:53:53,560
所以基本上就是说

1207
00:53:53,560 --> 00:53:55,331
一切都安定下来之后。 

1208
00:53:55,331 --> 00:53:58,345
而且，如果您在运行时开始收到警告， 

1209
00:53:58,345 --> 00:54:00,393
就是说，哦，你无法更新， 

1210
00:54:00,393 --> 00:54:02,810
您无权修改视图

1211
00:54:02,810 --> 00:54:03,643
在中间

1212
00:54:03,643 --> 00:54:06,217
构造它的身体之类的东西

1213
00:54:06,217 --> 00:54:09,184
那么您可能会想到延迟这样的事情。 

1214
00:54:09,184 --> 00:54:12,771
我们可能也想在Enroute中做到这一点。 

1215
00:54:12,771 --> 00:54:17,771
好的，在“途中”中单击地图上的“机场”时， 

1216
00:54:18,458 --> 00:54:21,616
也许选择机场

1217
00:54:21,616 --> 00:54:24,841
为了安全起见，我们也应该这样做。 

1218
00:54:24,841 --> 00:54:26,234
我没看到有什么问题

1219
00:54:26,234 --> 00:54:29,546
但是只要您在这里有回调

1220
00:54:29,546 --> 00:54:31,765
特别是在UIKit中

1221
00:54:31,765 --> 00:54:35,801
因为UIKit与SwiftUI的世界有些不同， 

1222
00:54:35,801 --> 00:54:38,655
有时您可以放一些安全缓冲区。 

1223
00:54:38,655 --> 00:54:39,741
不会伤害任何东西。 

1224
00:54:39,741 --> 00:54:42,677
我们实际上只是在这里做一个用户意图，对吧？ 

1225
00:54:42,677 --> 00:54:46,681
这是一个意图，一个改变背景URL的意图。 

1226
00:54:46,681 --> 00:54:50,111
完全可以延迟一小会儿

1227
00:54:50,111 --> 00:54:52,227
当我们等待调度队列安定下来时

1228
00:54:52,227 --> 00:54:53,470
然后回来。 

1229
00:54:53,470 --> 00:54:55,623
让我们看看这是否有效。 

1230
00:54:58,133 --> 00:54:58,966
是的，这是我们的“房子”。 

1231
00:54:58,966 --> 00:55:01,526
让我们看看是否可以更改房屋的背景

1232
00:55:01,526 --> 00:55:04,217
成为我们图片库中的东西。 

1233
00:55:04,217 --> 00:55:06,423
让我们单击照片库。 

1234
00:55:07,425 --> 00:55:08,893
这里是。 

1235
00:55:08,893 --> 00:55:12,370
让我们去挑选这个漂亮的小绿色。 

1236
00:55:12,370 --> 00:55:14,607
呜呼！ 

1237
00:55:14,607 --> 00:55:16,430
我们可以放大和缩小所有内容。 

1238
00:55:16,430 --> 00:55:18,937
我们甚至可以确保

1239
00:55:18,937 --> 00:55:21,040
确实在这里节省了很多东西。 

1240
00:55:21,040 --> 00:55:26,040
让我们回去，再次运行“ House”。 

1241
00:55:26,480 --> 00:55:28,328
呜呜，它还在里面！ 

1242
00:55:28,328 --> 00:55:29,658
我放大了。 

1243
00:55:29,658 --> 00:55:30,833
好的。 

1244
00:55:30,833 --> 00:55:31,800
所以这很棒。 

1245
00:55:31,800 --> 00:55:34,236
这适用于照片库。 

1246
00:55:34,236 --> 00:55:36,590
很简单，很强大。 

1247
00:55:36,590 --> 00:55:38,608
在我们的代码中看起来非常不错。 

1248
00:55:38,608 --> 00:55:41,954
在这里，我们的SwiftUI代码都是SwiftUI风格的。 

1249
00:55:41,954 --> 00:55:45,146
这里确实没有很多奇怪的东西。 

1250
00:55:45,146 --> 00:55:47,764
甚至ImagePicker，也非常简单。 

1251
00:55:47,764 --> 00:55:49,901
这几乎是最少的代码

1252
00:55:49,901 --> 00:55:53,280
使UIImagePicker工作。 

1253
00:55:53,280 --> 00:55:54,953
现在相机呢？ 

1254
00:55:54,953 --> 00:55:58,690
使这个UIImagePickerController为相机选择

1255
00:55:58,690 --> 00:55:59,646
非常简单。 

1256
00:55:59,646 --> 00:56:00,941
实际上只是在改变

1257
00:56:00,941 --> 00:56:05,002
此照片库在这里是.camera。 

1258
00:56:05,002 --> 00:56:08,094
但是，我真的想使用所有这些代码

1259
00:56:08,094 --> 00:56:10,528
适用于照片库和相机。 

1260
00:56:10,528 --> 00:56:12,986
因此，让我们在此处使其成为变量。 

1261
00:56:12,986 --> 00:56:14,539
所以我们说sourceType。 

1262
00:56:14,539 --> 00:56:17,206
我们将其放入var中。 

1263
00:56:18,959 --> 00:56:20,768
这种类型的枚举

1264
00:56:20,768 --> 00:56:23,413
是UIImagePickerController.SourceType。 

1265
00:56:26,784 --> 00:56:29,244
本质上就是这种枚举的类型。 

1266
00:56:29,244 --> 00:56:30,746
而且我们刚刚做到了

1267
00:56:30,746 --> 00:56:32,403
这样该ImagePicker可以选择

1268
00:56:32,403 --> 00:56:35,400
从相机或从照片库。 

1269
00:56:35,400 --> 00:56:38,063
当然，现在回到这里，我们会遇到一个错误。 

1270
00:56:38,063 --> 00:56:40,350
我们需要提供sourceType。 

1271
00:56:40,350 --> 00:56:45,350
让我们创建一个小图像imagePickerSourceType @State。 

1272
00:56:52,100 --> 00:56:53,107
我们将其设置为等于

1273
00:56:53,107 --> 00:56:58,107
UIImagePickerController.SourceType.photoLibrary。 

1274
00:56:58,415 --> 00:57:00,207
我们在这里选择什么都没关系

1275
00:57:00,207 --> 00:57:03,326
因为我们要去做的是这张照片， 

1276
00:57:03,326 --> 00:57:07,085
一，设置此self.imagePickerSourceType 

1277
00:57:07,085 --> 00:57:09,337
等于照相馆， 

1278
00:57:09,337 --> 00:57:11,787
然后我们将有另一个按钮

1279
00:57:11,787 --> 00:57:15,227
相机旁边， 

1280
00:57:15,227 --> 00:57:19,351
它的SourceType将是相机。 

1281
00:57:19,351 --> 00:57:21,426
我将这两件事放在HStack中

1282
00:57:21,426 --> 00:57:22,962
所以他们会并排坐着

1283
00:57:22,962 --> 00:57:26,053
在那个左上角

1284
00:57:26,938 --> 00:57:29,465
这就是我们所要做的，对吧？ 

1285
00:57:29,465 --> 00:57:30,723
让我们来看看。 

1286
00:57:34,305 --> 00:57:35,476
好吧，这是我们的“房子”。 

1287
00:57:35,476 --> 00:57:36,374
我们到了那里。 

1288
00:57:36,374 --> 00:57:38,353
让我们看看那里有一个照片库， 

1289
00:57:38,353 --> 00:57:39,186
它似乎仍然有效。 

1290
00:57:39,186 --> 00:57:41,887
我们可以选择不同的图像。 

1291
00:57:41,887 --> 00:57:42,808
效果很好。 

1292
00:57:42,808 --> 00:57:45,242
相机怎么样？ 

1293
00:57:45,242 --> 00:57:47,010
哇！ 

1294
00:57:47,010 --> 00:57:47,898
我们的应用程序崩溃了。 

1295
00:57:47,898 --> 00:57:49,330
这里发生了什么？ 

1296
00:57:49,330 --> 00:57:50,840
让我们看一下控制台。 

1297
00:57:50,840 --> 00:57:52,676
当然，每次崩溃

1298
00:57:52,676 --> 00:57:55,500
您想去控制台看一下发生了什么。 

1299
00:57:55,500 --> 00:57:59,205
可以肯定的是，“源类型1不可用”。 

1300
00:57:59,205 --> 00:58:01,227
哦耶。 

1301
00:58:01,227 --> 00:58:03,837
而且模拟器没有摄像头

1302
00:58:03,837 --> 00:58:05,891
因此它使我们的应用程序崩溃。 

1303
00:58:05,891 --> 00:58:08,710
因此，相机UIImagePickerController 

1304
00:58:08,710 --> 00:58:10,140
如果您查看此文档， 

1305
00:58:10,140 --> 00:58:12,205
这个事实非常非常清楚

1306
00:58:12,205 --> 00:58:15,667
你不应该要求这个SourceType相机

1307
00:58:15,667 --> 00:58:18,671
除非您先检查确定有摄像机。 

1308
00:58:18,671 --> 00:58:19,913
所以我们就在这里做。 

1309
00:58:19,913 --> 00:58:24,580
如果UIImagePickerController.isSourceTypeAvailable？ 

1310
00:58:26,459 --> 00:58:29,751
我们在这里谈论相机。 

1311
00:58:29,751 --> 00:58:32,723
然后，我们将这台相机放在这里。 

1312
00:58:36,375 --> 00:58:38,743
现在，当我们在模拟器上运行时， 

1313
00:58:40,248 --> 00:58:41,607
我们现在有一个相机。 

1314
00:58:41,607 --> 00:58:44,076
哇，效果很好！ 

1315
00:58:44,076 --> 00:58:47,227
好的，但是我们想看看相机的动作，不是吗？ 

1316
00:58:47,227 --> 00:58:49,582
因此，让我们尝试在设备上运行它。 

1317
00:58:49,582 --> 00:58:53,934
我在这里连接了一个设备，一个金iPad。 

1318
00:58:53,934 --> 00:58:56,323
让我们在上面运行它，看看会发生什么。 

1319
00:58:57,798 --> 00:58:59,718
好了，我们这里有一些文件。 

1320
00:58:59,718 --> 00:59:02,345
让我们转到“谷仓”文档

1321
00:59:02,345 --> 00:59:03,609
让我们拿起相机。 

1322
00:59:03,609 --> 00:59:05,252
看到那里的小相机图片吗？ 

1323
00:59:05,252 --> 00:59:06,683
提出来。 

1324
00:59:07,539 --> 00:59:09,655
哦，不，它又崩溃了！ 

1325
00:59:09,655 --> 00:59:10,488
什么？ 

1326
00:59:10,488 --> 00:59:12,325
回头看看，哦，不！ 

1327
00:59:12,325 --> 00:59:13,223
这是什么意思呢？ 

1328
00:59:13,223 --> 00:59:18,138
它说：“此应用程序的Info.plist必须包含NSCameraUsage 

1329
00:59:18,138 --> 00:59:20,692
“使用带有String值的键向用户解释

1330
00:59:20,692 --> 00:59:22,290
“应用程序如何使用这些数据。” 

1331
00:59:22,290 --> 00:59:23,297
那就对了。 

1332
00:59:23,297 --> 00:59:25,040
我们不能随便走

1333
00:59:25,040 --> 00:59:27,589
选择人们的相机和麦克风

1334
00:59:27,589 --> 00:59:29,085
和他们设备上的其他内容。 

1335
00:59:29,085 --> 00:59:31,536
我们需要征求许可。 

1336
00:59:31,536 --> 00:59:33,290
以及部分要求许可

1337
00:59:33,290 --> 00:59:36,977
在解释为什么要使用这个东西。 

1338
00:59:36,977 --> 00:59:40,422
就是说，这里转到Info.plist并添加它。 

1339
00:59:40,422 --> 00:59:43,152
让我们做到这一点，Info.plist。 

1340
00:59:43,152 --> 00:59:45,330
我们向Info.plist添加条目的方式

1341
00:59:45,330 --> 00:59:50,040
我们右键单击并说“添加行”，就在这里， 

1342
00:59:50,040 --> 00:59:51,093
然后我们向下滚动。 

1343
00:59:51,093 --> 00:59:52,177
这是隐私的事

1344
00:59:52,177 --> 00:59:54,840
因此它将在某个地方受到隐私保护。 

1345
00:59:54,840 --> 00:59:57,315
这里是隐私，是的，相机。 

1346
00:59:57,315 --> 00:59:58,880
看到那里，隐私，相机。 

1347
00:59:58,880 --> 01:00:00,076
这里有很多隐私问题。 

1348
01:00:00,076 --> 01:00:01,764
相机是我们想要的。 

1349
01:00:01,764 --> 01:00:05,244
我们只是要解释为什么我们想要相机， 

1350
01:00:05,244 --> 01:00:07,039
为什么我们要使用相机

1351
01:00:07,039 --> 01:00:12,039
我们会说“ EmojiArt让您设置

1352
01:00:12,570 --> 01:00:17,570
“使用相机的文档背景。” 

1353
01:00:17,996 --> 01:00:20,768
这是我们对原因的解释

1354
01:00:20,768 --> 01:00:24,580
EmojiArt希望他们的相机在那里。 

1355
01:00:24,580 --> 01:00:26,313
现在让我们再试一次。 

1356
01:00:30,160 --> 01:00:33,718
我们将再次转到“谷仓”，打相机。 

1357
01:00:33,718 --> 01:00:35,960
现在注意它在问我们

1358
01:00:35,960 --> 01:00:39,225
您要允许用户使用相机吗？ 

1359
01:00:39,225 --> 01:00:42,444
它里面有我们的一点解释。 

1360
01:00:42,444 --> 01:00:43,500
这很棒。 

1361
01:00:43,500 --> 01:00:45,207
因此，我们将说允许。 

1362
01:00:45,207 --> 01:00:48,320
然后让我们在这里拍照。 

1363
01:00:48,320 --> 01:00:49,153
也许现在。 

1364
01:00:51,709 --> 01:00:54,467
我们会说的，我们想使用这张照片。 

1365
01:00:54,467 --> 01:00:55,818
！ 

1366
01:00:55,818 --> 01:00:58,091
这是我们的背景图片。 

1367
01:00:58,091 --> 01:01:00,049
所以相机真的很容易做

1368
01:01:00,049 --> 01:01:01,346
作为照片库。 

1369
01:01:01,346 --> 01:01:02,641
我们只需要确保相机

1370
01:01:02,641 --> 01:01:04,280
实际上可以在我们的设备上使用

1371
01:01:04,280 --> 01:01:07,160
然后向用户提供一些信息

1372
01:01:07,160 --> 01:01:08,593
关于我们为什么要使用它。 

1373
01:01:09,506 --> 01:01:14,506
这就是我们的UIViewControllerRepresentable演示。 

1374
01:01:14,651 --> 01:01:16,570
现在您知道了如何放置两个视图

1375
01:01:16,570 --> 01:01:19,220
和ViewControllers放入您的应用

1376
01:01:19,220 --> 01:01:21,710
这就是我本季度为您准备的一切。 

1377
01:01:21,710 --> 01:01:24,827
因此，现在该轮到您向我们展示您所学的一切

1378
01:01:24,827 --> 01:01:26,798
与您出色的最终项目。 

1379
01:01:26,798 --> 01:01:29,615
我期待着帮助您

1380
01:01:29,615 --> 01:01:31,680
对此有任何疑问。 

1381
01:01:31,680 --> 01:01:34,688
并感谢您收听所有这些讲座。 

1382
01:01:34,688 --> 01:01:38,255
祝您最终的项目顺利。 

1383
01:01:38,255 --> 01:01:41,730
-[女士]有关更多信息，请访问standford.edu。 

