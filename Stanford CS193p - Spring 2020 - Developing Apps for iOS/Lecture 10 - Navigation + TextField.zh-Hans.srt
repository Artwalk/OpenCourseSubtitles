1
00:00:00,167 --> 00:00:03,000
（天体音乐） 

2
00:00:04,920 --> 00:00:06,523
-[旁白]斯坦福大学。 

3
00:00:08,610 --> 00:00:13,280
-[Presenter] 2020年春季斯坦福CS193p讲座10 

4
00:00:13,280 --> 00:00:17,470
完全是关于演示的，今天一直都是演示。 

5
00:00:17,470 --> 00:00:22,200
该演示主要是关于在屏幕上显示视图。 

6
00:00:22,200 --> 00:00:24,790
我们已经知道如何做到这一点。 

7
00:00:24,790 --> 00:00:28,560
ForEach可以在屏幕上和屏幕外显示视图。 

8
00:00:28,560 --> 00:00:31,150
另外，如果ViewBuilders中的if-elses， 

9
00:00:31,150 --> 00:00:33,400
这些使视图来来去去。 

10
00:00:33,400 --> 00:00:36,350
但是现在我们谈论的是大型的View组， 

11
00:00:36,350 --> 00:00:39,400
可能会占据整个屏幕的视图， 

12
00:00:39,400 --> 00:00:43,300
可能是由自己的MVVM驱动的视图，对不对？ 

13
00:00:43,300 --> 00:00:46,460
拥有自己的ViewModel，我们尚未见过

14
00:00:46,460 --> 00:00:49,787
一个具有多个ViewModel的应用， 

15
00:00:49,787 --> 00:00:51,040
但我们今天要看到。 

16
00:00:51,040 --> 00:00:52,853
我们将把Emoji Art推向新的高度。 

17
00:00:52,853 --> 00:00:55,440
它会有多个ViewModel。 

18
00:00:55,440 --> 00:00:59,940
当然，大多数大型程序都有许多ViewModel。 

19
00:00:59,940 --> 00:01:03,260
像往常一样，我在演示中向您展示的这些东西

20
00:01:03,260 --> 00:01:05,150
仅用于介绍

21
00:01:05,150 --> 00:01:08,100
在上下文中为您提供此功能。 

22
00:01:08,100 --> 00:01:10,270
这就是为什么我们要记住和表情符号艺术

23
00:01:10,270 --> 00:01:11,690
所以你有一个背景

24
00:01:11,690 --> 00:01:14,610
以了解向您介绍的此功能。 

25
00:01:14,610 --> 00:01:17,860
仍然无法替代文档， 

26
00:01:17,860 --> 00:01:20,250
阅读有关事物的内容，尝试理解它们。 

27
00:01:20,250 --> 00:01:22,150
这就是为什么我们要您做作业的很多原因， 

28
00:01:22,150 --> 00:01:25,543
所以您必须真正弄清楚如何使用这些东西。 

29
00:01:26,650 --> 00:01:28,450
这是我们今天要做的事情的清单。 

30
00:01:28,450 --> 00:01:30,580
我不会讨论这个，只是为了快速参考， 

31
00:01:30,580 --> 00:01:31,807
你总是可以回去说， 

32
00:01:31,807 --> 00:01:33,980
“我应该从这个演示中学到什么？” 

33
00:01:33,980 --> 00:01:35,767
如您所见，这是一个很长的清单， 

34
00:01:35,767 --> 00:01:39,113
以及该列表中的许多非常重要的内容。 

35
00:01:40,110 --> 00:01:42,573
因此，事不宜迟，让我们开始吧。 

36
00:01:43,560 --> 00:01:47,760
该演示将全部关于在屏幕上显示视图

37
00:01:47,760 --> 00:01:50,850
警报，弹出窗口等等。 

38
00:01:50,850 --> 00:01:53,370
但在我深入探讨之前，我想向您展示

39
00:01:53,370 --> 00:01:56,920
上次我们可以做的一件事

40
00:01:56,920 --> 00:01:59,820
我认为值得展示的只是为了让您了解

41
00:01:59,820 --> 00:02:02,860
这些属性包装器要好一些。 

42
00:02:02,860 --> 00:02:05,840
现在，您还记得我们想初始化

43
00:02:05,840 --> 00:02:09,720
使用我们文档的默认调色板选择的调色板。 

44
00:02:09,720 --> 00:02:13,890
但是我们不能在这里做，因为这个ObservedObject 

45
00:02:13,890 --> 00:02:15,570
是正在初始化的内容的一部分

46
00:02:15,570 --> 00:02:19,710
因此我们无法在初始化期间在此处进行操作。 

47
00:02:19,710 --> 00:02:23,120
现在，事实证明我们也不能在init中真正做到这一点。 

48
00:02:23,120 --> 00:02:26,633
因此，如果我们有一个初始化文档的文件， 

49
00:02:27,965 --> 00:02:32,910
只是说self.document等于那个文件， 

50
00:02:32,910 --> 00:02:37,093
不幸的是，我们什至不能在这里做到这一点。 

51
00:02:38,150 --> 00:02:39,980
您可能认为我们可以做到

52
00:02:39,980 --> 00:02:41,720
因为现在我们有了文件， 

53
00:02:41,720 --> 00:02:43,977
我们可以只设置我们选择的调色板。 

54
00:02:43,977 --> 00:02:47,250
但是事情就在这里，我们正在初始化

55
00:02:47,250 --> 00:02:50,130
这需要初始化。 

56
00:02:50,130 --> 00:02:52,320
我有点惊讶甚至编译

57
00:02:52,320 --> 00:02:54,010
虽然，我可以想象一个很酷的功能

58
00:02:54,010 --> 00:02:57,900
在哪里可以编译并实际工作，但事实并非如此。 

59
00:02:57,900 --> 00:03:00,130
我们在init中必须要做的是

60
00:03:00,130 --> 00:03:02,660
初始化实际变量

61
00:03:02,660 --> 00:03:04,750
由该州创建， 

62
00:03:04,750 --> 00:03:07,070
如果您会记住该变量是什么

63
00:03:07,070 --> 00:03:10,230
其_chosenPalette。 

64
00:03:10,230 --> 00:03:13,550
这个_chosenPalette是State类型的。 

65
00:03:13,550 --> 00:03:14,970
这是国家结构。 

66
00:03:14,970 --> 00:03:17,980
这就是这行代码实际上创建的。 

67
00:03:17,980 --> 00:03:21,070
因此，我们可以通过创建State来对其进行初始化。 

68
00:03:21,070 --> 00:03:23,150
实际上，我们将创建一个州

69
00:03:23,150 --> 00:03:26,410
它的wrapedValue是我们想要的值。 

70
00:03:26,410 --> 00:03:28,673
因此，此文档为默认调色板。 

71
00:03:29,640 --> 00:03:33,520
这是在初始化器中初始化状态的一种方法

72
00:03:33,520 --> 00:03:36,850
通过直接设置此结构。 

73
00:03:36,850 --> 00:03:39,110
希望您不必经常这样做。 

74
00:03:39,110 --> 00:03:41,700
我在想这会是更优雅的方式

75
00:03:41,700 --> 00:03:43,550
在Swift的未来做， 

76
00:03:43,550 --> 00:03:47,420
但这确实向您展示了这是什么， 

77
00:03:47,420 --> 00:03:50,890
它正在创建这个underbar变量，它是其中之一。 

78
00:03:50,890 --> 00:03:52,690
因此，我们实际上不需要onAppear。 

79
00:03:52,690 --> 00:03:54,490
实际上，我们的onAppear在那里工作正常

80
00:03:54,490 --> 00:03:56,840
但这更多是一种有教育意义的事情

81
00:03:56,840 --> 00:03:59,370
有关这些属性包装器发生了什么。 

82
00:03:59,370 --> 00:04:01,220
我希望在本季度末， 

83
00:04:01,220 --> 00:04:03,290
也许我们将创建自己的属性包装器， 

84
00:04:03,290 --> 00:04:05,840
然后我们将真正了解这些内容。 

85
00:04:05,840 --> 00:04:07,187
但与此同时，这应该对您有帮助

86
00:04:07,187 --> 00:04:09,113
了解一点更好。 

87
00:04:11,060 --> 00:04:15,810
现在让我们深入了解我们真正想要构建的是

88
00:04:17,500 --> 00:04:19,430
调色板编辑器。 

89
00:04:19,430 --> 00:04:21,930
所以现在我在这里有这些调色板， 

90
00:04:21,930 --> 00:04:24,710
我可以在它们之间进行选择，但是我无法更改它们， 

91
00:04:24,710 --> 00:04:27,720
无法在此处添加表情符号，无法删除表情符号， 

92
00:04:27,720 --> 00:04:30,610
无法更改此表情的名称。 

93
00:04:30,610 --> 00:04:32,090
所以我想能够做到这一点， 

94
00:04:32,090 --> 00:04:33,890
我想能够编辑它们。 

95
00:04:33,890 --> 00:04:37,570
我将通过在此处提供一个小图标来做到这一点

96
00:04:37,570 --> 00:04:40,057
调色板名称旁边。 

97
00:04:40,057 --> 00:04:42,220
当您触摸该图标时， 

98
00:04:42,220 --> 00:04:43,360
它会带来一些UI 

99
00:04:43,360 --> 00:04:45,810
让您添加和删除表情符号， 

100
00:04:45,810 --> 00:04:47,310
更改名称等等。 

101
00:04:47,310 --> 00:04:49,273
本质上是调色板编辑器。 

102
00:04:50,170 --> 00:04:53,140
让我们开始在这里放置一个小图标。 

103
00:04:53,140 --> 00:04:56,830
现在，我在这里进入了SF Symbols 

104
00:04:56,830 --> 00:04:58,760
我环顾四周，试图决定

105
00:04:58,760 --> 00:05:00,140
这里有什么好图标

106
00:05:00,140 --> 00:05:01,400
可以帮助人们了解

107
00:05:01,400 --> 00:05:03,800
触摸它会做什么？ 

108
00:05:03,800 --> 00:05:07,010
我有点落在键盘上， 

109
00:05:07,010 --> 00:05:08,440
因为他们将要做的大部分

110
00:05:08,440 --> 00:05:12,480
正在使用键盘，表情符号键盘可在此处添加更多表情符号。 

111
00:05:12,480 --> 00:05:14,330
所以我认为那可能很好。 

112
00:05:14,330 --> 00:05:16,150
你知道，当我进入用户测试时

113
00:05:16,150 --> 00:05:18,437
进行焦点小组讨论，我们发现人们就像

114
00:05:18,437 --> 00:05:19,337
“那是什么键盘？ 

115
00:05:19,337 --> 00:05:20,830
“我不知道那是什么。” 

116
00:05:20,830 --> 00:05:23,190
我们甚至可以将其更改为其他内容。 

117
00:05:23,190 --> 00:05:26,380
建立使用者介面时，您无法假设

118
00:05:26,380 --> 00:05:27,970
你将会看到世界

119
00:05:27,970 --> 00:05:30,450
与您的用户完全相同。 

120
00:05:30,450 --> 00:05:34,590
因此，您必须能够适应用户的需求

121
00:05:34,590 --> 00:05:37,700
真正了解您的应用如何工作。 

122
00:05:37,700 --> 00:05:38,533
但是我们将从键盘开始。 

123
00:05:38,533 --> 00:05:40,723
所以我要在那里添加一个小键盘， 

124
00:05:40,723 --> 00:05:43,330
名称后面的键盘图像， 

125
00:05:43,330 --> 00:05:45,050
那真的很容易做到。 

126
00:05:45,050 --> 00:05:46,060
这是我们的名字

127
00:05:46,060 --> 00:05:48,357
这就是正负步进的位置。 

128
00:05:48,357 --> 00:05:52,970
我只是说Image，systemName，使用键盘。 

129
00:05:52,970 --> 00:05:56,410
同样，我在SF Symbols中查找了该键盘。 

130
00:05:56,410 --> 00:05:58,210
而且我还要将其放大。 

131
00:05:58,210 --> 00:06:00,470
我要做这个imageScale.large 

132
00:06:03,000 --> 00:06:04,810
添加此小图像非常简单。 

133
00:06:04,810 --> 00:06:07,140
在那里，就在每个地方。 

134
00:06:07,140 --> 00:06:10,340
当我谈到这一点时，我想要一些UI 

135
00:06:10,340 --> 00:06:13,813
让我编辑此调色板。那么我们该怎么做呢？ 

136
00:06:13,813 --> 00:06:16,290
我们如何做到使之触及某物

137
00:06:16,290 --> 00:06:19,060
导致出现一些UI？ 

138
00:06:19,060 --> 00:06:21,060
在这种情况下，我要使用一个弹出窗口

139
00:06:21,060 --> 00:06:22,650
我们将展示许多不同的方式

140
00:06:22,650 --> 00:06:25,300
提出来，但我要开始做popover。 

141
00:06:25,300 --> 00:06:27,620
因此弹出窗口就像一个小矩形区域

142
00:06:27,620 --> 00:06:29,150
将会出现。 

143
00:06:29,150 --> 00:06:32,460
并指出了引起它的东西。 

144
00:06:32,460 --> 00:06:34,690
这就是我们的小键盘图标

145
00:06:34,690 --> 00:06:35,960
提出来，所以要点

146
00:06:35,960 --> 00:06:37,460
在那个小键盘图标上

147
00:06:37,460 --> 00:06:40,247
这样，当用户启动时，就可以记住

148
00:06:40,247 --> 00:06:42,747
“哦，是的，我点击了那个小键盘图标。 

149
00:06:42,747 --> 00:06:47,480
“这就是这个小用户界面，此视图的出现方式。” 

150
00:06:47,480 --> 00:06:50,130
那么我们如何使弹出窗口出现呢？ 

151
00:06:50,130 --> 00:06:54,440
我们只是在这里转到我们希望它指向的视图

152
00:06:54,440 --> 00:06:58,200
当它出现时，这就是我们的形象，我们说弹出窗口。 

153
00:06:58,200 --> 00:07:01,470
在这里，Popover有四种不同的显示方式。 

154
00:07:01,470 --> 00:07:05,220
其中两个涉及将其传递给可标识的绑定

155
00:07:05,220 --> 00:07:07,600
可识别性将是一种识别

156
00:07:07,600 --> 00:07:09,980
您想在弹出窗口中显示什么内容。 

157
00:07:09,980 --> 00:07:11,460
但是在弹出窗口中很多次

158
00:07:11,460 --> 00:07:12,690
我们正在展示同一件事。 

159
00:07:12,690 --> 00:07:15,460
像我们的情况一样，我们总是显示一个调色板编辑器。 

160
00:07:15,460 --> 00:07:16,760
这就是一切。 

161
00:07:16,760 --> 00:07:19,440
因此，我们可以使用以下两个弹出窗口之一： 

162
00:07:19,440 --> 00:07:21,580
isPresented就在这里。 

163
00:07:21,580 --> 00:07:25,310
这些isPresented版本需要绑定到Bool， 

164
00:07:25,310 --> 00:07:27,990
那个布尔说那个弹出窗口

165
00:07:27,990 --> 00:07:29,980
当前是否显示。 

166
00:07:29,980 --> 00:07:31,570
让我们在这里使用这个， 

167
00:07:31,570 --> 00:07:33,810
我们需要给它绑定布尔。 

168
00:07:33,810 --> 00:07:35,380
我们现在知道如何进行绑定。 

169
00:07:35,380 --> 00:07:38,420
我们创建自己的国家。 

170
00:07:38,420 --> 00:07:40,640
因此，我将在这里建立一个私有国家。 

171
00:07:40,640 --> 00:07:42,773
我称它为showPaletteEditor。 

172
00:07:43,720 --> 00:07:45,940
这是一个布尔，它将开始虚假。 

173
00:07:45,940 --> 00:07:49,010
换句话说，我不希望调色板编辑器显示

174
00:07:49,010 --> 00:07:50,960
当我的视图首次出现时。 

175
00:07:50,960 --> 00:07:52,960
我只是提供一个绑定

176
00:07:52,960 --> 00:07:55,107
这是$ showPaletteEditor。 

177
00:07:55,990 --> 00:07:59,320
请记住，一国的美元具有约束力

178
00:07:59,320 --> 00:08:00,950
达到国家的这一价值。 

179
00:08:00,950 --> 00:08:03,270
现在可以分享这个布尔

180
00:08:03,270 --> 00:08:06,370
和我们之间。 

181
00:08:06,370 --> 00:08:08,110
现在，谁来做什么？ 

182
00:08:08,110 --> 00:08:10,440
好吧，我将其设置为true 

183
00:08:10,440 --> 00:08:12,910
每当我希望此弹出窗口出现时。 

184
00:08:12,910 --> 00:08:14,730
当弹出窗口出现时， 

185
00:08:14,730 --> 00:08:17,880
如果用户点击弹出框之外的其他位置， 

186
00:08:17,880 --> 00:08:21,780
它将设置为false，然后消失。 

187
00:08:21,780 --> 00:08:24,040
所以我们要互相交谈

188
00:08:24,040 --> 00:08:27,453
通过这个布尔值，这个布尔值。 

189
00:08:28,410 --> 00:08:29,390
然后是内容。 

190
00:08:29,390 --> 00:08:31,670
就像这里有内容的其他东西一样， 

191
00:08:31,670 --> 00:08:34,130
我们只是提供一个视图， 

192
00:08:34,130 --> 00:08:36,390
实际上，它可能是一个ViewBuilder。 

193
00:08:36,390 --> 00:08:39,740
在这里，我们想要呈现的观点

194
00:08:39,740 --> 00:08:41,550
是我们的PaletteEditor。 

195
00:08:42,551 --> 00:08:46,600
所以我们将不得不在这里创建我们自己的小视图

196
00:08:46,600 --> 00:08:50,133
编辑调色板，让我们轻松地做到这一点。 

197
00:08:50,133 --> 00:08:51,943
在这里留一些空间。 

198
00:08:53,490 --> 00:08:56,020
我们将说struct PaletteEditor。 

199
00:08:56,930 --> 00:09:01,287
这是一个View，表示它具有var body，其中包含一些View。 

200
00:09:01,287 --> 00:09:04,327
现在，我要说的是

201
00:09:04,327 --> 00:09:08,343
“调色板编辑器”，因为这就是这个东西。 

202
00:09:09,400 --> 00:09:11,710
现在，您可能会想，“好吧，我们明白了。” 

203
00:09:11,710 --> 00:09:13,970
Popover，是的，让我们做，让我们运行， 

204
00:09:13,970 --> 00:09:18,970
我们应该能够以某种方式点击我们的图像并看到它。 

205
00:09:21,090 --> 00:09:23,240
在这里，点击。 

206
00:09:23,240 --> 00:09:26,513
哦，我看不到任何变化，请点击，再点击，再点击。 

207
00:09:27,510 --> 00:09:31,240
那是因为我们从未设置过showPaletteEditor Bool 

208
00:09:32,570 --> 00:09:34,080
确实，它总是错误的。 

209
00:09:34,080 --> 00:09:37,100
因此，这意味着永远不会显示弹出窗口。 

210
00:09:37,100 --> 00:09:39,310
因此，弹出窗口的操作完全正确。 

211
00:09:39,310 --> 00:09:41,240
请记住，这是声明性UI， 

212
00:09:41,240 --> 00:09:44,140
我们只是声明应该显示一个弹出窗口， 

213
00:09:44,140 --> 00:09:46,810
如果为真，则应显示在弹出窗口中， 

214
00:09:46,810 --> 00:09:48,543
但我们从未将其设置为true。 

215
00:09:49,410 --> 00:09:50,790
不过，这很容易做到。 

216
00:09:50,790 --> 00:09:53,710
此图片的OnTapGesture， 

217
00:09:53,710 --> 00:09:57,190
self.showPalettEditor等于true。 

218
00:09:57,190 --> 00:09:59,300
因此，当您点击此处的此键盘时， 

219
00:09:59,300 --> 00:10:01,540
我将其设置为true。 

220
00:10:01,540 --> 00:10:04,480
我们宣布该弹出窗口应出现

221
00:10:04,480 --> 00:10:06,353
发生这种情况时，请参阅此工作。 

222
00:10:09,143 --> 00:10:10,669
我们走了，准备好了吗？ 

223
00:10:10,669 --> 00:10:13,220
哔，这是我们的调色板编辑器。 

224
00:10:13,220 --> 00:10:15,220
所以我点击了这个，我将其设置为true 

225
00:10:15,220 --> 00:10:17,960
并声明弹出窗口显示

226
00:10:17,960 --> 00:10:18,930
当那件事是真的。 

227
00:10:18,930 --> 00:10:22,750
同样，当我单击该处以外的其他任何地方时， 

228
00:10:22,750 --> 00:10:26,520
boop，弹出框将该变量设置回false。 

229
00:10:26,520 --> 00:10:30,240
这就是我们再次相互交流的方式。 

230
00:10:30,240 --> 00:10:33,790
并看到弹出框顶部的小三角形

231
00:10:33,790 --> 00:10:36,530
向用户显示他们所触摸的内容

232
00:10:36,530 --> 00:10:38,940
使该弹出窗口出现

233
00:10:38,940 --> 00:10:43,340
您可以设置该箭头的允许方向

234
00:10:43,340 --> 00:10:45,230
而且有些控制

235
00:10:45,230 --> 00:10:47,830
您的弹出窗口允许出现的位置。 

236
00:10:47,830 --> 00:10:50,160
该系统将尝试并适合弹出窗口

237
00:10:50,160 --> 00:10:53,130
并遵循所需的箭头方向。 

238
00:10:53,130 --> 00:10:56,380
顺便说一下，弹出窗口几乎是iPad上的东西

239
00:10:56,380 --> 00:10:59,810
因为iPhone上确实没有太多空间， 

240
00:10:59,810 --> 00:11:02,130
但我们会看到iPhone适应了

241
00:11:02,130 --> 00:11:04,420
而且仍然可以显示弹出窗口

242
00:11:04,420 --> 00:11:05,693
但它不会显示为弹出窗口， 

243
00:11:05,693 --> 00:11:07,760
它只是使用全屏。 

244
00:11:07,760 --> 00:11:09,310
我们会看到一点。 

245
00:11:10,720 --> 00:11:12,450
好的，现在我们应该可以进行编辑了

246
00:11:12,450 --> 00:11:15,440
我们想要的任何这些调色板。 

247
00:11:15,440 --> 00:11:17,820
不过，在我们到达这里之前， 

248
00:11:17,820 --> 00:11:20,360
我想让这个弹窗大很多。 

249
00:11:20,360 --> 00:11:21,230
您会看到它很小， 

250
00:11:21,230 --> 00:11:23,940
它正在调整自身大小以适合我们的内容， 

251
00:11:23,940 --> 00:11:27,077
这实际上很好，这是popover的一个很酷的功能。 

252
00:11:27,077 --> 00:11:28,530
我们可以在此处放置一些填充。 

253
00:11:28,530 --> 00:11:30,210
但是，不只是放置填充， 

254
00:11:30,210 --> 00:11:31,360
我想腾出一些空间。 

255
00:11:31,360 --> 00:11:34,050
因此，当我构建用户界面时，您将有一个更好的主意

256
00:11:34,050 --> 00:11:36,840
最终将是什么样子。 

257
00:11:36,840 --> 00:11:39,840
扩大空间，扩大空间， 

258
00:11:39,840 --> 00:11:40,913
我们可以再次尝试做

259
00:11:40,913 --> 00:11:42,680
如果我在它周围放一些填充物， 

260
00:11:42,680 --> 00:11:44,410
那会使它更大一点。 

261
00:11:44,410 --> 00:11:48,070
但是相反，我将制作整个调色板编辑器

262
00:11:48,070 --> 00:11:50,340
最小尺寸。 

263
00:11:50,340 --> 00:11:53,360
我们使用.frame做到这一点，我们之前已经看过.frame。 

264
00:11:53,360 --> 00:11:54,747
正如我之前告诉你的

265
00:11:54,747 --> 00:11:56,627
.frame这里有很多争论

266
00:11:56,627 --> 00:12:00,400
我们将使用minWidth和minHeight参数。 

267
00:12:00,400 --> 00:12:03,740
所以这是minWidth，可能是300宽， 

268
00:12:03,740 --> 00:12:08,063
和minHeight，大约是500。 

269
00:12:09,230 --> 00:12:13,200
看起来不错，好多了！ 

270
00:12:13,200 --> 00:12:15,780
因此，我们在这里有足够的回旋余地。 

271
00:12:15,780 --> 00:12:19,350
一旦我以所需的方式获得了该用户界面， 

272
00:12:19,350 --> 00:12:21,590
我不需要minWidth。 

273
00:12:21,590 --> 00:12:23,420
但是我也总是可以把它留在那里

274
00:12:23,420 --> 00:12:25,763
取决于我希望我的UI外观如何。 

275
00:12:26,920 --> 00:12:29,280
我们想编辑这个调色板

276
00:12:29,280 --> 00:12:33,210
因此，请确保我们可以转移此调色板

277
00:12:33,210 --> 00:12:35,563
进入此编辑器，以便可以对其进行编辑。 

278
00:12:37,970 --> 00:12:40,830
为此，我要输入文本：“调色板编辑器”。 

279
00:12:40,830 --> 00:12:42,990
我要放一点分频器

280
00:12:42,990 --> 00:12:46,683
现在我要放置我选择的调色板的文本。 

281
00:12:47,810 --> 00:12:49,730
我想要这个选择的调色板就在这里

282
00:12:49,730 --> 00:12:52,930
与此处选择的调色板相同

283
00:12:52,930 --> 00:12:55,030
所以我们将编辑选择的任何内容

284
00:12:55,030 --> 00:12:56,410
我们在这里显示。 

285
00:12:56,410 --> 00:12:59,140
为此，我将创建一个绑定

286
00:13:00,070 --> 00:13:02,260
选择palette。 

287
00:13:02,260 --> 00:13:05,080
请注意，我给这个名字完全相同， 

288
00:13:05,080 --> 00:13:07,430
就像我在这里给它的一样

289
00:13:07,430 --> 00:13:08,970
我们在这里给它。 

290
00:13:08,970 --> 00:13:10,640
但是没有规则，没有法律

291
00:13:10,640 --> 00:13:12,180
表示必须具有相同的名称。 

292
00:13:12,180 --> 00:13:15,410
如果需要，我们可以将其称为正在编辑的调色板， 

293
00:13:15,410 --> 00:13:18,040
像这样的东西，但是我们经常给它们起同样的名字

294
00:13:18,040 --> 00:13:19,790
这样才不会让人很困惑

295
00:13:19,790 --> 00:13:22,810
因为我们将它们直接绑定在一起。 

296
00:13:22,810 --> 00:13:25,743
因此，它们基本上都是同一件事。 

297
00:13:27,320 --> 00:13:30,010
因此，我们可以在此处使用此selectedPalette。 

298
00:13:30,010 --> 00:13:32,243
让我们将这些东西放入VStack中。 

299
00:13:36,790 --> 00:13:38,767
而且我们看到这里有一个错误， 

300
00:13:38,767 --> 00:13:41,660
“缺少参数selectedPalette的参数。” 

301
00:13:41,660 --> 00:13:44,710
在我们的PaletteEditor中，这是一个未初始化的变量。 

302
00:13:44,710 --> 00:13:47,393
因此，我们必须对其进行初始化：selectedPalette。 

303
00:13:48,924 --> 00:13:52,475
以及我们如何对我们选择的调色板进行绑定， 

304
00:13:52,475 --> 00:13:54,920
$ chosenPalette。 

305
00:13:54,920 --> 00:13:58,510
而且这里的selectedPalette实际上是一个Binding本身。 

306
00:13:58,510 --> 00:14:00,910
在这里与这个国家绑定

307
00:14:00,910 --> 00:14:03,233
我们的文档View，这个@State。 

308
00:14:04,070 --> 00:14:07,310
但是我们知道，如果我们在绑定上进行美元交易， 

309
00:14:07,310 --> 00:14:10,770
那本质上是回归自我，好吧， 

310
00:14:10,770 --> 00:14:13,480
绑定本身或对事物的绑定

311
00:14:13,480 --> 00:14:16,500
绑定是绑定到任何一种方式。 

312
00:14:16,500 --> 00:14:17,800
这正是我们想要的。 

313
00:14:17,800 --> 00:14:19,270
因此，我们需要此绑定和该状态。 

314
00:14:19,270 --> 00:14:24,270
因此，现在有三个视图共享相同的值。 

315
00:14:24,380 --> 00:14:26,750
让我们确保这确实有效。 

316
00:14:27,943 --> 00:14:30,860
我要触摸此键盘。 

317
00:14:30,860 --> 00:14:31,777
哇！在那里。 

318
00:14:31,777 --> 00:14:33,700
它在这里显示了这一点。 

319
00:14:33,700 --> 00:14:36,450
让我们去一个不同的地方，触摸它， 

320
00:14:36,450 --> 00:14:37,810
哇，正在显示它。 

321
00:14:37,810 --> 00:14:41,690
因此，我们的“调色板编辑器”绝对掌握了该调色板

322
00:14:41,690 --> 00:14:43,963
应该在这里编辑。 

323
00:14:45,120 --> 00:14:48,000
我将为此做一些工作。 

324
00:14:48,000 --> 00:14:50,100
我想要这个东西说，“ Palette Editor” 

325
00:14:50,100 --> 00:14:51,910
真的像在顶部

326
00:14:51,910 --> 00:14:56,720
像是某种标题或我的小观点

327
00:14:56,720 --> 00:14:58,620
而不是像这样放在中间。 

328
00:14:58,620 --> 00:15:01,493
因此，让我们真正快速地进行布局。 

329
00:15:03,008 --> 00:15:06,230
我要让这个标题更多

330
00:15:06,230 --> 00:15:08,860
标题类型的字体标题。 

331
00:15:08,860 --> 00:15:11,620
我会给它一些填充。 

332
00:15:11,620 --> 00:15:13,620
然后，让它到达顶部

333
00:15:13,620 --> 00:15:15,720
通过在底部放置一个垫片

334
00:15:15,720 --> 00:15:18,250
只是在其中放了一大堆空间。 

335
00:15:18,250 --> 00:15:20,233
让我们看看它是什么样子。 

336
00:15:24,084 --> 00:15:25,580
看，靠近。 

337
00:15:25,580 --> 00:15:27,650
这里的间距有点大

338
00:15:27,650 --> 00:15:29,210
我们得到了周围的填充

339
00:15:29,210 --> 00:15:32,360
然后我们得到了VStack的间距， 

340
00:15:32,360 --> 00:15:34,050
这样我们就可以摆脱它。 

341
00:15:38,487 --> 00:15:40,040
但是如果我没有间距， 

342
00:15:40,040 --> 00:15:43,983
也许我希望这个东西有自己的填充物。 

343
00:15:49,374 --> 00:15:51,960
好吧，那看起来很棒。 

344
00:15:51,960 --> 00:15:53,310
我们有了调色板编辑器。 

345
00:15:53,310 --> 00:15:55,650
现在这将是

346
00:15:55,650 --> 00:15:56,773
编辑调色板。 

347
00:15:57,930 --> 00:16:01,520
让我们从编辑调色板的名称开始。 

348
00:16:01,520 --> 00:16:02,840
所以现在我们看到了调色板

349
00:16:02,840 --> 00:16:04,860
但我实际上想在这里看到它的名字。 

350
00:16:04,860 --> 00:16:06,740
然后我们要使其可编辑

351
00:16:06,740 --> 00:16:08,770
这样您就可以从活动中更改

352
00:16:08,770 --> 00:16:11,030
如果需要的话。 

353
00:16:11,030 --> 00:16:12,940
那么我们该怎么做呢？ 

354
00:16:12,940 --> 00:16:14,560
好吧，与其显示调色板， 

355
00:16:14,560 --> 00:16:15,900
我想显示它的名字。 

356
00:16:15,900 --> 00:16:17,760
我们在这里进行所有操作。 

357
00:16:17,760 --> 00:16:20,700
这就是此文档的paletteNames。 

358
00:16:20,700 --> 00:16:24,307
我什至要复制该代码并将其放在此处。 

359
00:16:24,307 --> 00:16:28,310
问题是，我们这里没有文件，对吗？ 

360
00:16:28,310 --> 00:16:32,210
我们在这里有文件，但在这里没有文件。 

361
00:16:32,210 --> 00:16:34,717
您可能会第一个倾向是， 

362
00:16:34,717 --> 00:16:36,557
“哦，让我们创建另一个绑定

363
00:16:36,557 --> 00:16:39,010
“我们会绑在这里。” 

364
00:16:39,010 --> 00:16:42,410
但这不是我们共享ViewModels的方式。 

365
00:16:42,410 --> 00:16:44,527
本文档是我们的ViewModel。 

366
00:16:44,527 --> 00:16:48,823
相反，我们将使用EnvironmentObject共享它。 

367
00:16:51,392 --> 00:16:54,500
因此我们的文档将是一个EnvironmentObject。 

368
00:16:54,500 --> 00:16:57,240
我们将用EnvironmentObject这样做

369
00:16:57,240 --> 00:17:00,760
因为我们在单独的视图中展示了这个东西。 

370
00:17:00,760 --> 00:17:03,260
每当我们要在弹出窗口中展示一些东西时， 

371
00:17:03,260 --> 00:17:05,030
或任何单独的视图， 

372
00:17:05,030 --> 00:17:09,730
我们想使用EnvironmentObject传递ViewModel。 

373
00:17:09,730 --> 00:17:12,000
我们可以将其作为ObservedObject传递

374
00:17:12,000 --> 00:17:15,410
然后在此处为PaletteEditor提供另一个参数。 

375
00:17:15,410 --> 00:17:17,600
但是结果出了问题

376
00:17:17,600 --> 00:17:19,670
当您执行这些单独的视图时

377
00:17:19,670 --> 00:17:22,290
像弹出式窗口之类的东西。 

378
00:17:22,290 --> 00:17:24,960
他们拥有自己的生活世界

379
00:17:24,960 --> 00:17:28,900
而您必须将这个ViewModel传递到那个世界， 

380
00:17:28,900 --> 00:17:32,000
否则，它将无法正常运行。 

381
00:17:32,000 --> 00:17:35,040
那么我们如何在这里设置环境？ 

382
00:17:35,040 --> 00:17:38,017
我们使用此.environmentObject。 

383
00:17:40,896 --> 00:17:42,803
再一次，我们在幻灯片中看到了这一点， 

384
00:17:42,803 --> 00:17:45,200
这就是我们通过环境的方式。 

385
00:17:45,200 --> 00:17:47,670
在这种情况下，这只是我们自己的文件

386
00:17:47,670 --> 00:17:50,970
作为环境被传递。 

387
00:17:50,970 --> 00:17:52,830
这些环境对象

388
00:17:52,830 --> 00:17:55,200
以及@Environment在一定程度上

389
00:17:55,200 --> 00:17:58,080
它们的名字确实暗示着： 

390
00:17:58,080 --> 00:18:01,490
该视图在其中运行的环境。 

391
00:18:01,490 --> 00:18:03,810
正确，正在使用，正在环境中工作

392
00:18:03,810 --> 00:18:07,033
这实际上是他们的ViewModel。 

393
00:18:08,270 --> 00:18:09,217
现在我们有了文件

394
00:18:09,217 --> 00:18:11,570
我们应该能够在那里得到这个名字。 

395
00:18:11,570 --> 00:18:13,120
让我们看看它是什么样的。 

396
00:18:17,554 --> 00:18:20,230
好的，这是我们的活动面板， 

397
00:18:20,230 --> 00:18:21,830
当然可以，我们在那里。 

398
00:18:21,830 --> 00:18:24,440
让我们再尝试一个，我们的动物呢？ 

399
00:18:24,440 --> 00:18:25,633
是的，动物。 

400
00:18:26,860 --> 00:18:30,860
我们的下一步是使这些动物可编辑。 

401
00:18:30,860 --> 00:18:33,340
我们希望能够改变这种动物

402
00:18:33,340 --> 00:18:34,810
成为别的东西。 

403
00:18:34,810 --> 00:18:38,450
那么我们如何使此文本可编辑？ 

404
00:18:38,450 --> 00:18:41,720
为此，我们需要的视图与文本稍有不同。 

405
00:18:41,720 --> 00:18:44,403
我们需要一个TextField。 

406
00:18:45,280 --> 00:18:49,230
TextField需要一些不同的参数

407
00:18:49,230 --> 00:18:50,530
比文字。 

408
00:18:50,530 --> 00:18:53,780
它采用的第一个参数是其标签， 

409
00:18:53,780 --> 00:18:56,800
它应该描述它是什么

410
00:18:56,800 --> 00:18:58,990
该TextField正在编辑。 

411
00:18:58,990 --> 00:19:00,320
在我们的情况下，这将是

412
00:19:00,320 --> 00:19:01,750
编辑调色板的名称， 

413
00:19:01,750 --> 00:19:03,490
所以我们要说“ Palette Name”。 

414
00:19:03,490 --> 00:19:06,380
我们将在UI中看到该标签的显示位置。 

415
00:19:06,380 --> 00:19:09,170
这取决于UI，这将适应

416
00:19:09,170 --> 00:19:12,830
到Apple TV，Apple Watch，iOS，Mac， 

417
00:19:12,830 --> 00:19:15,277
它会在这里做正确的事。 

418
00:19:15,277 --> 00:19:16,830
然后是第二个参数

419
00:19:16,830 --> 00:19:20,997
TextField中最重要的参数称为文本。 

420
00:19:20,997 --> 00:19:25,750
它是对某些字符串的绑定， 

421
00:19:25,750 --> 00:19:29,100
那将是正在编辑的内容。 

422
00:19:29,100 --> 00:19:32,680
这就是TextField实际正在编辑的内容。 

423
00:19:32,680 --> 00:19:34,630
所以我们需要，这将是一个绑定。 

424
00:19:34,630 --> 00:19:38,340
所以我要在这里做一个State私有变量， 

425
00:19:38,340 --> 00:19:41,540
叫我的paletteName，它将是一个字符串。 

426
00:19:41,540 --> 00:19:44,263
我们将其初始化为空开始。 

427
00:19:45,320 --> 00:19:48,380
这就是TextField要做的就是对其进行编辑。 

428
00:19:48,380 --> 00:19:50,070
让我们看看这个UI的样子

429
00:19:50,070 --> 00:19:52,673
用TextField代替Text。 

430
00:19:53,794 --> 00:19:54,960
开始了。 

431
00:19:54,960 --> 00:19:58,110
糟糕，您可以在其中看到“ Palette Name”。 

432
00:19:58,110 --> 00:20:01,050
现在，当我触摸它时，它开始编辑， 

433
00:20:01,050 --> 00:20:03,400
你可以看到它弹出了键盘

434
00:20:03,400 --> 00:20:08,400
我可以输入“你好”，或任何我想要的

435
00:20:08,450 --> 00:20:10,360
作为我的调色板的名称。 

436
00:20:10,360 --> 00:20:13,240
因此，我们看到的标签是“ Palette Name” 

437
00:20:13,240 --> 00:20:17,140
它只有在我们什么都没有的时候才出现

438
00:20:17,140 --> 00:20:18,940
当字段完全为空时。 

439
00:20:19,840 --> 00:20:21,970
现在通常不会在这里发生

440
00:20:21,970 --> 00:20:26,970
因为当我们第一次针对某个给定的调色板提出这个问题时， 

441
00:20:27,210 --> 00:20:30,260
这可能应该预先填写

442
00:20:30,260 --> 00:20:33,060
当前名称是什么

443
00:20:33,060 --> 00:20:35,230
而且只有在该人

444
00:20:35,230 --> 00:20:38,090
删除，删除，删除并使其消失， 

445
00:20:38,090 --> 00:20:40,120
然后，好吧，这个领域是关于什么的？ 

446
00:20:40,120 --> 00:20:41,880
他们会找到有关“调色板名称”的信息。 

447
00:20:41,880 --> 00:20:45,660
但是如果我去面对很明显

448
00:20:45,660 --> 00:20:49,120
然后触摸调色板旁边的按钮

449
00:20:49,120 --> 00:20:52,313
它说在这里的面孔，那将是名字。 

450
00:20:53,150 --> 00:20:54,210
在iOS中

451
00:20:54,210 --> 00:20:56,880
我们尽量不要有很多无关的标签

452
00:20:56,880 --> 00:20:59,210
诸如此类的事情是不必要的。 

453
00:20:59,210 --> 00:21:01,640
在这种情况下，绝对不需要在这里

454
00:21:01,640 --> 00:21:03,880
除非有人将其全部删除

455
00:21:03,880 --> 00:21:06,460
然后他们可能会说：“哦，等等，这又是什么？” 

456
00:21:06,460 --> 00:21:07,990
然后提示他们

457
00:21:07,990 --> 00:21:09,933
这是一种很酷的用户界面。 

458
00:21:11,470 --> 00:21:15,420
那么我们如何得到这个说出的面孔

459
00:21:15,420 --> 00:21:17,690
在这里而不是空白？ 

460
00:21:17,690 --> 00:21:20,040
好吧，因为我们是州，所以这个paletteName 

461
00:21:20,040 --> 00:21:22,440
我们正在编辑的字符串

462
00:21:22,440 --> 00:21:25,670
我们将其初始化为虚无。 

463
00:21:25,670 --> 00:21:27,550
所以我们需要初始化它

464
00:21:27,550 --> 00:21:30,630
是调色板的名称，对不对？ 

465
00:21:30,630 --> 00:21:32,910
我们在这里有这个东西

466
00:21:32,910 --> 00:21:36,165
我们最初在那个TextField中拥有的。 

467
00:21:36,165 --> 00:21:38,380
我要用onAppear做到这一点， 

468
00:21:38,380 --> 00:21:41,730
onAppear，我们真的很希望这样做。 

469
00:21:41,730 --> 00:21:44,680
我只是要设置我的paletteName 

470
00:21:45,780 --> 00:21:48,400
等于我的文档的调色板名称。 

471
00:21:48,400 --> 00:21:49,910
再说一次，我可以初始化它

472
00:21:49,910 --> 00:21:52,130
以我们在本课开始时展示的方式

473
00:21:52,130 --> 00:21:54,763
但这是在这里做的一种非常好的方法。 

474
00:21:58,860 --> 00:22:00,930
是的，还有活动， 

475
00:22:00,930 --> 00:22:03,520
并且仍然可以编辑，可以单击它并对其进行编辑， 

476
00:22:03,520 --> 00:22:05,920
走过去这里的动物，是的。 

477
00:22:05,920 --> 00:22:07,600
调出键盘。 

478
00:22:07,600 --> 00:22:08,920
注意何时调出键盘

479
00:22:08,920 --> 00:22:12,700
它确实将UI的胸部向上滚动了一点

480
00:22:12,700 --> 00:22:16,670
这样就不会被键盘挡住。 

481
00:22:16,670 --> 00:22:20,970
当我们触摸以开始在iOS中进行编辑时，这一点非常重要， 

482
00:22:20,970 --> 00:22:23,800
特别是在空间有限的iPhone上

483
00:22:23,800 --> 00:22:25,350
和键盘出现

484
00:22:25,350 --> 00:22:26,990
将掩盖很多事情。 

485
00:22:26,990 --> 00:22:29,550
我们希望它向上滚动到可编辑的位置， 

486
00:22:29,550 --> 00:22:32,073
因此它会自动为我们做到这一点。 

487
00:22:33,560 --> 00:22:34,677
现在，如果我更改了该怎么办？ 

488
00:22:34,677 --> 00:22:39,677
如果我将其从动物改为野兽，该怎么办？ 

489
00:22:43,810 --> 00:22:46,390
如果我说动物就是野兽， 

490
00:22:46,390 --> 00:22:48,330
它并没有改变任何东西。 

491
00:22:48,330 --> 00:22:51,330
这里仍然说动物，但是说野兽。 

492
00:22:51,330 --> 00:22:53,730
现在，它仍然说动物，现在我明白了， 

493
00:22:53,730 --> 00:22:56,410
它从未改变过，为什么它从未改变过？ 

494
00:22:56,410 --> 00:23:00,450
好吧，当我们在这里编辑文本字段时， 

495
00:23:00,450 --> 00:23:03,090
我们正在编辑该本地州。 

496
00:23:03,090 --> 00:23:06,730
我们不会在任何地方重新编辑文档。 

497
00:23:06,730 --> 00:23:10,300
因此，当此更改时，只要此TextField更改， 

498
00:23:10,300 --> 00:23:14,400
我们需要为此设置文档的调色板名称， 

499
00:23:14,400 --> 00:23:17,000
将该调色板重命名为该调色板。 

500
00:23:17,000 --> 00:23:18,803
我们使用另一个TextField参数， 

501
00:23:18,803 --> 00:23:21,240
它叫做onEditingChanged， 

502
00:23:22,269 --> 00:23:24,070
而且只需要一点关闭即可。 

503
00:23:24,070 --> 00:23:28,730
现在，这种关闭开始有一个论点，我通常称之为它。 

504
00:23:28,730 --> 00:23:30,930
此参数是编辑是否更改

505
00:23:30,930 --> 00:23:34,300
因为编辑是从TextField开始的

506
00:23:34,300 --> 00:23:35,980
还是因为它结束了。 

507
00:23:35,980 --> 00:23:38,460
因此，这是开始还是结束。 

508
00:23:38,460 --> 00:23:41,740
因此，在我们的情况下，我们只想更新调色板的名称

509
00:23:41,740 --> 00:23:44,060
或在编辑结束时重命名我们的调色板。 

510
00:23:44,060 --> 00:23:48,147
所以我要说如果开始，那我该怎么办？ 

511
00:23:48,147 --> 00:23:53,147
我要告诉我的文档重命名此调色板， 

512
00:23:53,610 --> 00:23:57,730
选择到该名称的调色板

513
00:23:57,730 --> 00:23:59,963
这是paletteName。 

514
00:24:02,090 --> 00:24:04,870
就这么简单，我要重命名我的调色板

515
00:24:04,870 --> 00:24:06,800
所以我的文件得到消息

516
00:24:06,800 --> 00:24:08,573
我们刚刚编辑了这个东西。 

517
00:24:13,210 --> 00:24:14,920
所以我仍然可以通过这里。 

518
00:24:14,920 --> 00:24:18,980
现在，如果我想将动物重命名为野兽，我可以选择动物

519
00:24:18,980 --> 00:24:21,050
在此处单击它，上面写着“动物”。 

520
00:24:21,050 --> 00:24:22,663
我们将在这里备份。 

521
00:24:23,530 --> 00:24:25,763
我们将输入“ Beasts”。 

522
00:24:28,330 --> 00:24:30,850
我们已经完成了编辑，我们可以在此处关闭键盘， 

523
00:24:30,850 --> 00:24:33,600
或者我们可以点击离开。 

524
00:24:33,600 --> 00:24:34,830
我们正在更改它，看到了吗？ 

525
00:24:34,830 --> 00:24:36,450
当我们在那里完成编辑时， 

526
00:24:36,450 --> 00:24:39,383
编辑完成后，它就改变了。 

527
00:24:40,950 --> 00:24:42,990
现在让我们使用另一个TextField， 

528
00:24:42,990 --> 00:24:44,780
以便在此处添加表情符号。 

529
00:24:44,780 --> 00:24:47,935
我们想将表情符号添加到我们的列表中。 

530
00:24:47,935 --> 00:24:49,010
太相似了

531
00:24:49,010 --> 00:24:51,670
我实际上将在这里使用此TextField 

532
00:24:52,510 --> 00:24:55,920
并复制并粘贴它，并创建另一个TextField。 

533
00:24:55,920 --> 00:24:59,810
这是“添加表情符号”文本字段，即其标签。 

534
00:24:59,810 --> 00:25:01,530
无需编辑paletteName， 

535
00:25:01,530 --> 00:25:04,417
我们将编辑$ emojisToAdd之类的东西。 

536
00:25:05,750 --> 00:25:10,080
当这一更改发生时，无需重命名调色板， 

537
00:25:10,080 --> 00:25:15,080
我们将要求我们的文档添加表情符号， 

538
00:25:15,620 --> 00:25:17,800
这些表情符号添加

539
00:25:19,440 --> 00:25:21,053
这个调色板

540
00:25:23,564 --> 00:25:24,731
selectedPalette。 

541
00:25:25,880 --> 00:25:28,370
当然，将表情符号添加到我们选择的面板中

542
00:25:28,370 --> 00:25:30,920
将会改变我们的选择面板。 

543
00:25:30,920 --> 00:25:34,410
因此，我们将更新我们自己的州来做到这一点。 

544
00:25:34,410 --> 00:25:39,410
而且，我们将此处的emojisToAdd设置为空

545
00:25:40,570 --> 00:25:42,760
因为我们刚刚添加了这些表情符号， 

546
00:25:42,760 --> 00:25:46,227
我们真的不需要将它们留在emojisToAdd中， 

547
00:25:46,227 --> 00:25:47,500
我们不会再添加它们。 

548
00:25:47,500 --> 00:25:50,820
实际上，我的文档中的addEmoji 

549
00:25:50,820 --> 00:25:52,800
不允许您两次添加相同的表情符号。 

550
00:25:52,800 --> 00:25:54,830
它只是将表情符号移到列表的最前面

551
00:25:54,830 --> 00:25:56,790
如果您添加两次。 

552
00:25:56,790 --> 00:25:58,730
当然，我们也需要这个国家。 

553
00:25:58,730 --> 00:26:02,473
因此，在@State private var emojisToAdd。 

554
00:26:03,982 --> 00:26:07,093
这是一个字符串，我们也将以空字符串开头。 

555
00:26:08,791 --> 00:26:09,763
让我们看看这个。 

556
00:26:13,508 --> 00:26:15,677
和活动，那里！ 

557
00:26:17,030 --> 00:26:18,800
因此，让我们单击此处添加一些表情符号， 

558
00:26:18,800 --> 00:26:23,010
我们将转到表情符号键盘，所有iOS键盘都有。 

559
00:26:23,010 --> 00:26:25,870
这是活动，所以让我们继续我们的活动。 

560
00:26:25,870 --> 00:26:29,089
也许我们在这里增加了一些自行车骑手。 

561
00:26:29,089 --> 00:26:30,263
然后是高尔夫球手。 

562
00:26:35,167 --> 00:26:38,200
在那里，将其添加到我们的文档中， 

563
00:26:38,200 --> 00:26:39,180
没问题。 

564
00:26:46,321 --> 00:26:47,238
雪边界。 

565
00:26:49,110 --> 00:26:49,943
射箭。 

566
00:26:56,050 --> 00:26:58,150
当我们开始拥有UI时， 

567
00:26:58,150 --> 00:26:59,960
在这里添加了很多东西。 

568
00:26:59,960 --> 00:27:01,390
我们甚至还要添加另一部分

569
00:27:01,390 --> 00:27:03,010
用于删除表情符号。 

570
00:27:03,010 --> 00:27:06,870
我们不希望它们在外太空开放

571
00:27:06,870 --> 00:27:11,870
只是间隔开，对它们没有任何凝聚力或没有形式。 

572
00:27:12,560 --> 00:27:14,750
因此，有一个很棒的小视图

573
00:27:14,750 --> 00:27:16,600
你可以用来给

574
00:27:16,600 --> 00:27:21,600
一组类似于这种形式的字段，称为“表单”。 

575
00:27:22,350 --> 00:27:25,653
因此，我们将围绕此表单。 

576
00:27:25,653 --> 00:27:28,373
这就是放置表单的外观。 

577
00:27:29,285 --> 00:27:33,403
我们将Form放在这两个TextField的周围。 

578
00:27:35,220 --> 00:27:37,070
关于Form的一件好事

579
00:27:37,070 --> 00:27:39,710
它是自动滚动空间吗

580
00:27:39,710 --> 00:27:41,410
这将处理事实

581
00:27:41,410 --> 00:27:42,370
我们在底部有空间

582
00:27:42,370 --> 00:27:44,770
因此我们在那里不再需要垫片。 

583
00:27:44,770 --> 00:27:48,190
表单将使用其所有空间，这是这些视图之一

584
00:27:48,190 --> 00:27:50,210
占用所有提供的空间。 

585
00:27:50,210 --> 00:27:52,130
我们不在那儿使用Spacer。 

586
00:27:52,130 --> 00:27:54,170
表格也可以分为几节。 

587
00:27:54,170 --> 00:27:56,670
例如，我们可以在这里有一个Section 

588
00:27:56,670 --> 00:28:00,640
这是我们的“调色板名称”部分。 

589
00:28:05,300 --> 00:28:06,570
我们也不需要填充

590
00:28:06,570 --> 00:28:08,910
表单负责所有填充， 

591
00:28:08,910 --> 00:28:11,703
它本身在布置所有这些东西。 

592
00:28:11,703 --> 00:28:14,650
在此还有另一个栏目，也许这个栏目没有标题， 

593
00:28:14,650 --> 00:28:16,363
这也是允许的。 

594
00:28:18,340 --> 00:28:19,190
让我们看看它是什么样子。 

595
00:28:19,190 --> 00:28:23,490
因此，我们在此处的面板中添加了一个用于调色板名称的表格

596
00:28:23,490 --> 00:28:25,523
和“添加表情符号”部分。 

597
00:28:29,353 --> 00:28:30,810
（叹气）看看我们的表格。 

598
00:28:30,810 --> 00:28:33,010
您以前可能已经看过这样的表格， 

599
00:28:33,010 --> 00:28:34,490
甚至在“设置”应用中

600
00:28:34,490 --> 00:28:36,930
我们已经看到了这种外观。 

601
00:28:36,930 --> 00:28:38,580
现在，实际上有点多余， 

602
00:28:38,580 --> 00:28:42,110
在此处具有板块标题名称

603
00:28:42,110 --> 00:28:45,440
当我们知道如果将其编辑为零时

604
00:28:45,440 --> 00:28:47,470
我们也将在那里获得“调色板名称”。 

605
00:28:47,470 --> 00:28:50,660
所以我可能不会有完全相同的标题

606
00:28:50,660 --> 00:28:52,463
名称为其中的TextField。 

607
00:28:53,391 --> 00:28:54,900
实际上，我什至不确定

608
00:28:54,900 --> 00:28:57,210
我将把这两个部分分开。 

609
00:28:57,210 --> 00:29:00,323
我可以将它们放在同一部分中。 

610
00:29:03,470 --> 00:29:07,273
使其UI更加整洁，您可以看到它仍然放在

611
00:29:07,273 --> 00:29:09,990
有点特殊的分隔线

612
00:29:09,990 --> 00:29:13,203
我仍然可以在这里添加我的表情符号

613
00:29:17,790 --> 00:29:19,710
但是有时您确实需要Sections。 

614
00:29:19,710 --> 00:29:23,010
例如，我要在此处添加一个部分以删除表情符号， 

615
00:29:23,010 --> 00:29:26,480
如您所见，它将要成为自己的Section。 

616
00:29:26,480 --> 00:29:27,530
因此，让我们继续进行。 

617
00:29:27,530 --> 00:29:29,973
添加删除表情符号部分。 

618
00:29:32,250 --> 00:29:36,270
栏目，标题，文字， 

619
00:29:36,270 --> 00:29:37,883
“删除表情符号”。 

620
00:29:40,260 --> 00:29:43,547
在这里，我本质上想做一个ForEach 

621
00:29:45,390 --> 00:29:49,370
在我选择的所有调色板的表情符号上， 

622
00:29:49,370 --> 00:29:53,623
因此我将像以前一样将它们映射到Strings。 

623
00:29:54,610 --> 00:29:57,580
当然，这些是无法识别的

624
00:29:57,580 --> 00:30:01,470
因此我们必须对自己进行身份识别。 

625
00:30:01,470 --> 00:30:03,643
对于这里的每个表情符号， 

626
00:30:04,640 --> 00:30:09,640
我们将它们放在这样的小文本中。 

627
00:30:09,700 --> 00:30:11,163
当您点击它们时， 

628
00:30:12,705 --> 00:30:15,963
它将它们从我们选择的调色板中删除。 

629
00:30:18,746 --> 00:30:21,010
当然，ForEach不会将它们布置

630
00:30:21,010 --> 00:30:22,520
以任何特定方式。 

631
00:30:22,520 --> 00:30:24,640
因此，让我们继续将它们放入

632
00:30:24,640 --> 00:30:26,180
我现在说一个VStack。 

633
00:30:26,180 --> 00:30:27,550
我认为我们可以做得更好

634
00:30:27,550 --> 00:30:30,644
但我们将从将它们放入VStack开始。 

635
00:30:30,644 --> 00:30:34,550
所以我要把我所有的表情符号堆积在那里

636
00:30:34,550 --> 00:30:37,013
然后点击“ em”将其删除。 

637
00:30:40,440 --> 00:30:42,810
我们走了，看看那边，有我们所有的表情符号。 

638
00:30:42,810 --> 00:30:44,030
让我们尝试删除一些。 

639
00:30:44,030 --> 00:30:47,930
让我们决定，我们不想让高尔夫球手走了。 

640
00:30:47,930 --> 00:30:52,040
我们不希望这个足球消失了。 

641
00:30:52,040 --> 00:30:55,840
我们不希望冲浪者，滑雪者消失。 

642
00:30:55,840 --> 00:30:58,100
这个表情符号问题的唯一问题

643
00:30:58,100 --> 00:30:59,503
这是一个令人讨厌的用户界面吗？ 

644
00:31:00,580 --> 00:31:02,760
要在这样的长列表中

645
00:31:02,760 --> 00:31:06,350
例如，如果它在网格中会更好。 

646
00:31:06,350 --> 00:31:08,460
我们有一个来自记忆的网格。 

647
00:31:08,460 --> 00:31:11,300
让我们看看是否可以在此处使用“记忆”网格。 

648
00:31:11,300 --> 00:31:12,640
它会让它看起来更好， 

649
00:31:12,640 --> 00:31:14,720
这也将帮助我们了解

650
00:31:14,720 --> 00:31:19,710
甚至更多关于协议的内容，而且不在乎， 

651
00:31:19,710 --> 00:31:22,883
限制和收获，以及所有这些。 

652
00:31:24,410 --> 00:31:26,840
让我们从跳到记忆开始

653
00:31:26,840 --> 00:31:28,440
然后从那里抢网格。 

654
00:31:28,440 --> 00:31:33,440
我只是要去这里给开发人员。 

655
00:31:33,473 --> 00:31:36,660
我去记忆，这是记忆，我要去抓网格

656
00:31:36,660 --> 00:31:39,520
当然，我们也需要GridLayout 

657
00:31:39,520 --> 00:31:41,523
拖到这里

658
00:31:42,470 --> 00:31:44,783
我们确实想在那里复制项目。 

659
00:31:50,086 --> 00:31:52,530
这就是我们在记忆中使用的网格

660
00:31:52,530 --> 00:31:54,770
没有任何改变。 

661
00:31:54,770 --> 00:31:58,400
我想用它代替这个VStack和ForEach， 

662
00:31:58,400 --> 00:32:00,210
记住我们的网格有点结合了这一点。 

663
00:32:00,210 --> 00:32:04,570
所以我要说网格，摆脱这些花括号之一。 

664
00:32:04,570 --> 00:32:08,020
这样做真的很好。 

665
00:32:08,020 --> 00:32:10,630
不幸的是，这是行不通的。 

666
00:32:10,630 --> 00:32:13,920
因为我们的网格不知道该怎么做

667
00:32:13,920 --> 00:32:17,030
这个身份证自我交易，对不对？ 

668
00:32:17,030 --> 00:32:20,400
我们的网格要求传递给它的所有东西

669
00:32:20,400 --> 00:32:22,560
是可识别的。 

670
00:32:22,560 --> 00:32:27,560
参见项目可识别，这些项目必须是可识别的。 

671
00:32:27,900 --> 00:32:30,650
因此，让我们花一些时间来构建UI 

672
00:32:30,650 --> 00:32:33,620
并了解如何更改网格

673
00:32:33,620 --> 00:32:37,180
这样它在这里确实接受了id参数

674
00:32:37,180 --> 00:32:38,630
让我们指定

675
00:32:40,010 --> 00:32:44,330
使用什么KeyPath查找ID。 

676
00:32:44,330 --> 00:32:47,490
就像我们在这里一样，想要通过这个。 

677
00:32:47,490 --> 00:32:50,130
那么，这是什么小事呢？ 

678
00:32:50,130 --> 00:32:52,270
我们已经讨论过几次了。 

679
00:32:52,270 --> 00:32:53,820
它是一个KeyPath。 

680
00:32:53,820 --> 00:32:57,750
它只是指定要访问的某个变量

681
00:32:57,750 --> 00:32:59,047
在对象的实例上。 

682
00:32:59,047 --> 00:33:02,730
在这种情况下，我正在做自我，因为这些是弦乐

683
00:33:02,730 --> 00:33:04,610
而String.self是String本身。 

684
00:33:04,610 --> 00:33:08,361
这是可识别的一件好事。 

685
00:33:08,361 --> 00:33:10,160
效果很好。 

686
00:33:10,160 --> 00:33:12,350
那么，我们该怎么说呢？ 

687
00:33:12,350 --> 00:33:15,610
因为如果我们要将此传递为类型

688
00:33:15,610 --> 00:33:18,230
对我们的身份证，我们必须说这是什么。 

689
00:33:18,230 --> 00:33:23,230
它的类型是KeyPath，并且有两个无关位。 

690
00:33:23,650 --> 00:33:28,650
一种是您要在其上查找变量的对象。 

691
00:33:29,750 --> 00:33:31,970
在我们的例子中，这是项。 

692
00:33:31,970 --> 00:33:34,405
这就是这个数组中的东西， 

693
00:33:34,405 --> 00:33:35,970
密钥路径项。 

694
00:33:35,970 --> 00:33:39,920
第二个无关紧要的是它的返回值。 

695
00:33:39,920 --> 00:33:43,560
现在，我们真的不在乎您使用什么作为您的身份证明。 

696
00:33:43,560 --> 00:33:45,947
因此，我们的返回类型将对我们无关。 

697
00:33:45,947 --> 00:33:49,950
我将其称为ID，然后将其放在此处。 

698
00:33:49,950 --> 00:33:52,680
这就是我们可以指定此ID的方式。 

699
00:33:52,680 --> 00:33:57,680
现在我们有了这个ID，让我们继续将其设置为var。 

700
00:33:57,980 --> 00:33:59,170
等一下

701
00:33:59,170 --> 00:34:01,450
所以我们需要一个私人变种

702
00:34:01,450 --> 00:34:05,763
类型为KeyPath <Item，ID>。 

703
00:34:07,120 --> 00:34:10,670
几乎到了，让我们在这里找到我们的ForEach， 

704
00:34:10,670 --> 00:34:15,670
我们将在此传递此ID，即我们自己的ID var。 

705
00:34:16,650 --> 00:34:17,833
这应该工作，对不对？ 

706
00:34:17,833 --> 00:34:20,750
这几乎是我们需要的一切。 

707
00:34:20,750 --> 00:34:22,480
但是我们有一个问题

708
00:34:22,480 --> 00:34:24,713
我们在这里遇到了限制和收益问题。 

709
00:34:25,590 --> 00:34:29,580
在这里说，“通用结构ForEach需要该ID，” 

710
00:34:29,580 --> 00:34:33,120
此ID符合Hashable。 

711
00:34:33,120 --> 00:34:34,530
哪种方法有意义？ 

712
00:34:34,530 --> 00:34:36,300
ForEach做什么？ 

713
00:34:36,300 --> 00:34:38,460
查看所有项目，对于其中的每一项， 

714
00:34:38,460 --> 00:34:42,050
它为此构建了此视图，这很棒， 

715
00:34:42,050 --> 00:34:44,270
但它可能必须保留这些物品

716
00:34:44,270 --> 00:34:47,020
在某种字典或哈希表之类的东西中

717
00:34:47,020 --> 00:34:48,840
这样就可以知道哪个视图

718
00:34:48,840 --> 00:34:50,700
与他们相关，等等。 

719
00:34:50,700 --> 00:34:53,040
所以期望是完全合理的

720
00:34:53,040 --> 00:34:55,290
该ID必须在此处可哈希。 

721
00:34:55,290 --> 00:34:59,680
但是我们的ID是这里KeyPath的返回值， 

722
00:34:59,680 --> 00:35:02,140
不在乎。 

723
00:35:02,140 --> 00:35:05,540
但显然，我们对这种类型的ID有点关心

724
00:35:05,540 --> 00:35:07,400
这是KeyPath的返回值。 

725
00:35:07,400 --> 00:35:09,653
它必须是可哈希的。 

726
00:35:10,843 --> 00:35:13,416
所以我将其标记为“可哈希” 

727
00:35:13,416 --> 00:35:15,270
只是要求这不在乎， 

728
00:35:15,270 --> 00:35:17,210
不管它是可哈希的。 

729
00:35:17,210 --> 00:35:19,760
而当我这样做时，我可以摆脱可识别的项目。 

730
00:35:19,760 --> 00:35:22,110
这就是整个过程的重点

731
00:35:22,110 --> 00:35:25,163
因此我们的商品不必是可识别的。 

732
00:35:26,150 --> 00:35:29,070
所以实际上我们快要到了，但是我们有一个问题

733
00:35:29,070 --> 00:35:31,420
因为我们使用了firstIndex匹配， 

734
00:35:31,420 --> 00:35:33,210
记住，firstIndex匹配。 

735
00:35:33,210 --> 00:35:37,080
这是我们添加到数组的功能

736
00:35:37,080 --> 00:35:38,750
进入收藏集

737
00:35:38,750 --> 00:35:43,570
通过其可识别性来查找事物。 

738
00:35:43,570 --> 00:35:45,630
好吧，我们的物品不再可识别， 

739
00:35:45,630 --> 00:35:47,540
我不再让它们可识别。 

740
00:35:47,540 --> 00:35:50,520
但是，我们确实有此ID，此KeyPath 

741
00:35:50,520 --> 00:35:52,370
我们可以在物品上使用的

742
00:35:52,370 --> 00:35:56,150
找出一个可识别的东西，可哈希的东西。 

743
00:35:56,150 --> 00:35:59,330
那么我们如何将item的firstIndex替换为

744
00:35:59,330 --> 00:36:01,086
使用这个ID？ 

745
00:36:01,086 --> 00:36:05,750
好吧，我要去做firstIndex，另一个叫where， 

746
00:36:05,750 --> 00:36:09,100
在这里需要一些关闭。 

747
00:36:09,100 --> 00:36:13,060
每个事物都有这种封闭， 

748
00:36:13,060 --> 00:36:14,410
数组中的项目。 

749
00:36:14,410 --> 00:36:18,243
因此，我们将使用内置参数$ 0。 

750
00:36:19,560 --> 00:36:22,490
它可以让你做一些事情

751
00:36:22,490 --> 00:36:25,423
并在匹配时返回true。 

752
00:36:26,920 --> 00:36:31,880
我们希望此KeyPath不在我们的产品中。 

753
00:36:31,880 --> 00:36:36,850
我们想比较$ 0中的这个KeyPath 

754
00:36:36,850 --> 00:36:39,870
在项目数组中查看它们是否相同。 

755
00:36:39,870 --> 00:36:44,180
因此，这是您获取项目并使用KeyPath的方法

756
00:36:44,180 --> 00:36:46,150
去获取var的值

757
00:36:46,150 --> 00:36:48,240
KeyPath在谈论它。 

758
00:36:48,240 --> 00:36:52,270
您说，[keyPath： 

759
00:36:52,270 --> 00:36:54,530
和KeyPath。 

760
00:36:54,530 --> 00:36:59,530
所以这里的表达式意味着将这个KeyPath变量称为

761
00:37:00,150 --> 00:37:03,070
并将其交给我们。 

762
00:37:03,070 --> 00:37:05,147
我们只是要检查一下是否等于

763
00:37:05,147 --> 00:37:08,853
$ 0的ID的KeyPath。 

764
00:37:10,700 --> 00:37:14,590
希望这里有很多事情，你们正在关注， 

765
00:37:14,590 --> 00:37:16,700
我会说你真的不需要了解

766
00:37:16,700 --> 00:37:19,060
我刚刚在这里使用SwiftUI所做的。 

767
00:37:19,060 --> 00:37:21,470
但是，如果您这样做，您将真正理解

768
00:37:21,470 --> 00:37:24,113
这限制和收获了这里发生的事情。 

769
00:37:28,750 --> 00:37:31,393
但是，让我们更进一步。 

770
00:37:32,300 --> 00:37:35,180
不幸的是，这有点破

771
00:37:35,180 --> 00:37:37,060
我们过去使用网格的旧方法。 

772
00:37:37,060 --> 00:37:41,380
现在我们被迫执行此ID KeyPath 

773
00:37:41,380 --> 00:37:43,660
即使我们的物品是可识别的， 

774
00:37:43,660 --> 00:37:45,440
我们仍然必须提供这个论点。 

775
00:37:45,440 --> 00:37:48,170
此参数没有默认值。 

776
00:37:48,170 --> 00:37:50,330
因此，让我们看看如何

777
00:37:50,330 --> 00:37:53,450
采取我们刚修改过的完全相同的代码

778
00:37:53,450 --> 00:37:55,980
并对其进行更改，使其仍然适用于旧世界。 

779
00:37:55,980 --> 00:37:59,260
这确实可以使您获得约束和收获。 

780
00:37:59,260 --> 00:38:01,520
因此，我将扩展Grid。 

781
00:38:01,520 --> 00:38:05,230
在这个扩展中，我将要求

782
00:38:05,230 --> 00:38:08,760
该项目是可识别的。 

783
00:38:08,760 --> 00:38:10,470
所以这只会在这个扩展中

784
00:38:10,470 --> 00:38:11,850
他们是可识别的。 

785
00:38:11,850 --> 00:38:14,590
然后我想添加一个新的init， 

786
00:38:14,590 --> 00:38:18,250
像我们以前一样处理物品

787
00:38:18,250 --> 00:38:20,690
并且不采用该id参数。 

788
00:38:20,690 --> 00:38:23,820
但是，当然仍然具有viewForItem。 

789
00:38:23,820 --> 00:38:25,560
我想叫另一个init， 

790
00:38:25,560 --> 00:38:29,720
我在这里提出的所有正确的论点

791
00:38:29,720 --> 00:38:31,720
使它工作。 

792
00:38:31,720 --> 00:38:33,100
因此，让我们尝试一下。 

793
00:38:33,100 --> 00:38:35,970
得到了物品，得到了身份证。 

794
00:38:35,970 --> 00:38:40,470
所以我们知道可识别对象上有一个名为id的变量

795
00:38:41,470 --> 00:38:42,470
使它们可识别。 

796
00:38:42,470 --> 00:38:47,470
那么，如果我只说\ Item.id然后再说viewForItem怎么办？ 

797
00:38:48,360 --> 00:38:50,580
这个词能做到吗？ 

798
00:38:50,580 --> 00:38:52,520
哦，不是。 

799
00:38:52,520 --> 00:38:56,347
在这里说，“关键路径值Item.ID无法转换

800
00:38:56,347 --> 00:38:58,140
“到上下文类型ID。” 

801
00:38:58,140 --> 00:39:01,640
换句话说，我们的ID不在乎不一定

802
00:39:01,640 --> 00:39:05,600
与该Identifiable的.id类型相同， 

803
00:39:05,600 --> 00:39:08,260
这是无关紧要的。 

804
00:39:08,260 --> 00:39:12,957
但实际上，我们也可以通过说出ID来强制这样做

805
00:39:14,480 --> 00:39:19,200
它的类型等于商品的ID， 

806
00:39:19,200 --> 00:39:23,340
此处的此ID无关可识别， 

807
00:39:23,340 --> 00:39:26,120
这个ID是我们不在乎的。 

808
00:39:26,120 --> 00:39:29,100
因此，通过强迫它们相同， 

809
00:39:29,100 --> 00:39:31,850
我们做到这一点，以便我们可以将此称为init。 

810
00:39:33,610 --> 00:39:34,880
这是您可以做的事情

811
00:39:34,880 --> 00:39:36,050
有限制和收获。 

812
00:39:36,050 --> 00:39:39,150
这里有一些高级话题， 

813
00:39:39,150 --> 00:39:42,770
但这使它可以在这里使用旧的Grid初始化器

814
00:39:42,770 --> 00:39:45,163
并且新的Grid初始化器将起作用。 

815
00:39:47,230 --> 00:39:49,490
好吧，有足够的时间在那里

816
00:39:49,490 --> 00:39:52,730
应该做到这一点，以便我们此处的网格能够正常工作。 

817
00:39:52,730 --> 00:39:54,880
让我们看看当我们这样做时会发生什么。 

818
00:39:56,983 --> 00:39:57,963
好吧，准备好了吗？ 

819
00:39:59,890 --> 00:40:02,430
好吧，它不再是垂直的，而是水平的。 

820
00:40:02,430 --> 00:40:05,640
这实际上是网格按照要求执行的。 

821
00:40:05,640 --> 00:40:09,300
这条线花了这么小的空间， 

822
00:40:09,300 --> 00:40:12,630
表单在那里提供的是那里的东西。 

823
00:40:12,630 --> 00:40:13,780
占用了这个小空间

824
00:40:13,780 --> 00:40:16,490
它使所有表情符号都适合其中

825
00:40:16,490 --> 00:40:19,470
这是使自己适应的最好方法。 

826
00:40:19,470 --> 00:40:23,210
我们真正想做的是为这个东西提供更多的空间。 

827
00:40:23,210 --> 00:40:25,020
我们希望这个更高

828
00:40:25,020 --> 00:40:27,550
我们希望这个白色小矩形更高。 

829
00:40:27,550 --> 00:40:30,600
我也会用框架做。 

830
00:40:30,600 --> 00:40:32,027
我要把这个东西放高一点。 

831
00:40:32,027 --> 00:40:33,690
我要有身高， 

832
00:40:33,690 --> 00:40:36,680
当表情符号更多时，我会给更多的高度。 

833
00:40:36,680 --> 00:40:39,277
我们拥有的表情符号越多，我要给您的身高就越高。 

834
00:40:39,277 --> 00:40:42,270
这应该使它们之间的间距大致相同

835
00:40:42,270 --> 00:40:43,103
不管您有多少个表情符号

836
00:40:43,103 --> 00:40:45,830
如果你有1000，我会给你很多的身高。 

837
00:40:45,830 --> 00:40:47,140
如果只有三四个

838
00:40:47,140 --> 00:40:50,270
我要给你这么小的身高。 

839
00:40:50,270 --> 00:40:52,310
好吧，我们该怎么做呢？ 

840
00:40:52,310 --> 00:40:53,420
很简单。 

841
00:40:53,420 --> 00:40:58,420
这个gGid，我要给它一个固定的高度。 

842
00:40:58,631 --> 00:41:02,943
我要为此准备一个变量，变量高度。 

843
00:41:03,783 --> 00:41:05,270
CGFloat。 

844
00:41:05,270 --> 00:41:06,550
我要计算一下。 

845
00:41:06,550 --> 00:41:08,220
我玩这个，我上来了

846
00:41:08,220 --> 00:41:12,920
像这样的CGFloat selectedPalette.count 

847
00:41:12,920 --> 00:41:17,920
减一除以六十乘以70加70。 

848
00:41:20,130 --> 00:41:25,130
那似乎是最合适的一种

849
00:41:25,210 --> 00:41:27,697
使这些东西散布开来。 

850
00:41:27,697 --> 00:41:30,960
而且您以后可以自己玩那个数学。 

851
00:41:30,960 --> 00:41:32,180
让我们来看看。 

852
00:41:32,180 --> 00:41:34,370
是的，很好。 

853
00:41:34,370 --> 00:41:35,510
我只想要这些图片

854
00:41:35,510 --> 00:41:37,110
虽然要大一点

855
00:41:37,110 --> 00:41:40,060
因为我给了他们很少的空间。 

856
00:41:40,060 --> 00:41:44,360
我将在此处设置此字体大小

857
00:41:44,360 --> 00:41:47,350
Font.system大小。 

858
00:41:47,350 --> 00:41:50,280
让我们继续，并具有一个self.fontSize。 

859
00:41:50,280 --> 00:41:55,280
这些本质上就是绘制常量， 

860
00:41:55,350 --> 00:42:00,350
高度，也让我们的fontSize设为40左右。 

861
00:42:02,180 --> 00:42:05,063
这些东西似乎很合适。 

862
00:42:07,669 --> 00:42:09,710
我们走了，这应该在这里仍然有效。 

863
00:42:09,710 --> 00:42:12,070
这仍然是一个网格，它知道如何显示事物。 

864
00:42:12,070 --> 00:42:15,340
因此，让我们摆脱足球，网球。 

865
00:42:15,340 --> 00:42:17,210
这不是活动。 

866
00:42:17,210 --> 00:42:18,043
好了

867
00:42:21,260 --> 00:42:24,820
所以这看起来很棒，它是一个不错的，紧凑的小UI， 

868
00:42:24,820 --> 00:42:26,810
确实使人们容易通过， 

869
00:42:26,810 --> 00:42:30,860
改变他们想要的表情符号

870
00:42:30,860 --> 00:42:33,193
他们的每个调色板都在这里。 

871
00:42:34,081 --> 00:42:35,330
我要告诉你一些其他方式

872
00:42:35,330 --> 00:42:36,400
呈现这个。 

873
00:42:36,400 --> 00:42:39,670
在这里的iPad上，这是一个非常有意义的弹出窗口， 

874
00:42:39,670 --> 00:42:41,690
还有另一种在iPad上展示的方式， 

875
00:42:41,690 --> 00:42:45,070
而不是在这里使用弹出窗口， 

876
00:42:45,070 --> 00:42:47,570
我们使用一种叫做床单的东西。 

877
00:42:47,570 --> 00:42:49,923
所以表看起来像这样。 

878
00:42:53,882 --> 00:42:56,640
更大，对用户界面很有用

879
00:42:56,640 --> 00:42:58,940
显然要占用很多空间。 

880
00:42:58,940 --> 00:43:02,600
可能出于我们的目的，弹出窗口会更好， 

881
00:43:02,600 --> 00:43:04,680
这真的不需要那么大， 

882
00:43:04,680 --> 00:43:07,320
您永远不会拥有真正长的调色板名称， 

883
00:43:07,320 --> 00:43:10,560
您可能不会一次添加100个表情符号。 

884
00:43:10,560 --> 00:43:14,610
而且不需要如此间隔开。 

885
00:43:14,610 --> 00:43:17,650
这些事情可以忽略不计， 

886
00:43:17,650 --> 00:43:19,190
不是通过点击离开。 

887
00:43:19,190 --> 00:43:21,790
看到我在点击，触摸外部， 

888
00:43:21,790 --> 00:43:25,060
您将其向下滑动以使其消失。 

889
00:43:25,060 --> 00:43:28,260
现在，我发现这种轻扫， 

890
00:43:28,260 --> 00:43:32,270
这是一个隐藏的用户界面，需要向下滑动

891
00:43:32,270 --> 00:43:34,040
使它消失。 

892
00:43:34,040 --> 00:43:35,860
因此，如果我在一张纸上进行此操作， 

893
00:43:35,860 --> 00:43:38,400
我可能会放一个“完成”按钮， 

894
00:43:38,400 --> 00:43:40,930
或类似关闭按钮或此处的内容。 

895
00:43:40,930 --> 00:43:42,490
完成通常是个好词， 

896
00:43:42,490 --> 00:43:45,090
这意味着您已经完成了这件事。 

897
00:43:45,090 --> 00:43:48,160
那么我们如何在此UI中放置一个Button 

898
00:43:48,160 --> 00:43:52,460
当我们单击它时，它会自行消失吗？ 

899
00:43:52,460 --> 00:43:55,370
知道如何做确实是一件好事。 

900
00:43:55,370 --> 00:43:57,850
让我们先在其中放置“完成”按钮。 

901
00:43:57,850 --> 00:43:59,940
为此，这是标题栏， 

902
00:43:59,940 --> 00:44:02,210
该“调色板编辑器”标题栏。 

903
00:44:02,210 --> 00:44:07,210
让我们继续制作具有该标题的ZStack， 

904
00:44:07,550 --> 00:44:11,670
然后还有一个HStack和一个垫片

905
00:44:11,670 --> 00:44:14,197
将Button一直移到右边。 

906
00:44:14,197 --> 00:44:16,160
然后有一个按钮。 

907
00:44:16,160 --> 00:44:17,760
还有Button，我们将讨论动作

908
00:44:17,760 --> 00:44:18,877
一秒钟。 

909
00:44:18,877 --> 00:44:23,293
我们将其标签为“ Done”一词的“文字”。 

910
00:44:25,130 --> 00:44:27,170
我们也要在这上面加上一些填充

911
00:44:27,170 --> 00:44:30,233
只是为了确保它拥有所需的空间。 

912
00:44:32,246 --> 00:44:33,380
让我们看一下它的外观。 

913
00:44:33,380 --> 00:44:36,380
所以我有一个ZStack，所以我把它放在

914
00:44:36,380 --> 00:44:40,453
Button在右边隔开的东西。 

915
00:44:43,120 --> 00:44:45,360
哦，是的，看起来不错，是“完成”。 

916
00:44:45,360 --> 00:44:47,740
因此，单击“完成”没有任何反应

917
00:44:47,740 --> 00:44:49,490
因为我们没有采取任何行动。 

918
00:44:49,490 --> 00:44:52,860
因此，当我们触摸此“完成”按钮时我们将要做什么

919
00:44:52,860 --> 00:44:54,563
使这种嗡嗡声消失？ 

920
00:44:56,020 --> 00:44:58,200
这里很简单

921
00:44:58,200 --> 00:45:03,200
在Button中，我们将不得不在此处进行一些说明， 

922
00:45:03,560 --> 00:45:06,923
设置一些布尔值，说明当前是否正在显示。 

923
00:45:06,923 --> 00:45:11,740
我称isShowing等于false。 

924
00:45:11,740 --> 00:45:14,570
这个isShowing将会类似， 

925
00:45:14,570 --> 00:45:17,750
实际上与这个showPalette非常相似

926
00:45:17,750 --> 00:45:19,870
确定是否显示， 

927
00:45:19,870 --> 00:45:22,820
实际上，正是这个布尔值。 

928
00:45:22,820 --> 00:45:23,870
这个布尔值使

929
00:45:23,870 --> 00:45:25,800
该表首先出现。 

930
00:45:25,800 --> 00:45:29,760
因此，如果以某种方式此isShowing可以进行设置， 

931
00:45:29,760 --> 00:45:32,350
那么这将使它消失。 

932
00:45:32,350 --> 00:45:36,410
而且我们知道如何使它与这个挂钩。 

933
00:45:36,410 --> 00:45:37,800
这就是绑定的目的。 

934
00:45:37,800 --> 00:45:40,420
因此，让我们在此处进行另一个绑定， 

935
00:45:40,420 --> 00:45:44,210
isShowing将成为一个布尔。 

936
00:45:45,264 --> 00:45:49,490
我们想绑定到此isShowing up this here。 

937
00:45:49,490 --> 00:45:52,240
因此，就像我们绑定selectedPalette一样， 

938
00:45:52,240 --> 00:45:56,013
在这里使用此绑定，我们将绑定isShowing 

939
00:45:57,950 --> 00:46:02,170
在此处使用此showPaletteEditor。 

940
00:46:02,170 --> 00:46:05,020
这就是我们让这些事情来来去去的方式， 

941
00:46:05,020 --> 00:46:07,020
我们共享一个布尔。 

942
00:46:07,020 --> 00:46:10,230
在某些情况下可能是可识别的

943
00:46:10,230 --> 00:46:13,500
带有一些SwiftUI，但通常只是一个布尔

944
00:46:13,500 --> 00:46:15,993
那说明这个东西是否正在显示。 

945
00:46:17,170 --> 00:46:18,573
看看是否可行。 

946
00:46:21,557 --> 00:46:24,310
在这里，我们朝这个方向前进，走了。 

947
00:46:25,452 --> 00:46:26,777
然后回头。 

948
00:46:26,777 --> 00:46:30,240
当我单击此按钮时，我们所做的一切

949
00:46:30,240 --> 00:46:35,230
正在设置此showPaletteEditor状态。 

950
00:46:35,230 --> 00:46:37,310
这是将其设置为true的过程。 

951
00:46:37,310 --> 00:46:39,430
这是将其设置为false 

952
00:46:39,430 --> 00:46:42,503
通过绑定在另一个视图中。 

953
00:46:43,860 --> 00:46:47,570
现在，我们已经在iPad上做了很多工作

954
00:46:47,570 --> 00:46:50,900
这是我们在这里使用iPad的作品。 

955
00:46:50,900 --> 00:46:52,690
iPhone呢？ 

956
00:46:52,690 --> 00:46:54,930
这一切都可以在iPhone上使用吗？ 

957
00:46:54,930 --> 00:46:57,730
让我们看一下，看看它是否可以在iPhone上使用。 

958
00:47:01,156 --> 00:47:02,313
看。 

959
00:47:02,313 --> 00:47:05,900
呜呼，看看，它的功能没有改变。 

960
00:47:05,900 --> 00:47:08,580
这是工作表，完成了，很好。 

961
00:47:08,580 --> 00:47:11,357
您甚至可以向下滑动以摆脱这一情况。 

962
00:47:11,357 --> 00:47:13,660
现在，我们可以对其进行编辑， 

963
00:47:13,660 --> 00:47:18,223
让我们将其更改为活动内容。 

964
00:47:20,720 --> 00:47:22,570
活动的东西，很好。 

965
00:47:22,570 --> 00:47:24,200
我们可以添加表情符号。 

966
00:47:24,200 --> 00:47:25,793
让我们在这里添加表情符号。 

967
00:47:26,650 --> 00:47:29,800
现在，当我单击此按钮对其进行编辑时， 

968
00:47:29,800 --> 00:47:32,870
它希望我使用硬件键盘和类型。 

969
00:47:32,870 --> 00:47:34,960
所以你必须要注意的一件事

970
00:47:34,960 --> 00:47:38,070
当您在模拟器中处理应用程序时

971
00:47:38,070 --> 00:47:40,340
是否打开了硬件键盘

972
00:47:40,340 --> 00:47:43,310
然后您可以通过此IO菜单在模拟器中进行控制。 

973
00:47:43,310 --> 00:47:45,130
您会在这里看到它是此键盘。 

974
00:47:45,130 --> 00:47:47,290
现在，我已经连接了硬件键盘。 

975
00:47:47,290 --> 00:47:49,230
如果我断开硬件键盘， 

976
00:47:49,230 --> 00:47:52,150
然后我会得到您的实际用户使用的键盘

977
00:47:52,150 --> 00:47:53,260
要去做， 

978
00:47:53,260 --> 00:47:56,330
我真的建议你用这个

979
00:47:56,330 --> 00:48:00,570
因为你让自己陷入用户的视线中

980
00:48:00,570 --> 00:48:02,760
当您使用此功能与在键盘上打字时。 

981
00:48:02,760 --> 00:48:04,300
他们没有，其中一些可能

982
00:48:04,300 --> 00:48:06,570
连接了蓝牙等的硬件键盘， 

983
00:48:06,570 --> 00:48:09,560
但其中99％的人也必须在这里输入

984
00:48:09,560 --> 00:48:14,560
这样可以帮助您确保您的用户界面确实可用

985
00:48:14,750 --> 00:48:16,793
而不是太依赖打字。 

986
00:48:17,750 --> 00:48:21,137
因此，要添加足球，我们将在此处单击。 

987
00:48:21,137 --> 00:48:23,720
哦，我在那儿不必要地双击了。 

988
00:48:23,720 --> 00:48:25,400
我们可以看到效果很好。 

989
00:48:25,400 --> 00:48:29,380
因此，如果您将其中两个放入其中，则只会放入一个

990
00:48:29,380 --> 00:48:32,030
那是我的小表情符号。 

991
00:48:32,030 --> 00:48:33,437
因此，它在那里添加了表情符号。 

992
00:48:33,437 --> 00:48:35,610
而且我可以删除骑自行车的人或其他任何东西， 

993
00:48:35,610 --> 00:48:36,517
我正在编辑。 

994
00:48:36,517 --> 00:48:38,943
当我点击“完成”时，是的，好的。 

995
00:48:38,943 --> 00:48:40,843
我认为那儿没有骑自行车的人。 

996
00:48:42,490 --> 00:48:44,060
我们那里有新的。 

997
00:48:44,060 --> 00:48:47,620
因此，这在这里非常适合iPhone。 

998
00:48:47,620 --> 00:48:50,530
不幸的是，无法添加背景图片。 

999
00:48:50,530 --> 00:48:53,550
因此，这是我们必须在iPhone上修复的问题。 

1000
00:48:53,550 --> 00:48:56,730
而且这只是要时间到这里

1001
00:48:56,730 --> 00:48:59,010
才能拥有多个文档。 

1002
00:48:59,010 --> 00:49:02,600
到现在为止，我们始终只有这份无标题的文档

1003
00:49:02,600 --> 00:49:05,310
我们正在编辑，在iPad上也是如此。 

1004
00:49:05,310 --> 00:49:09,030
因此，我们下一步将能够在此处添加一些UI 

1005
00:49:09,030 --> 00:49:12,250
拥有文档列表，不同的EmojiArtDocuments 

1006
00:49:12,250 --> 00:49:13,430
我们可以点击

1007
00:49:13,430 --> 00:49:16,023
并向我们​​展示每个文档。 

1008
00:49:17,120 --> 00:49:20,790
这将使我们学到更多

1009
00:49:20,790 --> 00:49:24,460
在SwiftUI中，这是如何具有多个ViewModels 

1010
00:49:24,460 --> 00:49:25,530
在您的应用中。 

1011
00:49:25,530 --> 00:49:27,310
因为现在我们有一个ViewModel 

1012
00:49:27,310 --> 00:49:29,500
代表一个EmojiArtDocument。 

1013
00:49:29,500 --> 00:49:30,500
那很棒。 

1014
00:49:30,500 --> 00:49:33,560
我们将需要一个新的ViewModel，它代表

1015
00:49:33,560 --> 00:49:36,863
一堆EmojiArtDocuments存储在某个地方。 

1016
00:49:38,160 --> 00:49:42,240
因此，让我们通过创建ViewModel来深入研究

1017
00:49:42,240 --> 00:49:45,430
对于EmojiArtDocuments的商店， 

1018
00:49:45,430 --> 00:49:47,290
存储的EmojiArtDocuments。 

1019
00:49:47,290 --> 00:49:50,940
现在，我已经了解了如何创建ViewModel， 

1020
00:49:50,940 --> 00:49:52,810
这样做会有些重复。 

1021
00:49:52,810 --> 00:49:56,490
所以我实际上在这里创建了我的EmojiArtDocument存储。 

1022
00:49:56,490 --> 00:49:59,490
我们将其拖入并进行查看。 

1023
00:49:59,490 --> 00:50:01,040
复制到。 

1024
00:50:01,040 --> 00:50:05,660
这是世界上最简单的小存储设备。 

1025
00:50:05,660 --> 00:50:08,730
但是请注意，这是一个ViewModel类

1026
00:50:08,730 --> 00:50:10,740
和ObservableObject。 

1027
00:50:10,740 --> 00:50:12,690
并且此ViewModel有一个名称。 

1028
00:50:12,690 --> 00:50:14,580
所以这就像商店的名字， 

1029
00:50:14,580 --> 00:50:16,550
我们可能会把它称为我们的EmojiArtStore 

1030
00:50:16,550 --> 00:50:17,610
或类似的东西。 

1031
00:50:17,610 --> 00:50:19,230
所以这是存储东西的地方。 

1032
00:50:19,230 --> 00:50:20,500
但是它也有名字

1033
00:50:20,500 --> 00:50:22,130
存储中的所有文档。 

1034
00:50:22,130 --> 00:50:24,290
您可以获取文档名称， 

1035
00:50:24,290 --> 00:50:26,330
看，这只是一个EmojiArtDocument。 

1036
00:50:26,330 --> 00:50:28,070
这是我们的另一个ViewModel。 

1037
00:50:28,070 --> 00:50:29,860
所以从某种意义上讲，这是一个ViewModel 

1038
00:50:29,860 --> 00:50:34,860
此处包含其他ViewModel作为其内容的一部分。 

1039
00:50:34,920 --> 00:50:37,610
但是您可以在此处为文档设置名称。 

1040
00:50:37,610 --> 00:50:39,910
您可以获取我们拥有名称的所有文档， 

1041
00:50:39,910 --> 00:50:41,340
很好

1042
00:50:41,340 --> 00:50:43,860
您可以添加文档，标题或不添加

1043
00:50:43,860 --> 00:50:46,730
如果您未指定名称，它将使用“无标题”。 

1044
00:50:46,730 --> 00:50:48,680
您可以在此处删除文档。 

1045
00:50:49,750 --> 00:50:52,710
信不信由你，整个商店，整个事情

1046
00:50:52,710 --> 00:50:55,530
只有一个实际上正在做任何存储的变量。 

1047
00:50:55,530 --> 00:50:57,690
当然，这是一个已发布的var，因为更改时

1048
00:50:57,690 --> 00:51:00,620
我们是一个ObservableObject，我们是ViewModel， 

1049
00:51:00,620 --> 00:51:02,510
我们希望我们的观点能够找到。 

1050
00:51:02,510 --> 00:51:06,560
而这家商店只是带有EmojiArtDocuments的字典

1051
00:51:06,560 --> 00:51:11,130
作为文档的键及其名称作为String。 

1052
00:51:11,130 --> 00:51:14,550
就是这样，这就是整个存储空间

1053
00:51:14,550 --> 00:51:16,197
在此ViewModel中。 

1054
00:51:16,197 --> 00:51:17,360
这就是我们所需要的， 

1055
00:51:17,360 --> 00:51:20,010
我们只需要文档名称， 

1056
00:51:20,010 --> 00:51:22,700
我们可以从我们的商店中访问它们。 

1057
00:51:22,700 --> 00:51:25,050
顺便说一句，有ViewModels是很常见的

1058
00:51:25,050 --> 00:51:29,080
本质上就是商店，东西的存放场所。 

1059
00:51:29,080 --> 00:51:31,180
我们用于记忆的ViewModel 

1060
00:51:31,180 --> 00:51:35,850
而且您对Set的需求实际上更面向逻辑。 

1061
00:51:35,850 --> 00:51:38,360
这里的逻辑确实不是很多。 

1062
00:51:38,360 --> 00:51:40,380
我想命名这些东西是一种逻辑， 

1063
00:51:40,380 --> 00:51:42,930
但大多数情况下只是存储东西。 

1064
00:51:42,930 --> 00:51:44,060
所以您会看到很多ViewModels 

1065
00:51:44,060 --> 00:51:46,493
以名称存储的单词。 

1066
00:51:47,890 --> 00:51:49,820
现在，我在这里做了几件事， 

1067
00:51:49,820 --> 00:51:54,370
是我用过我们所知道的Publisher资料

1068
00:51:54,370 --> 00:51:57,270
使它自动保存到UserDefaults中。 

1069
00:51:57,270 --> 00:51:59,450
同样，UserDefaults是唯一的存储机制

1070
00:51:59,450 --> 00:52:02,140
到目前为止我们都知道，所以我必须使用UserDefault。 

1071
00:52:02,140 --> 00:52:04,190
我不会存储这些文件

1072
00:52:04,190 --> 00:52:07,620
在现实世界中的UserDefaults中，但操作很简单。 

1073
00:52:07,620 --> 00:52:09,740
关于在UserDefault中存储内容的一件事

1074
00:52:09,740 --> 00:52:13,230
我们知道UserDefaults仅存储属性列表吗？ 

1075
00:52:13,230 --> 00:52:16,330
这当然不是属性列表

1076
00:52:16,330 --> 00:52:20,690
因为这不是规定的类型之一， 

1077
00:52:20,690 --> 00:52:23,503
字符串和数据，这些都不是。 

1078
00:52:23,503 --> 00:52:25,850
这是它自己的自定义类。 

1079
00:52:25,850 --> 00:52:28,610
所以我不得不在这里写下一些代码， 

1080
00:52:28,610 --> 00:52:30,620
我把它作为字典的扩展

1081
00:52:30,620 --> 00:52:35,430
将此字典转换为属性列表并返回。 

1082
00:52:35,430 --> 00:52:37,097
因此，将其作为属性列表

1083
00:52:37,097 --> 00:52:39,350
这是从属性列表创建的。 

1084
00:52:39,350 --> 00:52:42,530
这样，我可以将UserDefaults设置为key的对象

1085
00:52:42,530 --> 00:52:46,330
并设置并获取对象forKey 

1086
00:52:46,330 --> 00:52:49,253
并将key对象设置为属性列表。 

1087
00:52:50,950 --> 00:52:53,430
现在，您可以稍后再看看我是如何做到的

1088
00:52:53,430 --> 00:52:55,470
挺酷的

1089
00:52:55,470 --> 00:52:57,960
但不是很重要，因为再次

1090
00:52:57,960 --> 00:53:00,530
我们在这里谈论与旧API的接口

1091
00:53:00,530 --> 00:53:02,880
在UserDefaults中，因此了解它并不是超级重要

1092
00:53:02,880 --> 00:53:03,920
这是怎么回事。 

1093
00:53:03,920 --> 00:53:07,160
但是我们把它当作我所说的， 

1094
00:53:07,160 --> 00:53:10,983
而且我们正在使用Any，所以这真的是一个旧东西。 

1095
00:53:11,980 --> 00:53:14,930
无论如何，您可以看到我在这里有很多错误。 

1096
00:53:14,930 --> 00:53:16,410
这主要是这个错误

1097
00:53:16,410 --> 00:53:17,787
这就是问题所在。 

1098
00:53:17,787 --> 00:53:21,497
“通用结构字典要求EmojiArtDocuments 

1099
00:53:21,497 --> 00:53:23,410
“符合Hashable”。 

1100
00:53:23,410 --> 00:53:25,880
每当您想成为字典的钥匙时， 

1101
00:53:25,880 --> 00:53:27,540
您必须是可哈希的。 

1102
00:53:27,540 --> 00:53:29,970
现在我们已经看过这个Hashable协议， 

1103
00:53:29,970 --> 00:53:31,347
我们没有看到如何实现它， 

1104
00:53:31,347 --> 00:53:32,970
但是我们看到它存在， 

1105
00:53:32,970 --> 00:53:35,720
是在我们网格中的这里，好吗？ 

1106
00:53:35,720 --> 00:53:39,680
ForEach本质上是在创建一个小词典

1107
00:53:39,680 --> 00:53:42,800
这些项目以及所有这些Views作为其值

1108
00:53:42,800 --> 00:53:44,040
这就是为什么我们不得不说

1109
00:53:44,040 --> 00:53:48,300
那个ID进入这个东西，那一定是一个可哈希的东西

1110
00:53:48,300 --> 00:53:50,580
这样ForEach可以将它们放入词典中

1111
00:53:50,580 --> 00:53:52,500
或它在里面做什么

1112
00:53:52,500 --> 00:53:54,590
所以我们以前见过Hashable 

1113
00:53:54,590 --> 00:53:57,330
但是现在我们必须实际实现Hashable 

1114
00:53:57,330 --> 00:53:59,250
在EmojiArtDocument中

1115
00:53:59,250 --> 00:54:02,890
因为我们希望EmojiArtDocument本身是可哈希的。 

1116
00:54:02,890 --> 00:54:05,300
这是EmojiArtDocument，这是一个ViewModel， 

1117
00:54:05,300 --> 00:54:09,553
这是一类，我们的要求是它是可哈希的。 

1118
00:54:10,690 --> 00:54:13,800
现在，该哈希协​​议中包含什么？ 

1119
00:54:13,800 --> 00:54:16,620
它只有一个功能。 

1120
00:54:16,620 --> 00:54:19,670
您可能已经猜到了，此函数称为哈希。 

1121
00:54:19,670 --> 00:54:23,670
您可以在哈希器中看到它。 

1122
00:54:23,670 --> 00:54:26,560
所以这个哈希只是给你的一个对象

1123
00:54:26,560 --> 00:54:28,390
当系统要求您进行哈希运算时。 

1124
00:54:28,390 --> 00:54:31,270
而且它实际上只有一个功能。 

1125
00:54:31,270 --> 00:54:36,270
该哈希器已结合使用，您可以在此处输入一些内容， 

1126
00:54:37,600 --> 00:54:41,090
它本身是可哈希的，并且结合了

1127
00:54:41,090 --> 00:54:45,850
对象中可能有多个事物

1128
00:54:45,850 --> 00:54:47,310
使它可哈希化。 

1129
00:54:47,310 --> 00:54:48,960
所以我们结合了Hashable的东西

1130
00:54:48,960 --> 00:54:50,950
使某些东西变得可哈希化。 

1131
00:54:50,950 --> 00:54:53,410
现在，我们可以在这里结合吗？ 

1132
00:54:53,410 --> 00:54:56,900
是什么使我们足够独特以至于无法进行哈希处理，对吗？ 

1133
00:54:56,900 --> 00:54:58,683
要放入哈希表吗？ 

1134
00:54:59,670 --> 00:55:02,630
好吧，当然我们的EmojiArtDocument本身

1135
00:55:02,630 --> 00:55:06,510
非常独特，背景中有表情符号

1136
00:55:06,510 --> 00:55:08,870
所以我们可以使它变得可哈希

1137
00:55:08,870 --> 00:55:11,143
然后结合这里有emojiArt。 

1138
00:55:12,370 --> 00:55:14,820
但这有点矫kill过正， 

1139
00:55:14,820 --> 00:55:16,750
实际上可能不是那么好

1140
00:55:16,750 --> 00:55:18,690
因为每次我们更改文档时， 

1141
00:55:18,690 --> 00:55:21,211
我们的哈希值会改变。 

1142
00:55:21,211 --> 00:55:24,810
如果我们有一些唯一的标识符会更好

1143
00:55:24,810 --> 00:55:26,850
我们可以在这里散列。 

1144
00:55:26,850 --> 00:55:27,850
所以我要去做。 

1145
00:55:27,850 --> 00:55:30,870
我要在这里创建一个唯一标识符

1146
00:55:30,870 --> 00:55:32,593
我将其称为id。 

1147
00:55:33,460 --> 00:55:35,850
我要使其成为一个UUID。 

1148
00:55:35,850 --> 00:55:39,280
现在，我之前提到过UUID，这是一个小结构

1149
00:55:39,280 --> 00:55:42,120
产生独特的东西。 

1150
00:55:42,120 --> 00:55:45,610
真正要做的就是创建一个独特的东西。 

1151
00:55:45,610 --> 00:55:48,930
现在，我之所以称呼我的唯一标识符为ID 

1152
00:55:48,930 --> 00:55:52,830
因为现在我也可以说我是可识别的

1153
00:55:52,830 --> 00:55:54,800
有一天可能会很好。 

1154
00:55:54,800 --> 00:55:57,130
为什么还要这样称呼

1155
00:55:57,130 --> 00:55:59,640
什么时候是唯一可识别的东西？ 

1156
00:55:59,640 --> 00:56:02,730
也可以在此处免费获得可识别的身份。 

1157
00:56:02,730 --> 00:56:04,650
所以我将结合起来并对其进行哈希处理。 

1158
00:56:04,650 --> 00:56:07,730
所以我的哈希基本上就是这个的哈希。 

1159
00:56:07,730 --> 00:56:10,713
幸运的是，您的UUID本身就是可哈希对象。 

1160
00:56:11,580 --> 00:56:13,150
看起来就足够了

1161
00:56:13,150 --> 00:56:15,403
但是我们这里有更多的投诉。 

1162
00:56:15,403 --> 00:56:19,180
“ EmojiArtDocument不符合Equatable。” 

1163
00:56:19,180 --> 00:56:23,320
因此，要变得可哈希化，还必须实现Equatable。 

1164
00:56:23,320 --> 00:56:25,840
换句话说，有一个继承关系

1165
00:56:25,840 --> 00:56:28,600
在Hashable和Equatable之间。 

1166
00:56:28,600 --> 00:56:30,170
那两个协议。 

1167
00:56:30,170 --> 00:56:32,820
那么，Equatable协议中有什么？ 

1168
00:56:32,820 --> 00:56:34,750
我实际上要在这里使用“修复” 

1169
00:56:34,750 --> 00:56:39,000
给这个协议存根简单地向我们展示其中的内容。 

1170
00:56:39,000 --> 00:56:41,410
嘘，这就是这一功能。 

1171
00:56:41,410 --> 00:56:43,690
当您考虑它时，这完全有道理。 

1172
00:56:43,690 --> 00:56:47,570
这是称为==的类型上的静态函数

1173
00:56:47,570 --> 00:56:50,950
记住Swift可以使用任何

1174
00:56:50,950 --> 00:56:53,340
它可以使用表情符号作为函数的名称。 

1175
00:56:53,340 --> 00:56:57,080
所以==完全合理

1176
00:56:57,080 --> 00:56:58,360
函数名称。 

1177
00:56:58,360 --> 00:57:00,550
这就是函数的名称。 

1178
00:57:00,550 --> 00:57:02,560
它需要两个参数，左手边

1179
00:57:02,560 --> 00:57:03,870
和右手边。 

1180
00:57:03,870 --> 00:57:06,650
当然，两者都是EmojiArtDocuments， 

1181
00:57:06,650 --> 00:57:08,070
它正在返回一个布尔， 

1182
00:57:08,070 --> 00:57:10,820
这两件事是否相等。 

1183
00:57:10,820 --> 00:57:12,390
所以对我们来说，这很容易。 

1184
00:57:12,390 --> 00:57:16,100
左手side.id等于右手side.id。 

1185
00:57:16,100 --> 00:57:18,530
如果这些ID相同，则此唯一ID， 

1186
00:57:18,530 --> 00:57:20,760
那么这必须是同一文档。 

1187
00:57:20,760 --> 00:57:22,370
但是这里有个警告

1188
00:57:22,370 --> 00:57:24,440
这个策略真的只会奏效

1189
00:57:24,440 --> 00:57:27,100
对于一个类的引用类型， 

1190
00:57:27,100 --> 00:57:30,890
因为我们在堆中都看到了相同的版本。 

1191
00:57:30,890 --> 00:57:33,640
对于struct，它是一个值类型， 

1192
00:57:33,640 --> 00:57:35,740
我们一直在复制它， 

1193
00:57:35,740 --> 00:57:37,270
我们实际上需要能够看到

1194
00:57:37,270 --> 00:57:40,830
这个副本==到另一个副本吗？ 

1195
00:57:40,830 --> 00:57:43,320
而且我们不想仅凭ID做到这一点。 

1196
00:57:43,320 --> 00:57:45,750
这就是可识别的目的

1197
00:57:45,750 --> 00:57:48,080
我们实际上需要检查一下

1198
00:57:48,080 --> 00:57:50,360
所有的变量彼此相等。 

1199
00:57:50,360 --> 00:57:51,440
对于散列来说， 

1200
00:57:51,440 --> 00:57:54,440
我们想哈希其中的所有变量。 

1201
00:57:54,440 --> 00:57:56,590
实际上，这是默认实现

1202
00:57:56,590 --> 00:58:01,590
Swift中的Hashable是针对结构体检查所有变量的。 

1203
00:58:02,690 --> 00:58:05,420
我们在EmojiArt模型中做到这一点， 

1204
00:58:05,420 --> 00:58:07,750
我们在那里有一个子结构，表情符号， 

1205
00:58:07,750 --> 00:58:11,300
并且我们将其标记为Hashable和Hashable包括Equatable。 

1206
00:58:11,300 --> 00:58:13,840
是的，我们不必做==或哈希， 

1207
00:58:13,840 --> 00:58:16,650
我们只是使用了从Swift获得的默认版本， 

1208
00:58:16,650 --> 00:58:18,293
检查所有变量。 

1209
00:58:19,420 --> 00:58:22,000
但是对于一个班级来说，这真的是一个不错的选择

1210
00:58:22,000 --> 00:58:25,580
获得相等性和哈希性的非常非常简单的方法

1211
00:58:25,580 --> 00:58:29,120
和身份信息都非常简单的代码

1212
00:58:29,120 --> 00:58:32,870
我们可以将这少量代码用于另一件事， 

1213
00:58:32,870 --> 00:58:36,270
就是现在我们存储了EmojiArtDocuments 

1214
00:58:36,270 --> 00:58:40,560
在UserDefaults中，但我们将其存储为“无标题”， 

1215
00:58:40,560 --> 00:58:42,810
所以它们不是每个都单独存储

1216
00:58:42,810 --> 00:58:43,920
和其他一样。 

1217
00:58:43,920 --> 00:58:46,010
但是现在我们有了唯一的ID， 

1218
00:58:46,010 --> 00:58:48,280
我们仍然可以将它们默认存储

1219
00:58:48,280 --> 00:58:51,283
而是使用该唯一ID代替“无标题”下的内容。 

1220
00:58:52,550 --> 00:58:56,500
为此，我将让我的init接受ID， 

1221
00:58:56,500 --> 00:59:01,200
该特定EmojiArtDocument的UUID， 

1222
00:59:01,200 --> 00:59:02,330
因为如果您给我一个ID， 

1223
00:59:02,330 --> 00:59:05,203
我将在UserDefaults中查找它并为您获取。 

1224
00:59:06,460 --> 00:59:09,997
我可以让它默认创建一个随机的UUID 

1225
00:59:10,916 --> 00:59:13,810
那么我什至不需要在这里进行初始化。 

1226
00:59:13,810 --> 00:59:17,100
我可以让它成为ID UUID 

1227
00:59:17,100 --> 00:59:20,273
然后说出self.id等于这个ID。 

1228
00:59:21,360 --> 00:59:24,530
这种默认设置，我们在演示中没有做太多， 

1229
00:59:24,530 --> 00:59:26,400
但希望您知道这一点， 

1230
00:59:26,400 --> 00:59:28,640
你可以有一些默认值， 

1231
00:59:28,640 --> 00:59:31,880
然后有人可以不加任何参数地调用我的init， 

1232
00:59:31,880 --> 00:59:34,830
它将获得一些新的标识符， 

1233
00:59:34,830 --> 00:59:37,150
如果我用以下方式创建表情符号艺术， 

1234
00:59:37,150 --> 00:59:39,350
一个不带参数的EmojiArtDocument 

1235
00:59:39,350 --> 00:59:42,340
我希望它获得自己的唯一ID。 

1236
00:59:42,340 --> 00:59:43,290
我要告诉你另一种方式

1237
00:59:43,290 --> 00:59:46,320
您会经常看到此默认设置已完成， 

1238
00:59:46,320 --> 00:59:48,540
这不是设定平等，所以我在想， 

1239
00:59:48,540 --> 00:59:52,090
并将其设为Optional并将其设置为nil， 

1240
00:59:52,090 --> 00:59:54,623
然后在此处进行默认设置。 

1241
00:59:55,790 --> 00:59:58,130
现在，为什么我们要这样做呢？ 

1242
00:59:58,130 --> 01:00:00,900
我们为什么要选择此项？ 

1243
01:00:00,900 --> 01:00:04,360
因为现在我们可以不带参数地调用此init 

1244
01:00:04,360 --> 01:00:09,360
或者我们可以使用UUID进行调用，也可以使用nil进行调用。 

1245
01:00:09,390 --> 01:00:11,440
所以现在有了更多的灵活性

1246
01:00:11,440 --> 01:00:15,620
我们如何创建此EmojiArtDocument。 

1247
01:00:15,620 --> 01:00:16,880
完全灵活， 

1248
01:00:16,880 --> 01:00:18,780
真的没有其他区别

1249
01:00:18,780 --> 01:00:21,980
但我提到了这一点，因为您将在Swift中看到它

1250
01:00:21,980 --> 01:00:24,720
那里似乎有一个参数的函数

1251
01:00:24,720 --> 01:00:26,600
不是可选的，默认为nil， 

1252
01:00:26,600 --> 01:00:27,730
而您想，为什么要这么做呢？ 

1253
01:00:27,730 --> 01:00:29,270
好吧，这就是它的全部工作。 

1254
01:00:29,270 --> 01:00:33,160
它希望保留默认值，使其内部保持不变。 

1255
01:00:33,160 --> 01:00:35,590
它不希望它变得明确， 

1256
01:00:35,590 --> 01:00:38,430
这样人们就可以看到默认值是

1257
01:00:38,430 --> 01:00:42,120
如果出于某种原因不希望其成为公共信息。 

1258
01:00:42,120 --> 01:00:43,183
很好

1259
01:00:44,380 --> 01:00:47,600
因此，现在不用将其存储为“无标题”，对吗？ 

1260
01:00:47,600 --> 01:00:49,740
这个“无标题”，让我们摆脱它。 

1261
01:00:49,740 --> 01:00:54,000
取而代之的是，我将在这里让defaultsKey放些。 

1262
01:00:54,000 --> 01:00:57,173
我们将使用EmojiArtDocument。 

1263
01:00:59,340 --> 01:01:03,470
我将在这里使用这种小的字符串嵌入

1264
01:01:03,470 --> 01:01:07,140
将我的ID作为字符串放入其中。 

1265
01:01:07,140 --> 01:01:10,510
它在这里有一个很好的功能，uuidString 

1266
01:01:10,510 --> 01:01:12,720
这样就可以给您。 

1267
01:01:12,720 --> 01:01:14,270
这是我要使用的默认密钥

1268
01:01:14,270 --> 01:01:15,843
而不是这个“无标题”， 

1269
01:01:17,650 --> 01:01:22,513
无论是在到达目的地还是在保存时。 

1270
01:01:23,460 --> 01:01:25,890
所以现在我做了我的文件

1271
01:01:25,890 --> 01:01:28,603
始终保留在UserDefaults中。 

1272
01:01:29,750 --> 01:01:31,830
这就是我们的商店。 

1273
01:01:31,830 --> 01:01:34,050
我们现在要使用这家商店

1274
01:01:34,050 --> 01:01:36,880
作为我们要构建的新视图的ViewModel 

1275
01:01:36,880 --> 01:01:39,170
让我们选择文档。 

1276
01:01:39,170 --> 01:01:40,980
因此，它是一个文档选择器。 

1277
01:01:40,980 --> 01:01:44,053
让我们继续在这里创建一个新的SwiftUI视图。 

1278
01:01:45,670 --> 01:01:47,940
这是一个SwiftUI视图，该选择器。 

1279
01:01:47,940 --> 01:01:50,180
这是文档列表，但它是一个视图。 

1280
01:01:50,180 --> 01:01:52,430
我将其称为EmojiArtDocumentChooser。 

1281
01:01:54,720 --> 01:01:57,540
我可能会开始后悔把EmojiArtDocument 

1282
01:01:57,540 --> 01:01:59,340
在这里的一切前面，但不是真的。 

1283
01:01:59,340 --> 01:02:02,633
拥有明确的事物名称真是太好了。 

1284
01:02:03,800 --> 01:02:05,740
所以这是我的选择器。 

1285
01:02:05,740 --> 01:02:09,710
而且这个选择器实际上将要拥有一家商店。 

1286
01:02:09,710 --> 01:02:11,030
我要把商店变成

1287
01:02:11,030 --> 01:02:12,943
环境对象也是如此。 

1288
01:02:14,140 --> 01:02:16,370
我可以做这个ObservedObject， 

1289
01:02:16,370 --> 01:02:18,110
但我只是想在这里混在一起。 

1290
01:02:18,110 --> 01:02:20,780
我不是真的把它放在弹出窗口中

1291
01:02:20,780 --> 01:02:24,200
或需要我做EnvironmentObject的工作表。 

1292
01:02:24,200 --> 01:02:27,260
但是使用EnvironmentObject很常见

1293
01:02:27,260 --> 01:02:29,307
特别是对于这样的顶级视图

1294
01:02:29,307 --> 01:02:32,113
那将是选择其他视图等等。 

1295
01:02:33,610 --> 01:02:37,420
那么我们该怎么做，在这里获取我们商店中的对象列表

1296
01:02:37,420 --> 01:02:39,010
并显示在我们的体内？ 

1297
01:02:39,010 --> 01:02:41,670
我们确切地知道如何列出事物并显示， 

1298
01:02:41,670 --> 01:02:46,230
我们进行一次ForEach，然后要做store.documents。 

1299
01:02:46,230 --> 01:02:48,340
现在我很高兴

1300
01:02:48,340 --> 01:02:51,690
我使EmojiArtDocument可识别的

1301
01:02:51,690 --> 01:02:53,920
因为在这里的store.documents 

1302
01:02:54,790 --> 01:02:57,010
是EmojiArtDocument的数组。 

1303
01:02:57,010 --> 01:03:00,100
oo，这对于ForEach来说必须是可识别的

1304
01:03:00,100 --> 01:03:02,910
呜，我们知道了它

1305
01:03:02,910 --> 01:03:04,470
通过将其称为ID。 

1306
01:03:04,470 --> 01:03:05,723
当然，我知道我会那样做。 

1307
01:03:05,723 --> 01:03:08,643
但是您可以看到这样做的好处。 

1308
01:03:10,220 --> 01:03:11,820
好吧，所以我们有文件

1309
01:03:11,820 --> 01:03:15,000
对于每个文档，我只想创建一个视图

1310
01:03:15,000 --> 01:03:17,263
还可以在列表中显示该文档。 

1311
01:03:19,040 --> 01:03:23,130
因此，我们仅通过编写文本来做到这一点， 

1312
01:03:23,130 --> 01:03:27,080
该文档的商店名称。 

1313
01:03:27,080 --> 01:03:30,570
因此，这只是文档名称的列表。 

1314
01:03:30,570 --> 01:03:33,430
现在，我们当然知道ForEach不做布局。 

1315
01:03:33,430 --> 01:03:36,830
所以我们必须将其放入HStack或VStack 

1316
01:03:36,830 --> 01:03:39,220
或网格或某种布局的东西。 

1317
01:03:39,220 --> 01:03:41,200
今天我们要学习新的。 

1318
01:03:41,200 --> 01:03:44,090
这个称为列表。 

1319
01:03:44,090 --> 01:03:47,750
所以List，有点像VStack 

1320
01:03:47,750 --> 01:03:49,730
感觉有点像VStack， 

1321
01:03:49,730 --> 01:03:51,020
但功能更强大

1322
01:03:51,020 --> 01:03:53,270
它创建了一个大的可滚动列表

1323
01:03:53,270 --> 01:03:55,860
与分隔符和所有的东西。 

1324
01:03:55,860 --> 01:03:59,800
看起来就像在其他应用程序中看到的一样

1325
01:03:59,800 --> 01:04:03,083
在旧版UI工具包中，我们称之为TableView。 

1326
01:04:04,490 --> 01:04:08,900
现在，我们必须通过，我们很快就会看到这一点， 

1327
01:04:08,900 --> 01:04:11,190
我们必须通过我们的商店在这里。 

1328
01:04:11,190 --> 01:04:13,270
我也想要这个文档选择器。 

1329
01:04:13,270 --> 01:04:15,003
当我现在运行我的应用程序时， 

1330
01:04:16,300 --> 01:04:18,630
向我显示了EmojiArtDocument。 

1331
01:04:18,630 --> 01:04:20,810
但是我想让它显示这个选择器。 

1332
01:04:20,810 --> 01:04:23,370
所以我将不得不回到这里的主题代表， 

1333
01:04:23,370 --> 01:04:25,870
而不是这样做EmojiArtDocumentView 

1334
01:04:26,780 --> 01:04:29,783
而是改用EmojiArtDocumentChooser。 

1335
01:04:32,190 --> 01:04:34,500
这不需要任何争论，好的。 

1336
01:04:34,500 --> 01:04:38,783
但它确实希望您提供此EnvironmentObject， 

1337
01:04:40,100 --> 01:04:41,800
必须是商店。 

1338
01:04:41,800 --> 01:04:43,830
因此，我们将不得不创建该商店。 

1339
01:04:43,830 --> 01:04:47,746
我要说让商店平等

1340
01:04:47,746 --> 01:04:51,504
EmojiArtDocumentStore。 

1341
01:04:52,400 --> 01:04:54,000
碰巧有个名字

1342
01:04:54,000 --> 01:04:56,362
所以我要称呼我为“表情符号艺术” 

1343
01:04:56,362 --> 01:04:58,940
那将是该文档存储的名称。 

1344
01:04:58,940 --> 01:05:02,070
我们什至在其中放几个文件。 

1345
01:05:02,070 --> 01:05:03,120
因此，store.addDocument。 

1346
01:05:04,480 --> 01:05:09,480
也许store.addDocument名为“ Hello World”。 

1347
01:05:11,470 --> 01:05:13,540
所以我在这里做的所有这些事情addDocument 

1348
01:05:13,540 --> 01:05:14,410
并创建商店

1349
01:05:14,410 --> 01:05:16,620
这就是这里存储的所有东西，对吧？ 

1350
01:05:16,620 --> 01:05:18,530
这是addDocument创建的。 

1351
01:05:18,530 --> 01:05:22,313
这是文档，创建文档。 

1352
01:05:23,270 --> 01:05:25,190
初始化器就在这里，对吗？ 

1353
01:05:25,190 --> 01:05:27,230
以Init命名，我只是在创建它， 

1354
01:05:27,230 --> 01:05:29,120
我在这里没什么特别的

1355
01:05:29,120 --> 01:05:31,220
我只是在创建商店。 

1356
01:05:31,220 --> 01:05:33,410
然后我将商店设置为环境

1357
01:05:33,410 --> 01:05:36,770
给我的选择者，以便我的选择者拥有这家商店

1358
01:05:36,770 --> 01:05:39,027
它可以检查商店的所有文件

1359
01:05:39,027 --> 01:05:40,070
并显示名称。 

1360
01:05:40,070 --> 01:05:43,393
它将在此List UI中进行。 

1361
01:05:43,393 --> 01:05:45,343
因此，让我们看看此列表的外观。 

1362
01:05:47,929 --> 01:05:50,250
呜呜，我们走了，我们有两个文件。 

1363
01:05:50,250 --> 01:05:52,040
现在，这是一个可滚动的列表， 

1364
01:05:52,040 --> 01:05:53,763
因此我们可以上下滚动它。 

1365
01:05:55,220 --> 01:05:57,830
因此，此存储本身是持久性的。 

1366
01:05:57,830 --> 01:06:01,920
因此，如果我们回到这里的SceneDelegate， 

1367
01:06:01,920 --> 01:06:05,573
并删除这些addDocuments并重新运行， 

1368
01:06:08,230 --> 01:06:11,200
他们将留在列表中。 

1369
01:06:11,200 --> 01:06:15,130
现在，这很棒，但是当我们点击这些时， 

1370
01:06:15,130 --> 01:06:17,520
它没有向我们显示这些文件， 

1371
01:06:17,520 --> 01:06:20,350
Hello World和Untitled，未向我们显示。 

1372
01:06:20,350 --> 01:06:22,340
为了做到这一点，点击事物

1373
01:06:22,340 --> 01:06:26,730
导航到其他视图以向我们显示这些文档， 

1374
01:06:26,730 --> 01:06:31,730
我们必须将我们的列表嵌入到另一个视图中

1375
01:06:32,240 --> 01:06:34,193
称为NavigationView。 

1376
01:06:36,221 --> 01:06:39,910
NavigationView，通常，几乎总是

1377
01:06:39,910 --> 01:06:42,430
用于将列表放入导航中， 

1378
01:06:42,430 --> 01:06:43,770
不是绝对必需的。 

1379
01:06:43,770 --> 01:06:47,563
有时，我们可能会在此处放置一个表格。 

1380
01:06:48,570 --> 01:06:50,530
所以我们的NavigationView只是改变了

1381
01:06:50,530 --> 01:06:52,200
我们的观点在这里

1382
01:06:52,200 --> 01:06:55,030
但是仍然没有成功，所以如果我们点击这些， 

1383
01:06:55,030 --> 01:06:58,410
我点击这些，没有任何区别。 

1384
01:06:58,410 --> 01:07:01,050
那是因为这些只是这里的文本， 

1385
01:07:01,050 --> 01:07:04,930
当您点击它们时，他们不知道如何导航。 

1386
01:07:04,930 --> 01:07:08,250
所以我们也将它们包装在一个视图中

1387
01:07:08,250 --> 01:07:10,253
称为NavigationLink。 

1388
01:07:11,900 --> 01:07:16,340
现在，NavigationLink有很多创建它的方法。 

1389
01:07:16,340 --> 01:07:19,100
但是在所有这些中，都有一个非常重要的论点

1390
01:07:19,100 --> 01:07:22,290
您可以在这里看到目的地。 

1391
01:07:22,290 --> 01:07:25,740
该链接将到达的目的地

1392
01:07:25,740 --> 01:07:26,880
当您点击它时。 

1393
01:07:26,880 --> 01:07:31,880
换句话说，给我一个View来导航到

1394
01:07:32,210 --> 01:07:33,900
当我点击这个。 

1395
01:07:33,900 --> 01:07:36,210
所以在我们的情况下，我们想要的目的地

1396
01:07:36,210 --> 01:07:39,520
我们要一个EmojiArtDocumentView吗

1397
01:07:39,520 --> 01:07:43,670
显示您刚刚单击的文档，对吗？ 

1398
01:07:43,670 --> 01:07:46,180
我们在ForEach中，我们有这些文件。 

1399
01:07:46,180 --> 01:07:49,093
我们想要转到显示此文档的文档视图。 

1400
01:07:50,230 --> 01:07:53,330
现在我们把这个文本放进去

1401
01:07:53,330 --> 01:07:55,693
此NavigationLink视图的内容。 

1402
01:07:56,780 --> 01:07:59,360
这就是我们做到的方式

1403
01:07:59,360 --> 01:08:02,023
我们列表中的那些是可导航的。 

1404
01:08:03,080 --> 01:08:04,330
让我们看看实际情况。 

1405
01:08:06,300 --> 01:08:08,670
好吧，现在请注意有些变化。 

1406
01:08:08,670 --> 01:08:11,120
现在这里比符号要大一点。 

1407
01:08:11,120 --> 01:08:14,020
让用户知道您是否点击了此按钮， 

1408
01:08:14,020 --> 01:08:15,650
它会去某个地方。 

1409
01:08:15,650 --> 01:08:17,100
让我们尝试。 

1410
01:08:17,100 --> 01:08:20,123
哎呀，在那里，看看那个。 

1411
01:08:20,123 --> 01:08:23,650
好的，我们在这里有不同的文件。 

1412
01:08:23,650 --> 01:08:26,860
现在，这有点空白

1413
01:08:26,860 --> 01:08:28,687
而且很难说是怎么回事。 

1414
01:08:28,687 --> 01:08:32,360
而NavigationView提供了很多机制

1415
01:08:32,360 --> 01:08:35,440
使用户更容易理解。 

1416
01:08:35,440 --> 01:08:38,070
例如标题，我们可以放置标题

1417
01:08:38,070 --> 01:08:39,993
这就是顶部的空白。 

1418
01:08:39,993 --> 01:08:43,650
我们可以将标题放在此列表的顶部， 

1419
01:08:43,650 --> 01:08:45,930
如果您愿意，我们也可以放一个不同的标题

1420
01:08:45,930 --> 01:08:48,670
在此视图顶部。 

1421
01:08:48,670 --> 01:08:50,390
因此，当您在NavigationView中时， 

1422
01:08:50,390 --> 01:08:51,760
而您正在四处浏览， 

1423
01:08:51,760 --> 01:08:54,050
您可以在每个标题上放置标题。 

1424
01:08:54,050 --> 01:08:57,970
您可以在此处显示的每个视图上设置此标题。 

1425
01:08:57,970 --> 01:09:00,760
因此，我们将在此列表上设置标题， 

1426
01:09:00,760 --> 01:09:02,070
那我们要设置一个标题

1427
01:09:02,070 --> 01:09:05,490
在此EmojiArtDocument视图上。 

1428
01:09:05,490 --> 01:09:06,930
来做吧。 

1429
01:09:06,930 --> 01:09:09,430
所以这是列表，让我们设置它的标题。 

1430
01:09:09,430 --> 01:09:14,020
因此，当显示列表时，navigationBarTitle 

1431
01:09:14,020 --> 01:09:17,610
将会...商店的名称如何， 

1432
01:09:17,610 --> 01:09:18,730
我们商店的名称

1433
01:09:18,730 --> 01:09:20,430
因为这就是该列表显示的内容， 

1434
01:09:20,430 --> 01:09:22,660
显示该商店中的所有文档。 

1435
01:09:22,660 --> 01:09:23,980
让我们来命名商店的名称。 

1436
01:09:23,980 --> 01:09:26,083
商店名称在这里只是一个变量， 

1437
01:09:26,083 --> 01:09:28,330
商店会跟踪其名称， 

1438
01:09:28,330 --> 01:09:30,060
仅此而已。 

1439
01:09:30,060 --> 01:09:34,490
然后这里是我们的EmojiArtDocument视图。 

1440
01:09:34,490 --> 01:09:38,710
让我们在上面加上一个名字，navigationBarTitle。 

1441
01:09:39,950 --> 01:09:44,950
这是此文档的商店名称。 

1442
01:09:45,480 --> 01:09:50,480
现在，请注意，我正在将该栏标题放到该视图上。 

1443
01:09:51,810 --> 01:09:54,300
这是EmojiArtDocumentView 

1444
01:09:54,300 --> 01:09:56,960
我在此处导航时显示的目的地。 

1445
01:09:56,960 --> 01:09:58,980
因此，当显示此视图时， 

1446
01:09:58,980 --> 01:10:01,199
这就是我们要使用的标题

1447
01:10:01,199 --> 01:10:03,589
navigationBarTitle，将其放在视图上

1448
01:10:03,589 --> 01:10:07,050
将会显示出来，这就是您得到的。 

1449
01:10:08,640 --> 01:10:10,913
表情符号艺术，这就是我们商店的名称。 

1450
01:10:11,769 --> 01:10:13,560
当我们单击Hello World时， 

1451
01:10:13,560 --> 01:10:14,690
那是这个文件的名字，对吧？ 

1452
01:10:14,690 --> 01:10:17,140
这是Hello World文档， 

1453
01:10:17,140 --> 01:10:19,170
这是无标题文档。 

1454
01:10:19,170 --> 01:10:20,970
现在我们可以在这里放其他东西

1455
01:10:20,970 --> 01:10:23,990
除了标题，我们实际上可以放一些按钮。 

1456
01:10:23,990 --> 01:10:25,070
就像拥有它会很好

1457
01:10:25,070 --> 01:10:27,170
这里顶部的一个小按钮， 

1458
01:10:27,170 --> 01:10:29,930
也许是一个按钮，添加了另一种表情符号艺术， 

1459
01:10:29,930 --> 01:10:32,200
创建一个新的无标题文档。 

1460
01:10:32,200 --> 01:10:34,350
所以我要在这里放一个加号按钮

1461
01:10:34,350 --> 01:10:36,565
就是那样。 

1462
01:10:36,565 --> 01:10:37,497
在这下吧

1463
01:10:37,497 --> 01:10:40,620
这是，此按钮将仅可用

1464
01:10:40,620 --> 01:10:42,790
当此列表未显示在此处时

1465
01:10:42,790 --> 01:10:44,853
当显示EmojiArtDocumentView时， 

1466
01:10:44,853 --> 01:10:46,190
仅当列表显示时， 

1467
01:10:46,190 --> 01:10:49,660
navigationBarItems，这称为。 

1468
01:10:49,660 --> 01:10:51,200
而且您可以领先和落后。 

1469
01:10:51,200 --> 01:10:53,570
我将其放在领先位置。 

1470
01:10:53,570 --> 01:10:54,823
这只是一个按钮。 

1471
01:10:55,954 --> 01:10:57,430
你知道怎么做按钮。 

1472
01:10:57,430 --> 01:10:59,507
因此，我们将在一秒钟内完成。 

1473
01:10:59,507 --> 01:11:02,913
该按钮的标签将是图像。 

1474
01:11:04,090 --> 01:11:05,007
我将在这里使用systemName。 

1475
01:11:05,007 --> 01:11:08,980
我要加，再说一次，我经过这里

1476
01:11:08,980 --> 01:11:10,960
到SF符号并在周围搜索

1477
01:11:10,960 --> 01:11:12,980
对于什么才有意义。 

1478
01:11:12,980 --> 01:11:14,900
我也会在这里做大规模。 

1479
01:11:14,900 --> 01:11:16,733
将此按钮变大。 

1480
01:11:17,844 --> 01:11:20,520
当单击此加号按钮时我该怎么办？ 

1481
01:11:20,520 --> 01:11:23,067
没问题，存储，addDocument， 

1482
01:11:23,067 --> 01:11:25,593
只需将文档添加到我们的商店即可。 

1483
01:11:26,777 --> 01:11:29,450
因此，我们将此按钮添加到了栏项目中

1484
01:11:29,450 --> 01:11:34,000
在此NavigationView的最前沿。 

1485
01:11:34,000 --> 01:11:34,860
那里就在那里。 

1486
01:11:34,860 --> 01:11:37,300
注意，这里没有我们的加号按钮。 

1487
01:11:37,300 --> 01:11:40,260
取而代之的是，我们在此具有Back按钮。 

1488
01:11:40,260 --> 01:11:41,530
是因为我们在这里

1489
01:11:41,530 --> 01:11:43,800
未添加此navigationBarItems 

1490
01:11:43,800 --> 01:11:45,577
在这里到EmojiArtDocumentView 

1491
01:11:45,577 --> 01:11:49,250
我们正在显示这个EmojiArtDocumentView 

1492
01:11:49,250 --> 01:11:51,050
当我们单击它时， 

1493
01:11:51,050 --> 01:11:53,000
所以它没有那个加Button。 

1494
01:11:53,930 --> 01:11:55,560
让我们尝试加。 

1495
01:11:55,560 --> 01:11:59,890
oo，这里还有另一个无标题的文档，太好了！ 

1496
01:11:59,890 --> 01:12:03,840
现在我们也可以在此处添加一些酒吧项目

1497
01:12:03,840 --> 01:12:05,850
在我们的EmojiArtDocumentView中。 

1498
01:12:05,850 --> 01:12:06,993
例如，也许是时候做到了

1499
01:12:06,993 --> 01:12:10,450
因此该应用实际上可以在iPhone上使用， 

1500
01:12:10,450 --> 01:12:13,350
这样我们就可以设置背景图片

1501
01:12:13,350 --> 01:12:16,560
iPhone中没有拖放功能， 

1502
01:12:16,560 --> 01:12:18,940
因此要设置背景图片，我们必须采取其他方法。 

1503
01:12:18,940 --> 01:12:22,660
简单地说，如何复制和粘贴？ 

1504
01:12:22,660 --> 01:12:24,327
您去找到想要的图像，然后复制它， 

1505
01:12:24,327 --> 01:12:26,400
你回到这里，点击粘贴。 

1506
01:12:26,400 --> 01:12:27,780
我要在这里贴

1507
01:12:27,780 --> 01:12:30,400
是右上角的一个小按钮。 

1508
01:12:30,400 --> 01:12:32,170
现在，因为我只想要此粘贴按钮

1509
01:12:32,170 --> 01:12:34,630
在我显示文件时出现

1510
01:12:34,630 --> 01:12:37,780
我要把这个按钮的代码

1511
01:12:37,780 --> 01:12:41,980
在EmojiArtDocumentView中，因为这就是这里显示的内容， 

1512
01:12:41,980 --> 01:12:43,897
这就是将要控制此Button的内容。 

1513
01:12:43,897 --> 01:12:46,200
所以我要去EmojiArtDocumentView。 

1514
01:12:46,200 --> 01:12:48,870
让我们下去，也许在onDrop之后就在这里

1515
01:12:50,330 --> 01:12:53,563
并在此处添加navigationBarItems。 

1516
01:12:54,900 --> 01:12:58,383
这次我希望它位于它的末尾。 

1517
01:12:59,320 --> 01:13:02,133
让我们再做一个按钮。 

1518
01:13:03,112 --> 01:13:08,112
而这个按钮与第二个动作

1519
01:13:08,410 --> 01:13:13,410
和标签，让我们将标签设为图像系统名称。 

1520
01:13:15,780 --> 01:13:18,840
我搜寻了SF Symbols，发现其中的一种很酷， 

1521
01:13:18,840 --> 01:13:22,450
剪贴板上的文档， 

1522
01:13:22,450 --> 01:13:24,940
所以这是一个显示

1523
01:13:24,940 --> 01:13:27,490
剪贴板上有文档时。 

1524
01:13:27,490 --> 01:13:29,853
让我们再次放大图像缩放。 

1525
01:13:31,000 --> 01:13:34,430
因此，这样做确实很酷，很完美。 

1526
01:13:34,430 --> 01:13:36,930
当他们尝试粘贴时我们该怎么办

1527
01:13:36,930 --> 01:13:37,930
从粘贴板？ 

1528
01:13:37,930 --> 01:13:39,210
好吧，我们要从粘贴板中粘贴

1529
01:13:39,210 --> 01:13:41,830
事实证明，在iOS中确实非常容易做到。 

1530
01:13:41,830 --> 01:13:46,830
我要说的是，让URL等于我的一般粘贴板URL变量

1531
01:13:49,300 --> 01:13:51,230
如果不是零， 

1532
01:13:51,230 --> 01:13:55,050
然后我要设置文档的backgroundURL 

1533
01:13:55,050 --> 01:13:55,950
等于该URL。 

1534
01:13:56,930 --> 01:13:59,270
因此，让我们在这里了解粘贴板。 

1535
01:13:59,270 --> 01:14:01,670
Pasteboard.general是共享的Pasteboard 

1536
01:14:01,670 --> 01:14:05,060
代表此设备上的粘贴板。 

1537
01:14:05,060 --> 01:14:09,530
它有很多不同的变量，例如字符串，网址， 

1538
01:14:09,530 --> 01:14:12,500
其他类型的东西，如果粘贴板上的东西

1539
01:14:12,500 --> 01:14:16,210
可以代表这一点，它在这里返回非零。 

1540
01:14:16,210 --> 01:14:18,620
因此，如果粘贴板上有一个URL， 

1541
01:14:18,620 --> 01:14:21,570
我们将尝试在此处将其设置为背景。 

1542
01:14:22,690 --> 01:14:23,890
让我们看看是否可行。 

1543
01:14:26,789 --> 01:14:27,877
所以我在这里打招呼。 

1544
01:14:27,877 --> 01:14:28,880
哦，是的。 

1545
01:14:28,880 --> 01:14:30,820
点击，这什么也没做。 

1546
01:14:30,820 --> 01:14:33,791
让我们看看是否可以在粘贴板中放置一些内容。 

1547
01:14:33,791 --> 01:14:36,363
让我们去那里获取我最喜欢的图像。 

1548
01:14:37,650 --> 01:14:39,760
这不是哪一个。 

1549
01:14:39,760 --> 01:14:41,990
我喜欢这个。 

1550
01:14:41,990 --> 01:14:42,823
在那里。 

1551
01:14:42,823 --> 01:14:45,840
我只是按住不放并说复制。 

1552
01:14:45,840 --> 01:14:48,510
因此，假设在iOS中复制图片。 

1553
01:14:48,510 --> 01:14:50,870
返回此处并粘贴。 

1554
01:14:50,870 --> 01:14:52,997
oo，效果很好。 

1555
01:14:52,997 --> 01:14:56,120
看看，我可以放大，很好！ 

1556
01:14:56,120 --> 01:14:58,010
我什至可以踢一点足球

1557
01:14:58,010 --> 01:14:59,800
在这里的前院。 

1558
01:14:59,800 --> 01:15:01,370
好，很好

1559
01:15:01,370 --> 01:15:04,230
所以这太棒了。 

1560
01:15:04,230 --> 01:15:06,090
不幸的是，当我这样做时

1561
01:15:06,090 --> 01:15:08,440
我在表情符号艺术中发现了另一个小错误。 

1562
01:15:08,440 --> 01:15:09,347
看这个。 

1563
01:15:09,347 --> 01:15:11,160
我要回去，让我们回去。 

1564
01:15:11,160 --> 01:15:15,710
哦，不，有我的表情符号，但是我丢失了背景图片。 

1565
01:15:15,710 --> 01:15:18,870
事实证明，在我们的EmojiArt背景视图中， 

1566
01:15:18,870 --> 01:15:21,960
当我们缩放到适合时，我们做得很好

1567
01:15:21,960 --> 01:15:25,170
防止图像大小为零， 

1568
01:15:25,170 --> 01:15:29,190
但是我们忘记了防止视图大小为零。 

1569
01:15:29,190 --> 01:15:31,750
因为当该视图出现在屏幕上时， 

1570
01:15:31,750 --> 01:15:34,920
它似乎暂时具有零高度。 

1571
01:15:34,920 --> 01:15:37,970
我不确定正在发生什么过程。 

1572
01:15:37,970 --> 01:15:40,670
但是我们会放大以使其在那一点上为零。 

1573
01:15:40,670 --> 01:15:43,110
所以我也要在这里检查并缩放以适合

1574
01:15:43,110 --> 01:15:45,690
我的size.height大于零， 

1575
01:15:45,690 --> 01:15:47,810
并且我的size.width大于零。 

1576
01:15:47,810 --> 01:15:50,230
我只是在保护变焦以适应， 

1577
01:15:50,230 --> 01:15:54,340
这样就不会将此处的zoomScale设置为零。 

1578
01:15:54,340 --> 01:15:55,890
我永远不希望我的zoomScale为零

1579
01:15:55,890 --> 01:15:58,240
因为那样我看不到我的文件。 

1580
01:15:58,240 --> 01:16:01,410
如果我回到这里模拟器

1581
01:16:01,410 --> 01:16:02,720
我实际上可以双击

1582
01:16:02,720 --> 01:16:05,700
并将其从零放大，这很好， 

1583
01:16:05,700 --> 01:16:08,150
但我永远都不想把它放在零阶段。 

1584
01:16:08,150 --> 01:16:11,023
因此，让我们在此处进行此修复。 

1585
01:16:12,000 --> 01:16:15,250
大家好，这是我们的文档。 

1586
01:16:15,250 --> 01:16:16,900
也许我们会缩小它， 

1587
01:16:16,900 --> 01:16:19,550
我们将在后端出去。 

1588
01:16:19,550 --> 01:16:21,240
好吧，现在很有趣。 

1589
01:16:21,240 --> 01:16:24,550
因此它没有放大到零。 

1590
01:16:24,550 --> 01:16:27,750
但它会放大以恢复其完整尺寸， 

1591
01:16:27,750 --> 01:16:29,950
即使我缩小了

1592
01:16:29,950 --> 01:16:33,550
当我走来走去时，它失去了变焦。 

1593
01:16:33,550 --> 01:16:36,690
当您拥有这些视图时，这是要考虑的事情

1594
01:16:36,690 --> 01:16:38,860
由于导航而来来往往。 

1595
01:16:38,860 --> 01:16:41,053
因此，我正在导航并返回。 

1596
01:16:41,930 --> 01:16:44,780
执行此操作时，这些视图将被重建， 

1597
01:16:44,780 --> 01:16:47,920
并且他们的@State大部分被保留， 

1598
01:16:47,920 --> 01:16:52,020
但是某些国家可能无法保留。 

1599
01:16:52,020 --> 01:16:55,570
例如，我们的缩放状态

1600
01:16:55,570 --> 01:16:58,670
在执行此操作时不会保留。 

1601
01:16:58,670 --> 01:17:01,050
现在，如果您希望保留State， 

1602
01:17:01,050 --> 01:17:02,700
有一个很棒的地方。 

1603
01:17:02,700 --> 01:17:04,240
您的ViewModel。 

1604
01:17:04,240 --> 01:17:06,970
好的，无论View端发生了什么， 

1605
01:17:06,970 --> 01:17:09,320
如果您的ViewModel坚持下去， 

1606
01:17:09,320 --> 01:17:10,360
它会被保留。 

1607
01:17:10,360 --> 01:17:12,940
现在，这与将其放入模型中不同。 

1608
01:17:12,940 --> 01:17:15,710
我不希望比例缩放成为模型的一部分， 

1609
01:17:15,710 --> 01:17:20,610
模型就是房子，还有表情符号， 

1610
01:17:20,610 --> 01:17:22,930
但不包括缩放比例。 

1611
01:17:22,930 --> 01:17:24,700
但是把它放在我的ViewModel中， 

1612
01:17:24,700 --> 01:17:26,140
如果我的ViewModel没有转过身

1613
01:17:26,140 --> 01:17:29,060
并将其放入模型中，完全可以做到

1614
01:17:29,060 --> 01:17:31,660
它提供了跨多个视图的共享

1615
01:17:31,660 --> 01:17:36,070
可能正在查看同一文档ViewModel。 

1616
01:17:36,070 --> 01:17:37,280
因此，让我们开始吧。 

1617
01:17:37,280 --> 01:17:38,230
我们将如何做？ 

1618
01:17:38,230 --> 01:17:41,560
我要在这里做，这样我们的稳定状态

1619
01:17:41,560 --> 01:17:45,141
让我们搜索我们的steadyStatePanOffset在哪里。 

1620
01:17:45,141 --> 01:17:47,001
所以这是steadyStatePanOffset， 

1621
01:17:47,001 --> 01:17:50,877
这是我们在此处设置的stableStateZoomOffset。 

1622
01:17:50,877 --> 01:17:52,396
我们将拥有这些而不是被

1623
01:17:52,396 --> 01:17:54,750
在我们看来，@ State 

1624
01:17:54,750 --> 01:17:56,943
我们将它们放入我们的ViewModel中。 

1625
01:17:57,830 --> 01:18:00,393
所以，让我们这样做，让我们在这里削减这些支出。 

1626
01:18:03,272 --> 01:18:05,570
并将它们放在我们的ViewModel中。 

1627
01:18:05,570 --> 01:18:08,693
我想再说一次。 

1628
01:18:09,560 --> 01:18:11,800
当然，它们不是在ViewModel中声明的， 

1629
01:18:11,800 --> 01:18:13,893
相反，它们将被@Published。 

1630
01:18:15,500 --> 01:18:16,670
而且我不会把它们保密

1631
01:18:16,670 --> 01:18:20,807
因为我要允许我的View设置它们并获取它们。 

1632
01:18:20,807 --> 01:18:23,400
在我这里的视图中，我将替换所有地方

1633
01:18:23,400 --> 01:18:28,400
我用document.steadyState代替了稳态。 

1634
01:18:32,458 --> 01:18:34,093
因此，只需在各处进行即可。 

1635
01:18:35,730 --> 01:18:38,670
我们回到panOffset，开始。 

1636
01:18:38,670 --> 01:18:39,670
现在，让我们尝试一下。 

1637
01:18:43,618 --> 01:18:45,530
好的，Hello World，就在这里。 

1638
01:18:45,530 --> 01:18:47,000
现在，让我们缩小。 

1639
01:18:47,000 --> 01:18:50,690
缩放比例保留在我们的ViewModel中。 

1640
01:18:50,690 --> 01:18:53,180
所以现在如果我们回到过去， 

1641
01:18:53,180 --> 01:18:54,660
它仍然在我们的ViewModel中

1642
01:18:54,660 --> 01:18:56,833
即使此视图已被重建。 

1643
01:18:58,180 --> 01:19:00,080
现在，我们可以在这里做更多的事情

1644
01:19:00,080 --> 01:19:01,820
对我们的用户更好

1645
01:19:01,820 --> 01:19:06,080
一件事就是这个小按钮，很多时候您单击它

1646
01:19:06,080 --> 01:19:07,540
没有任何反应，好吧。 

1647
01:19:07,540 --> 01:19:11,110
我们经过这里并单击它，没有任何反应，好吗？ 

1648
01:19:11,110 --> 01:19:12,530
那个东西不再在粘贴板上了， 

1649
01:19:12,530 --> 01:19:15,460
我复制并粘贴了此稳定状态的东西，所以它消失了。 

1650
01:19:15,460 --> 01:19:17,980
所以我没有得到很多用户反馈

1651
01:19:17,980 --> 01:19:19,730
关于此按钮的功能。 

1652
01:19:19,730 --> 01:19:20,660
还不清楚

1653
01:19:20,660 --> 01:19:24,010
我想好像是复制到粘贴板上的东西， 

1654
01:19:24,010 --> 01:19:27,960
我想，但这就像，我们要做什么

1655
01:19:27,960 --> 01:19:30,670
为了给大家一些反馈。 

1656
01:19:30,670 --> 01:19:33,410
那如果他们点击这个呢

1657
01:19:33,410 --> 01:19:35,900
而且不会在那里做任何事情， 

1658
01:19:35,900 --> 01:19:40,090
我们设置了一个小警报，解释了这是什么。 

1659
01:19:40,090 --> 01:19:41,220
这样给我们机会

1660
01:19:41,220 --> 01:19:43,640
了解如何设置警报。 

1661
01:19:43,640 --> 01:19:45,863
设置警报非常简单。 

1662
01:19:45,863 --> 01:19:48,610
您可以将其放在此图像上。 

1663
01:19:48,610 --> 01:19:52,420
如果您单击此图像，我们要发出警报。 

1664
01:19:52,420 --> 01:19:57,420
现在，这里的Alerts是有趣的小ViewModifiers。 

1665
01:19:58,750 --> 01:20:01,275
他们开始看起来很像一个弹出窗口。 

1666
01:20:01,275 --> 01:20:02,610
您可以看到他们拥有

1667
01:20:02,610 --> 01:20:04,530
可识别的绑定版本

1668
01:20:04,530 --> 01:20:07,300
如果您想在警报中添加其他内容

1669
01:20:07,300 --> 01:20:08,347
视情况而定。 

1670
01:20:08,347 --> 01:20:10,760
但它也有这个不错的表现， 

1671
01:20:10,760 --> 01:20:12,380
这就是我们要使用的那个。 

1672
01:20:12,380 --> 01:20:16,830
我们将需要某种布尔变量

1673
01:20:16,830 --> 01:20:18,550
表示此警报是否应该启动， 

1674
01:20:18,550 --> 01:20:21,480
我将其命名为explainBackgroundPaste。 

1675
01:20:23,088 --> 01:20:28,009
这将是我的州立私人变量， 

1676
01:20:28,009 --> 01:20:30,529
说明背景粘贴。 

1677
01:20:30,529 --> 01:20:31,620
我将以虚假开始。 

1678
01:20:31,620 --> 01:20:34,180
我不希望我们第一次出现时显示该警报。 

1679
01:20:34,180 --> 01:20:37,960
我只需要设置此值即可显示此警报。 

1680
01:20:37,960 --> 01:20:39,520
我要在哪里设置呢？ 

1681
01:20:39,520 --> 01:20:40,670
我要在这里设置。 

1682
01:20:40,670 --> 01:20:44,630
我会在任何时候设置它

1683
01:20:44,630 --> 01:20:45,868
在此更新背景。 

1684
01:20:45,868 --> 01:20:48,560
所以我要说的是如果我不更新背景， 

1685
01:20:48,560 --> 01:20:51,130
如果只是单击“按钮”而不执行任何操作。 

1686
01:20:51,130 --> 01:20:55,833
我要说self.explainBackgroundPaste等于true。 

1687
01:20:56,790 --> 01:20:59,383
这将导致此警报出现。 

1688
01:20:59,383 --> 01:21:03,320
我想如果网址也可以

1689
01:21:03,320 --> 01:21:07,813
不等于我们现有的backgroundURL， 

1690
01:21:09,310 --> 01:21:12,540
因此，如果您已经粘贴，然后尝试再次粘贴， 

1691
01:21:12,540 --> 01:21:15,650
那么我们就不会粘贴，相反，我们会解释

1692
01:21:15,650 --> 01:21:18,730
此背景粘贴到您及其工作方式。 

1693
01:21:18,730 --> 01:21:22,200
现在，快讯没有您在场

1694
01:21:22,200 --> 01:21:24,340
在这里使用ViewBuilder， 

1695
01:21:24,340 --> 01:21:27,220
您可以看到该小闭合的返回值

1696
01:21:27,220 --> 01:21:30,270
您发出警报的不是ViewBuilder或View， 

1697
01:21:30,270 --> 01:21:31,850
这是一个警报。 

1698
01:21:31,850 --> 01:21:35,370
因此，我们实际上将在此处返回警报， 

1699
01:21:35,370 --> 01:21:36,763
返回警报。 

1700
01:21:37,890 --> 01:21:40,630
因此Alert可以提供消息，然后可以

1701
01:21:40,630 --> 01:21:43,150
一个关闭按钮，例如“确定”按钮， 

1702
01:21:43,150 --> 01:21:43,983
这就是我们想要的。 

1703
01:21:43,983 --> 01:21:45,820
或者它实际上可以有两个按钮

1704
01:21:45,820 --> 01:21:48,640
例如“确定”按钮和“取消”按钮。 

1705
01:21:48,640 --> 01:21:52,620
因此，让我们继续使用只有一个的那个。 

1706
01:21:52,620 --> 01:21:55,720
为了清楚起见，我将这些论点分开

1707
01:21:55,720 --> 01:21:57,543
这样您可以更好地看到它们。 

1708
01:21:58,770 --> 01:22:00,003
这是我们的警报。 

1709
01:22:01,040 --> 01:22:04,250
标题和消息都是文本。 

1710
01:22:04,250 --> 01:22:07,960
所以标题是“粘贴背景” 

1711
01:22:07,960 --> 01:22:10,790
因为这就是用户试图做的。 

1712
01:22:10,790 --> 01:22:12,820
然后消息， 

1713
01:22:12,820 --> 01:22:14,960
假设这是我们要自我解释的地方， 

1714
01:22:14,960 --> 01:22:19,960
与“将图像的URL复制到剪贴板

1715
01:22:21,640 --> 01:22:25,200
然后触摸此按钮”，即您刚刚点击的那个按钮， 

1716
01:22:25,200 --> 01:22:29,650
“使其成为文档的背景。” 

1717
01:22:29,650 --> 01:22:32,450
这是首先需要做的事情

1718
01:22:32,450 --> 01:22:34,520
可国际化为其他语言。 

1719
01:22:34,520 --> 01:22:36,870
而且，我们将进行重点测试

1720
01:22:36,870 --> 01:22:38,980
而且我们可能会有文档， 

1721
01:22:38,980 --> 01:22:40,760
人们可以帮助我们选择好的措辞

1722
01:22:40,760 --> 01:22:43,130
这样人们就不会对正在发生的事情感到困惑， 

1723
01:22:43,130 --> 01:22:44,063
等，这里。 

1724
01:22:45,553 --> 01:22:47,240
最后，我们有“关闭”按钮

1725
01:22:47,240 --> 01:22:49,310
属于Alert.Button类型。 

1726
01:22:49,310 --> 01:22:51,260
现在Alert.Button是一个具有

1727
01:22:51,260 --> 01:22:53,340
上面有很多静态函数

1728
01:22:53,340 --> 01:22:55,857
其中一些是默认按钮。 

1729
01:22:55,857 --> 01:22:57,690
那只是一个普通的按钮。 

1730
01:22:57,690 --> 01:23:00,030
还有破坏性的按钮

1731
01:23:00,030 --> 01:23:02,300
并且有取消按钮。 

1732
01:23:02,300 --> 01:23:05,140
所以在这种情况下，我们只需要默认的Button 

1733
01:23:05,140 --> 01:23:06,750
和它的标签， 

1734
01:23:06,750 --> 01:23:09,880
它只是一个文本，上面写着“好”。 

1735
01:23:09,880 --> 01:23:14,510
这也需要执行一个闭包

1736
01:23:14,510 --> 01:23:16,430
当按下此按钮时。 

1737
01:23:16,430 --> 01:23:18,910
现在就我们而言，我们不需要做任何事情

1738
01:23:18,910 --> 01:23:21,500
当按下“确定”时，我们只希望它关闭。 

1739
01:23:21,500 --> 01:23:24,080
这个默认按钮，这个“关闭”按钮

1740
01:23:24,080 --> 01:23:26,833
会为我们将其设置为false。 

1741
01:23:28,370 --> 01:23:30,773
顺便说一下，这美元总是在这里。 

1742
01:23:32,020 --> 01:23:35,460
因此，我们不必进入此处并将其设置为false 

1743
01:23:35,460 --> 01:23:38,173
使警报消失，它将为我们做到这一点。 

1744
01:23:39,795 --> 01:23:43,160
让我们看看这里的UI如何显示？ 

1745
01:23:43,160 --> 01:23:45,980
返回Hello World，这是我们的文档。 

1746
01:23:45,980 --> 01:23:48,220
单击此处，它说，哦，“粘贴背景...” 

1747
01:23:48,220 --> 01:23:51,170
将此复制给我解释，哦，你要做什么。 

1748
01:23:51,170 --> 01:23:53,280
哦，好的，我去做。 

1749
01:23:53,280 --> 01:23:54,600
我去那边

1750
01:23:54,600 --> 01:23:57,023
这次，也许我去拿张照片

1751
01:23:57,023 --> 01:23:59,873
我不太喜欢这个人。 

1752
01:24:01,130 --> 01:24:03,193
就在这里，让我们复制一下。 

1753
01:24:04,470 --> 01:24:05,570
回到这里

1754
01:24:05,570 --> 01:24:08,000
现在打粘贴，哦，粘贴它。 

1755
01:24:08,000 --> 01:24:10,223
但是实际上，它粘贴起来有点吓人。 

1756
01:24:10,223 --> 01:24:14,010
这是我们这里马匹的低分辨率版本。 

1757
01:24:14,010 --> 01:24:15,380
因为这就像哦， 

1758
01:24:15,380 --> 01:24:16,780
我不知道会那样做。 

1759
01:24:16,780 --> 01:24:18,310
哇，这到底是什么？ 

1760
01:24:18,310 --> 01:24:22,370
因此，也许我们需要在这里进行一些预警， 

1761
01:24:22,370 --> 01:24:25,720
如果您单击此按钮，它将在背景中显示

1762
01:24:25,720 --> 01:24:28,030
那会先问你

1763
01:24:28,030 --> 01:24:29,800
如果那真的是您想要的。 

1764
01:24:29,800 --> 01:24:32,810
那么我们如何设置一个警报，询问我们是或否

1765
01:24:32,810 --> 01:24:34,610
我们想做点什么吗？ 

1766
01:24:34,610 --> 01:24:36,530
好吧，我们要去的确切方式

1767
01:24:36,530 --> 01:24:38,930
必须有一些状态。 

1768
01:24:38,930 --> 01:24:41,360
所以我要称这个州

1769
01:24:41,360 --> 01:24:44,290
而不是称其为explainBackgroundPaste， 

1770
01:24:44,290 --> 01:24:47,080
我将其称为confirmBackgroundPaste。 

1771
01:24:49,065 --> 01:24:52,180
然后我将其设置为confirmBackgroundPaste 

1772
01:24:52,180 --> 01:24:54,155
就在这里。 

1773
01:24:54,155 --> 01:24:57,340
ConfirmBackgroundPaste等于true。 

1774
01:24:57,340 --> 01:25:00,153
现在我在这里需要另一个警报， 

1775
01:25:00,153 --> 01:25:02,890
另一个警报将

1776
01:25:02,890 --> 01:25:05,460
对这个设置为true的东西做出反应。 

1777
01:25:05,460 --> 01:25:08,070
现在，要了解有关警报的一些非常重要的信息。 

1778
01:25:08,070 --> 01:25:13,070
您不能将两个带有isPresented的警报放在同一视图上。 

1779
01:25:13,600 --> 01:25:17,850
所以我不能在此处在图像上放置另一个警报， 

1780
01:25:17,850 --> 01:25:19,720
它必须在其他视图上

1781
01:25:19,720 --> 01:25:21,760
否则我必须使用其他警报

1782
01:25:21,760 --> 01:25:23,500
这需要一个可识别的。 

1783
01:25:23,500 --> 01:25:26,370
可识别的，通常是一个枚举

1784
01:25:26,370 --> 01:25:29,737
将选择要显示的警报，这一个​​或这个。 

1785
01:25:29,737 --> 01:25:32,110
我可能会决定

1786
01:25:32,110 --> 01:25:33,570
而不是让它成为布尔， 

1787
01:25:33,570 --> 01:25:37,440
我希望这是一个已经解释或确认的枚举。 

1788
01:25:37,440 --> 01:25:40,990
然后我将对发现进行警报

1789
01:25:40,990 --> 01:25:43,603
与具有该枚举的国家绑定。 

1790
01:25:43,603 --> 01:25:45,680
那可能是一个更好的方法

1791
01:25:45,680 --> 01:25:47,500
比这两个布尔人

1792
01:25:47,500 --> 01:25:50,350
但是出于演示目的，我们将继续进行下去。 

1793
01:25:50,350 --> 01:25:51,870
所以我该把警报放在哪里

1794
01:25:51,870 --> 01:25:52,817
因为我不能把它放在图片上？ 

1795
01:25:52,817 --> 01:25:54,970
哦，我几乎可以放在任何地方。 

1796
01:25:54,970 --> 01:25:56,870
这是我们的GeometryReader。 

1797
01:25:56,870 --> 01:25:58,896
这是我们的顶级VStack。 

1798
01:25:58,896 --> 01:26:00,680
继续并将其放在我们的顶级VStack上， 

1799
01:26:00,680 --> 01:26:03,210
但这并不重要，只要是View 

1800
01:26:03,210 --> 01:26:05,930
发生这种情况时，它就会显示在屏幕上。 

1801
01:26:05,930 --> 01:26:10,100
我要非常快地输入，然后就可以了。 

1802
01:26:10,100 --> 01:26:11,670
这个很相似，对吧？ 

1803
01:26:11,670 --> 01:26:12,640
出现警报， 

1804
01:26:12,640 --> 01:26:16,930
它使用此确认作为决策者，相同的标题。 

1805
01:26:16,930 --> 01:26:19,390
这就是说，“替换您的背景。” 

1806
01:26:19,390 --> 01:26:21,770
现在，它向您显示了它将要使用的URL 

1807
01:26:21,770 --> 01:26:24,580
挺酷的，它在粘贴板上。 

1808
01:26:24,580 --> 01:26:27,000
现在我有一个primaryButton，再次是

1809
01:26:27,000 --> 01:26:31,550
默认文本，确定，但是现在我提供了闭包。 

1810
01:26:31,550 --> 01:26:33,420
现在，当按下“确定”按钮时， 

1811
01:26:33,420 --> 01:26:36,850
我将背景URL设置为通用URL。 

1812
01:26:36,850 --> 01:26:38,460
那是以前的代码

1813
01:26:38,460 --> 01:26:39,890
现在我把它放在这里。 

1814
01:26:39,890 --> 01:26:44,427
仅当我在此警报中单击“确定”时才发生，对吧？ 

1815
01:26:44,427 --> 01:26:48,100
现在，我还有第二个按钮，即.cancel按钮。 

1816
01:26:48,100 --> 01:26:52,120
记住，这些都是Alert.Button.cancel。 

1817
01:26:52,120 --> 01:26:54,300
斯威夫特只是在推断

1818
01:26:54,300 --> 01:26:56,963
因为它知道此参数采用Alert.Button。 

1819
01:26:57,835 --> 01:26:59,643
让我们看看这个动作。 

1820
01:27:03,020 --> 01:27:06,270
转到此处的“ Hello World”文档，然后单击。 

1821
01:27:06,270 --> 01:27:07,730
哦，它告诉您复制URL。 

1822
01:27:07,730 --> 01:27:09,610
好吧，我要去做。 

1823
01:27:09,610 --> 01:27:11,150
回到这里

1824
01:27:11,150 --> 01:27:16,150
让我们回去，回到我们最喜欢的那一个。 

1825
01:27:16,530 --> 01:27:19,750
将其复制到此处。 

1826
01:27:19,750 --> 01:27:23,410
现在，当我遇到这个问题时，应该让我确认一下。 

1827
01:27:23,410 --> 01:27:26,445
哦，“用这个URL替换背景吗？” 

1828
01:27:26,445 --> 01:27:29,100
我可以说，“取消，不，不要这样做。” 

1829
01:27:29,100 --> 01:27:31,200
或者我可以在这里说：“是的。” 

1830
01:27:32,070 --> 01:27:32,903
所以这很警报。 

1831
01:27:32,903 --> 01:27:34,580
所以我们学会了Alert，我们学会了工作表， 

1832
01:27:34,580 --> 01:27:36,490
我们了解了弹出窗口，也了解了NavigationView。 

1833
01:27:36,490 --> 01:27:38,930
而且有很多不同的方式

1834
01:27:38,930 --> 01:27:43,170
决定如何在此处构建用户界面

1835
01:27:43,170 --> 01:27:46,713
使信息尽可能地展现在用户面前。 

1836
01:27:48,160 --> 01:27:50,510
现在，我想做的最后一件事

1837
01:27:50,510 --> 01:27:55,370
使此视图在此处更具可变性。 

1838
01:27:55,370 --> 01:27:56,850
例如，我希望能够

1839
01:27:56,850 --> 01:27:58,680
删除我想要的项目。 

1840
01:27:58,680 --> 01:28:00,260
我想滑动删除

1841
01:28:00,260 --> 01:28:02,380
或以某种方式单击以删除。 

1842
01:28:02,380 --> 01:28:04,760
我想重命名我的文档。 

1843
01:28:04,760 --> 01:28:06,880
好吧，没有办法，这些无标题的

1844
01:28:06,880 --> 01:28:08,270
我不能给他们起名字， 

1845
01:28:08,270 --> 01:28:10,750
那我该如何重命名这些文件？ 

1846
01:28:10,750 --> 01:28:11,996
因此，让我们把它弄出来。 

1847
01:28:11,996 --> 01:28:15,240
事实证明，使删除工作非常容易。 

1848
01:28:15,240 --> 01:28:17,020
您需要做的才能使删除工作正常进行， 

1849
01:28:17,020 --> 01:28:19,220
这是ForEach中的功能。 

1850
01:28:19,220 --> 01:28:22,273
因此，如果您在ForEach中说onDelete， 

1851
01:28:23,150 --> 01:28:25,463
它将为您提供所谓的indexSet。 

1852
01:28:27,052 --> 01:28:31,450
所以indexSet有点像一个索引数组， 

1853
01:28:31,450 --> 01:28:33,980
并告诉您已删除的内容。 

1854
01:28:33,980 --> 01:28:36,210
现在，在iOS中，您正在滑动以删除， 

1855
01:28:36,210 --> 01:28:39,550
这总是一个只有一件事的数组。 

1856
01:28:39,550 --> 01:28:41,650
但是我们仍然要尝试编写代码

1857
01:28:41,650 --> 01:28:44,800
概括地说，以便我们可以经历所有这些

1858
01:28:44,800 --> 01:28:47,240
在那里删除所有内容。 

1859
01:28:47,240 --> 01:28:50,350
我要编写删除该商店的代码

1860
01:28:50,350 --> 01:28:54,480
在所谓的高级Swift中， 

1861
01:28:54,480 --> 01:28:57,100
但是我只是在Swift中使用原语， 

1862
01:28:57,100 --> 01:29:00,830
特别是在indexSet和Array中编写此代码

1863
01:29:00,830 --> 01:29:02,530
更加简洁。 

1864
01:29:02,530 --> 01:29:03,497
所以看我这样做。 

1865
01:29:03,497 --> 01:29:07,890
我要使用indexSet并映射它

1866
01:29:07,890 --> 01:29:12,890
从我的商店获取这些索引处的文档。 

1867
01:29:13,540 --> 01:29:18,540
所以现在我在那些索引处有一个文档数组。 

1868
01:29:18,940 --> 01:29:22,070
我要问他们每个人的数组， 

1869
01:29:22,070 --> 01:29:23,923
每个文件， 

1870
01:29:25,360 --> 01:29:30,153
只需要求商店删除该文件即可。 

1871
01:29:32,330 --> 01:29:34,740
这基本上是简洁的说法， 

1872
01:29:34,740 --> 01:29:36,470
对于indexSet中的所有内容

1873
01:29:36,470 --> 01:29:38,221
只需删除该文档即可。 

1874
01:29:38,221 --> 01:29:39,810
我们通过制作一些地图来做到这一点

1875
01:29:39,810 --> 01:29:43,743
在地图之间将索引映射到文档。 

1876
01:29:45,100 --> 01:29:46,920
所以这种编码就在这里， 

1877
01:29:46,920 --> 01:29:49,400
最终，您会习惯于这样做。 

1878
01:29:49,400 --> 01:29:52,290
真正的Swift程序员正在做这样的事情。 

1879
01:29:52,290 --> 01:29:54,720
实际上，即使不容易阅读，也一样容易

1880
01:29:54,720 --> 01:29:57,300
而不是这里有两个for循环

1881
01:29:57,300 --> 01:29:59,600
indexSet，然后遍历文档。 

1882
01:29:59,600 --> 01:30:01,360
就像六到七行代码， 

1883
01:30:01,360 --> 01:30:03,070
很多阅读和解析， 

1884
01:30:03,070 --> 01:30:07,930
而这更容易阅读。 

1885
01:30:10,730 --> 01:30:12,373
因此，让我们看看实际情况。 

1886
01:30:13,240 --> 01:30:15,470
只要您在那里有删除并且在列表中， 

1887
01:30:15,470 --> 01:30:17,770
我可以滑动删除，看到吗？ 

1888
01:30:17,770 --> 01:30:19,600
我只是向左滑动。 

1889
01:30:19,600 --> 01:30:20,710
现在，如果我不想删除， 

1890
01:30:20,710 --> 01:30:21,690
我可以将其推回右侧。 

1891
01:30:21,690 --> 01:30:24,640
如果我一路滑动删除即可删除。 

1892
01:30:24,640 --> 01:30:26,940
或者我可以滑动以部分删除

1893
01:30:26,940 --> 01:30:29,390
并按该按钮确认。 

1894
01:30:29,390 --> 01:30:31,760
这就是删除的工作方式。 

1895
01:30:31,760 --> 01:30:34,763
现在，您仍然可以在此处添加文档。 

1896
01:30:36,000 --> 01:30:37,800
这是删除的一种方式， 

1897
01:30:37,800 --> 01:30:39,610
这是一个很好的方法。 

1898
01:30:39,610 --> 01:30:42,720
还有另一种方法，就是有一个特殊的按钮

1899
01:30:42,720 --> 01:30:44,643
在iOS中，您可以将其称为“编辑”按钮。 

1900
01:30:44,643 --> 01:30:46,290
我要把它放在这里

1901
01:30:46,290 --> 01:30:49,990
在此视图中处于尾随情况。 

1902
01:30:49,990 --> 01:30:51,820
这将使您进入编辑模式

1903
01:30:51,820 --> 01:30:55,060
每行上几乎没有删除按钮。 

1904
01:30:55,060 --> 01:30:56,320
那么我们该怎么做呢？ 

1905
01:30:56,320 --> 01:30:58,690
这是我的酒吧项目的引导按钮。 

1906
01:30:58,690 --> 01:31:02,150
我要添加尾随按钮。 

1907
01:31:02,150 --> 01:31:04,870
这就是EditButton。 

1908
01:31:04,870 --> 01:31:08,640
好的，所以EditButton是一个SwiftUI结构。 

1909
01:31:08,640 --> 01:31:11,110
当您在此处放置EditButton时， 

1910
01:31:11,110 --> 01:31:13,750
然后单击编辑，如果此处有列表， 

1911
01:31:13,750 --> 01:31:16,160
在您的ForEach上有一个onDelete， 

1912
01:31:16,160 --> 01:31:18,190
它将使您进入此模式，可以在其中删除

1913
01:31:18,190 --> 01:31:20,963
通过点击这些而不是滑动来删除。 

1914
01:31:22,070 --> 01:31:23,440
太酷了吧？ 

1915
01:31:23,440 --> 01:31:26,780
那里有一些删除/编辑模式。 

1916
01:31:26,780 --> 01:31:28,180
现在，我想做的最后一件事

1917
01:31:28,180 --> 01:31:30,900
能够编辑我的文档名称， 

1918
01:31:30,900 --> 01:31:32,880
但我真的很想编辑它们

1919
01:31:32,880 --> 01:31:35,040
只需单击它们即可对其进行编辑。 

1920
01:31:35,040 --> 01:31:37,600
但是我真的不想点击它们来编辑它们

1921
01:31:37,600 --> 01:31:40,420
因为我想显示我的文件。 

1922
01:31:40,420 --> 01:31:43,310
但是当它处于编辑模式时呢？ 

1923
01:31:43,310 --> 01:31:44,510
看看它何时处于编辑模式， 

1924
01:31:44,510 --> 01:31:46,840
我单击它仍然无法导航， 

1925
01:31:46,840 --> 01:31:48,480
因为我正在编辑它。 

1926
01:31:48,480 --> 01:31:51,080
所以如果我点击这些，那将是一个美好的时光

1927
01:31:51,080 --> 01:31:53,120
让他们进行适当的编辑， 

1928
01:31:53,120 --> 01:31:56,643
只需将这些文本转换为TextFields。 

1929
01:31:57,790 --> 01:31:59,870
但是我们需要找出

1930
01:31:59,870 --> 01:32:03,430
单击完成按钮时，对吗？ 

1931
01:32:03,430 --> 01:32:05,230
然后点击完成按钮

1932
01:32:05,230 --> 01:32:08,566
实际上会影响您@Environment中的某些内容。 

1933
01:32:08,566 --> 01:32:11,560
您还记得诸如colorScheme之类的@Environments吗？ 

1934
01:32:11,560 --> 01:32:14,570
好吧，那里还有一个叫做editMode的。 

1935
01:32:14,570 --> 01:32:16,270
这是一种特殊的感觉。 

1936
01:32:16,270 --> 01:32:18,610
所以我们要去看看那个

1937
01:32:18,610 --> 01:32:19,833
在文档中。 

1938
01:32:20,920 --> 01:32:23,110
这里是EnvironmentValues。 

1939
01:32:23,110 --> 01:32:25,620
而EnvironmentValues是要上市的东西

1940
01:32:25,620 --> 01:32:27,580
所有这些东西都是配色方案， 

1941
01:32:27,580 --> 01:32:29,370
以及环境中可能存在的所有事物。 

1942
01:32:29,370 --> 01:32:31,960
其中之一就是editMode 

1943
01:32:31,960 --> 01:32:33,356
你看到这个editMode吗？ 

1944
01:32:33,356 --> 01:32:35,960
但是看看editMode的类型，让我们点击它， 

1945
01:32:35,960 --> 01:32:39,178
它是对EditMode的绑定。 

1946
01:32:39,178 --> 01:32:41,380
而EditMode只是一个枚举

1947
01:32:41,380 --> 01:32:43,930
具有活跃，不活跃或短暂的状态。 

1948
01:32:43,930 --> 01:32:46,480
无论我们是否进行编辑，它都有一个不错的变量。 

1949
01:32:46,480 --> 01:32:47,440
所以这很有意义。 

1950
01:32:47,440 --> 01:32:49,970
我有这个EditMode，无论我是否在编辑， 

1951
01:32:49,970 --> 01:32:52,120
但是为什么是绑定

1952
01:32:52,120 --> 01:32:55,200
不仅是绑定还是可选绑定？ 

1953
01:32:55,200 --> 01:32:57,890
还要注意，这是设置好的。 

1954
01:32:57,890 --> 01:33:01,150
因此，我们可以实际设置此环境值。 

1955
01:33:01,150 --> 01:33:03,880
因此，如果您想知道该完成按钮是否

1956
01:33:03,880 --> 01:33:08,090
是否被激活，您将要设置

1957
01:33:08,090 --> 01:33:11,230
这个环境变量是一个绑定

1958
01:33:11,230 --> 01:33:14,920
到视图中的某些editMode状态。 

1959
01:33:14,920 --> 01:33:15,930
那就是你得到的方式。 

1960
01:33:15,930 --> 01:33:19,240
现在，为什么他们要对绑定进行这种间接访问？ 

1961
01:33:19,240 --> 01:33:21,460
好吧，因为只要单击完成按钮， 

1962
01:33:21,460 --> 01:33:24,540
您想找出答案，绑定便会记住， 

1963
01:33:24,540 --> 01:33:27,400
当它们改变时，当它们指向的值改变时， 

1964
01:33:27,400 --> 01:33:29,380
它们会导致您的视图重绘， 

1965
01:33:29,380 --> 01:33:31,410
这正是您想要的。 

1966
01:33:31,410 --> 01:33:34,133
这就是我们要找出editMode的方式。 

1967
01:33:34,133 --> 01:33:38,210
并不是很多EnvironmentValue都是这样的， 

1968
01:33:38,210 --> 01:33:40,460
无论您是否具有绑定以及所有这些功能， 

1969
01:33:40,460 --> 01:33:43,180
但是对于editMode来说，这是很有意义的。 

1970
01:33:43,180 --> 01:33:45,540
因此，我们将不得不设置此环境。 

1971
01:33:45,540 --> 01:33:47,420
现在，我们没有在幻灯片中学习

1972
01:33:47,420 --> 01:33:48,820
如何设置环境

1973
01:33:48,820 --> 01:33:50,700
我们知道如何获得环境，对吗？ 

1974
01:33:50,700 --> 01:33:55,700
我们做类似@Environment的\ .editMode。 

1975
01:33:56,670 --> 01:34:00,170
您可以通过这种方式获得editMode，但事实并非如此， 

1976
01:34:00,170 --> 01:34:03,098
我们不想在这里得到它，我们想要设置它。 

1977
01:34:03,098 --> 01:34:07,515
因此，设置环境的方式是使用.environment。 

1978
01:34:08,560 --> 01:34:11,775
.environment采用路径editMode， 

1979
01:34:11,775 --> 01:34:14,284
然后它需要您要设置的内容。 

1980
01:34:14,284 --> 01:34:16,040
记住，这是一个绑定。 

1981
01:34:16,040 --> 01:34:20,120
所以我将不得不将Binding设置为某些editMode。 

1982
01:34:20,120 --> 01:34:24,130
因此，我们认为这将必须是某种状态。 

1983
01:34:24,130 --> 01:34:28,550
所以@State private var editMode， 

1984
01:34:28,550 --> 01:34:30,173
属于EditMode类型。 

1985
01:34:31,317 --> 01:34:32,583
这是一个绑定。 

1986
01:34:34,142 --> 01:34:35,520
还有几件事。 

1987
01:34:35,520 --> 01:34:38,910
注意这是一个变量，它需要一个初始值。 

1988
01:34:38,910 --> 01:34:42,580
首先，它要么是.inactive， 

1989
01:34:42,580 --> 01:34:46,440
或.active或.transient，这是三个。 

1990
01:34:46,440 --> 01:34:49,160
很明显，当我们第一次启动View时， 

1991
01:34:49,160 --> 01:34:49,993
它是不活动的。 

1992
01:34:49,993 --> 01:34:52,750
因此，我们将其设置为非活动状态。 

1993
01:34:52,750 --> 01:34:55,210
要理解的另一件事非常重要

1994
01:34:55,210 --> 01:34:59,470
是.environment在EnvironmentValues中设置该var 

1995
01:34:59,470 --> 01:35:02,610
仅针对您调用的视图。 

1996
01:35:02,610 --> 01:35:05,520
对，这就是环境

1997
01:35:05,520 --> 01:35:07,870
无论您调用什么视图。 

1998
01:35:07,870 --> 01:35:11,140
这是我正在调用的View环境。 

1999
01:35:11,140 --> 01:35:14,500
因此，它正在为此视图设置环境。 

2000
01:35:14,500 --> 01:35:17,720
现在，这个视图在这里某处

2001
01:35:17,720 --> 01:35:20,450
必须具有EditButton。 

2002
01:35:20,450 --> 01:35:22,920
好吧，如果您在“视图”中设置了环境

2003
01:35:22,920 --> 01:35:24,380
没有EditButton， 

2004
01:35:24,380 --> 01:35:26,460
然后，当EditButton单击时， 

2005
01:35:26,460 --> 01:35:28,250
它不会设置此绑定

2006
01:35:28,250 --> 01:35:30,790
因为绑定不会被设置到环境中。 

2007
01:35:30,790 --> 01:35:32,650
所以这意味着我们不能放环境

2008
01:35:32,650 --> 01:35:34,790
例如在这里，您可能会认为， 

2009
01:35:34,790 --> 01:35:36,500
哦，让我们在这里搭建环境。 

2010
01:35:36,500 --> 01:35:37,540
好吧，这行不通

2011
01:35:37,540 --> 01:35:41,070
因为这只会为该视图设置环境。 

2012
01:35:41,070 --> 01:35:44,200
并且EditButton不在此视图中。 

2013
01:35:44,200 --> 01:35:46,950
因此，EditButton将永远看不到这种环境。 

2014
01:35:46,950 --> 01:35:50,990
所以我们需要这种环境，包括它， 

2015
01:35:50,990 --> 01:35:54,950
您发送给它的任何内容都必须包含EditButton， 

2016
01:35:54,950 --> 01:35:57,220
在这种情况下，此var项目。 

2017
01:35:57,220 --> 01:35:58,283
在那里有意义吗？ 

2018
01:35:58,283 --> 01:36:00,630
有些人想念的有些微妙之处。 

2019
01:36:00,630 --> 01:36:02,340
但是当您设置环境时， 

2020
01:36:02,340 --> 01:36:04,150
可设置的环境变量

2021
01:36:04,150 --> 01:36:07,573
它仅在您设置的视图中进行设置。 

2022
01:36:09,605 --> 01:36:10,670
让我们看看这个动作

2023
01:36:10,670 --> 01:36:12,587
只是为了确保它在这里没有损坏。 

2024
01:36:12,587 --> 01:36:14,030
好的，点击“编辑”。 

2025
01:36:14,030 --> 01:36:15,250
一切正常。 

2026
01:36:15,250 --> 01:36:16,410
好吧，做完了。 

2027
01:36:16,410 --> 01:36:18,980
所以现在当我们处于编辑模式时，我们知道我们处于编辑模式

2028
01:36:18,980 --> 01:36:20,930
因为将设置此editMode。 

2029
01:36:20,930 --> 01:36:24,500
因此，我们希望将其从文本更改为

2030
01:36:24,500 --> 01:36:26,883
从本质上讲是一个TextField。 

2031
01:36:27,940 --> 01:36:29,950
因此，这里就是我们的文本所在的位置。 

2032
01:36:29,950 --> 01:36:34,950
我实际上创建了一个名为EditableText的漂亮小结构。 

2033
01:36:36,250 --> 01:36:39,853
因此，让我们抓住它就在这里并将其拖入。 

2034
01:36:40,690 --> 01:36:41,663
复制到。 

2035
01:36:42,530 --> 01:36:45,060
我们不太会看EditableText， 

2036
01:36:45,060 --> 01:36:46,970
但从本质上讲，它是一个TextField。 

2037
01:36:46,970 --> 01:36:50,520
它正在做其他一些棘手的事情， 

2038
01:36:50,520 --> 01:36:54,330
在它可编辑或不可编辑时很好地切换出来。 

2039
01:36:54,330 --> 01:36:59,057
它需要一个附加参数isEditing。 

2040
01:36:59,920 --> 01:37:03,130
这就是是否编辑

2041
01:37:03,130 --> 01:37:05,350
此EditableText当前正在编辑。 

2042
01:37:05,350 --> 01:37:09,073
对我们来说，这就是我们的self.editMode.isEditing。 

2043
01:37:11,175 --> 01:37:13,830
如果那是editMode，那是编辑

2044
01:37:13,830 --> 01:37:16,600
这只是一个查看此非活动状态的变量

2045
01:37:16,600 --> 01:37:19,707
或活动状态，并告诉您在哪里进行编辑。 

2046
01:37:19,707 --> 01:37:24,690
最后还需要关闭一点

2047
01:37:24,690 --> 01:37:27,760
每当此EditableText更改时。 

2048
01:37:27,760 --> 01:37:31,600
因此用户更改了它，然后它为您调用了此关闭

2049
01:37:31,600 --> 01:37:32,950
与文本。 

2050
01:37:32,950 --> 01:37:34,440
在我们的例子中，这就是名字

2051
01:37:34,440 --> 01:37:35,810
所以我称这个参数名称

2052
01:37:35,810 --> 01:37:37,840
可以称为文本或任何您想要的东西。 

2053
01:37:37,840 --> 01:37:39,510
当发生这种情况时， 

2054
01:37:39,510 --> 01:37:42,150
我想在我们的商店里设置名字

2055
01:37:43,330 --> 01:37:44,403
该文件。 

2056
01:37:46,520 --> 01:37:47,493
经历一下，所以我只是替换这个

2057
01:37:47,493 --> 01:37:49,133
这个小的EditableText。 

2058
01:37:50,450 --> 01:37:52,113
因此，让我们看一下是否可行。 

2059
01:37:54,380 --> 01:37:58,840
是的，我们开始编辑，然后单击， 

2060
01:37:58,840 --> 01:38:00,540
宇，看看那个。 

2061
01:38:00,540 --> 01:38:03,363
你好，你好，你好。 

2062
01:38:04,840 --> 01:38:05,673
哎呀。 

2063
01:38:08,600 --> 01:38:09,640
现在我们完成了。 

2064
01:38:09,640 --> 01:38:12,713
这就是“ Hello There”。 

2065
01:38:13,850 --> 01:38:16,270
让我在这里更改此“无标题”。 

2066
01:38:16,270 --> 01:38:21,163
编辑，称之为“谷仓”。 

2067
01:38:25,140 --> 01:38:28,100
现在，这会自动按字母顺序

2068
01:38:28,100 --> 01:38:29,870
因为那是商店要做的。 

2069
01:38:29,870 --> 01:38:33,457
所以这是一个谷仓，所以也许我们把谷仓放在这里。 

2070
01:38:35,180 --> 01:38:37,313
告诉我们该怎么做，很好。 

2071
01:38:37,313 --> 01:38:40,490
去这里，回到谷仓。 

2072
01:38:40,490 --> 01:38:42,170
这是谷仓。 

2073
01:38:42,170 --> 01:38:43,954
低谷仓在这里。 

2074
01:38:43,954 --> 01:38:47,510
复制，返回并粘贴。 

2075
01:38:47,510 --> 01:38:49,210
是的，我们确实想粘贴它。 

2076
01:38:49,210 --> 01:38:51,670
在那里，那就是我们的谷仓。 

2077
01:38:51,670 --> 01:38:53,130
有我们的“你好，那里”。 

2078
01:38:53,130 --> 01:38:54,693
有一个无标题的文件。 

2079
01:38:55,570 --> 01:38:56,403
！ 

2080
01:38:57,280 --> 01:39:00,087
因此，我们在这里构建了一个功能强大的小应用程序。 

2081
01:39:00,087 --> 01:39:03,503
这很容易使用，可以直接操作。 

2082
01:39:04,420 --> 01:39:07,810
我们通过呈现视图完成了很多工作

2083
01:39:07,810 --> 01:39:10,930
以不同的方式，无论是工作表还是弹出窗口。 

2084
01:39:10,930 --> 01:39:14,370
顺便说一句，让我们来看看，就在这里，我们在iPhone中， 

2085
01:39:14,370 --> 01:39:16,920
让我们回去并确保我们没有损坏任何东西

2086
01:39:16,920 --> 01:39:18,693
在我们的iPad上。 

2087
01:39:19,680 --> 01:39:23,050
我们在iPhone上做了很多工作。 

2088
01:39:23,050 --> 01:39:26,503
因此，我当然希望在iPad上看起来仍然不错。 

2089
01:39:27,410 --> 01:39:30,610
哇，实际上，这很有趣， 

2090
01:39:30,610 --> 01:39:33,290
这看起来有很大的不同。 

2091
01:39:33,290 --> 01:39:36,670
您会看到我们的选择器在屏幕上有此空间， 

2092
01:39:36,670 --> 01:39:39,140
实际上是我们的文件。 

2093
01:39:39,140 --> 01:39:42,140
因此我们可以在iPad上同时看到两者。 

2094
01:39:42,140 --> 01:39:45,260
正如我们所见，SwiftUI将适应

2095
01:39:45,260 --> 01:39:48,010
我们声明的任何用户界面

2096
01:39:48,010 --> 01:39:50,560
到它所在的设备上。 

2097
01:39:50,560 --> 01:39:54,730
因此，这不一定是iPad的理想UI， 

2098
01:39:54,730 --> 01:39:57,560
我不确定我是否需要能够看到我的文档选择器

2099
01:39:57,560 --> 01:40:00,340
随时都可以在屏幕上显示

2100
01:40:00,340 --> 01:40:04,650
即使在iPad上，也可以在弹出窗口中找到文档选择器。 

2101
01:40:04,650 --> 01:40:06,430
但是我们当然可以看到它做了一些事情

2102
01:40:06,430 --> 01:40:08,860
作为此处的默认值非常明智。 

2103
01:40:08,860 --> 01:40:11,460
现在，您可以看到我已经加载了

2104
01:40:11,460 --> 01:40:13,640
这里有几个文件，“谷仓”和“房屋” 

2105
01:40:13,640 --> 01:40:15,290
使它更快一点。 

2106
01:40:15,290 --> 01:40:16,373
因此，让我们看一下并确保

2107
01:40:16,373 --> 01:40:17,650
我们什么都没做

2108
01:40:17,650 --> 01:40:20,293
在这里破坏我们的调色板编辑器。 

2109
01:40:21,460 --> 01:40:24,280
嗯，似乎在这里工作， 

2110
01:40:24,280 --> 01:40:28,440
但我认为这看起来更好。 

2111
01:40:28,440 --> 01:40:32,030
因此，让我们跳回到我们的PaletteChooser 

2112
01:40:32,030 --> 01:40:35,393
然后将此工作表改回弹出窗口。 

2113
01:40:39,570 --> 01:40:44,360
在这里的房屋文件中，让我们放大一点。 

2114
01:40:44,360 --> 01:40:45,790
然后单击。 

2115
01:40:45,790 --> 01:40:49,103
，我在此键盘上点击。 

2116
01:40:50,451 --> 01:40:52,440
它不起作用，我点击了这个。 

2117
01:40:52,440 --> 01:40:55,610
为什么单击此按钮不起作用？ 

2118
01:40:55,610 --> 01:40:58,780
好吧，问题在于我们已经缩小了， 

2119
01:40:58,780 --> 01:41:02,270
即使我们裁剪以在此空间中绘制， 

2120
01:41:02,270 --> 01:41:05,960
我们的视野仍然很大，当我们点击此处时， 

2121
01:41:05,960 --> 01:41:08,290
试图点击这个键盘

2122
01:41:08,290 --> 01:41:10,930
我们的观点恰好在前面。 

2123
01:41:10,930 --> 01:41:12,100
因此，它正在拦截

2124
01:41:12,100 --> 01:41:12,993
即使它不在这里

2125
01:41:12,993 --> 01:41:16,240
它仍然在拦截水龙头。 

2126
01:41:16,240 --> 01:41:17,910
那么我们该如何解决呢？ 

2127
01:41:17,910 --> 01:41:21,380
我们如何做到这一点，使它不会成为主流。 

2128
01:41:21,380 --> 01:41:24,160
您可以控制哪些视图位于最前面

2129
01:41:24,160 --> 01:41:26,840
使用称为zIndex修饰符的东西。 

2130
01:41:26,840 --> 01:41:29,560
因此，让我们回到我们的文档“查看此处”。 

2131
01:41:29,560 --> 01:41:31,170
而且我们要做到

2132
01:41:31,170 --> 01:41:35,580
我们整个GeometryReader都放在后面

2133
01:41:35,580 --> 01:41:39,670
通过将其zIndex设置为减一。 

2134
01:41:39,670 --> 01:41:41,640
默认的zIndex为零。 

2135
01:41:41,640 --> 01:41:43,967
所以我们所有其他视图都像我们的调色板一样

2136
01:41:43,967 --> 01:41:45,170
都将为零

2137
01:41:45,170 --> 01:41:46,880
他们会更靠近前面。 

2138
01:41:46,880 --> 01:41:50,270
还有我们所有的GeometryReader 

2139
01:41:50,270 --> 01:41:52,327
在我们的文档中会更靠近背面。 

2140
01:41:52,327 --> 01:41:56,170
因此，视图的这种简单重新排序

2141
01:41:56,170 --> 01:41:57,210
会做这项工作的。 

2142
01:41:57,210 --> 01:42:00,520
所以我们开始，我们有一个大图像，它重叠了

2143
01:42:00,520 --> 01:42:04,213
并且它仍然在此处打开我们的调色板编辑器。 

2144
01:42:05,290 --> 01:42:08,630
当我们将其更改回popover时，一切就开始了

2145
01:42:08,630 --> 01:42:09,870
从成为一张纸， 

2146
01:42:09,870 --> 01:42:12,593
看起来在这里很好用。 

2147
01:42:13,580 --> 01:42:17,640
但是，将其更改为popover会破坏我们的iPhone吗？ 

2148
01:42:17,640 --> 01:42:19,653
确实没有，让我们来看一下。 

2149
01:42:24,390 --> 01:42:25,233
你好。 

2150
01:42:26,830 --> 01:42:28,860
而且即使是这样，它也仍然有效

2151
01:42:28,860 --> 01:42:32,100
显然，您无法在iPhone上显示弹出式窗口， 

2152
01:42:32,100 --> 01:42:34,380
但仍然可以正常工作。 

2153
01:42:34,380 --> 01:42:38,190
好吧，这是今年最长的演示。 

2154
01:42:38,190 --> 01:42:39,560
希望你喜欢。 

2155
01:42:39,560 --> 01:42:42,160
而您基于这一切的作业

2156
01:42:42,160 --> 01:42:47,160
实际上就是在这里创建这种选择器

2157
01:42:47,250 --> 01:42:49,790
适用于记忆。 

2158
01:42:49,790 --> 01:42:52,470
因此，您将拥有自己的主题， 

2159
01:42:52,470 --> 01:42:54,961
从这里选择您的记忆主题， 

2160
01:42:54,961 --> 01:42:56,800
当您单击时，您将玩一个游戏

2161
01:42:56,800 --> 01:42:58,093
基于该主题。 

2162
01:42:59,210 --> 01:43:00,670
当然，您将成功实现

2163
01:43:00,670 --> 01:43:02,760
这样您的主题是可编辑的

2164
01:43:02,760 --> 01:43:06,690
与此类似的某种编辑器。 

2165
01:43:06,690 --> 01:43:09,207
您可以更改主题的颜色等内容， 

2166
01:43:09,207 --> 01:43:11,410
主题中的表情符号之类的东西。 

2167
01:43:11,410 --> 01:43:12,960
所以你要做的事情很相似

2168
01:43:12,960 --> 01:43:16,283
到我们在这里所做的事情，只是在记忆中。 

2169
01:43:17,838 --> 01:43:19,080
祝你功课顺利

2170
01:43:19,080 --> 01:43:21,943
如果您有任何疑问，也知道在哪里可以找到我们。 

2171
01:43:23,000 --> 01:43:26,213
-[旁白]有关更多信息，请访问stanford.edu。 

