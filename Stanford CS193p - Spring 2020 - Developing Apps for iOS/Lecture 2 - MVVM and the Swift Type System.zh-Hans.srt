1
00:00:00,000 --> 00:00:03,250
（优美的环境音乐） 

2
00:00:04,930 --> 00:00:06,630
-[播音员]斯坦福大学。 

3
00:00:08,280 --> 00:00:10,560
-[老师]好吧，欢迎回到第二讲

4
00:00:10,560 --> 00:00:15,452
斯坦福CS193p在2020年春季投入使用。 

5
00:00:15,452 --> 00:00:17,640
我将直接回到演示中

6
00:00:17,640 --> 00:00:19,250
我们从第一讲开始

7
00:00:19,250 --> 00:00:22,070
但是，首先，我要介绍这两个

8
00:00:22,070 --> 00:00:24,810
真正重要的概念性想法。 

9
00:00:24,810 --> 00:00:26,840
首先是MVVM。 

10
00:00:26,840 --> 00:00:29,430
这是我们要使用的设计范例

11
00:00:29,430 --> 00:00:33,220
设计我们的应用程序，有点组织我们的代码

12
00:00:33,220 --> 00:00:34,550
然后第二件事

13
00:00:34,550 --> 00:00:37,630
我要谈谈Swift中的类型系统。 

14
00:00:37,630 --> 00:00:40,370
因此，让我们首先执行此MVVM。 

15
00:00:40,370 --> 00:00:44,270
MVVM是代码组织模型。 

16
00:00:44,270 --> 00:00:46,400
基本上是一个确定的地方

17
00:00:46,400 --> 00:00:48,810
您所有代码都存放在应用程序中的位置

18
00:00:48,810 --> 00:00:50,890
它与这个概念协调一致

19
00:00:50,890 --> 00:00:55,460
我上次提到的反应式用户界面。 

20
00:00:55,460 --> 00:00:59,700
要使SwiftUI能够正常工作，必须遵循此MVVM。 

21
00:00:59,700 --> 00:01:02,250
没有它，您将无法执行SwiftUI。 

22
00:01:02,250 --> 00:01:04,590
对于你们中的那些人来说，这堂课

23
00:01:04,590 --> 00:01:08,510
在前几个季度，这与MVC不同， 

24
00:01:08,510 --> 00:01:12,150
UIKit是Model-View-Controller 

25
00:01:12,150 --> 00:01:16,463
旧版iOS开发机制使用。 

26
00:01:17,810 --> 00:01:22,520
好的，MVVM与MVC有很多共同点

27
00:01:22,520 --> 00:01:25,750
因为我们试图分离模型， 

28
00:01:25,750 --> 00:01:27,607
这是我们应用程序的后端，对吗？ 

29
00:01:27,607 --> 00:01:30,270
与UI无关的部分，带有View， 

30
00:01:30,270 --> 00:01:32,310
这是用户面前的事情。 

31
00:01:32,310 --> 00:01:34,380
让我们先谈谈模型和视图

32
00:01:34,380 --> 00:01:38,393
然后我们将讨论MVVM如何将它们连接在一起。 

33
00:01:39,490 --> 00:01:42,840
因此，模型是独立于UI的。 

34
00:01:42,840 --> 00:01:46,720
例如，模型不导入SwiftUI。 

35
00:01:46,720 --> 00:01:50,580
它试图封装数据和逻辑

36
00:01:50,580 --> 00:01:53,280
关于您的应用程序的功能。 

37
00:01:53,280 --> 00:01:55,870
因此，在我们的纸牌配对游戏中， 

38
00:01:55,870 --> 00:01:59,200
这是卡，就是数据， 

39
00:01:59,200 --> 00:02:02,840
这也是逻辑，当我选择一张卡时会发生什么， 

40
00:02:02,840 --> 00:02:06,650
我该如何匹配，当我匹配时可以得到多少分， 

41
00:02:06,650 --> 00:02:08,400
如果我不匹配怎么办。 

42
00:02:08,400 --> 00:02:12,773
所有这些逻辑和卡数据都存在于模型中。 

43
00:02:14,180 --> 00:02:16,870
模型是事实，好吗？ 

44
00:02:16,870 --> 00:02:19,340
对于所有这些数据和逻辑，这都是事实。 

45
00:02:19,340 --> 00:02:22,680
我们永远不会将这些数据存储在其他地方

46
00:02:22,680 --> 00:02:24,610
并有两个不同的版本。 

47
00:02:24,610 --> 00:02:27,923
我们总是会去了解真相的模型。 

48
00:02:28,770 --> 00:02:31,730
现在，视图反映了模型。 

49
00:02:31,730 --> 00:02:35,410
数据始终从模型流向视图。 

50
00:02:35,410 --> 00:02:37,770
我们总是会尝试使我们的观点

51
00:02:37,770 --> 00:02:39,450
看起来就像我们的模型。 

52
00:02:39,450 --> 00:02:42,040
但是，我们的视图绘制了模型中的内容， 

53
00:02:42,040 --> 00:02:46,090
所以，但是我们的纸牌配对游戏出现在屏幕上， 

54
00:02:46,090 --> 00:02:49,130
它总是会反映游戏的状态

55
00:02:49,130 --> 00:02:50,110
在模型中。 

56
00:02:50,110 --> 00:02:51,850
因此，了解View非常重要。 

57
00:02:51,850 --> 00:02:54,410
始终反映模型中的内容。 

58
00:02:54,410 --> 00:02:57,030
视图几乎是无状态的

59
00:02:57,030 --> 00:03:00,510
因为有关游戏的所有状态都在模型中。 

60
00:03:00,510 --> 00:03:03,660
因此，视图本身不需要任何状态。 

61
00:03:03,660 --> 00:03:05,580
视图本质上只是

62
00:03:05,580 --> 00:03:08,110
无论模型的当前状态是什么并显示

63
00:03:08,110 --> 00:03:10,420
而且它应该能够随时执行此操作， 

64
00:03:10,420 --> 00:03:13,070
只要在任何时候都可以对View说， 

65
00:03:13,070 --> 00:03:15,393
看一下模型，现在看起来像那样。 

66
00:03:15,393 --> 00:03:18,650
这就是我们设计视图的方式。 

67
00:03:18,650 --> 00:03:22,870
这使得View称为声明式。 

68
00:03:22,870 --> 00:03:25,220
声明式意味着我们将要声明

69
00:03:25,220 --> 00:03:26,950
视图看起来像这样

70
00:03:26,950 --> 00:03:30,030
而且我们只会实际更改屏幕上的任何内容

71
00:03:30,030 --> 00:03:31,503
当模型更改时。 

72
00:03:32,703 --> 00:03:35,843
如果您看一下我们上次编写的代码， 

73
00:03:35,843 --> 00:03:39,300
注意我们不调用函数将事物放置在适当的位置， 

74
00:03:39,300 --> 00:03:44,300
我们只是创建RoundedRectangles和Texts和HStacks 

75
00:03:44,560 --> 00:03:47,520
和ZStacks之类的东西，这样我们就可以创建它们

76
00:03:47,520 --> 00:03:49,870
并将它们放在用户界面中我们想要的位置。 

77
00:03:49,870 --> 00:03:54,100
我们在编写的这段代码中调用的唯一函数

78
00:03:54,100 --> 00:03:57,750
是修饰符，可以改变事物外观的事物

79
00:03:57,750 --> 00:03:59,960
他们正在正确地做到这一点。 

80
00:03:59,960 --> 00:04:02,760
因此，尽管我们昨天编写的所有这些代码

81
00:04:02,760 --> 00:04:06,350
只是在声明我们的用户界面是什么样子。 

82
00:04:06,350 --> 00:04:11,300
现在，这与旧的iOS应用制作方法不同

83
00:04:11,300 --> 00:04:12,905
还有很多其他系统

84
00:04:12,905 --> 00:04:14,090
已经存在多年了

85
00:04:14,090 --> 00:04:16,615
我们将其称为当务之急。 

86
00:04:16,615 --> 00:04:20,730
因此，如果您听到执行用户界面的命令式模型

87
00:04:20,730 --> 00:04:24,530
或一般的编码，认为当务之急， 

88
00:04:24,530 --> 00:04:27,620
和“帝国”一词有相同的词根吧？ 

89
00:04:27,620 --> 00:04:32,090
帝制是皇帝统治的国家

90
00:04:32,090 --> 00:04:33,820
皇帝四处说， 

91
00:04:33,820 --> 00:04:37,650
哦，您要做的就是建造这个，然后种植这些田地， 

92
00:04:37,650 --> 00:04:40,890
所以，他告诉人们该怎么做，他是皇帝

93
00:04:40,890 --> 00:04:43,640
这就是该国的运作方式。 

94
00:04:43,640 --> 00:04:46,650
好吧，要在用户界面世界中使用这种隐喻， 

95
00:04:46,650 --> 00:04:48,570
你是说把这个按钮放在这里

96
00:04:48,570 --> 00:04:51,590
并在UI上安排这些东西

97
00:04:51,590 --> 00:04:54,540
并且随着时间的推移，您要调用函数来执行此操作。 

98
00:04:54,540 --> 00:04:58,430
那么，命令式模型为什么对UI不利？ 

99
00:04:58,430 --> 00:05:00,860
好吧，主要原因与时间有关。 

100
00:05:00,860 --> 00:05:03,400
这些东西，这些功能随着时间的推移而被调用。 

101
00:05:03,400 --> 00:05:04,950
将按钮放在这里，然后稍后， 

102
00:05:04,950 --> 00:05:06,130
我们要在这里安排

103
00:05:06,130 --> 00:05:08,140
然后以后，这里会发生什么。 

104
00:05:08,140 --> 00:05:11,440
因此，如果您想了解UI的构建方式， 

105
00:05:11,440 --> 00:05:14,610
您需要时间的另一个维度

106
00:05:14,610 --> 00:05:16,750
知道何时可以调用此函数

107
00:05:16,750 --> 00:05:20,050
什么函数调用取决于其他一些调用

108
00:05:20,050 --> 00:05:23,100
首先发生，然后在您的用户界面启动并运行后， 

109
00:05:23,100 --> 00:05:25,790
有人可以随时调用函数来更改您的用户界面

110
00:05:25,790 --> 00:05:27,720
所以你必须时刻保持警惕

111
00:05:27,720 --> 00:05:28,850
并为此做好准备。 

112
00:05:28,850 --> 00:05:31,340
好吧，这就像一场噩梦

113
00:05:31,340 --> 00:05:35,260
几乎不可能证明您的UI确实有效

114
00:05:35,260 --> 00:05:37,690
因为你不能调用所有功能

115
00:05:37,690 --> 00:05:39,230
以各种可能的顺序

116
00:05:39,230 --> 00:05:40,810
所以这没有任何意义， 

117
00:05:40,810 --> 00:05:43,040
而声明性的，你总是可以看

118
00:05:43,040 --> 00:05:45,540
按照您为UI声明的内容

119
00:05:45,540 --> 00:05:47,520
看看这是做什么的。 

120
00:05:47,520 --> 00:05:50,480
在任何时候，它都是时间独立的， 

121
00:05:50,480 --> 00:05:52,900
它应该能够随时被询问

122
00:05:52,900 --> 00:05:55,310
做它做的事，画它做的事

123
00:05:55,310 --> 00:05:57,530
看起来就像是代码

124
00:05:57,530 --> 00:05:58,950
你在眼前。 

125
00:05:58,950 --> 00:06:01,200
它还将所有代码本地化。 

126
00:06:01,200 --> 00:06:06,110
因此，所有用于绘制UI的代码都就在您眼前。 

127
00:06:06,110 --> 00:06:08,350
我们昨天写的代码就是这样， 

128
00:06:08,350 --> 00:06:12,080
那就是显示卡的用户界面的完整代码

129
00:06:12,080 --> 00:06:13,680
而且没有其他地方的一些代码

130
00:06:13,680 --> 00:06:17,420
那会在上面调用一个函数并将其弄乱。 

131
00:06:17,420 --> 00:06:21,000
实际上，您将在今天晚些时候学习有关结构的信息， 

132
00:06:21,000 --> 00:06:22,620
我们的观点是结构， 

133
00:06:22,620 --> 00:06:25,370
默认情况下，它们实际上是只读的。 

134
00:06:25,370 --> 00:06:28,850
不允许任何人调用会对其进行更改的函数。 

135
00:06:28,850 --> 00:06:30,700
甚至不可能做。 

136
00:06:30,700 --> 00:06:32,850
这样一来，您可以确定

137
00:06:32,850 --> 00:06:36,060
总是看起来就像你所看到的

138
00:06:36,060 --> 00:06:38,560
在您前面声明的代码中。 

139
00:06:38,560 --> 00:06:40,820
巨大的优势在于理解

140
00:06:40,820 --> 00:06:42,660
您的代码将如何工作， 

141
00:06:42,660 --> 00:06:43,770
确保你， 

142
00:06:43,770 --> 00:06:46,300
而且没有随机的事情发生

143
00:06:46,300 --> 00:06:48,130
当您的应用程序运行时。 

144
00:06:48,130 --> 00:06:49,170
这是梦幻般的。 

145
00:06:49,170 --> 00:06:52,523
相对于UI的命令式模型有很大的改进。 

146
00:06:54,018 --> 00:06:56,150
然后是视图的最后一部分

147
00:06:56,150 --> 00:06:58,180
它会是被动的。 

148
00:06:58,180 --> 00:07:00,430
这意味着只要模型发生变化， 

149
00:07:00,430 --> 00:07:03,260
它会自动更新视图

150
00:07:03,260 --> 00:07:05,290
因为我告诉过您，视图是无状态的。 

151
00:07:05,290 --> 00:07:07,420
任何时候您都应该能够说

152
00:07:07,420 --> 00:07:09,030
使它看起来像模型

153
00:07:09,030 --> 00:07:11,900
因此，我们将拥有一个系统

154
00:07:11,900 --> 00:07:13,530
每当模型发生变化时， 

155
00:07:13,530 --> 00:07:16,700
它要求视图自动看起来像它。 

156
00:07:16,700 --> 00:07:18,690
称之为反应式编程， 

157
00:07:18,690 --> 00:07:22,410
它会对模型中的更改做出反应。 

158
00:07:22,410 --> 00:07:23,470
就是这样了。 

159
00:07:23,470 --> 00:07:26,303
这就是我们要做的

160
00:07:27,980 --> 00:07:32,980
它引入了另一种称为ViewModel的东西。 

161
00:07:33,044 --> 00:07:36,870
ViewModel的工作是将视图绑定到模型。 

162
00:07:36,870 --> 00:07:38,940
因此，模型发生了一次变化， 

163
00:07:38,940 --> 00:07:41,530
视图得到反映。 

164
00:07:41,530 --> 00:07:43,130
一路上

165
00:07:43,130 --> 00:07:45,920
因为它完成了模型和视图之间的绑定， 

166
00:07:45,920 --> 00:07:49,150
它可能正在解释视图的模型

167
00:07:49,150 --> 00:07:50,980
因为我们希望视图非常简单

168
00:07:50,980 --> 00:07:53,870
因为我们以声明性的方式编写它， 

169
00:07:53,870 --> 00:07:55,790
我们不希望它里面有很多代码

170
00:07:55,790 --> 00:07:58,750
这就像从一种数据类型转换为另一种数据类型一样

171
00:07:58,750 --> 00:07:59,770
之类的。 

172
00:07:59,770 --> 00:08:02,320
因此，我们将要求ViewModel做到这一点。 

173
00:08:02,320 --> 00:08:05,480
我们在这里编写的游戏模型

174
00:08:05,480 --> 00:08:08,150
在这个记忆游戏中，我们的模型只是一个结构。 

175
00:08:08,150 --> 00:08:10,130
这是一个非常简单的小演示

176
00:08:10,130 --> 00:08:11,940
但是你可以想象你的模型

177
00:08:11,940 --> 00:08:15,560
是SQL数据库还是网络上的东西

178
00:08:15,560 --> 00:08:17,610
您在哪里发出HTTP请求。 

179
00:08:17,610 --> 00:08:19,760
所以那边可能很复杂

180
00:08:19,760 --> 00:08:22,460
而您的ViewModel可以简化这一点， 

181
00:08:22,460 --> 00:08:25,080
归结为一些更简单的数据结构

182
00:08:25,080 --> 00:08:27,420
它可以传递给视图

183
00:08:27,420 --> 00:08:30,340
这将使View是绘制它的简单代码。 

184
00:08:30,340 --> 00:08:32,760
因此，ViewModel确实扮演了这个角色

185
00:08:32,760 --> 00:08:36,053
作为该模型数据的解释器。 

186
00:08:36,990 --> 00:08:40,101
所以我们要插入ViewModel 

187
00:08:40,101 --> 00:08:41,960
在模型和视图之间。 

188
00:08:41,960 --> 00:08:44,750
那将是

189
00:08:44,750 --> 00:08:48,020
有助于使此自动更新发生。 

190
00:08:48,020 --> 00:08:50,430
那么它是如何做的呢？ 

191
00:08:50,430 --> 00:08:51,890
好吧，首先是ViewModel 

192
00:08:51,890 --> 00:08:54,710
一直试图注意到模型的变化

193
00:08:54,710 --> 00:08:57,390
它可以按照自己想要的任何方式进行操作。 

194
00:08:57,390 --> 00:09:00,900
如果您的模型是结构，则实际上非常简单。 

195
00:09:00,900 --> 00:09:02,600
再说一次，我要讲一个结构

196
00:09:02,600 --> 00:09:05,450
稍后会详细介绍Swift中的该类型

197
00:09:05,450 --> 00:09:07,980
但是结构的一大特色

198
00:09:07,980 --> 00:09:09,460
因为它被复制

199
00:09:09,460 --> 00:09:11,431
当它传递给函数和东西时

200
00:09:11,431 --> 00:09:15,030
是Swift知道结构何时更改。 

201
00:09:15,030 --> 00:09:16,998
它可以跟踪结构更改的时间

202
00:09:16,998 --> 00:09:19,110
因此，对于ViewModel来说非常容易

203
00:09:19,110 --> 00:09:22,710
其模型是查看更改时间的结构。 

204
00:09:22,710 --> 00:09:24,600
但是如果模型是SQL数据库， 

205
00:09:24,600 --> 00:09:26,980
我不知道你们对数据库了解多少

206
00:09:26,980 --> 00:09:30,610
但是将内容插入SQL数据库很容易

207
00:09:30,610 --> 00:09:33,270
这样当它更改时，您会收到通知。 

208
00:09:33,270 --> 00:09:34,303
但这取决于ViewModel 

209
00:09:34,303 --> 00:09:36,980
了解模型中的这些更改。 

210
00:09:36,980 --> 00:09:40,477
那是它必须要做的主要事情之一。 

211
00:09:40,477 --> 00:09:44,250
现在，当数据更改时，它可能会解释该数据， 

212
00:09:44,250 --> 00:09:46,140
可能会将其转换为其他格式

213
00:09:46,140 --> 00:09:48,560
或类似的东西，但是然后它会做什么

214
00:09:48,560 --> 00:09:53,370
它发布了一些改变世界的东西，好吗？ 

215
00:09:53,370 --> 00:09:54,930
对任何有兴趣的人。 

216
00:09:54,930 --> 00:09:58,090
这就是全部，发布更改了的内容。 

217
00:09:58,090 --> 00:10:01,820
它实际上没有指向任何视图的指针，好吗？ 

218
00:10:01,820 --> 00:10:04,270
ViewModel从不具有指向其View的指针。 

219
00:10:04,270 --> 00:10:05,860
这是一件很重要的事情。 

220
00:10:05,860 --> 00:10:10,590
ViewModel不会直接与其视图对话。 

221
00:10:10,590 --> 00:10:11,934
当模型发生变化时， 

222
00:10:11,934 --> 00:10:15,610
它发布了一些更改。 

223
00:10:15,610 --> 00:10:20,350
但是随后，View订阅了该出版物

224
00:10:20,350 --> 00:10:22,760
当看到某些变化时， 

225
00:10:22,760 --> 00:10:25,780
它返回到ViewModel并询问， 

226
00:10:25,780 --> 00:10:27,480
好吧，目前的世界状况如何？ 

227
00:10:27,480 --> 00:10:30,297
我要吸引自己去适应世界的状况。 

228
00:10:30,297 --> 00:10:32,490
以及它问ViewModel的原因， 

229
00:10:32,490 --> 00:10:34,610
它不会直接回到模型， 

230
00:10:34,610 --> 00:10:36,480
是因为ViewModel可能正在做

231
00:10:36,480 --> 00:10:38,240
这种解释

232
00:10:38,240 --> 00:10:40,720
否则可能会保护模型

233
00:10:40,720 --> 00:10:42,870
确保某些邪恶的观点

234
00:10:42,870 --> 00:10:44,780
不会对模型造成不良影响。 

235
00:10:44,780 --> 00:10:46,927
这就是整个过程的工作原理，就这么简单。 

236
00:10:46,927 --> 00:10:49,098
ViewModel注意到模型中的更改

237
00:10:49,098 --> 00:10:50,920
但是任何时候改变

238
00:10:50,920 --> 00:10:53,130
它说，哦，有些变化

239
00:10:53,130 --> 00:10:57,180
然后视图只观察到那些改变了

240
00:10:57,180 --> 00:10:59,550
事情发生，然后提取数据

241
00:10:59,550 --> 00:11:01,260
从ViewModel并重绘自身

242
00:11:01,260 --> 00:11:02,829
因为那是View可以做的

243
00:11:02,829 --> 00:11:06,400
可以随时使用模型的当前状态重绘自身

244
00:11:06,400 --> 00:11:09,790
它是通过此ViewModel解释器获取的。 

245
00:11:09,790 --> 00:11:13,780
这就是全部内容，随着这一季度的进行， 

246
00:11:13,780 --> 00:11:18,200
我们将看到Swift语法来使所有这些工作。 

247
00:11:18,200 --> 00:11:21,760
我在这里放了一些语法，例如ObservableObjects 

248
00:11:21,760 --> 00:11:25,080
然后onReceive和objectWillChange继续进行， 

249
00:11:25,080 --> 00:11:26,960
这些都是我要开始的事情

250
00:11:26,960 --> 00:11:28,167
谈论下周。 

251
00:11:28,167 --> 00:11:29,560
其实我们会看到的

252
00:11:29,560 --> 00:11:31,740
就在今天演示的最后

253
00:11:31,740 --> 00:11:33,770
当我们要开始使用其中一些关键字时

254
00:11:33,770 --> 00:11:36,493
使整个事情发生。 

255
00:11:37,660 --> 00:11:40,320
现在，另一个方向呢？ 

256
00:11:40,320 --> 00:11:42,384
我们已经讨论过模型

257
00:11:42,384 --> 00:11:44,187
可以流入视图

258
00:11:44,187 --> 00:11:46,860
并且视图始终反映模型中的内容。 

259
00:11:46,860 --> 00:11:50,110
如果视图位于按钮所在的位置怎么办

260
00:11:50,110 --> 00:11:52,720
滑动手势正在发生， 

261
00:11:52,720 --> 00:11:55,310
如果要更改模型怎么办，好吗？ 

262
00:11:55,310 --> 00:11:56,920
这是如何运作的？ 

263
00:11:56,920 --> 00:12:01,330
好吧，为此，我们添加了另一个责任

264
00:12:01,330 --> 00:12:05,250
为ViewModel处理它的意图

265
00:12:05,250 --> 00:12:09,060
所谓“意图”，是指用户的意图， 

266
00:12:09,060 --> 00:12:12,090
用户的意图，实际的最终用户。 

267
00:12:12,090 --> 00:12:15,370
这就是MVVM，整个系统。 

268
00:12:15,370 --> 00:12:18,380
还有另一种相关的架构

269
00:12:18,380 --> 00:12:20,870
叫做Model-View-Intent，好吗？ 

270
00:12:20,870 --> 00:12:23,500
这更清楚地说明了当用户

271
00:12:23,500 --> 00:12:25,730
想做点什么，他们经历了这个意图。 

272
00:12:25,730 --> 00:12:30,730
现在，Apple的iOS SwiftUI设计未实现

273
00:12:31,180 --> 00:12:34,140
一个意图系统，所以我只想谈论意图

274
00:12:34,140 --> 00:12:35,550
作为一个概念。 

275
00:12:35,550 --> 00:12:38,300
意图是某种用户意图。 

276
00:12:38,300 --> 00:12:41,340
这里有一个经典的例子，在我们的记忆游戏中， 

277
00:12:41,340 --> 00:12:44,550
用户将具有选择卡片的意图。 

278
00:12:44,550 --> 00:12:45,950
那是他们的意图。 

279
00:12:45,950 --> 00:12:48,880
因此，由ViewModel处理这些Intent 

280
00:12:48,880 --> 00:12:52,530
它通过使功能可用来实现

281
00:12:52,530 --> 00:12:56,010
调用视图以明确意图。 

282
00:12:56,010 --> 00:12:58,630
因此，只要有手势发生，视图

283
00:12:58,630 --> 00:13:00,920
点击手势，滑动手势或其他任何方式， 

284
00:13:00,920 --> 00:13:03,850
视图将调用一个Intent函数

285
00:13:03,850 --> 00:13:04,683
在ViewModel中。 

286
00:13:04,683 --> 00:13:06,880
这只是一个文档。 

287
00:13:06,880 --> 00:13:09,993
我们将在ViewModel的代码中有一部分

288
00:13:09,993 --> 00:13:12,120
在顶部有一个评论， 

289
00:13:12,120 --> 00:13:17,120
这些是最终用户的意图或意图。 

290
00:13:17,750 --> 00:13:21,100
这样就很清楚会发生什么， 

291
00:13:21,100 --> 00:13:24,000
用户可以执行的操作将更改模型。 

292
00:13:24,000 --> 00:13:25,977
现在，当ViewModel收到

293
00:13:25,977 --> 00:13:28,680
像这样的函数调用了它们， 

294
00:13:28,680 --> 00:13:30,310
他们将修改模型

295
00:13:30,310 --> 00:13:33,750
再一次，ViewModel知道所有关于模型的信息

296
00:13:33,750 --> 00:13:36,040
以及它的表示方式（如果是SQL） 

297
00:13:36,040 --> 00:13:38,999
它会发出SQL命令来更改模型， 

298
00:13:38,999 --> 00:13:42,240
如果是结构，那么也许只是设置变量

299
00:13:42,240 --> 00:13:45,040
或调用模型中的函数进行修改。 

300
00:13:45,040 --> 00:13:46,730
你可以做任何有意义的事

301
00:13:46,730 --> 00:13:50,990
表达用户更改模型的意图。 

302
00:13:50,990 --> 00:13:52,400
所以现在模型正在改变。 

303
00:13:52,400 --> 00:13:53,530
接下来发生什么？ 

304
00:13:53,530 --> 00:13:56,280
好吧，我们之前谈到的确切意图。 

305
00:13:56,280 --> 00:13:59,240
ViewModel注意到它所做的更改， 

306
00:13:59,240 --> 00:14:01,470
它发布了一些更改

307
00:14:01,470 --> 00:14:03,940
然后视图看到有些变化

308
00:14:03,940 --> 00:14:06,910
并自动重绘。 

309
00:14:06,910 --> 00:14:08,670
这就是这张图片， 

310
00:14:08,670 --> 00:14:10,240
您在这里看到的整个图片， 

311
00:14:10,240 --> 00:14:13,239
这是MVVM架构， 

312
00:14:13,239 --> 00:14:15,560
这些是Swift关键字

313
00:14:15,560 --> 00:14:18,470
您将在代码中看到的

314
00:14:18,470 --> 00:14:19,896
当我们写这一切的时候

315
00:14:19,896 --> 00:14:21,630
就是这么简单

316
00:14:21,630 --> 00:14:24,800
实际上，所有这些的关键只是理解

317
00:14:24,800 --> 00:14:27,150
这三个角色的每个角色

318
00:14:27,150 --> 00:14:30,500
因为它们将在代码中非常明确地定义。 

319
00:14:30,500 --> 00:14:32,230
因此，在我今天要进行的演示中， 

320
00:14:32,230 --> 00:14:35,810
我们将实现此MVVM体系结构

321
00:14:35,810 --> 00:14:37,800
为我们的记忆游戏

322
00:14:37,800 --> 00:14:40,990
我们无法使记忆游戏真正以其他方式运行。 

323
00:14:40,990 --> 00:14:43,170
如果我们做到了，那就太糟糕了。 

324
00:14:43,170 --> 00:14:44,130
我不确定我们该怎么做

325
00:14:44,130 --> 00:14:47,040
但是，如果我们可以使其以某种方式起作用，那将是错误的。 

326
00:14:47,040 --> 00:14:48,543
我们想使用MVVM。 

327
00:14:50,080 --> 00:14:51,630
好吧，在我们这样做之前， 

328
00:14:51,630 --> 00:14:55,150
让我们有另一个，在这里讨论另一个小话题

329
00:14:55,150 --> 00:14:56,542
这是类型。 

330
00:14:56,542 --> 00:14:58,060
所以有很多东西要学

331
00:14:58,060 --> 00:14:59,847
关于Swift编程语言

332
00:14:59,847 --> 00:15:01,710
但我们将从学习开始

333
00:15:01,710 --> 00:15:03,710
关于它的类型

334
00:15:03,710 --> 00:15:08,010
它具有您已经看到的这六种类型的结构。 

335
00:15:08,010 --> 00:15:10,680
用于对象或您的编程的类。 

336
00:15:10,680 --> 00:15:11,560
我们会看到的。 

337
00:15:11,560 --> 00:15:14,219
协议，实际上，您也已经看到了。 

338
00:15:14,219 --> 00:15:17,890
不用管类型，好吧，我们称之为通用， 

339
00:15:17,890 --> 00:15:19,050
因此是通用系统。 

340
00:15:19,050 --> 00:15:21,230
枚举和函数。 

341
00:15:21,230 --> 00:15:24,173
是的，函数是Swift中的类型。 

342
00:15:25,260 --> 00:15:26,560
但是为了时间的利益， 

343
00:15:26,560 --> 00:15:30,030
我将只介绍以下四种类型： 

344
00:15:30,030 --> 00:15:34,080
struct，class，这些都不关心类型和功能。 

345
00:15:34,080 --> 00:15:37,760
下次我将介绍协议和枚举。 

346
00:15:37,760 --> 00:15:40,520
好吧，让我们从struct和class开始。 

347
00:15:40,520 --> 00:15:43,350
结构和类看起来几乎完全相同。 

348
00:15:43,350 --> 00:15:45,580
它们的语法非常非常相似。 

349
00:15:45,580 --> 00:15:49,393
它们都存储了像var isFaceUp这样的变量

350
00:15:49,393 --> 00:15:52,070
这是我们上次在演示中看到的。 

351
00:15:52,070 --> 00:15:54,760
它们都可以具有计算变量

352
00:15:54,760 --> 00:15:56,790
就像我们上次从演示中看到的一样，对吗？ 

353
00:15:56,790 --> 00:15:57,800
Var的身体。 

354
00:15:57,800 --> 00:16:00,010
每次计算其值

355
00:16:00,010 --> 00:16:02,530
有人要求提供类和结构。 

356
00:16:02,530 --> 00:16:03,763
两者都有。 

357
00:16:04,610 --> 00:16:07,310
他们也可以拥有被称为let的东西。 

358
00:16:07,310 --> 00:16:10,440
好吧，让我们只是一个变种

359
00:16:10,440 --> 00:16:11,620
实际上并没有变化。 

360
00:16:11,620 --> 00:16:13,810
它不是变量，而是常量。 

361
00:16:13,810 --> 00:16:15,600
因此，let本质上是一个常量。 

362
00:16:15,600 --> 00:16:18,280
它们都可以包含常量。 

363
00:16:18,280 --> 00:16:20,350
它们也都具有功能。 

364
00:16:20,350 --> 00:16:23,260
关于函数的语法，我们还没有讨论太多

365
00:16:23,260 --> 00:16:27,240
因此，让我在这里花点时间谈论一下。 

366
00:16:27,240 --> 00:16:29,640
我们已经知道对于某个功能， 

367
00:16:29,640 --> 00:16:34,230
参数具有标签或在此乘法函数中， 

368
00:16:34,230 --> 00:16:35,610
它有两个论点。 

369
00:16:35,610 --> 00:16:37,217
第一个参数称为操作数

370
00:16:37,217 --> 00:16:38,997
第二个是由

371
00:16:38,997 --> 00:16:42,105
在两个Int类型中，此函数返回一个Int 

372
00:16:42,105 --> 00:16:44,540
在乘法里面

373
00:16:44,540 --> 00:16:48,520
我只是使用标签操作数并使其运行。 

374
00:16:48,520 --> 00:16:52,750
所以如果我说操作数5乘以6， 

375
00:16:52,750 --> 00:16:56,050
那显然将为我们返回30。 

376
00:16:56,050 --> 00:16:58,960
我想告诉你那些标签， 

377
00:16:58,960 --> 00:17:02,760
实际上，每个参数可以有两个标签。 

378
00:17:02,760 --> 00:17:04,980
所以在这里，我又乘了

379
00:17:04,980 --> 00:17:07,350
但它们每个都有两个标签。 

380
00:17:07,350 --> 00:17:11,550
我的第一个参数的标签为underbar 

381
00:17:11,550 --> 00:17:16,020
标签操作数，第二个操作符的标签为

382
00:17:16,020 --> 00:17:18,114
和标签otherOperand。 

383
00:17:18,114 --> 00:17:21,130
看看有两个，蓝色的和紫色的

384
00:17:21,130 --> 00:17:24,740
对于每个参数，为什么有两个？ 

385
00:17:24,740 --> 00:17:29,040
好吧，蓝色的供函数调用者使用

386
00:17:29,040 --> 00:17:32,720
紫色的用于函数内部。 

387
00:17:32,720 --> 00:17:35,520
所以紫色的看起来和我们之前的一样

388
00:17:35,520 --> 00:17:37,660
返回操作数乘以其他操作数。 

389
00:17:37,660 --> 00:17:42,660
这是它们两个标签中的第二个

390
00:17:42,870 --> 00:17:44,260
但看看来电者。 

391
00:17:44,260 --> 00:17:48,550
他现在说乘以五乘以六。 

392
00:17:48,550 --> 00:17:52,560
因此，下划线标签表示没有标签。 

393
00:17:52,560 --> 00:17:55,680
这就是为什么我们看到文字， 

394
00:17:55,680 --> 00:17:57,500
需要一点表情符号字符串， 

395
00:17:57,500 --> 00:17:58,833
它不必在那里有标签， 

396
00:17:58,833 --> 00:18:03,360
这是因为它在代码中的某处使用了下划线

397
00:18:03,360 --> 00:18:04,704
表示您可以忽略它。 

398
00:18:04,704 --> 00:18:08,100
Underbar始终意味着将其保留，好吗？ 

399
00:18:08,100 --> 00:18:10,130
未使用，您想这样想， 

400
00:18:10,130 --> 00:18:13,060
它是Swift中未使用的字符。 

401
00:18:13,060 --> 00:18:16,090
我们还将在今天的演示中看到这一点。 

402
00:18:16,090 --> 00:18:19,800
然后第二个仍然使用by作为外部名称。 

403
00:18:19,800 --> 00:18:21,763
我们称其为外部名称， 

404
00:18:21,763 --> 00:18:24,883
它使用otherOperand作为内部名称。 

405
00:18:25,720 --> 00:18:27,550
所以你稍后可以凝视

406
00:18:27,550 --> 00:18:31,180
但这基本上是函数的语法

407
00:18:31,180 --> 00:18:35,600
函数和功能都存在于结构和类中。 

408
00:18:35,600 --> 00:18:38,330
现在，结构和类也具有特殊功能

409
00:18:38,330 --> 00:18:40,461
称为初始值设定项。 

410
00:18:40,461 --> 00:18:45,133
和初始值设定项用于创建您的结构或类

411
00:18:46,230 --> 00:18:50,220
带有一些不是您的变量之一的参数。 

412
00:18:50,220 --> 00:18:51,710
我们已经看到了CardView 

413
00:18:51,710 --> 00:18:53,698
并记住CardView 

414
00:18:53,698 --> 00:18:56,954
我们使用参数isFaceUp true创建了它

415
00:18:56,954 --> 00:19:00,560
并在CardView中设置了var isFaceUp。 

416
00:19:00,560 --> 00:19:04,410
所以我们总是可以这样初始化

417
00:19:04,410 --> 00:19:08,060
但是如果我们想使用其他类型的参数呢？ 

418
00:19:08,060 --> 00:19:09,915
得到一些初始化？ 

419
00:19:09,915 --> 00:19:12,900
一个很好的例子就是它将成为我们的MemoryGame 

420
00:19:12,900 --> 00:19:15,310
因为当您创建一个MemoryGame时， 

421
00:19:15,310 --> 00:19:18,910
var就像卡片或类似的东西

422
00:19:18,910 --> 00:19:20,750
但是实际上，当您创建一个MemoryGame时， 

423
00:19:20,750 --> 00:19:23,650
您想说游戏中有几副牌。 

424
00:19:23,650 --> 00:19:25,428
这是有20张卡片的大型MemoryGame吗？ 

425
00:19:25,428 --> 00:19:29,120
或只有六对卡片的较小型MemoryGame 

426
00:19:29,120 --> 00:19:30,100
或类似的东西？ 

427
00:19:30,100 --> 00:19:32,750
所以，我想提出论点

428
00:19:32,750 --> 00:19:36,110
创建一个MemoryGame是numberOfPairsOfCards 

429
00:19:36,110 --> 00:19:38,270
这是一个Int，我可以做到

430
00:19:38,270 --> 00:19:41,352
通过在我的MemoryGame中放置一个初始化函数， 

431
00:19:41,352 --> 00:19:43,280
以此为理由。 

432
00:19:43,280 --> 00:19:45,270
而且很酷的事情是我可以拥有

433
00:19:45,270 --> 00:19:47,570
我想要的任何数量的init， 

434
00:19:47,570 --> 00:19:49,300
每个人都有不同的论点。 

435
00:19:49,300 --> 00:19:51,750
也许还有其他方法可以创建MemoryGame。 

436
00:19:51,750 --> 00:19:55,733
因此结构和类都具有初始化程序。 

437
00:19:56,660 --> 00:19:59,210
那么，结构和类之间有什么区别？ 

438
00:19:59,210 --> 00:20:02,250
他们看起来非常相似，而且大致相似

439
00:20:02,250 --> 00:20:04,050
但是有一些根本的不同

440
00:20:04,050 --> 00:20:06,730
因此，让我们谈谈这些差异是什么。 

441
00:20:06,730 --> 00:20:11,130
最大的不同是struct是一个值类型

442
00:20:11,130 --> 00:20:13,940
而class是引用类型。 

443
00:20:13,940 --> 00:20:16,610
因此，让我们再谈谈这意味着什么。 

444
00:20:16,610 --> 00:20:18,861
值类型与引用类型。 

445
00:20:18,861 --> 00:20:23,430
引用类型通过指针传递。 

446
00:20:23,430 --> 00:20:25,710
引用类型存在于堆中。 

447
00:20:25,710 --> 00:20:27,570
好的，当您创建类时， 

448
00:20:27,570 --> 00:20:30,130
它们的存储在堆中。 

449
00:20:30,130 --> 00:20:31,570
每个人都知道这意味着什么。 

450
00:20:31,570 --> 00:20:34,730
就像存储在内存中一样，当我传递它时， 

451
00:20:34,730 --> 00:20:36,120
我正在传递指向它的指针。 

452
00:20:36,120 --> 00:20:37,610
所以很多人可能都有一个指针

453
00:20:37,610 --> 00:20:39,670
到某个地方的同一个班级。 

454
00:20:39,670 --> 00:20:44,670
指针不传递结构，而是对其进行复制。 

455
00:20:45,550 --> 00:20:49,720
因此，如果您将结构作为参数传递给函数， 

456
00:20:49,720 --> 00:20:51,535
该函数获取它的副本

457
00:20:51,535 --> 00:20:53,811
即使我只有一个变量

458
00:20:53,811 --> 00:20:56,090
我说了另一个变量

459
00:20:56,090 --> 00:20:57,720
等于第一个变量， 

460
00:20:57,720 --> 00:21:01,690
这两个变量都是它的单独副本。 

461
00:21:01,690 --> 00:21:04,560
看来，哇，你在开玩笑。 

462
00:21:04,560 --> 00:21:08,010
我正在复制，我的意思是数组是结构

463
00:21:08,010 --> 00:21:10,700
所以我正在制作大量数组的副本

464
00:21:10,700 --> 00:21:14,200
每次我将其传递给函数或类似的东西时？ 

465
00:21:14,200 --> 00:21:17,840
答案当然是实际上没有发生。 

466
00:21:17,840 --> 00:21:20,340
在幕后，斯威夫特是， 

467
00:21:20,340 --> 00:21:21,640
当你传递这些东西时

468
00:21:21,640 --> 00:21:23,530
它正在复制这些结构， 

469
00:21:23,530 --> 00:21:26,720
它并没有真正复制它的片段， 

470
00:21:26,720 --> 00:21:30,880
共享它们，直到您尝试对其进行写操作为止。 

471
00:21:30,880 --> 00:21:33,513
因此，如果您将数组传递给函数， 

472
00:21:33,513 --> 00:21:36,650
可能会将其复制到另一个变量中

473
00:21:36,650 --> 00:21:40,630
然后它想向该数组添加一些东西， 

474
00:21:40,630 --> 00:21:44,015
然后要复制一个实际的按位复制

475
00:21:44,015 --> 00:21:46,410
的数组，以便您可以添加到它

476
00:21:46,410 --> 00:21:49,750
因为您将其添加到的是另一份副本

477
00:21:49,750 --> 00:21:50,590
比另一个。 

478
00:21:50,590 --> 00:21:52,630
这就是所谓的写时复制

479
00:21:52,630 --> 00:21:54,950
当您实际写入结构时， 

480
00:21:54,950 --> 00:21:57,520
它实际上确实可以复制。 

481
00:21:57,520 --> 00:22:01,810
但是从语义上讲，每次传递struct时， 

482
00:22:01,810 --> 00:22:03,220
它正在被复制。 

483
00:22:03,220 --> 00:22:04,840
它总是被复制。 

484
00:22:04,840 --> 00:22:06,810
所以您不共享这些结构， 

485
00:22:06,810 --> 00:22:10,240
当您传递它们时，永远不会共享它们，它们会被复制。 

486
00:22:10,240 --> 00:22:12,248
另一方面，现在一堂课

487
00:22:12,248 --> 00:22:13,770
您正在传递指向它的指针， 

488
00:22:13,770 --> 00:22:17,625
因此，它正在做的是计数引用。 

489
00:22:17,625 --> 00:22:21,145
看看这个东西有多少个指针

490
00:22:21,145 --> 00:22:22,540
这会自动发生

491
00:22:22,540 --> 00:22:25,870
当最后，没有人留下来

492
00:22:25,870 --> 00:22:29,543
到堆中的类，然后释放内存

493
00:22:29,543 --> 00:22:30,923
走出堆。 

494
00:22:31,920 --> 00:22:34,640
这就是所谓的自动引用计数。 

495
00:22:34,640 --> 00:22:36,470
所以这是两种非常不同的方式

496
00:22:36,470 --> 00:22:38,840
对世界的思考，对吗？ 

497
00:22:38,840 --> 00:22:43,180
在传递时或通过指针复制时进行复制。 

498
00:22:43,180 --> 00:22:45,710
您看到的大多数东西都是结构。 

499
00:22:45,710 --> 00:22:48,480
所以数组，字典，整数，布尔，双打， 

500
00:22:48,480 --> 00:22:50,690
这些都是结构。 

501
00:22:50,690 --> 00:22:54,120
而struct是基本构建的

502
00:22:54,120 --> 00:22:55,540
支持一种编程

503
00:22:55,540 --> 00:22:58,230
称为函数式编程。 

504
00:22:58,230 --> 00:22:59,750
函数式编程重点

505
00:22:59,750 --> 00:23:02,900
关于事物的功能。 

506
00:23:02,900 --> 00:23:06,750
类是为面向对象的编程而构建的。 

507
00:23:06,750 --> 00:23:09,125
面向对象的编程侧重于

508
00:23:09,125 --> 00:23:11,140
封装数据

509
00:23:11,140 --> 00:23:15,320
并将功能放入某个容器中，好吗？ 

510
00:23:15,320 --> 00:23:16,490
一个东西。 

511
00:23:16,490 --> 00:23:18,740
这些是世界上截然不同的概念。 

512
00:23:18,740 --> 00:23:22,140
他们都在努力实现相似的目标， 

513
00:23:22,140 --> 00:23:24,900
这有点封装

514
00:23:24,900 --> 00:23:29,050
也只是了解功能的用途

515
00:23:29,050 --> 00:23:32,140
在您的程序中，但他们的做法大不相同。 

516
00:23:32,140 --> 00:23:34,944
您可以通过它们的类型构建方式来判断。 

517
00:23:34,944 --> 00:23:37,932
到处复制与指向它的指针

518
00:23:37,932 --> 00:23:40,700
导致很多不同的行为

519
00:23:40,700 --> 00:23:42,780
在本季度的整个过程中， 

520
00:23:42,780 --> 00:23:45,390
我们将学习很多有关函数式编程的知识

521
00:23:45,390 --> 00:23:49,230
以及在本小节的其余部分中它是如何工作的， 

522
00:23:49,230 --> 00:23:51,900
我们将对此有更多了解。 

523
00:23:51,900 --> 00:23:53,620
我假设你们都知道

524
00:23:53,620 --> 00:23:54,930
关于面向对象的编程。 

525
00:23:54,930 --> 00:23:57,700
您使用Java或C ++进行编程

526
00:23:57,700 --> 00:23:58,853
所以你有点知道

527
00:23:59,872 --> 00:24:02,210
结构没有继承。 

528
00:24:02,210 --> 00:24:03,770
那不是真的

529
00:24:03,770 --> 00:24:05,920
真的没有任何意义

530
00:24:05,920 --> 00:24:08,020
在函数式编程中要具有继承性。 

531
00:24:08,020 --> 00:24:09,280
我们确实有一种继承

532
00:24:09,280 --> 00:24:10,810
在函数式编程中，您会看到， 

533
00:24:10,810 --> 00:24:12,090
但不能使用结构，好吗？ 

534
00:24:12,090 --> 00:24:13,680
结构不能继承。 

535
00:24:13,680 --> 00:24:16,520
Swift中的类具有继承性。 

536
00:24:16,520 --> 00:24:18,830
当然，如果愿意，他们可以拥有超类

537
00:24:18,830 --> 00:24:20,040
但这是单一继承。 

538
00:24:20,040 --> 00:24:22,861
它们只能从一个类继承。 

539
00:24:22,861 --> 00:24:23,694
那就是你习惯的

540
00:24:23,694 --> 00:24:25,507
Java只有单一继承， 

541
00:24:25,507 --> 00:24:28,890
C ++是单一继承，等等。 

542
00:24:28,890 --> 00:24:30,833
因此，这也是一个很大的差异。 

543
00:24:31,970 --> 00:24:34,130
我告诉过你那些初始化函数。 

544
00:24:34,130 --> 00:24:36,804
在结构中，您可以获得免费的初始化

545
00:24:36,804 --> 00:24:40,050
初始化结构中的所有变量。 

546
00:24:40,050 --> 00:24:41,670
免费获得那个

547
00:24:41,670 --> 00:24:44,753
这就是为什么我们可以说CardView isFaceUp冒号是真的

548
00:24:45,820 --> 00:24:49,353
然后初始化那边的isFaceUp var 

549
00:24:49,353 --> 00:24:51,640
因为我们有一个免费的初始化器

550
00:24:51,640 --> 00:24:53,270
初始化所有变量。 

551
00:24:53,270 --> 00:24:55,581
在课堂上，您还将获得免费的初始化程序

552
00:24:55,581 --> 00:24:58,320
但它不会初始化任何变量。 

553
00:24:58,320 --> 00:25:00,160
它总是开括号，闭括号， 

554
00:25:00,160 --> 00:25:01,540
那是免费的。 

555
00:25:01,540 --> 00:25:03,070
因此，这意味着您所有的var 

556
00:25:03,070 --> 00:25:05,770
他们之后必须拥有平等的东西

557
00:25:05,770 --> 00:25:08,930
否则您必须在课程中提供自己的init。 

558
00:25:08,930 --> 00:25:13,350
因此，在课堂上，我们几乎总是提供init。 

559
00:25:13,350 --> 00:25:15,920
因此，我们没有一个很好的免费软件。 

560
00:25:15,920 --> 00:25:17,610
在结构中，这是一个混合体。 

561
00:25:17,610 --> 00:25:21,730
有时，我们使用CardView的方式使用免费的init， 

562
00:25:21,730 --> 00:25:23,710
有时，我们创建自己的init。 

563
00:25:25,460 --> 00:25:27,150
在值类型编程中， 

564
00:25:27,150 --> 00:25:30,320
我们正在围绕可变性复制这些东西

565
00:25:30,320 --> 00:25:35,320
否则必须使用结构明确声明可更改性。 

566
00:25:35,910 --> 00:25:38,700
如果您有一个结构并且想要，例如它是一个数组， 

567
00:25:38,700 --> 00:25:40,143
而且您想向其中添加项目， 

568
00:25:40,143 --> 00:25:42,400
就像它想成为一个可变数组， 

569
00:25:42,400 --> 00:25:45,080
那么你必须明确地说

570
00:25:45,080 --> 00:25:46,130
那就是你要做的

571
00:25:46,130 --> 00:25:49,890
然后使用var vs let做到这一点。 

572
00:25:49,890 --> 00:25:52,270
记得我说过结构和类

573
00:25:52,270 --> 00:25:54,600
都有这个东西让哪个恒定吗？ 

574
00:25:54,600 --> 00:25:57,950
好吧，如果您说让变量等于结构， 

575
00:25:57,950 --> 00:26:00,920
那么你就不能变异它，你不能， 

576
00:26:00,920 --> 00:26:03,450
如果是数组，则无法向其中添加项目

577
00:26:03,450 --> 00:26:07,940
但是，如果您说var等于结构，那么就可以了。 

578
00:26:07,940 --> 00:26:10,240
而类总是可变的。 

579
00:26:10,240 --> 00:26:12,470
它们生活在堆中，您有一个指向它们的指针， 

580
00:26:12,470 --> 00:26:14,410
你总是可以通过那个指针

581
00:26:14,410 --> 00:26:16,570
并修改堆中的内容，好吗？ 

582
00:26:16,570 --> 00:26:20,750
课堂上无法控制可变性， 

583
00:26:20,750 --> 00:26:23,620
确实更大

584
00:26:23,620 --> 00:26:24,847
当涉及到构建代码时， 

585
00:26:24,847 --> 00:26:29,250
您了解它实际上在做什么吗？ 

586
00:26:29,250 --> 00:26:31,040
这是班级的大问题， 

587
00:26:31,040 --> 00:26:32,890
任何有上课指导的人

588
00:26:32,890 --> 00:26:34,250
可以改变它。 

589
00:26:34,250 --> 00:26:36,151
就像西部狂野一样

590
00:26:36,151 --> 00:26:38,660
真的很难理解发生了什么。 

591
00:26:38,660 --> 00:26:40,810
因此，要明确这种可变性， 

592
00:26:40,810 --> 00:26:42,160
这是非常好的功能

593
00:26:42,160 --> 00:26:44,820
在函数式编程和结构中。 

594
00:26:44,820 --> 00:26:47,600
现在，结构是您的首选数据结构。 

595
00:26:47,600 --> 00:26:50,912
您几乎将第一次使用struct。 

596
00:26:50,912 --> 00:26:52,889
你只会上课

597
00:26:52,889 --> 00:26:55,600
在某些特定情况下。 

598
00:26:55,600 --> 00:26:58,860
我们今天会看到其中一种情况， 

599
00:26:58,860 --> 00:27:01,190
这是您的ViewModel。 

600
00:27:01,190 --> 00:27:05,040
MVVM中的ViewModel始终是一个类。 

601
00:27:05,040 --> 00:27:07,450
也是执行iOS编程的旧方法， 

602
00:27:07,450 --> 00:27:08,770
那都是基于阶级的， 

603
00:27:08,770 --> 00:27:12,180
那都是面向对象的，而不是函数式编程。 

604
00:27:12,180 --> 00:27:15,100
为什么MVVM中的ViewModel是类？ 

605
00:27:15,100 --> 00:27:17,680
顺便说一句，我将在演示中对此进行讨论

606
00:27:17,680 --> 00:27:19,530
但这与事实有关

607
00:27:19,530 --> 00:27:21,820
一个ViewModel需要共享

608
00:27:21,820 --> 00:27:24,780
也许有很多不同的观点。 

609
00:27:24,780 --> 00:27:27,550
ViewModel是模型的门户。 

610
00:27:27,550 --> 00:27:29,260
许多不同的观点可能想要

611
00:27:29,260 --> 00:27:33,530
在那个模型上，他们想共享那个门户。 

612
00:27:33,530 --> 00:27:35,000
课程非常适合分享

613
00:27:35,000 --> 00:27:37,110
因为我们都有指向他们的指针。 

614
00:27:37,110 --> 00:27:38,560
分享有一个缺点， 

615
00:27:38,560 --> 00:27:40,990
我们尝试缓解MVVM中的问题， 

616
00:27:40,990 --> 00:27:43,080
我还将在演示中向您展示

617
00:27:43,080 --> 00:27:44,650
但这是一个类的例子。 

618
00:27:44,650 --> 00:27:47,380
您所看到的几乎所有其他内容，都是结构。 

619
00:27:47,380 --> 00:27:49,570
您显然已经看到了所有这些视图， 

620
00:27:49,570 --> 00:27:51,050
它们都是结构。 

621
00:27:51,050 --> 00:27:53,160
我说过，数组，整数，布尔，双打， 

622
00:27:53,160 --> 00:27:54,830
一切，都在范围内， 

623
00:27:54,830 --> 00:27:58,720
除了View以外，几乎所有东西都是结构。 

624
00:27:58,720 --> 00:28:02,720
视图实际上是另一种称为协议的类型。 

625
00:28:02,720 --> 00:28:05,980
视图不是结构或类，它是一个协议

626
00:28:05,980 --> 00:28:07,870
我们将讨论协议

627
00:28:07,870 --> 00:28:10,223
下周详细介绍。 

628
00:28:11,360 --> 00:28:15,540
好吧，我接下来要谈的是泛型。 

629
00:28:15,540 --> 00:28:18,350
我们可能要操纵一些数据结构

630
00:28:18,350 --> 00:28:21,170
我们有点不可知类型。 

631
00:28:21,170 --> 00:28:24,330
我们并不真正在乎类型，就像任何东西一样。 

632
00:28:24,330 --> 00:28:27,200
给我什么类型，除了Swift的问题

633
00:28:27,200 --> 00:28:30,250
这是一种非常强类型的语言， 

634
00:28:30,250 --> 00:28:33,450
每个变量，每个函数的每个参数， 

635
00:28:33,450 --> 00:28:36,080
一切都必须有一种类型。 

636
00:28:36,080 --> 00:28:38,490
没有这样的事情不是真的，很好， 

637
00:28:38,490 --> 00:28:41,080
为了向后兼容旧版UIKit， 

638
00:28:41,080 --> 00:28:43,180
这是一种没有类型的东西。 

639
00:28:43,180 --> 00:28:45,790
但是，确实，在Swift中，在SwiftUI中， 

640
00:28:45,790 --> 00:28:47,700
我们不使用无类型变量。 

641
00:28:47,700 --> 00:28:50,370
变量都必须具有类型。 

642
00:28:50,370 --> 00:28:52,630
那么，我们如何指定这种类型

643
00:28:52,630 --> 00:28:54,880
当我们不在乎的情况下

644
00:28:54,880 --> 00:28:56,030
是什么类型的？ 

645
00:28:56,030 --> 00:28:59,160
因此，我们正在处理一些东西

646
00:28:59,160 --> 00:29:02,010
但是我们真的不在乎它的类型，好吗？ 

647
00:29:02,010 --> 00:29:03,370
那么，我们该怎么做呢？ 

648
00:29:03,370 --> 00:29:05,740
好吧，这是最好的例子。 

649
00:29:05,740 --> 00:29:09,080
世界上最好的例子之一就是数组。 

650
00:29:09,080 --> 00:29:13,000
数组包含很多东西，这就是数组

651
00:29:13,000 --> 00:29:15,910
但并不关心这些东西是什么类型。 

652
00:29:15,910 --> 00:29:18,480
不过，在Array的代码内部，必须存储这些内容， 

653
00:29:18,480 --> 00:29:21,983
它里面必须有一些var或其他东西。 

654
00:29:21,983 --> 00:29:25,270
他们将事物存储在其中。 

655
00:29:25,270 --> 00:29:28,140
那么我们如何解决这个难题

656
00:29:28,140 --> 00:29:30,560
需要在哪里存储东西的数组

657
00:29:30,560 --> 00:29:31,860
但实际上它根本不在乎

658
00:29:31,860 --> 00:29:33,820
无论是整数数组，字符串数组， 

659
00:29:33,820 --> 00:29:37,060
另一个数组的数组，数组的数组，无论如何， 

660
00:29:37,060 --> 00:29:38,740
数组不在乎。 

661
00:29:38,740 --> 00:29:42,110
另外，Array上具有函数和var。 

662
00:29:42,110 --> 00:29:44,500
他们会让您做诸如添加到数组之类的事情

663
00:29:44,500 --> 00:29:46,134
或获取数组的值。 

664
00:29:46,134 --> 00:29:48,930
那些人将如何声明其返回类型

665
00:29:48,930 --> 00:29:50,630
及其参数类型？ 

666
00:29:50,630 --> 00:29:53,580
好吧，答案是您使用泛型执行此操作。 

667
00:29:53,580 --> 00:29:56,940
现在，以其他语言（例如Java）为例， 

668
00:29:56,940 --> 00:29:58,080
也有泛型。 

669
00:29:58,080 --> 00:30:00,280
对于你们中的一些人来说，只是一点点评论

670
00:30:00,280 --> 00:30:02,810
但是我们将采用这些泛型

671
00:30:02,810 --> 00:30:05,600
下周我们将它们结合起来

672
00:30:05,600 --> 00:30:08,760
以及Swift中的其他一些类型功能。 

673
00:30:08,760 --> 00:30:12,020
因此，让我们谈谈泛型如何与Array一起使用。 

674
00:30:12,020 --> 00:30:13,510
数组的声明

675
00:30:13,510 --> 00:30:15,760
大概是这样的。 

676
00:30:15,760 --> 00:30:19,460
结构数组，尖括号，元素

677
00:30:19,460 --> 00:30:23,350
然后，例如，函数append接受一个参数

678
00:30:23,350 --> 00:30:25,910
属于元素类型。 

679
00:30:25,910 --> 00:30:28,600
这个元素类型是什么？ 

680
00:30:28,600 --> 00:30:32,320
这就是我所谓的“不关心”类型。 

681
00:30:32,320 --> 00:30:36,010
这是Array组成的名称， 

682
00:30:36,010 --> 00:30:38,860
这意味着我不在乎这种类型。 

683
00:30:38,860 --> 00:30:40,140
所以这是一种无关紧要的类型

684
00:30:40,140 --> 00:30:41,120
和数组不在乎。 

685
00:30:41,120 --> 00:30:43,880
可以是整数数组，字符串数组等。 

686
00:30:43,880 --> 00:30:46,660
这实质上是Swift中的另一种类型

687
00:30:46,660 --> 00:30:50,430
叫我无论如何都要打电话，我不在乎打字。 

688
00:30:50,430 --> 00:30:53,530
因此，现在，Array的关于追加的实现

689
00:30:53,530 --> 00:30:56,310
对元素的类型一无所知。 

690
00:30:56,310 --> 00:30:58,520
它不会向发送任何消息

691
00:30:58,520 --> 00:30:59,673
或访问元素上的任何var， 

692
00:30:59,673 --> 00:31:02,550
它只是将其存储在vars之类的东西中。 

693
00:31:02,550 --> 00:31:04,730
所以Element有点像占位符

694
00:31:04,730 --> 00:31:06,400
无论是哪种类型。 

695
00:31:06,400 --> 00:31:10,090
该类型何时真正设置为实型， 

696
00:31:10,090 --> 00:31:11,150
不是占位符？ 

697
00:31:11,150 --> 00:31:13,360
好吧，那是人们使用数组的时候。 

698
00:31:13,360 --> 00:31:17,900
所以如果我声明一个数组，我可以说var a equals Array 

699
00:31:17,900 --> 00:31:19,910
现在，我放入尖括号

700
00:31:19,910 --> 00:31:22,690
Element的实际类型。 

701
00:31:22,690 --> 00:31:24,790
所以这是一个整数数组。 

702
00:31:24,790 --> 00:31:26,970
现在，几乎就像有人一样

703
00:31:26,970 --> 00:31:29,820
搜索并替换所有Array代码

704
00:31:29,820 --> 00:31:32,620
他们在那里搜索并用Int替换了Element。 

705
00:31:32,620 --> 00:31:36,460
因此，函数append现在将Int作为参数。 

706
00:31:36,460 --> 00:31:39,990
这就是为什么我可以说a.append（5）并能正常工作的原因

707
00:31:39,990 --> 00:31:41,440
因为五是整数

708
00:31:41,440 --> 00:31:44,403
并且append现在将一个Int作为参数。 

709
00:31:45,290 --> 00:31:47,320
所以，这是数组的使用

710
00:31:47,320 --> 00:31:49,760
确定Element的实际类型后， 

711
00:31:49,760 --> 00:31:52,090
在编写Array中的代码时， 

712
00:31:52,090 --> 00:31:53,160
都是无关紧要的。 

713
00:31:53,160 --> 00:31:56,870
它只是使用Element类型，这是无关紧要的。 

714
00:31:56,870 --> 00:31:59,140
请注意，当您使用“无关”字样时， 

715
00:31:59,140 --> 00:32:01,620
你必须让世界知道

716
00:32:01,620 --> 00:32:03,000
因为他们必须告诉你

717
00:32:03,000 --> 00:32:05,080
他们使用时实际上是什么

718
00:32:05,080 --> 00:32:07,700
那就是尖括号元素

719
00:32:07,700 --> 00:32:09,580
最重要的是

720
00:32:09,580 --> 00:32:12,096
并且有多个无关紧要是完全合法的。 

721
00:32:12,096 --> 00:32:15,748
结构数组，尖括号元素，逗号，Foo，逗号， 

722
00:32:15,748 --> 00:32:18,890
所以你可能有很多不在乎的人

723
00:32:18,890 --> 00:32:21,650
然后使用它的人必须指定

724
00:32:21,650 --> 00:32:23,433
所有这些类型是什么。 

725
00:32:24,940 --> 00:32:27,690
好吧，我称这些为无关类型

726
00:32:27,690 --> 00:32:29,310
无关类型的元素。 

727
00:32:29,310 --> 00:32:31,843
这些的真实名称是type参数。 

728
00:32:33,750 --> 00:32:36,710
我想谈的最后一种类型是函数。 

729
00:32:36,710 --> 00:32:39,120
因此，功能也是人。 

730
00:32:39,120 --> 00:32:42,450
函数可以作为一种类型

731
00:32:42,450 --> 00:32:47,020
它的语法非常简单明了。 

732
00:32:47,020 --> 00:32:51,070
这是一些类型函数的示例。 

733
00:32:51,070 --> 00:32:54,940
这是黄色，这是您看到的黄色的东西。 

734
00:32:54,940 --> 00:32:59,940
试想一下，黄色部分是整数还是字符串，对不对？ 

735
00:33:00,000 --> 00:33:02,040
还是整数数组，好吗？ 

736
00:33:02,040 --> 00:33:04,070
确实，它也是一种类型

737
00:33:04,070 --> 00:33:05,320
像那些东西一样。 

738
00:33:05,320 --> 00:33:09,320
因此，此类型的函数需要两个Int 

739
00:33:09,320 --> 00:33:11,030
并返回一个布尔。 

740
00:33:11,030 --> 00:33:12,240
那就是那种类型。 

741
00:33:12,240 --> 00:33:15,390
因此，您可以为该函数指定参数。 

742
00:33:15,390 --> 00:33:18,290
这是一项需要Double 

743
00:33:18,290 --> 00:33:20,230
却一无所获

744
00:33:20,230 --> 00:33:23,350
这是一项不需要任何功能的功能

745
00:33:23,350 --> 00:33:25,350
并返回一个字符串数组。 

746
00:33:25,350 --> 00:33:28,290
这是一个不带参数的函数

747
00:33:28,290 --> 00:33:30,400
却一无所获

748
00:33:30,400 --> 00:33:31,460
这些都是类型， 

749
00:33:31,460 --> 00:33:34,010
每个黄色的东西，只是一种。 

750
00:33:34,010 --> 00:33:37,300
没什么特别的，真的。 

751
00:33:37,300 --> 00:33:40,160
这意味着我可以声明这些类型之一的变量。 

752
00:33:40,160 --> 00:33:42,250
假设我有一个变量foo， 

753
00:33:42,250 --> 00:33:45,400
它的类型可能是需要Double的函数

754
00:33:45,400 --> 00:33:47,010
却一无所获

755
00:33:47,010 --> 00:33:48,420
或者我可以有一个功能。 

756
00:33:48,420 --> 00:33:52,310
做一个有争议的事情，做什么

757
00:33:52,310 --> 00:33:55,510
它的类型是一个不带参数的函数

758
00:33:55,510 --> 00:33:58,920
然后返回一个布尔，大概是在做某件事

759
00:33:58,920 --> 00:34:01,580
它想做什么。 

760
00:34:01,580 --> 00:34:05,130
因此，让我们看看我们如何使用类型函数

761
00:34:05,130 --> 00:34:07,830
所以我要在这里有一个叫做操作的变量

762
00:34:07,830 --> 00:34:10,730
类型函数的类型，它需要一个Double并返回一个Double。 

763
00:34:11,710 --> 00:34:15,180
我将创建一个函数

764
00:34:15,180 --> 00:34:16,780
需要Double并返回Double。 

765
00:34:16,780 --> 00:34:20,630
所以我有这个函数的平方，取一个操作数Double 

766
00:34:20,630 --> 00:34:22,750
并返回一个Double，将其平方， 

767
00:34:22,750 --> 00:34:24,980
操作数乘以操作数。 

768
00:34:24,980 --> 00:34:27,400
现在，既然如此，我可以说

769
00:34:27,400 --> 00:34:29,670
运算等于平方，对不对？ 

770
00:34:29,670 --> 00:34:32,397
需要Double的类型函数的操作

771
00:34:32,397 --> 00:34:34,250
并返回一个Double equals square。 

772
00:34:34,250 --> 00:34:36,790
Square是接受Double并返回Double的函数。 

773
00:34:36,790 --> 00:34:39,210
这是完全合法的，然后我可以

774
00:34:39,210 --> 00:34:42,100
现在我有了操作，我可以说

775
00:34:42,100 --> 00:34:46,260
让result1等于四个的相等运算。 

776
00:34:46,260 --> 00:34:50,900
所以result1将为16，因为那是平方的结果。 

777
00:34:50,900 --> 00:34:52,980
请注意，当我调用操作时， 

778
00:34:52,980 --> 00:34:56,030
我没有说操作数： 

779
00:34:56,030 --> 00:34:58,870
小var东西掉了，好吗？ 

780
00:34:58,870 --> 00:35:01,190
当你通过某件事时，那是一回事

781
00:35:01,190 --> 00:35:06,190
通过函数类型会丢失它的小标签。 

782
00:35:06,640 --> 00:35:08,070
但我也可以说

783
00:35:08,070 --> 00:35:09,660
运算等于平方根

784
00:35:09,660 --> 00:35:13,190
所以sqrt是Swift中的内置函数

785
00:35:13,190 --> 00:35:15,390
它扎根了一个东西， 

786
00:35:15,390 --> 00:35:17,240
但这只是一个需要Double的函数

787
00:35:17,240 --> 00:35:18,480
并返回一个Double。 

788
00:35:18,480 --> 00:35:20,430
所以我可以说运算等于平方根。 

789
00:35:20,430 --> 00:35:23,563
现在，如果我说让result2等于4的运算

790
00:35:23,563 --> 00:35:24,873
result2将是两个

791
00:35:24,873 --> 00:35:27,450
因为我改变了操作的价值。 

792
00:35:27,450 --> 00:35:29,140
曾经是一个功能广场

793
00:35:29,140 --> 00:35:32,110
我将其更改为函数平方根。 

794
00:35:32,110 --> 00:35:32,970
就这么简单。 

795
00:35:32,970 --> 00:35:36,200
我的意思是，似乎太简单了，难以置信

796
00:35:36,200 --> 00:35:38,280
但是它就是这样啊。 

797
00:35:38,280 --> 00:35:40,900
在演示中，我要做

798
00:35:40,900 --> 00:35:42,970
在几秒钟内， 

799
00:35:42,970 --> 00:35:44,658
我们将创建自己的小功能

800
00:35:44,658 --> 00:35:47,270
需要一个函数作为参数。 

801
00:35:47,270 --> 00:35:49,340
您将听到短语闭包

802
00:35:49,340 --> 00:35:51,410
我将谈论更多关于闭包的内容

803
00:35:51,410 --> 00:35:53,313
大概是下周或下周。 

804
00:35:54,200 --> 00:35:57,430
闭包本质上是内联函数， 

805
00:35:57,430 --> 00:36:00,487
接受要传递给另一个功能的功能

806
00:36:00,487 --> 00:36:03,250
作为参数，您正在衬砌它

807
00:36:03,250 --> 00:36:06,440
而不是在某个地方单独声明它。 

808
00:36:06,440 --> 00:36:08,450
不仅仅是内联它

809
00:36:08,450 --> 00:36:09,960
因为它做得很好

810
00:36:09,960 --> 00:36:12,115
捕获局部变量和事物。 

811
00:36:12,115 --> 00:36:14,240
所以，这就是我下周要谈的

812
00:36:14,240 --> 00:36:16,100
但我要告诉你语法

813
00:36:16,100 --> 00:36:19,783
内联函数的外观类似于演示中的

814
00:36:19,783 --> 00:36:20,913
我们要做的。 

815
00:36:21,810 --> 00:36:25,580
实际上，这就是我们今天的幻灯片的结尾。 

816
00:36:25,580 --> 00:36:27,660
这就是我们所说的

817
00:36:27,660 --> 00:36:31,140
所以现在，我们将回到演示

818
00:36:31,140 --> 00:36:34,890
我们将尝试谈论所有事情

819
00:36:34,890 --> 00:36:37,990
我在演示幻灯片中介绍的内容。 

820
00:36:37,990 --> 00:36:40,490
请记住，您将必须复制此演示

821
00:36:40,490 --> 00:36:43,700
第一次的家庭作业，在那里

822
00:36:43,700 --> 00:36:45,410
这些讲课出来了

823
00:36:45,410 --> 00:36:48,283
因此请确保您检查了广场。 

824
00:36:49,820 --> 00:36:53,160
让我们在这里将“记忆”应用程序提升到一个新的水平

825
00:36:53,160 --> 00:36:58,160
通过使用这种MVVM架构让它更加聪明， 

826
00:36:58,510 --> 00:37:02,003
一些逻辑和一些数据就是卡片。 

827
00:37:02,003 --> 00:37:03,510
我们该怎么做？ 

828
00:37:03,510 --> 00:37:05,350
好吧，到目前为止我们一直在努力， 

829
00:37:05,350 --> 00:37:08,690
您在“视图”屏幕上的此处看到的所有这些代码。 

830
00:37:08,690 --> 00:37:13,580
因此，在MVVM中，我们一直在研究第一个V 

831
00:37:13,580 --> 00:37:16,510
我们接下来要研究的是模型，好吗？ 

832
00:37:16,510 --> 00:37:19,260
再一次，模型是独立于UI的， 

833
00:37:19,260 --> 00:37:21,260
对游戏如何一无所知

834
00:37:21,260 --> 00:37:23,130
将要显示。 

835
00:37:23,130 --> 00:37:26,820
每当我们要向Xcode添加新的Swift文件时， 

836
00:37:26,820 --> 00:37:30,763
我们可以通过“新建”，“文件”下的“文件”菜单来执行此操作。 

837
00:37:31,770 --> 00:37:34,470
您可以创建许多不同类型的文件

838
00:37:34,470 --> 00:37:37,350
但实际上，归结为这两个。 

839
00:37:37,350 --> 00:37:40,890
这样会为您创建一个新的SwiftUI视图，对吗？ 

840
00:37:40,890 --> 00:37:43,720
可以说构造任何冒号的东西

841
00:37:43,720 --> 00:37:47,960
使用var body，所有这些和这创建了一个非UI， 

842
00:37:47,960 --> 00:37:50,480
只是空白的Swift文件，这就是我们想要的

843
00:37:50,480 --> 00:37:54,620
因为我们的模型不是UI结构。 

844
00:37:54,620 --> 00:37:56,360
因此，我们双击它。 

845
00:37:56,360 --> 00:37:58,500
现在，它在问您要在哪里存储它

846
00:37:58,500 --> 00:38:00,000
以及您想要的名称。 

847
00:38:00,000 --> 00:38:02,600
好吧，这将成为我们记忆游戏的核心

848
00:38:02,600 --> 00:38:05,440
所以我实际上将这个文件称为MemoryGame 

849
00:38:05,440 --> 00:38:08,230
因为我要在其中创建的结构

850
00:38:08,230 --> 00:38:11,210
主要结构是MemoryGame结构

851
00:38:11,210 --> 00:38:12,910
播放MemoryGame。 

852
00:38:12,910 --> 00:38:15,190
所以，这里还有另外一件事

853
00:38:15,190 --> 00:38:16,850
你想放在哪里？ 

854
00:38:16,850 --> 00:38:20,810
这个黄色和这里的黄色一样

855
00:38:20,810 --> 00:38:25,120
同样，蓝色与这里的蓝色相同。 

856
00:38:25,120 --> 00:38:28,690
我们真的从来不想把事情放在这里。 

857
00:38:28,690 --> 00:38:30,650
我们想把它们放在这些文件夹中， 

858
00:38:30,650 --> 00:38:32,590
好的，这些黄色文件夹。 

859
00:38:32,590 --> 00:38:34,840
另外，无论您在这里选择哪个组， 

860
00:38:34,840 --> 00:38:36,570
你想确保它在同一个地方

861
00:38:36,570 --> 00:38:39,440
在文件系统中就像内容视图一样。 

862
00:38:39,440 --> 00:38:41,230
您在此处看到内容查看， 

863
00:38:41,230 --> 00:38:45,370
我们要确保这是在此处选择的内容。 

864
00:38:45,370 --> 00:38:47,280
因此，让我们创建它。 

865
00:38:47,280 --> 00:38:48,251
在这里，对吗？ 

866
00:38:48,251 --> 00:38:49,084
记忆游戏。 

867
00:38:49,084 --> 00:38:50,900
请注意，它不会导入SwiftUI 

868
00:38:50,900 --> 00:38:53,780
因为这不是UI问题。 

869
00:38:53,780 --> 00:38:56,170
基金会在这里，这是我上次谈论的话题。 

870
00:38:56,170 --> 00:38:59,580
它具有数组和字典以及字符串和整数和布尔值

871
00:38:59,580 --> 00:39:00,680
和所有基本类型

872
00:39:00,680 --> 00:39:02,900
但现在，它没有查看或文本

873
00:39:02,900 --> 00:39:06,710
或RoundedRectangle或任何此类UI内容。 

874
00:39:06,710 --> 00:39:08,010
所以我们要在这里创建一个结构。 

875
00:39:08,010 --> 00:39:10,720
请记住，结构是我们的首选数据结构

876
00:39:10,720 --> 00:39:12,427
我将其命名为MemoryGame 

877
00:39:13,510 --> 00:39:15,430
而且不会有冒号View 

878
00:39:15,430 --> 00:39:17,250
因为它的行为不会像View， 

879
00:39:17,250 --> 00:39:20,490
这是非UI的事情。 

880
00:39:20,490 --> 00:39:24,080
当我创建一个可以代表我的模型的结构时， 

881
00:39:24,080 --> 00:39:26,630
顺便说一句，我的模型可能不是这样的结构， 

882
00:39:26,630 --> 00:39:30,580
它可能是SQL数据库或某些网络设备

883
00:39:30,580 --> 00:39:32,640
我从中获取信息

884
00:39:32,640 --> 00:39:34,377
但是很多时候，有一个结构

885
00:39:34,377 --> 00:39:37,760
至少包裹了很多东西。 

886
00:39:37,760 --> 00:39:39,110
它也可以是一类。 

887
00:39:39,110 --> 00:39:41,350
在某些情况下可能

888
00:39:41,350 --> 00:39:44,000
具有属于类的模型

889
00:39:44,000 --> 00:39:46,250
但您不会将结构作为我们的首选

890
00:39:46,250 --> 00:39:47,800
所以我们一定要开始

891
00:39:47,800 --> 00:39:49,703
与我们这里的数据结构。 

892
00:39:51,000 --> 00:39:54,600
现在，当我创建模型时，我总是问自己

893
00:39:54,600 --> 00:39:56,350
这个模型做什么？ 

894
00:39:56,350 --> 00:39:59,630
让我看看是否可以使用var和函数

895
00:39:59,630 --> 00:40:04,000
可以真正描述这件事的作用。 

896
00:40:04,000 --> 00:40:05,590
因此，当我想到MemoryGame时， 

897
00:40:05,590 --> 00:40:07,480
匹配卡片的MemoryGame， 

898
00:40:07,480 --> 00:40:09,720
我正在考虑的最重要的事情

899
00:40:09,720 --> 00:40:11,290
要有一些卡。 

900
00:40:11,290 --> 00:40:15,410
所以我必须要有一些var，就是卡片

901
00:40:15,410 --> 00:40:17,240
当然，我们所有人都需要一种

902
00:40:17,240 --> 00:40:20,200
所以我们用冒号做类型

903
00:40:20,200 --> 00:40:23,820
而且我认为我的牌将成为一个数组。 

904
00:40:23,820 --> 00:40:26,300
Array是一个通用类型， 

905
00:40:26,300 --> 00:40:29,440
这意味着它具有此无关类型， 

906
00:40:29,440 --> 00:40:31,410
在数组的情况下

907
00:40:31,410 --> 00:40:35,330
是数组中包含的事物的类型。 

908
00:40:35,330 --> 00:40:38,960
所以，我需要一些类型，一些实类型

909
00:40:38,960 --> 00:40:40,010
在这个数组中。 

910
00:40:40,010 --> 00:40:43,750
所以要补一张，我在这里称它为Card 

911
00:40:43,750 --> 00:40:46,100
我要下去说struct Card 

912
00:40:46,100 --> 00:40:49,060
是某种结构，这个结构

913
00:40:49,060 --> 00:40:52,230
将不得不代表一张卡。 

914
00:40:52,230 --> 00:40:56,860
请注意，我将此结构卡放在此结构内。 

915
00:40:56,860 --> 00:40:58,750
所以这个的全名

916
00:40:58,750 --> 00:41:01,990
实际上是MemoryGame.Card。 

917
00:41:01,990 --> 00:41:05,960
在结构内部嵌套结构，主要是命名， 

918
00:41:05,960 --> 00:41:08,250
一个名称间隔的东西，以便我们知道

919
00:41:08,250 --> 00:41:09,810
那不是纸牌

920
00:41:09,810 --> 00:41:11,420
或其他某种随机卡， 

921
00:41:11,420 --> 00:41:14,243
这是MemoryGames卡，所以我们将其放在这里

922
00:41:14,243 --> 00:41:16,210
并有其他一些小好处

923
00:41:16,210 --> 00:41:19,370
一路上会看到。 

924
00:41:19,370 --> 00:41:21,410
现在，MemoryGame还需要什么

925
00:41:21,410 --> 00:41:23,410
一堆纸牌旁边？ 

926
00:41:23,410 --> 00:41:25,270
它需要一种选择卡的方法。 

927
00:41:25,270 --> 00:41:27,930
所以您将在这里看到您的第一个定义

928
00:41:27,930 --> 00:41:31,650
Swift函数，您可以使用关键字func来实现， 

929
00:41:31,650 --> 00:41:34,420
当然，接下来是函数的名称

930
00:41:34,420 --> 00:41:38,650
我会称其为“选择”，然后再加上任何参数， 

931
00:41:38,650 --> 00:41:41,500
在这种情况下，您将选择一张卡， 

932
00:41:41,500 --> 00:41:45,270
所以我要把这个论点放在卡片上

933
00:41:45,270 --> 00:41:47,800
现在，按照承诺， 

934
00:41:47,800 --> 00:41:52,350
几乎所有函数的所有参数都带有标签

935
00:41:52,350 --> 00:41:56,040
这样一来，当呼叫者打电话选择时， 

936
00:41:56,040 --> 00:41:57,810
很明显，他们在打电话选择

937
00:41:57,810 --> 00:42:01,823
用一张卡片，那是那里的论点。 

938
00:42:03,130 --> 00:42:07,510
现在，在这里，我们将不得不实际分叉

939
00:42:07,510 --> 00:42:10,505
并为我们的游戏匹配卡做所有逻辑。 

940
00:42:10,505 --> 00:42:13,000
现在，我实际上只是要做

941
00:42:13,000 --> 00:42:14,940
使用报表打印。 

942
00:42:14,940 --> 00:42:17,640
因此，打印是Swift中的一项强大功能

943
00:42:17,640 --> 00:42:20,260
并输出一个字符串。 

944
00:42:20,260 --> 00:42:22,870
所以我在这里打印一个空字符串。 

945
00:42:22,870 --> 00:42:26,780
但是我可以说选择卡片之类的话

946
00:42:26,780 --> 00:42:31,780
然后我想以某种方式将此卡片印在此印刷品中

947
00:42:31,870 --> 00:42:34,240
在这里和其他语言中

948
00:42:34,240 --> 00:42:38,370
你可能会做％s，然后把卡放到这里

949
00:42:38,370 --> 00:42:39,910
但是在Swift中，您不需要这样做。 

950
00:42:39,910 --> 00:42:42,020
当您想在字符串中嵌入一些东西时

951
00:42:42,020 --> 00:42:43,320
那是另一种类型

952
00:42:43,320 --> 00:42:45,030
你实际上反斜杠， 

953
00:42:45,030 --> 00:42:47,150
开括号，闭括号

954
00:42:47,150 --> 00:42:49,200
然后你可以把它放在这里

955
00:42:49,200 --> 00:42:51,150
而且只要可以转

956
00:42:51,150 --> 00:42:54,730
做某种字符串，那么这将工作

957
00:42:54,730 --> 00:42:56,660
而且Swift非常出色

958
00:42:56,660 --> 00:43:00,860
把几乎所有的东西变成一个字符串。 

959
00:43:00,860 --> 00:43:03,400
现在，这个结构在这里没有任何变量

960
00:43:03,400 --> 00:43:06,270
就在这里，所以它可能不会在那儿打印我的工作， 

961
00:43:06,270 --> 00:43:09,580
可能只说空的struct Card或类似的东西

962
00:43:09,580 --> 00:43:11,990
但我们显然要添加vars 

963
00:43:11,990 --> 00:43:13,880
然后当我们说选择卡片时， 

964
00:43:13,880 --> 00:43:17,390
它会打印出这些变量的值是什么

965
00:43:17,390 --> 00:43:19,230
只要所有这些变量都可以转换

966
00:43:19,230 --> 00:43:20,150
也变成字符串。 

967
00:43:20,150 --> 00:43:22,460
因此，这是一个超级强大的机制。 

968
00:43:22,460 --> 00:43:25,050
这个反斜杠，开括号，闭括号。 

969
00:43:25,050 --> 00:43:27,547
我鼓励您使用它，它非常适合调试。 

970
00:43:27,547 --> 00:43:31,170
您可以在事情发生时将其打印出来。 

971
00:43:31,170 --> 00:43:32,440
这很棒。 

972
00:43:32,440 --> 00:43:34,520
现在，这是一个非常简单的功能。 

973
00:43:34,520 --> 00:43:38,010
我们将在四分之一的时间内学习各种语法

974
00:43:38,010 --> 00:43:38,843
做功能。 

975
00:43:38,843 --> 00:43:41,280
例如，如果这返回一个值， 

976
00:43:41,280 --> 00:43:42,790
看起来像这样，好吗？ 

977
00:43:42,790 --> 00:43:44,540
这基本上是一个小箭头

978
00:43:44,540 --> 00:43:46,850
从这个函数出来的是一个字符串

979
00:43:46,850 --> 00:43:50,200
但是我们没有，如果这里有其他论点， 

980
00:43:50,200 --> 00:43:51,610
可能是其他论点， 

981
00:43:51,610 --> 00:43:53,070
可能是Int或类似的东西。 

982
00:43:53,070 --> 00:43:56,573
它可以具有任意数量的参数。 

983
00:43:58,670 --> 00:44:02,090
因此，基本上，这就是我们在此处的整个MemoryGame。 

984
00:44:02,090 --> 00:44:04,500
只需询问卡片，即可选择它们。 

985
00:44:04,500 --> 00:44:07,460
但是，我们将必须真的做出明确的决定

986
00:44:07,460 --> 00:44:10,970
卡片的外观，卡片的重要意义

987
00:44:10,970 --> 00:44:15,400
我们知道一张卡具有的一件事

988
00:44:15,400 --> 00:44:17,653
是要面朝上还是我要说

989
00:44:17,653 --> 00:44:19,236
var isFaceUp：布尔。 

990
00:44:20,290 --> 00:44:21,770
我想，我也需要知道

991
00:44:21,770 --> 00:44:24,123
卡是否匹配。 

992
00:44:25,060 --> 00:44:27,570
好的，所以也要有那个布尔。 

993
00:44:27,570 --> 00:44:31,000
卡上还有什么？ 

994
00:44:31,000 --> 00:44:34,830
好吧，我想其中有证卡的内容，好吗？ 

995
00:44:34,830 --> 00:44:36,810
所以，卡片上有什么。 

996
00:44:36,810 --> 00:44:38,500
现在，这是一个变量。 

997
00:44:38,500 --> 00:44:42,220
我称它为内容，问题是

998
00:44:42,220 --> 00:44:45,720
这个变数将是什么类型？ 

999
00:44:45,720 --> 00:44:48,370
现在，我可以想象制作纸牌游戏

1000
00:44:48,370 --> 00:44:50,360
上面有图像。 

1001
00:44:50,360 --> 00:44:53,160
显然，我们可以使用表情符号来制作纸牌游戏， 

1002
00:44:53,160 --> 00:44:54,490
那就是我们的。 

1003
00:44:54,490 --> 00:44:57,600
您可以构建一个带有文字的汽车游戏。 

1004
00:44:57,600 --> 00:45:00,040
也许这是一个带有数字的纸牌游戏。 

1005
00:45:00,040 --> 00:45:04,310
那么这是一个Int还是一个String 

1006
00:45:04,310 --> 00:45:07,305
还是某种图像？ 

1007
00:45:07,305 --> 00:45:12,305
几乎就像我们不在乎，好吗？ 

1008
00:45:12,480 --> 00:45:13,820
所以，如果我们是一个MemoryGame， 

1009
00:45:13,820 --> 00:45:15,940
您可以在卡上放任何东西。 

1010
00:45:15,940 --> 00:45:18,900
我们正在做独立于UI的游戏

1011
00:45:18,900 --> 00:45:22,540
因此我们并不在乎卡片上的内容。 

1012
00:45:22,540 --> 00:45:25,770
所以这不在乎，好吗？ 

1013
00:45:25,770 --> 00:45:26,790
这不在乎。 

1014
00:45:26,790 --> 00:45:29,760
因此，我将其称为CardContent。 

1015
00:45:29,760 --> 00:45:32,750
那是我刚刚写的，我不在乎的类型

1016
00:45:32,750 --> 00:45:35,050
当然，如果我做的是无关紧要的类型， 

1017
00:45:35,050 --> 00:45:38,830
我需要在这里说CardContent 

1018
00:45:40,100 --> 00:45:43,520
向世界宣告我是通用类型

1019
00:45:43,520 --> 00:45:46,220
我有这个不在乎你

1020
00:45:46,220 --> 00:45:48,650
如果您想使用MemoryGame， 

1021
00:45:48,650 --> 00:45:51,470
您将不得不告诉我这是什么。 

1022
00:45:51,470 --> 00:45:55,750
现在，在我们的游戏中，一旦我们开始使用此模型， 

1023
00:45:55,750 --> 00:45:59,340
我们要保存MemoryGame，尖括号字符串

1024
00:45:59,340 --> 00:46:02,010
因为表情符号只是字符串中的一个字符

1025
00:46:02,010 --> 00:46:04,250
所以我们要说尖括号字符串

1026
00:46:04,250 --> 00:46:07,210
这将定义这是哪种MemoryGame。 

1027
00:46:07,210 --> 00:46:09,850
但这是一个非常棒的简单示例

1028
00:46:09,850 --> 00:46:11,680
这无关的生意

1029
00:46:11,680 --> 00:46:15,040
因为真的，这个MemoryGame不在乎

1030
00:46:15,040 --> 00:46:16,503
这些卡上有什么。 

1031
00:46:18,300 --> 00:46:20,690
好吧，现在我们有了模型

1032
00:46:20,690 --> 00:46:22,490
我们的观点就在这里， 

1033
00:46:22,490 --> 00:46:27,300
我们来做第三部分MVVM，即ViewModel。 

1034
00:46:27,300 --> 00:46:30,370
因此，ViewModel将成为粘合剂

1035
00:46:30,370 --> 00:46:34,400
完全独立于UI的东西

1036
00:46:34,400 --> 00:46:37,053
完全依赖UI的东西。 

1037
00:46:38,120 --> 00:46:40,210
因此，让我们再次通过File（文件），New（新建）进行操作， 

1038
00:46:40,210 --> 00:46:43,584
我们将在这里创建一个新东西，一个新文件。 

1039
00:46:43,584 --> 00:46:46,560
好的，这不是SwiftUI视图，而是UI内容

1040
00:46:46,560 --> 00:46:49,350
但这不是实际的View，而是ViewModel。 

1041
00:46:49,350 --> 00:46:51,170
因此，我们将使用Swift File。 

1042
00:46:51,170 --> 00:46:54,380
我要在这里打电话给我的ViewModel， 

1043
00:46:54,380 --> 00:46:56,333
我将其命名为EmojiMemoryGame 

1044
00:46:57,395 --> 00:46:58,228
因为它是一种特殊的MemoryGame 

1045
00:47:01,020 --> 00:47:04,820
碰巧使用表情符号绘制事物。 

1046
00:47:04,820 --> 00:47:08,040
而且我要确保它在正确的文件夹中， 

1047
00:47:08,040 --> 00:47:09,828
它和所有其他东西都在同一个地方。 

1048
00:47:09,828 --> 00:47:11,380
好的，太好了。 

1049
00:47:11,380 --> 00:47:13,660
就是EmojiMemoryGame。 

1050
00:47:13,660 --> 00:47:16,100
它是导入基础，但是在这里， 

1051
00:47:16,100 --> 00:47:19,600
如果需要，我实际上可以导入SwiftUI。 

1052
00:47:19,600 --> 00:47:23,030
我实际上不在这里做UI， 

1053
00:47:23,030 --> 00:47:26,988
我将在“视图”中完成所有UI。 

1054
00:47:26,988 --> 00:47:31,860
但是ViewModel本质上是一个UI东西

1055
00:47:31,860 --> 00:47:32,693
因为它知道如何在屏幕上绘制。 

1056
00:47:32,693 --> 00:47:35,343
实际上，这就是其人生目标

1057
00:47:39,090 --> 00:47:42,170
就是要使用此UI独立的Model MemoryGame 

1058
00:47:42,170 --> 00:47:45,750
并对其进行翻译，使其以某种方式显示。 

1059
00:47:45,750 --> 00:47:49,870
在这种情况下，作为EmojiMemoryGame。 

1060
00:47:49,870 --> 00:47:52,600
在这里介绍我们的ViewModel之前， 

1061
00:47:52,600 --> 00:47:55,140
让我们隐藏您可以执行的preView， 

1062
00:47:55,140 --> 00:47:56,340
顺便说一句，就在这里。 

1063
00:47:56,340 --> 00:47:58,440
您可以看到仅显示编辑器。 

1064
00:47:58,440 --> 00:47:59,450
好吧，把那藏起来。 

1065
00:47:59,450 --> 00:48:02,610
您始终可以使用Canvas将其带回。 

1066
00:48:02,610 --> 00:48:04,073
好的，然后再次隐藏它。 

1067
00:48:05,180 --> 00:48:07,860
因此，让我们在这里构建我们的ViewModel。 

1068
00:48:07,860 --> 00:48:10,030
现在，一件有趣的事马上就发生了

1069
00:48:10,030 --> 00:48:14,020
我要使我们的ViewModel成为一类。 

1070
00:48:14,020 --> 00:48:15,720
我将其称为EmojiMemoryGame。 

1071
00:48:17,740 --> 00:48:20,180
顺便说一句，它是一个类，面向对象， 

1072
00:48:20,180 --> 00:48:21,860
在这里可能会有一个超类

1073
00:48:21,860 --> 00:48:24,300
我们将指定这样的内容

1074
00:48:24,300 --> 00:48:28,380
但是我们的表情符号游戏没有超类，好吗？ 

1075
00:48:28,380 --> 00:48:31,790
我要在这里解释一下为什么这是一堂课

1076
00:48:31,790 --> 00:48:33,460
而不是结构。 

1077
00:48:33,460 --> 00:48:37,150
但是让我们考虑一下ViewModel是对的吗？ 

1078
00:48:37,150 --> 00:48:40,860
我们知道这实际上是视图之间的门户

1079
00:48:40,860 --> 00:48:42,360
还有我们的模型，对吗？ 

1080
00:48:42,360 --> 00:48:46,670
这是等待视图进入模型的大门。 

1081
00:48:46,670 --> 00:48:50,020
所以可以肯定，我们的ViewModel需要什么

1082
00:48:50,020 --> 00:48:53,560
是某种可以通过其访问模型的变量。 

1083
00:48:53,560 --> 00:48:57,020
现在，我实际上在称这个var模型，对吧？ 

1084
00:48:57,020 --> 00:49:01,020
您可能不会调用任何var模型

1085
00:49:01,020 --> 00:49:03,090
因为那是一个概念

1086
00:49:03,090 --> 00:49:05,830
但我在这里仅出于指导目的而称呼它。 

1087
00:49:05,830 --> 00:49:09,250
您实际上可能会将此变量称为游戏， 

1088
00:49:09,250 --> 00:49:11,400
更能描述它的含义。 

1089
00:49:11,400 --> 00:49:13,190
这是一个MemoryGame，所以您可能会称之为游戏

1090
00:49:13,190 --> 00:49:15,077
或memoryGame之类的东西。 

1091
00:49:15,077 --> 00:49:16,360
但我将其称为模型

1092
00:49:16,360 --> 00:49:17,490
以便所有其余的代码， 

1093
00:49:17,490 --> 00:49:20,870
您将能够看到，哦，他正在那里访问模型。 

1094
00:49:20,870 --> 00:49:23,460
现在，我们的模型是什么类型？ 

1095
00:49:23,460 --> 00:49:26,010
嗯，这就是我们刚刚在这里建立的东西， 

1096
00:49:26,010 --> 00:49:29,630
这个struct MemoryGame，这个通用的MemoryGame 

1097
00:49:29,630 --> 00:49:32,070
拥有此CardContent的不在乎， 

1098
00:49:32,070 --> 00:49:34,960
这是Card和我们的表情符号游戏的内容， 

1099
00:49:34,960 --> 00:49:38,160
当然，卡片的内容是字符串，好吗？ 

1100
00:49:38,160 --> 00:49:39,500
表情符号是字符串。 

1101
00:49:39,500 --> 00:49:42,280
所以这种类型就是MemoryGame 

1102
00:49:42,280 --> 00:49:46,970
CardContent是字符串的地方，好吗？ 

1103
00:49:46,970 --> 00:49:49,470
就那么简单。 

1104
00:49:49,470 --> 00:49:54,350
现在，让我们更多地讨论为什么EmojiMemoryGame是一个类

1105
00:49:54,350 --> 00:49:57,350
甚至我可以作个比喻

1106
00:49:57,350 --> 00:50:00,470
在ViewModel和模型之间

1107
00:50:00,470 --> 00:50:03,710
这将有助于了解这些事物是如何相互作用的。 

1108
00:50:03,710 --> 00:50:08,410
现在，一堂课，可能是一堂课的最大优势

1109
00:50:08,410 --> 00:50:13,350
它很容易共享，因为一个类生活在堆中

1110
00:50:13,350 --> 00:50:14,560
并且有指向它的指针。 

1111
00:50:14,560 --> 00:50:17,970
这就是您在面向对象编程中所习惯的。 

1112
00:50:17,970 --> 00:50:20,210
好吧，因为它存在于堆中，所以可以有指针， 

1113
00:50:20,210 --> 00:50:23,430
我们所有的观点都可以指向它

1114
00:50:23,430 --> 00:50:26,240
当我们开始构建复杂的用户界面时， 

1115
00:50:26,240 --> 00:50:28,850
我们将有很多视图，其中许多视图

1116
00:50:28,850 --> 00:50:31,530
想通过这个门户网站浏览吗？ 

1117
00:50:31,530 --> 00:50:33,817
这就是几个模型，是模型的门户。 

1118
00:50:33,817 --> 00:50:35,950
您想在这里浏览

1119
00:50:35,950 --> 00:50:37,147
看看模型，好吗？ 

1120
00:50:37,147 --> 00:50:38,560
他们会想要分享的。 

1121
00:50:38,560 --> 00:50:42,490
因此，这是对课堂的真正运用

1122
00:50:42,490 --> 00:50:44,140
共享所有这些视图， 

1123
00:50:44,140 --> 00:50:45,950
他们每个人都有一个指向

1124
00:50:45,950 --> 00:50:49,030
这个，进入模型。 

1125
00:50:49,030 --> 00:50:53,020
但是，与许多事情一样，全班最大的优势

1126
00:50:53,020 --> 00:50:56,130
也是最大的弱点，好吗？ 

1127
00:50:56,130 --> 00:50:58,140
许多人的问题

1128
00:50:58,140 --> 00:51:02,260
在这里指向相同的ViewModel 

1129
00:51:02,260 --> 00:51:05,460
就是如果他们中的任何人搞砸了， 

1130
00:51:05,460 --> 00:51:07,880
它破坏了每个人的聚会。 

1131
00:51:07,880 --> 00:51:10,490
特别是在这种情况下。 

1132
00:51:10,490 --> 00:51:12,100
这是我的比喻。 

1133
00:51:12,100 --> 00:51:15,680
想象一下那里有一所房子，好吗？ 

1134
00:51:15,680 --> 00:51:19,120
在这所房子里是我们所有的意见，他们住在那里。 

1135
00:51:19,120 --> 00:51:22,920
这个ViewModel就在这里EmojiMemoryGame 

1136
00:51:22,920 --> 00:51:26,170
是前门，因为本质上， 

1137
00:51:26,170 --> 00:51:28,773
ViewModels是门口，它们是门户

1138
00:51:28,773 --> 00:51:30,860
使视图退出模型。 

1139
00:51:30,860 --> 00:51:33,530
因此，模型是外部世界，好吗？ 

1140
00:51:33,530 --> 00:51:35,700
屋子里的所有东西都是模型。 

1141
00:51:35,700 --> 00:51:37,350
所以我们所有的观点都将生活在房子里

1142
00:51:37,350 --> 00:51:39,140
想透过门口看

1143
00:51:39,140 --> 00:51:40,110
他们都在共享它，对不对？ 

1144
00:51:40,110 --> 00:51:40,943
他们都住在房子里

1145
00:51:40,943 --> 00:51:41,973
他们都在同一个门口看。 

1146
00:51:41,973 --> 00:51:43,950
他们都有指向同一个门口的指针。 

1147
00:51:43,950 --> 00:51:45,910
如果您想考虑一下，他们会挤在它周围

1148
00:51:45,910 --> 00:51:47,750
望出去，那是一件好事

1149
00:51:47,750 --> 00:51:50,420
因为他们都看到外面的世界

1150
00:51:50,420 --> 00:51:53,100
以完全相同的方式穿过同一扇门， 

1151
00:51:53,100 --> 00:51:55,810
因此，我们的用户界面始终会保持良好状态且自成一体。 

1152
00:51:55,810 --> 00:51:58,320
他们都看到同一件事。 

1153
00:51:58,320 --> 00:52:01,520
现在，我们的前门现在有一个大问题

1154
00:52:01,520 --> 00:52:03,530
它是敞开的，好吗？ 

1155
00:52:03,530 --> 00:52:04,860
我们的门是开着的。 

1156
00:52:04,860 --> 00:52:07,390
它有这个变量，模型， 

1157
00:52:07,390 --> 00:52:10,220
我们的任何观点都可以看

1158
00:52:10,220 --> 00:52:14,220
他们可以去那里，例如在那儿找到一张卡

1159
00:52:14,220 --> 00:52:17,580
他们可以将其设置为isMatched 

1160
00:52:17,580 --> 00:52:20,640
那真的会搞乱我们的游戏，好吗？ 

1161
00:52:20,640 --> 00:52:22,810
那为什么会弄乱我们的游戏呢？ 

1162
00:52:22,810 --> 00:52:24,980
好吧，也许我们的游戏会记录分数

1163
00:52:24,980 --> 00:52:26,760
当卡片匹配时， 

1164
00:52:26,760 --> 00:52:28,220
它给你点什么

1165
00:52:28,220 --> 00:52:29,727
如果你刚进入卡片

1166
00:52:29,727 --> 00:52:31,440
并设置isMatched 

1167
00:52:31,440 --> 00:52:34,060
现在，该卡将被标记为匹配

1168
00:52:34,060 --> 00:52:36,480
但您的分数从未改变，等等

1169
00:52:36,480 --> 00:52:39,770
从本质上讲，一个糟糕的流氓观点

1170
00:52:39,770 --> 00:52:43,250
破坏了所有其他视图的整个游戏

1171
00:52:43,250 --> 00:52:44,730
他们都在看同一件事。 

1172
00:52:44,730 --> 00:52:48,610
因此，您可以看到该模型的门户打开了

1173
00:52:48,610 --> 00:52:50,837
使得我们的ViewModel是一个类

1174
00:52:50,837 --> 00:52:54,420
而且这种共享有点危险。 

1175
00:52:54,420 --> 00:52:56,180
但是我们可以做一些事情

1176
00:52:56,180 --> 00:53:00,370
减轻那种令人担忧的影响

1177
00:53:00,370 --> 00:53:03,530
所有人共享同一堂课

1178
00:53:03,530 --> 00:53:05,500
但仍具有所有人共享的优势。 

1179
00:53:05,500 --> 00:53:08,270
一个是我们可以关上门，好吗？ 

1180
00:53:08,270 --> 00:53:12,730
所以这个变种如果我们用关键字private标记它

1181
00:53:12,730 --> 00:53:15,930
这意味着这个模型，这个变种

1182
00:53:15,930 --> 00:53:19,810
现在只能通过EmojiMemoryGame访问，好吗？ 

1183
00:53:19,810 --> 00:53:22,700
这是该课程的私有课程。 

1184
00:53:22,700 --> 00:53:26,500
现在，这解决了流氓View的问题

1185
00:53:26,500 --> 00:53:29,390
熄灭并设置isMatched in Card 

1186
00:53:29,390 --> 00:53:31,390
但这太好解决了

1187
00:53:31,390 --> 00:53:34,560
因为现在，没有任何一个视图可以望向外面，好吗？ 

1188
00:53:34,560 --> 00:53:36,570
所有视图都无法再看到模型。 

1189
00:53:36,570 --> 00:53:40,010
商店关门了，外面的世界

1190
00:53:40,010 --> 00:53:42,460
视图无法访问，好吗？ 

1191
00:53:42,460 --> 00:53:46,540
因此，那绝对是一个问题。 

1192
00:53:46,540 --> 00:53:50,180
那么，我们如何在其中找到中间立场？ 

1193
00:53:50,180 --> 00:53:51,630
好吧，我们可以做到的一种方法

1194
00:53:51,630 --> 00:53:53,670
是通过在这里使用一些不同的私人

1195
00:53:53,670 --> 00:53:56,120
称为私有集。 

1196
00:53:56,120 --> 00:53:58,010
因此，如果我们说私有集， 

1197
00:53:58,010 --> 00:54:00,900
基本上就像门是关闭的

1198
00:54:00,900 --> 00:54:03,980
但这是玻璃门，好吗？ 

1199
00:54:03,980 --> 00:54:07,180
因此私有集仅意味着EmojiMemoryGame 

1200
00:54:07,180 --> 00:54:10,610
可以修改模型，但其他所有人

1201
00:54:10,610 --> 00:54:12,300
仍然可以看到模型。 

1202
00:54:12,300 --> 00:54:14,720
这是玻璃门。 

1203
00:54:14,720 --> 00:54:17,810
现在，玻璃门可以很好地确保

1204
00:54:17,810 --> 00:54:19,690
胭脂视图不会进入那里

1205
00:54:19,690 --> 00:54:21,850
并更改要匹配的卡

1206
00:54:21,850 --> 00:54:23,440
并没有得到评分等等。 

1207
00:54:23,440 --> 00:54:25,850
它解决了这个问题，但是现在， 

1208
00:54:25,850 --> 00:54:27,600
没有人可以选择任何卡

1209
00:54:27,600 --> 00:54:29,040
因为我们无法通过， 

1210
00:54:29,040 --> 00:54:33,400
视图无法通过玻璃门选择卡片， 

1211
00:54:33,400 --> 00:54:34,880
例如，那是主要的事情之一

1212
00:54:34,880 --> 00:54:37,470
这些视图可能要执行的操作是点击卡片， 

1213
00:54:37,470 --> 00:54:38,687
你想选择它。 

1214
00:54:38,687 --> 00:54:41,580
这就是这些Intent进入的地方。 

1215
00:54:41,580 --> 00:54:45,018
记住，我们谈论过ViewModels， 

1216
00:54:45,018 --> 00:54:48,460
它的工作之一是解释用户意图

1217
00:54:48,460 --> 00:54:49,580
这就是刚刚发生的事情。 

1218
00:54:49,580 --> 00:54:51,560
我实际上要在这里发表一点评论。 

1219
00:54:51,560 --> 00:54:55,497
标记为Intent，好的或Intent。 

1220
00:54:55,497 --> 00:54:56,920
比方说意图

1221
00:54:56,920 --> 00:55:00,390
在这里，我将提供功能

1222
00:55:00,390 --> 00:55:04,400
允许这些视图访问外界。 

1223
00:55:04,400 --> 00:55:07,810
因此，以我们的类比，您可以想象有一个高科技门

1224
00:55:07,810 --> 00:55:10,800
像可视门铃对讲系统之类的东西

1225
00:55:10,800 --> 00:55:13,530
这些视图将按内部通话按钮

1226
00:55:13,530 --> 00:55:14,817
与外界交谈

1227
00:55:14,817 --> 00:55:17,347
说，请选择这张卡，好吗？ 

1228
00:55:17,347 --> 00:55:20,480
然后是门的ViewModel， 

1229
00:55:20,480 --> 00:55:23,730
显然可以直接与模型对话

1230
00:55:23,730 --> 00:55:26,180
并告诉它去做，这将会实现。 

1231
00:55:26,180 --> 00:55:29,190
所以这些用户意图是一回事

1232
00:55:29,190 --> 00:55:31,890
意见会说到对讲机，好吗？ 

1233
00:55:31,890 --> 00:55:34,800
他们想在游戏中发生的事情。 

1234
00:55:34,800 --> 00:55:37,680
因此，这里显而易见的一项功能是

1235
00:55:37,680 --> 00:55:40,240
叫选择卡，好吗？ 

1236
00:55:40,240 --> 00:55:42,730
就像我们在模型中一样。 

1237
00:55:42,730 --> 00:55:45,690
这是用户可能具有的意图

1238
00:55:45,690 --> 00:55:48,890
在这里选择一张卡和这张卡， 

1239
00:55:48,890 --> 00:55:50,820
我们必须确保它使用全名。 

1240
00:55:50,820 --> 00:55:55,740
这是一个MemoryGame <String> .Card， 

1241
00:55:55,740 --> 00:55:57,217
这是完整的类型

1242
00:55:57,217 --> 00:55:59,350
及其类型的所有部分。 

1243
00:55:59,350 --> 00:56:01,350
这真的很容易实现， 

1244
00:56:01,350 --> 00:56:05,060
我们只是要请模型选择该卡。 

1245
00:56:05,060 --> 00:56:07,760
好吧，幸运的是，我们的模型恰好具有

1246
00:56:07,760 --> 00:56:09,810
正是我们想要的功能。 

1247
00:56:09,810 --> 00:56:11,840
但请记住，我们的模型

1248
00:56:11,840 --> 00:56:13,667
再次，它可能是一个SQL数据库或其他

1249
00:56:13,667 --> 00:56:16,740
我们必须在这里发出一堆SQL命令

1250
00:56:16,740 --> 00:56:20,960
由用户做出这种意图

1251
00:56:20,960 --> 00:56:22,580
取得成果。 

1252
00:56:22,580 --> 00:56:26,390
当然，这是一个非常简单的第一个应用程序，演示应用程序， 

1253
00:56:26,390 --> 00:56:28,870
幸运的是，我们可以轻松表达

1254
00:56:28,870 --> 00:56:33,870
该用户在Card中的意图，好吗？ 

1255
00:56:33,980 --> 00:56:36,450
因此，这将起作用。 

1256
00:56:36,450 --> 00:56:38,470
很好，我们可以私人订座

1257
00:56:38,470 --> 00:56:42,020
所以我们可以看到卡片，我们可以看到模型的卡片

1258
00:56:42,020 --> 00:56:45,220
我们可以表达改变世界的意图。 

1259
00:56:45,220 --> 00:56:48,080
所以我们得到了这扇门，它是玻璃，我们可以看穿它， 

1260
00:56:48,080 --> 00:56:50,570
它保护我们免受外界侵害

1261
00:56:50,570 --> 00:56:53,500
但我们甚至可能希望更加严格。 

1262
00:56:53,500 --> 00:56:56,610
例如，我们可能真的希望关门

1263
00:56:56,610 --> 00:56:59,335
而不是透过玻璃门看

1264
00:56:59,335 --> 00:57:03,380
您将使用视频门铃的视频，好吗？ 

1265
00:57:03,380 --> 00:57:04,870
你知道视频门铃的工作原理

1266
00:57:04,870 --> 00:57:07,420
人们来到门口，你可以在那里看到他们

1267
00:57:07,420 --> 00:57:08,900
在一个小的视频屏幕上。 

1268
00:57:08,900 --> 00:57:12,080
因此，这里有点视频屏幕

1269
00:57:12,080 --> 00:57:14,900
是我们可以提供var和funcs 

1270
00:57:14,900 --> 00:57:19,860
让人们以狭窄的方式看待这个模型。 

1271
00:57:19,860 --> 00:57:22,324
现在，我们显然希望人们能够看到

1272
00:57:22,324 --> 00:57:23,790
模型中的卡片

1273
00:57:23,790 --> 00:57:27,000
所以也许我要创建自己的var卡，好吗？ 

1274
00:57:27,000 --> 00:57:31,923
哪个也是MemoryGame <String> .Card的数组，好吗？ 

1275
00:57:37,870 --> 00:57:41,730
而且这只是要退还我们的模特卡。 

1276
00:57:41,730 --> 00:57:43,270
同样，这里也是一样。 

1277
00:57:43,270 --> 00:57:46,070
我们有非常简单的模型，所以很容易做到

1278
00:57:46,070 --> 00:57:49,897
但是ViewModel可能在这里做了一些解释， 

1279
00:57:49,897 --> 00:57:53,170
尝试按摩模型的数据

1280
00:57:53,170 --> 00:57:57,670
转化为视图更易使用的某种形式

1281
00:57:57,670 --> 00:57:59,600
或实际上可能需要做一些工作， 

1282
00:57:59,600 --> 00:58:01,870
像这个数据，这个模型

1283
00:58:01,870 --> 00:58:03,230
来自网络

1284
00:58:03,230 --> 00:58:05,140
它必须做一些网络请求

1285
00:58:05,140 --> 00:58:06,600
或类似的东西。 

1286
00:58:06,600 --> 00:58:09,960
但是如果我们在增加一些复杂性之间做出选择

1287
00:58:09,960 --> 00:58:13,360
到ViewModel按摩数据

1288
00:58:13,360 --> 00:58:15,340
这样视图就更简单了

1289
00:58:15,340 --> 00:58:17,260
我们总是会朝着这个方向做出权衡。 

1290
00:58:17,260 --> 00:58:19,770
我们希望我们的观点尽可能简单

1291
00:58:19,770 --> 00:58:22,050
所以这确实是ViewModel工作的一部分

1292
00:58:22,050 --> 00:58:25,330
向视图展示模型

1293
00:58:25,330 --> 00:58:29,380
以“视图”易于使用的方式。 

1294
00:58:29,380 --> 00:58:31,750
当然，这是单线返回的东西

1295
00:58:31,750 --> 00:58:33,803
因此我们不需要在那里退货。 

1296
00:58:35,170 --> 00:58:36,003
所以，很好。 

1297
00:58:36,003 --> 00:58:38,750
因此，在这种情况下，如果我们有一个完全私密的门， 

1298
00:58:38,750 --> 00:58:43,470
全关门，我们有这个不错的功能

1299
00:58:43,470 --> 00:58:45,877
我们在这里让他们在对讲机上

1300
00:58:45,877 --> 00:58:50,710
所以我可以称这一标记为访问

1301
00:58:51,610 --> 00:58:53,510
到模型，好吗？ 

1302
00:58:53,510 --> 00:58:55,410
所以这些是函数和变量

1303
00:58:55,410 --> 00:58:57,310
允许访问var模型

1304
00:58:57,310 --> 00:58:58,840
这就是意图。 

1305
00:58:58,840 --> 00:59:01,630
顺便说一下，这个// MARK，我这样做的原因

1306
00:59:01,630 --> 00:59:03,730
是如果你在这里抬头告诉你

1307
00:59:03,730 --> 00:59:05,234
这里显示什么

1308
00:59:05,234 --> 00:59:09,030
它实际上是在向您显示所显示的确切内容

1309
00:59:09,030 --> 00:59:11,470
还有那些小标记，//标记

1310
00:59:11,470 --> 00:59:13,694
提供这些漂亮的小标题

1311
00:59:13,694 --> 00:59:17,810
有关函数和变量的列表。 

1312
00:59:18,700 --> 00:59:23,700
我有点喜欢这个更封闭的非玻璃门

1313
00:59:24,220 --> 00:59:27,250
对事物的一种方法

1314
00:59:27,250 --> 00:59:29,760
但有时候，进行私有设置很有意义

1315
00:59:29,760 --> 00:59:32,200
让人们有玻璃门看模型

1316
00:59:32,200 --> 00:59:34,840
但是你总是想拥有这个东西

1317
00:59:34,840 --> 00:59:36,500
调用意图的地方。 

1318
00:59:36,500 --> 00:59:38,460
这几乎就像文档一样。 

1319
00:59:38,460 --> 00:59:40,760
让所有视图都知道

1320
00:59:40,760 --> 00:59:42,290
编写View代码的人

1321
00:59:42,290 --> 00:59:45,273
您可以执行以下操作来更改模型。 

1322
00:59:46,500 --> 00:59:50,090
好吧，那么，我们这里有什么错误呢？ 

1323
00:59:50,090 --> 00:59:54,120
EmojiMemoryGame类没有初始化程序。 

1324
00:59:54,120 --> 00:59:55,270
嗯，那是什么意思？ 

1325
00:59:55,270 --> 00:59:57,165
我们已经了解了初始化程序

1326
00:59:57,165 --> 00:59:58,520
那是什么

1327
00:59:58,520 --> 01:00:01,760
好吧，这基本上是一堂课， 

1328
01:00:01,760 --> 01:00:04,700
与您有变种一样的抱怨

1329
01:00:04,700 --> 01:00:06,640
尚未初始化，实际上， 

1330
01:00:06,640 --> 01:00:09,530
这个变种，这个模型变种，虽然它有一个类型， 

1331
01:00:09,530 --> 01:00:11,420
它没有初始值，对吗？ 

1332
01:00:11,420 --> 01:00:14,422
需要设置为等于这里的值

1333
01:00:14,422 --> 01:00:17,930
满足Swift中的这一要求

1334
01:00:17,930 --> 01:00:21,580
所有变量都已初始化。 

1335
01:00:21,580 --> 01:00:24,050
那么，我们该如何初始化呢？ 

1336
01:00:24,050 --> 01:00:25,490
我们本质上需要做这件事

1337
01:00:25,490 --> 01:00:29,050
我们在哪里做MemoryGame <String>， 

1338
01:00:29,050 --> 01:00:31,430
类型，然后在括号中， 

1339
01:00:31,430 --> 01:00:35,810
我们将为其提供参数或其他参数。 

1340
01:00:35,810 --> 01:00:38,110
实际上这里有一个

1341
01:00:38,110 --> 01:00:41,970
我们可以双击卡片，它需要卡片。 

1342
01:00:41,970 --> 01:00:43,130
为什么要卡片？ 

1343
01:00:43,130 --> 01:00:46,030
好吧，如果您在这里查看我们的MemoryGame结构， 

1344
01:00:46,030 --> 01:00:48,980
它也有一个未初始化的变量。 

1345
01:00:48,980 --> 01:00:51,030
那么这是怎么回事？ 

1346
01:00:51,030 --> 01:00:53,420
哦，如果您想创建其中之一， 

1347
01:00:53,420 --> 01:00:56,173
你要给我这个

1348
01:00:57,314 --> 01:00:58,430
此卡的价值。 

1349
01:00:58,430 --> 01:01:00,274
这与我们在这里所做的完全一样

1350
01:01:00,274 --> 01:01:01,730
当我们有CardView isFaceUp时

1351
01:01:02,780 --> 01:01:06,700
需要满足未初始化的要求。 

1352
01:01:06,700 --> 01:01:10,153
因此，只要您拥有这些变量并且它们没有被初始化， 

1353
01:01:10,153 --> 01:01:13,610
然后由创建它们的人来初始化它们

1354
01:01:13,610 --> 01:01:15,260
这就是这里发生的事情。 

1355
01:01:15,260 --> 01:01:19,920
但这实际上是假的，在这种情况下， 

1356
01:01:19,920 --> 01:01:22,160
因为这个EmojiMemoryGame 

1357
01:01:22,160 --> 01:01:25,390
并不是真的不想创建卡片， 

1358
01:01:25,390 --> 01:01:29,390
做类似的事情，将它们设置为正面并且匹配

1359
01:01:29,390 --> 01:01:32,590
以及所有这些，因为这完全取决于MemoryGame 

1360
01:01:32,590 --> 01:01:35,820
以确定哪些卡面朝上，哪些卡面朝下。 

1361
01:01:35,820 --> 01:01:38,700
所以，真的，这是MemoryGame本身

1362
01:01:38,700 --> 01:01:41,540
想在这里初始化这些卡。 

1363
01:01:41,540 --> 01:01:43,097
所以几乎就像它想说的那样

1364
01:01:43,097 --> 01:01:45,160
等于这里的东西。 

1365
01:01:45,160 --> 01:01:47,430
但这是一个问题

1366
01:01:47,430 --> 01:01:48,980
因为它并不真正知道

1367
01:01:48,980 --> 01:01:52,730
例如，这个游戏中有几张纸牌，好吗？ 

1368
01:01:52,730 --> 01:01:56,030
那么要传达的卡数在哪里

1369
01:01:56,030 --> 01:01:59,615
从我们试图创建其模型的ViewModel中

1370
01:01:59,615 --> 01:02:03,350
转到MemoryGame，好吗？ 

1371
01:02:03,350 --> 01:02:06,120
我们真正喜欢这样做的地方就在这里。 

1372
01:02:06,120 --> 01:02:08,450
无需创建MemoryGame 

1373
01:02:08,450 --> 01:02:11,420
通过给卡片，如果我们只是创造

1374
01:02:11,420 --> 01:02:14,510
通过说创建MemoryGame来创建MemoryGame 

1375
01:02:14,510 --> 01:02:17,990
有了这个数量的卡对， 

1376
01:02:17,990 --> 01:02:22,383
两对或五对，六对任何牌。 

1377
01:02:23,880 --> 01:02:26,930
然后这个MemoryGame会说，哦，好吧， 

1378
01:02:26,930 --> 01:02:31,930
我将去创建这么多卡，成对的卡

1379
01:02:32,470 --> 01:02:35,110
然后我将它们全部正确设置并执行所有操作。 

1380
01:02:35,110 --> 01:02:38,460
所以，这里的底线是我们想要创建

1381
01:02:38,460 --> 01:02:42,810
这个MemoryGame <String>的东西

1382
01:02:42,810 --> 01:02:47,150
有一些随机的其他论点，而不是卡片

1383
01:02:47,150 --> 01:02:49,550
但是其他一些信息。 

1384
01:02:49,550 --> 01:02:51,780
这是很常见的

1385
01:02:51,780 --> 01:02:55,840
我们这样做的方法是使用init，好吗？ 

1386
01:02:55,840 --> 01:02:59,880
因此，我们转到此处，我们将添加另一个新功能。 

1387
01:02:59,880 --> 01:03:02,570
您不必说func init，好吗？ 

1388
01:03:02,570 --> 01:03:04,240
你可以说初始化

1389
01:03:04,240 --> 01:03:07,240
因为根据定义，init是函数

1390
01:03:07,240 --> 01:03:09,930
而您只要给它任何论点就可以了。 

1391
01:03:09,930 --> 01:03:13,260
所以我们想要numberOfPairsOfCards 

1392
01:03:13,260 --> 01:03:15,367
和类型，这是一个Int，对不对？ 

1393
01:03:15,367 --> 01:03:16,473
而且没有返回值

1394
01:03:16,473 --> 01:03:20,690
因为这只是初始化我们所有的变量， 

1395
01:03:20,690 --> 01:03:23,430
那就是init所做的，真正的酷

1396
01:03:23,430 --> 01:03:25,800
您可以拥有多个这些init， 

1397
01:03:25,800 --> 01:03:27,980
每个都有不同的论点。 

1398
01:03:27,980 --> 01:03:31,870
因此，如果还有其他方法可以考虑

1399
01:03:31,870 --> 01:03:36,870
要创建一个MemoryGame，我们可以有其他init，好吗？ 

1400
01:03:37,210 --> 01:03:38,960
而且我们之前也看到过。 

1401
01:03:38,960 --> 01:03:41,670
所以我们回到这里，我们看看RoundedRectangle，对吗？ 

1402
01:03:41,670 --> 01:03:44,000
当我们创建一个RoundedRectangle时

1403
01:03:44,000 --> 01:03:45,140
我们开了括号， 

1404
01:03:45,140 --> 01:03:47,600
看，有四种不同的方式

1405
01:03:47,600 --> 01:03:49,490
创建RoundedRectangle。 

1406
01:03:49,490 --> 01:03:52,390
它的半径或拐角大小或某些样式

1407
01:03:52,390 --> 01:03:54,110
或这里发生的事情。 

1408
01:03:54,110 --> 01:03:56,750
因此，这将是四个不同的init 

1409
01:03:56,750 --> 01:03:58,160
有不同的论据， 

1410
01:03:58,160 --> 01:04:02,810
所有这些都将用于创建RoundedRectangle。 

1411
01:04:02,810 --> 01:04:05,150
好的，这完全是一样的事情。 

1412
01:04:05,150 --> 01:04:07,930
在我们的情况下，我们只有一个init。 

1413
01:04:09,220 --> 01:04:11,150
现在，我们的init需要在这里做什么？ 

1414
01:04:11,150 --> 01:04:14,010
好吧，它需要初始化我们所有的变量

1415
01:04:14,010 --> 01:04:17,389
因为我们不允许有一个MemoryGame 

1416
01:04:17,389 --> 01:04:21,580
尚未初始化所有变量。 

1417
01:04:21,580 --> 01:04:23,100
因此，让我们直接进行研究。 

1418
01:04:23,100 --> 01:04:25,710
我将从创建我的卡开始

1419
01:04:25,710 --> 01:04:27,810
作为一个空的纸牌，对不对？ 

1420
01:04:27,810 --> 01:04:29,450
我的卡在卡数组中。 

1421
01:04:29,450 --> 01:04:34,040
我要制作等于Array <Card>的卡片

1422
01:04:34,040 --> 01:04:35,940
用圆括号括起来，用圆括号括起来。 

1423
01:04:35,940 --> 01:04:39,350
换句话说，如果它有一个

1424
01:04:39,350 --> 01:04:42,540
没有参数，当您在数组中执行此操作时， 

1425
01:04:42,540 --> 01:04:43,980
它创建一个空数组。 

1426
01:04:43,980 --> 01:04:47,770
所以这是纸牌，现在是一个空的纸牌阵列，好吗？ 

1427
01:04:47,770 --> 01:04:51,480
满足初始化要求。 

1428
01:04:51,480 --> 01:04:52,790
但是，当然，我们需要做更多的事情， 

1429
01:04:52,790 --> 01:04:56,620
我们需要创建这么多对卡片，好吗？ 

1430
01:04:56,620 --> 01:04:58,820
将那些添加到此数组。 

1431
01:04:58,820 --> 01:05:01,330
因此，要做到这一点，我们需要一个for循环。 

1432
01:05:01,330 --> 01:05:05,143
所以这是您第一次在Swift中看到for循环。 

1433
01:05:05,143 --> 01:05:08,520
是和迭代变量

1434
01:05:08,520 --> 01:05:10,270
对应该是pairIndex，对吗？ 

1435
01:05:10,270 --> 01:05:13,520
该对的索引，因为我要为每个对执行此操作。 

1436
01:05:13,520 --> 01:05:14,725
然后你说出来。 

1437
01:05:14,725 --> 01:05:17,190
所以for in是一个for循环。 

1438
01:05:17,190 --> 01:05:18,970
这是Swift中唯一的for循环

1439
01:05:18,970 --> 01:05:22,590
这是可迭代的事情，好吗？ 

1440
01:05:22,590 --> 01:05:23,580
我们以前见过。 

1441
01:05:23,580 --> 01:05:25,650
这是可以迭代的任何东西， 

1442
01:05:25,650 --> 01:05:27,570
通常，它是一个数组，好吗？ 

1443
01:05:27,570 --> 01:05:30,530
在这种情况下，我要做同样的可迭代的事情

1444
01:05:30,530 --> 01:05:34,070
我们在这里做了，这是范围，好吗？ 

1445
01:05:34,070 --> 01:05:36,360
所以范围是可迭代的

1446
01:05:36,360 --> 01:05:39,150
数组也是可迭代的东西

1447
01:05:39,150 --> 01:05:42,220
但在这里我想要的范围是从零到

1448
01:05:42,220 --> 01:05:45,870
但不包括纸牌对数。 

1449
01:05:45,870 --> 01:05:47,710
这就是您执行for循环的方式， 

1450
01:05:47,710 --> 01:05:51,410
它会做到零，一，二， 

1451
01:05:51,410 --> 01:05:54,130
直到（不包括）卡对数为止。 

1452
01:05:54,130 --> 01:05:56,360
因此，如果这是两对卡， 

1453
01:05:56,360 --> 01:05:58,720
那么它将是零，一， 

1454
01:05:58,720 --> 01:06:01,410
然后两个不小于两个。 

1455
01:06:01,410 --> 01:06:03,570
所以，它将停止，好吗？ 

1456
01:06:03,570 --> 01:06:06,040
因此，在这里，我需要添加两张卡。 

1457
01:06:06,040 --> 01:06:09,820
我要对我的Cards Array说，附加。 

1458
01:06:09,820 --> 01:06:13,390
所以append是数组中的一个函数

1459
01:06:13,390 --> 01:06:16,229
并允许您向其中添加卡片。 

1460
01:06:16,229 --> 01:06:20,160
所以我要在这里添加一张卡片

1461
01:06:21,334 --> 01:06:23,350
我们必须弄清楚该怎么做

1462
01:06:23,350 --> 01:06:25,930
然后我要追加另一张卡片，好吗？ 

1463
01:06:25,930 --> 01:06:27,880
一个，所以只有一对卡。 

1464
01:06:27,880 --> 01:06:29,900
所以我要两双

1465
01:06:29,900 --> 01:06:32,040
现在，我当然不能创建卡， 

1466
01:06:32,040 --> 01:06:33,600
这些小卡片事物之一

1467
01:06:33,600 --> 01:06:35,213
加上开括号，闭括号， 

1468
01:06:35,213 --> 01:06:38,260
这不合法，有这些东西

1469
01:06:38,260 --> 01:06:41,180
但是如果我做开括号，哦，那里， 

1470
01:06:41,180 --> 01:06:45,090
我在这里得到了这个漂亮的明亮的小初始化器

1471
01:06:45,090 --> 01:06:46,950
它的构建使我可以初始化

1472
01:06:46,950 --> 01:06:49,140
每个论点，好吗？ 

1473
01:06:49,140 --> 01:06:52,399
因此，我可以为这两件事做到这一点。 

1474
01:06:52,399 --> 01:06:55,710
因此，您得到了这个，如果它是一个结构，这是一个结构， 

1475
01:06:55,710 --> 01:06:59,260
您可以免费获得这种初始化器。 

1476
01:06:59,260 --> 01:07:01,520
初始化每个变量的变量。 

1477
01:07:01,520 --> 01:07:05,024
顺便说一句，对于一个类，它也有一个免费的初始化器

1478
01:07:05,024 --> 01:07:08,380
但是它没有初始化任何变量，好吗？ 

1479
01:07:08,380 --> 01:07:11,235
因此，在一个类中，您要么必须将它们全部初始化

1480
01:07:11,235 --> 01:07:13,938
等于这里吧？ 

1481
01:07:13,938 --> 01:07:18,340
或者您必须创建自己的初始化程序来初始化它， 

1482
01:07:18,340 --> 01:07:20,410
就像我们在这里做，好吗？ 

1483
01:07:20,410 --> 01:07:23,480
但是对于struct，我们不需要对此进行初始化

1484
01:07:23,480 --> 01:07:26,510
因为我们是免费的，因为它是一个结构， 

1485
01:07:26,510 --> 01:07:27,880
我们得到这个免费的。 

1486
01:07:27,880 --> 01:07:30,680
所以我在这里创建卡片，当然， 

1487
01:07:30,680 --> 01:07:32,240
我学会开始脸朝下。 

1488
01:07:32,240 --> 01:07:34,410
大概这是游戏的开始， 

1489
01:07:34,410 --> 01:07:36,302
当然，它还没有匹配

1490
01:07:36,302 --> 01:07:38,290
而且我们哦，我们很满意。 

1491
01:07:38,290 --> 01:07:40,116
嗯，那会很有趣

1492
01:07:40,116 --> 01:07:43,470
但是我们知道两张卡都想要这样，好吗？ 

1493
01:07:43,470 --> 01:07:45,570
所以我们在这里越来越近了吧？ 

1494
01:07:45,570 --> 01:07:47,800
所以我们要在那儿附加卡

1495
01:07:47,800 --> 01:07:51,302
但是这个CardContent怎么样？ 

1496
01:07:51,302 --> 01:07:53,260
那绝对是个问题。 

1497
01:07:53,260 --> 01:07:55,110
有点像我想做点什么

1498
01:07:55,110 --> 01:07:59,300
就像var content在这里等于

1499
01:07:59,300 --> 01:08:01,310
这对的内容

1500
01:08:01,310 --> 01:08:02,800
在这对卡上

1501
01:08:02,800 --> 01:08:04,810
然后放在这里，对吗？ 

1502
01:08:04,810 --> 01:08:07,120
两张卡上都有相同的内容

1503
01:08:07,120 --> 01:08:09,743
因为这是一对卡。 

1504
01:08:09,743 --> 01:08:14,330
但这就像我真的不知道如何创建内容

1505
01:08:14,330 --> 01:08:17,300
因为此内容属于CardContent类型

1506
01:08:17,300 --> 01:08:19,570
对我来说，这是无关紧要的。 

1507
01:08:19,570 --> 01:08:20,940
就像我什至不知道那是什么， 

1508
01:08:20,940 --> 01:08:23,160
可能是图像，整数，字符串，我不知道

1509
01:08:23,160 --> 01:08:25,094
所以我怎么可能知道

1510
01:08:25,094 --> 01:08:26,853
如何创建这些东西之一？ 

1511
01:08:26,853 --> 01:08:30,240
根本没有办法做到。 

1512
01:08:30,240 --> 01:08:34,420
那么，谁知道如何在此卡上创建内容？ 

1513
01:08:34,420 --> 01:08:37,130
好吧，这家伙肯定可以，好吗？ 

1514
01:08:37,130 --> 01:08:38,960
这是一个EmojiMemoryGame。 

1515
01:08:38,960 --> 01:08:40,920
他知道他正在创建一个MemoryGame 

1516
01:08:40,920 --> 01:08:44,430
与CardContent String，大概是这个家伙

1517
01:08:44,430 --> 01:08:46,790
会知道如何创建内容

1518
01:08:46,790 --> 01:08:49,260
每对卡中的对吧？ 

1519
01:08:49,260 --> 01:08:52,700
所以以某种方式，我们必须给这个人一个机会

1520
01:08:52,700 --> 01:08:57,400
在这里进行内容的少量创建。 

1521
01:08:57,400 --> 01:09:01,560
我们要用一个函数来做，好吗？ 

1522
01:09:01,560 --> 01:09:03,697
我只是要在初始化中添加另一个参数， 

1523
01:09:03,697 --> 01:09:07,150
我将其称为我的cardContentFactory， 

1524
01:09:07,150 --> 01:09:09,710
那就是论点的名字

1525
01:09:09,710 --> 01:09:12,363
该参数的类型是一个函数。 

1526
01:09:12,363 --> 01:09:14,460
需要一个Int的函数

1527
01:09:14,460 --> 01:09:17,830
并返回CardContent类型。 

1528
01:09:17,830 --> 01:09:20,610
再说一次，这不在乎，我不在乎它是什么

1529
01:09:20,610 --> 01:09:23,500
但我要给你一个Int，这就是对

1530
01:09:23,500 --> 01:09:25,000
所以我实际上会让你知道

1531
01:09:25,000 --> 01:09:27,283
我正在制作哪对。 

1532
01:09:27,283 --> 01:09:30,220
而且您只需要给我CardContent。 

1533
01:09:30,220 --> 01:09:32,232
那是一张图片，给我一张图片，那是一个字符串， 

1534
01:09:32,232 --> 01:09:33,380
给我一根绳子，我不在乎， 

1535
01:09:33,380 --> 01:09:35,330
这是我不在乎我。 

1536
01:09:35,330 --> 01:09:37,527
所以在这里，我可以使用这个CardContent 

1537
01:09:37,527 --> 01:09:40,480
通过在此处调用此函数， 

1538
01:09:40,480 --> 01:09:45,480
cardContentFactory，我将使用参数调用它

1539
01:09:46,750 --> 01:09:49,340
pairIndex。 

1540
01:09:49,340 --> 01:09:51,840
让我们正确的大写

1541
01:09:51,840 --> 01:09:54,860
这将调用此函数。 

1542
01:09:54,860 --> 01:09:58,620
这种类型，函数类型，可以是字符串

1543
01:09:58,620 --> 01:10:01,470
或类似的东西，但不是，它是一个函数。 

1544
01:10:01,470 --> 01:10:04,600
因此，函数是Swift中的第一类类型。 

1545
01:10:04,600 --> 01:10:07,240
他们甚至都不是特别的，好吗？ 

1546
01:10:07,240 --> 01:10:09,220
您可以传递函数。 

1547
01:10:09,220 --> 01:10:10,480
再次，如您所想， 

1548
01:10:10,480 --> 01:10:12,730
用功能性编程语言

1549
01:10:12,730 --> 01:10:14,550
能够传递功能， 

1550
01:10:14,550 --> 01:10:16,380
这很基本，好吗？ 

1551
01:10:16,380 --> 01:10:19,240
这是整个事情的基本部分。 

1552
01:10:19,240 --> 01:10:21,267
因此，您不必担心这一点。 

1553
01:10:21,267 --> 01:10:24,960
在其他语言中，传递函数可能会受到折磨。 

1554
01:10:24,960 --> 01:10:27,874
您传递给他们的指针以及各种疯狂的事物。 

1555
01:10:27,874 --> 01:10:31,470
在这里，只是字面上的解释

1556
01:10:31,470 --> 01:10:33,830
争论的类型以及收益和繁荣， 

1557
01:10:33,830 --> 01:10:35,840
您可以传递一个函数。 

1558
01:10:35,840 --> 01:10:38,280
现在，这里有一个黄色警告。 

1559
01:10:38,280 --> 01:10:40,210
顺便说一句，我们知道红色警告

1560
01:10:40,210 --> 01:10:42,942
就像啊，有些东西无法编译，太可怕了。 

1561
01:10:42,942 --> 01:10:46,770
黄色警告会编译，但您总是想修复这些警告

1562
01:10:46,770 --> 01:10:50,290
因为它们经常会导致未来的问题

1563
01:10:50,290 --> 01:10:52,500
如果不是眼前的问题。 

1564
01:10:52,500 --> 01:10:53,563
那这是在说什么呢？ 

1565
01:10:53,563 --> 01:10:55,720
就是说可变的内容， 

1566
01:10:55,720 --> 01:10:59,230
这就是这里的变量，从未被突变过。 

1567
01:10:59,230 --> 01:11:00,990
变异，意味着改变了，对吧？ 

1568
01:11:00,990 --> 01:11:02,050
它永远不会变异。 

1569
01:11:02,050 --> 01:11:04,600
考虑更改为let常量。 

1570
01:11:04,600 --> 01:11:07,530
所以基本上是说不要称这为var 

1571
01:11:07,530 --> 01:11:09,543
如果不是可变的，好吗？ 

1572
01:11:10,540 --> 01:11:13,660
如果没有变化，则不应是var， 

1573
01:11:13,660 --> 01:11:17,070
相反，在Swift中，我们使用关键字let 

1574
01:11:17,070 --> 01:11:19,850
我们可以在这里键入它，让我们修复它

1575
01:11:19,850 --> 01:11:22,930
或者我们也可以在这里使用此警告， 

1576
01:11:22,930 --> 01:11:25,320
单击它并进行修复。 

1577
01:11:25,320 --> 01:11:29,310
因此，解决方法是将var替换为let，在这里观看。 

1578
01:11:29,310 --> 01:11:30,330
固定。 

1579
01:11:30,330 --> 01:11:31,210
好吧，让它放手。 

1580
01:11:31,210 --> 01:11:33,440
这是一个非常好的词

1581
01:11:33,440 --> 01:11:36,100
因为这读起来很像英语。 

1582
01:11:36,100 --> 01:11:38,100
内容等于结果

1583
01:11:38,100 --> 01:11:42,420
为这个pairIndex调用cardContentFactory，好吗？ 

1584
01:11:42,420 --> 01:11:45,360
每当你有任何种类的变量

1585
01:11:45,360 --> 01:11:48,400
实际上并没有变化，换句话说，这是一个常数， 

1586
01:11:48,400 --> 01:11:50,863
您总是想在这里使用let。 

1587
01:11:51,780 --> 01:11:53,740
现在，这里要注意的另一件事很有趣

1588
01:11:53,740 --> 01:11:57,060
是我们没有在这件事上打上字样。 

1589
01:11:57,060 --> 01:12:00,580
尽管我们没有说出CardContent类型

1590
01:12:00,580 --> 01:12:01,980
那是什么类型。 

1591
01:12:01,980 --> 01:12:03,740
这是CardContent类型

1592
01:12:03,740 --> 01:12:07,050
因为那是contentCardFactory返回的

1593
01:12:07,050 --> 01:12:08,457
但我们不必这样做。 

1594
01:12:08,457 --> 01:12:11,730
这是Swift的一部分，只是为您解决问题， 

1595
01:12:11,730 --> 01:12:13,700
只要有可能就推断类型

1596
01:12:13,700 --> 01:12:16,250
我们真的会在另一边看到

1597
01:12:16,250 --> 01:12:19,923
马上在这里调用这个init，好吗？ 

1598
01:12:21,100 --> 01:12:23,660
好吧，让我们回到那边

1599
01:12:23,660 --> 01:12:25,530
并查看我们在哪里创建我们的MemoryGame。 

1600
01:12:25,530 --> 01:12:27,430
并将其放在单独的行上

1601
01:12:27,430 --> 01:12:28,580
所以我们有更多的空间。 

1602
01:12:28,580 --> 01:12:31,140
现在，我们在这里添加了第二个参数

1603
01:12:31,140 --> 01:12:33,990
就是这对cardContentFactory的卡对数， 

1604
01:12:35,630 --> 01:12:40,340
这个值必须是一个函数

1605
01:12:40,340 --> 01:12:42,980
它需要一个Int，即pairIndex， 

1606
01:12:42,980 --> 01:12:47,520
并返回一个CardContent，在这里我们知道它是String。 

1607
01:12:47,520 --> 01:12:48,728
因此它必须返回一个字符串。 

1608
01:12:48,728 --> 01:12:50,280
因此，让我们创建一个这样的功能。 

1609
01:12:50,280 --> 01:12:54,604
观看这个功能，我将其称为createCardContent。 

1610
01:12:54,604 --> 01:12:58,600
我们知道它必须采用一个Int，即pairIndex， 

1611
01:12:58,600 --> 01:13:02,060
进入Int，我们知道它必须返回CardContent， 

1612
01:13:02,060 --> 01:13:04,840
希望是一个字符串。 

1613
01:13:04,840 --> 01:13:07,860
好的，因为这是String的MemoryGame，好吗？ 

1614
01:13:07,860 --> 01:13:11,525
现在，我要回来，让我们现在就回来

1615
01:13:11,525 --> 01:13:14,780
一些表情符号，那怎么样？ 

1616
01:13:14,780 --> 01:13:16,980
在每张卡片上都放置相同的表情符号， 

1617
01:13:16,980 --> 01:13:19,200
也许那里是一张笑脸。 

1618
01:13:19,200 --> 01:13:23,090
因此，这里我们在此处返回一个字符串。 

1619
01:13:23,090 --> 01:13:28,090
现在，我们可以使用它并说出createCardContent。 

1620
01:13:28,970 --> 01:13:32,330
所以这是一个带有函数的参数

1621
01:13:32,330 --> 01:13:35,350
接受一个I​​nt并返回一个String。 

1622
01:13:35,350 --> 01:13:38,110
这当然是合格的，因此这是合法的。 

1623
01:13:38,110 --> 01:13:39,859
看，没有错误，没有警告。 

1624
01:13:39,859 --> 01:13:43,068
这完全是合法的方法。 

1625
01:13:43,068 --> 01:13:45,950
但是，我们永远不会这样

1626
01:13:45,950 --> 01:13:48,450
因为我们不想去创造

1627
01:13:48,450 --> 01:13:51,050
这些额外的小功能可以做到这一点。 

1628
01:13:51,050 --> 01:13:54,160
相反，我们会在这里内联

1629
01:13:54,160 --> 01:13:56,360
内联此代码。 

1630
01:13:56,360 --> 01:13:59,450
所以现在要仔细看，我要完成整个过程

1631
01:13:59,450 --> 01:14:02,100
我们如何在这里使用此功能

1632
01:14:02,100 --> 01:14:04,640
并在这里内联，好吗？ 

1633
01:14:04,640 --> 01:14:08,460
Swift中的函数内联称为闭包

1634
01:14:08,460 --> 01:14:11,120
它被称为闭包，因为它实际上捕获了

1635
01:14:11,120 --> 01:14:14,340
需要从周围环境中获取信息的信息。 

1636
01:14:14,340 --> 01:14:16,300
我们稍后再讨论，但是基本上

1637
01:14:16,300 --> 01:14:19,640
您现在可以将其视为内联函数。 

1638
01:14:19,640 --> 01:14:23,140
因此，我们将选择此功能， 

1639
01:14:23,140 --> 01:14:25,270
除名称外，所有其他信息。 

1640
01:14:25,270 --> 01:14:27,930
当我们内联时，它不需要名称，好吗？ 

1641
01:14:27,930 --> 01:14:31,720
无需命名，因为它就位于行内。 

1642
01:14:31,720 --> 01:14:34,240
所以我要选择除名称以外的所有内容

1643
01:14:34,240 --> 01:14:37,360
我要去剪然后我要去这里

1644
01:14:37,360 --> 01:14:39,930
并将其粘贴在此处而不是此处的名称。 

1645
01:14:39,930 --> 01:14:41,170
因此，粘贴。 

1646
01:14:41,170 --> 01:14:43,690
现在，这几乎可以正常工作

1647
01:14:43,690 --> 01:14:47,100
但是当我这样做时，我总是必须做的一件事

1648
01:14:47,100 --> 01:14:50,610
是在这里拿起花括号

1649
01:14:50,610 --> 01:14:54,130
剪下，用in替换

1650
01:14:54,130 --> 01:14:59,040
然后将大括号粘贴到此处开始。 

1651
01:14:59,040 --> 01:15:02,020
本质上，花括号必须环绕

1652
01:15:02,020 --> 01:15:04,420
整个内联函数。 

1653
01:15:04,420 --> 01:15:07,620
所以这就是为什么我们将花括号移到前面

1654
01:15:07,620 --> 01:15:10,620
它的参数和返回类型

1655
01:15:10,620 --> 01:15:14,350
并用它来分开它。 

1656
01:15:14,350 --> 01:15:16,270
好吧，现在，我们不需要这里的功能

1657
01:15:16,270 --> 01:15:18,060
您可以再次看到，没有错误， 

1658
01:15:18,060 --> 01:15:21,860
这是内联此功能的完全合法的方法。 

1659
01:15:21,860 --> 01:15:24,950
顺便说一句，您可能会意识到这一点， 

1660
01:15:24,950 --> 01:15:28,650
我们曾经在我们这里的其他地方

1661
01:15:28,650 --> 01:15:32,410
与每个，它使用了，并在这里有一个小争论。 

1662
01:15:32,410 --> 01:15:35,070
所以，这将开始对您更有意义

1663
01:15:35,070 --> 01:15:37,880
一旦我们完成了这个。 

1664
01:15:37,880 --> 01:15:39,700
我结束这个意味着什么？ 

1665
01:15:39,700 --> 01:15:40,759
这不是刚刚结束吗？ 

1666
01:15:40,759 --> 01:15:45,100
嗯，不完全是因为就像我们在这里的时候一样， 

1667
01:15:45,100 --> 01:15:49,420
Swift能够推断出这是CardContent类型

1668
01:15:49,420 --> 01:15:54,170
这样我们就不必在这里说冒号CardContent了吧？ 

1669
01:15:54,170 --> 01:15:59,080
因此，我们将这种类型推断称为类型推断

1670
01:15:59,080 --> 01:16:00,960
语言真的很好

1671
01:16:00,960 --> 01:16:03,710
在所有内容都必须严格键入的地方， 

1672
01:16:03,710 --> 01:16:06,000
每个var必须有一个类型，好吗？ 

1673
01:16:06,000 --> 01:16:10,960
这有点麻烦，但类型推断

1674
01:16:10,960 --> 01:16:13,770
帮助它做到这一点，从而减轻了负担。 

1675
01:16:13,770 --> 01:16:17,910
Swift可以在这里推断出哪种类型？ 

1676
01:16:17,910 --> 01:16:19,530
好吧，很多。 

1677
01:16:19,530 --> 01:16:22,370
它知道此var的类型， 

1678
01:16:22,370 --> 01:16:25,000
这是一个需要Int的函数

1679
01:16:25,000 --> 01:16:27,740
并返回CardContent。 

1680
01:16:27,740 --> 01:16:30,670
因此，这意味着我们不必说这是一个Int 

1681
01:16:30,670 --> 01:16:34,350
而且我们不必说这返回String，好吗？ 

1682
01:16:34,350 --> 01:16:35,600
斯威夫特可以推断出这一点。 

1683
01:16:35,600 --> 01:16:39,010
再次，看，没有错误，没有警告，这是完全合法的。 

1684
01:16:39,010 --> 01:16:40,320
你甚至根本不需要

1685
01:16:40,320 --> 01:16:43,182
这些括号就在这里，好吗？ 

1686
01:16:43,182 --> 01:16:45,760
因为当时他们并没有真正做任何事情

1687
01:16:45,760 --> 01:16:47,657
在这里，这个pairIndex 

1688
01:16:47,657 --> 01:16:51,340
再次，就像这里的索引一样可怕

1689
01:16:51,340 --> 01:16:53,543
因为这原来也是一个功能， 

1690
01:16:53,543 --> 01:16:54,450
一种特殊的功能

1691
01:16:54,450 --> 01:16:56,720
因为您可以在那里列出视图

1692
01:16:56,720 --> 01:17:00,760
但这是这里使用的相同语法。 

1693
01:17:00,760 --> 01:17:02,490
但是我们还没有完成，因为，当然， 

1694
01:17:02,490 --> 01:17:04,920
我们知道这是一个单行函数

1695
01:17:04,920 --> 01:17:07,760
返回此字符串。 

1696
01:17:07,760 --> 01:17:10,617
因此，我们不需要在那里退货。 

1697
01:17:10,617 --> 01:17:14,720
我们甚至可以在这里清理一些空间， 

1698
01:17:14,720 --> 01:17:17,860
删除一些这样的空间

1699
01:17:17,860 --> 01:17:22,050
甚至更多，我们知道如果您有大括号的东西， 

1700
01:17:22,050 --> 01:17:24,720
那是最后一个论点，对吗？ 

1701
01:17:24,720 --> 01:17:27,526
最后一个参数，这个init有两个参数

1702
01:17:27,526 --> 01:17:30,180
这是最后一个。 

1703
01:17:30,180 --> 01:17:33,360
我们可以做与上一个参数相同的操作

1704
01:17:33,360 --> 01:17:35,810
对于ForEach，这是HStack的最后一个参数， 

1705
01:17:35,810 --> 01:17:39,460
ZStack的最后一个参数，在这里做完全一样的事情

1706
01:17:39,460 --> 01:17:42,183
哪个可以摆脱关键字，好吗？ 

1707
01:17:43,390 --> 01:17:48,390
然后把花括号放在外面，漂浮在外面

1708
01:17:48,600 --> 01:17:53,117
所以我们最终得到了这个非常精简的功能

1709
01:17:54,530 --> 01:17:55,580
甚至不止如此

1710
01:17:55,580 --> 01:17:58,888
请注意，由于我们总是会返回一张笑脸， 

1711
01:17:58,888 --> 01:18:00,970
您甚至根本不需要这个pairIndex 

1712
01:18:00,970 --> 01:18:02,290
但您无法删除它， 

1713
01:18:02,290 --> 01:18:05,000
您必须用下划线标记

1714
01:18:05,000 --> 01:18:06,780
只是说是的，我知道这应该

1715
01:18:06,780 --> 01:18:08,610
吵架，但我不需要

1716
01:18:08,610 --> 01:18:10,850
所以我要在var下使用，然后在Swift中使用

1717
01:18:10,850 --> 01:18:14,790
您会看到我们在任何时候都使用下划线， 

1718
01:18:14,790 --> 01:18:15,900
没关系，这是什么， 

1719
01:18:15,900 --> 01:18:19,200
我不会用这种东西，一种未使用的东西

1720
01:18:19,200 --> 01:18:22,480
因此我们不使用该pairIndex，而是这样做。 

1721
01:18:22,480 --> 01:18:27,480
因此，这里的语法非常好。 

1722
01:18:27,600 --> 01:18:28,840
而且您要习惯

1723
01:18:28,840 --> 01:18:31,280
因为我们将要执行此调用函数。 

1724
01:18:31,280 --> 01:18:32,890
您已经在视图中看到了

1725
01:18:32,890 --> 01:18:35,940
我们其余的事情都做这些事情，这些花括号， 

1726
01:18:35,940 --> 01:18:38,429
他们无处不在，这是函数式编程

1727
01:18:38,429 --> 01:18:41,580
所以我们要传递很多函数作为参数

1728
01:18:41,580 --> 01:18:43,360
其他功能。 

1729
01:18:43,360 --> 01:18:46,020
如果我们想做某事怎么办

1730
01:18:46,020 --> 01:18:48,300
我们实际上返回的是不同的表情符号

1731
01:18:48,300 --> 01:18:49,650
每副卡好吗？ 

1732
01:18:49,650 --> 01:18:51,450
我们不想拥有每一副卡

1733
01:18:51,450 --> 01:18:52,283
有笑脸

1734
01:18:52,283 --> 01:18:53,567
那将使游戏非常容易

1735
01:18:53,567 --> 01:18:55,010
但是我们不想那样做。 

1736
01:18:55,010 --> 01:18:57,500
那么，我们该怎么做呢？ 

1737
01:18:57,500 --> 01:18:59,350
好吧，要做到这一点，首先， 

1738
01:18:59,350 --> 01:19:01,330
我要，而不是这样做， 

1739
01:19:01,330 --> 01:19:03,330
在这里设置正确的位置， 

1740
01:19:03,330 --> 01:19:05,637
我将尝试在此处创建一个函数， 

1741
01:19:05,637 --> 01:19:09,370
我将其称为createMemoryGame 

1742
01:19:11,140 --> 01:19:14,640
然后我要把它放进一个函子里

1743
01:19:14,640 --> 01:19:17,310
称为createMemoryGame。 

1744
01:19:17,310 --> 01:19:21,783
它会在字符串的MemoryGame中返回，好吗？ 

1745
01:19:23,210 --> 01:19:28,210
这实际上将返回此结果。 

1746
01:19:28,990 --> 01:19:31,800
在这里，我们要做一些更复杂的事情

1747
01:19:31,800 --> 01:19:33,690
不仅如此。 

1748
01:19:33,690 --> 01:19:37,640
记住，这是pairIndex。 

1749
01:19:37,640 --> 01:19:40,570
那么，我该如何实施呢？ 

1750
01:19:40,570 --> 01:19:44,263
我将创建一个小的表情符号数组。 

1751
01:19:45,290 --> 01:19:47,580
这将是一个字符串数组， 

1752
01:19:47,580 --> 01:19:49,380
实际上是一个表情符号数组。 

1753
01:19:49,380 --> 01:19:52,320
我将其设置为等于常数Array。 

1754
01:19:52,320 --> 01:19:55,360
这就是常量数组的语法。 

1755
01:19:55,360 --> 01:19:57,380
所以你只要打开方括号

1756
01:19:57,380 --> 01:19:59,617
然后你想要的东西在数组中

1757
01:19:59,617 --> 01:20:01,560
然后关闭方括号。 

1758
01:20:01,560 --> 01:20:03,750
所以这些东西对我来说就是表情符号

1759
01:20:03,750 --> 01:20:04,583
所以我要过去

1760
01:20:04,583 --> 01:20:08,117
让我们回到这里的万圣节主题

1761
01:20:08,117 --> 01:20:11,850
找鬼先生，有个鬼

1762
01:20:11,850 --> 01:20:14,800
然后在这一本书中，我们将放置其他万圣节用品。 

1763
01:20:14,800 --> 01:20:17,070
南瓜怎么样？ 

1764
01:20:17,070 --> 01:20:19,690
也许是打气筒，不，我去南瓜。 

1765
01:20:19,690 --> 01:20:20,748
好的，有一个南瓜。 

1766
01:20:20,748 --> 01:20:22,023
我们有这个。 

1767
01:20:22,023 --> 01:20:25,153
因此，这将创建一个字符串数组，因为这些是字符串

1768
01:20:25,153 --> 01:20:27,830
然后在这里返回这个MemoryGame， 

1769
01:20:27,830 --> 01:20:32,613
所以我的小卡片厂将要返回表情符号

1770
01:20:34,000 --> 01:20:36,440
子pairIndex。 

1771
01:20:36,440 --> 01:20:38,930
这就是您访问数组的方式。 

1772
01:20:38,930 --> 01:20:41,860
您只需在索引所在的位置加上方括号即可

1773
01:20:41,860 --> 01:20:44,130
所以这个pairIndex将是零

1774
01:20:44,130 --> 01:20:47,040
那么它将是1，所以我们将得到零索引

1775
01:20:47,040 --> 01:20:48,710
那么我们将获得索引一。 

1776
01:20:48,710 --> 01:20:51,291
因此，第一对牌将是一对幽灵， 

1777
01:20:51,291 --> 01:20:54,413
第二副牌将是一对南瓜。 

1778
01:20:55,380 --> 01:20:57,240
所以，这段代码没有错误

1779
01:20:57,240 --> 01:20:59,042
但是哦，我们这里有一个错误。 

1780
01:20:59,042 --> 01:21:00,030
这是什么意思

1781
01:21:00,030 --> 01:21:03,770
无法使用实例成员createMemoryGame 

1782
01:21:03,770 --> 01:21:05,920
在属性初始化器中。 

1783
01:21:05,920 --> 01:21:10,920
属性初始化程序在self可用之前运行。 

1784
01:21:11,561 --> 01:21:13,790
好吧，那是什么意思呢？ 

1785
01:21:13,790 --> 01:21:18,790
好吧，在这里，我告诉你，在Swift中我们无法做到， 

1786
01:21:19,395 --> 01:21:22,587
没有初始化为任何变量的任何变量， 

1787
01:21:22,587 --> 01:21:25,616
比这更严格的是， 

1788
01:21:25,616 --> 01:21:30,616
我们不能在我们的类或结构上使用任何函数

1789
01:21:30,820 --> 01:21:33,804
直到所有这些都已初始化。 

1790
01:21:33,804 --> 01:21:35,940
所以这里有22个主要收获， 

1791
01:21:35,940 --> 01:21:39,990
我想在这里在实例上使用一个函数

1792
01:21:39,990 --> 01:21:41,960
创建这个MemoryGame 

1793
01:21:41,960 --> 01:21:44,380
但是直到初始化后我才能这样做。 

1794
01:21:44,380 --> 01:21:45,890
所以，就像哇！ 

1795
01:21:45,890 --> 01:21:47,192
那么，我们该如何解决呢？ 

1796
01:21:47,192 --> 01:21:49,930
我们要在这里打开这个createMemoryGame 

1797
01:21:49,930 --> 01:21:53,220
实际上变成了静态函数。 

1798
01:21:53,220 --> 01:21:54,640
因此，静态函数

1799
01:21:54,640 --> 01:21:58,170
这使它成为类型上的函数，好吗？ 

1800
01:21:58,170 --> 01:21:59,650
所以不是功能

1801
01:21:59,650 --> 01:22:03,000
您发送到EmojiMemoryGame实例的信息， 

1802
01:22:03,000 --> 01:22:05,840
希望大家都知道面向对象

1803
01:22:05,840 --> 01:22:09,460
实例意味着什么，我们将其发送给该类型。 

1804
01:22:09,460 --> 01:22:12,480
这是我们输入的语法

1805
01:22:12,480 --> 01:22:17,480
类型的名称，MemoryGame。和功能

1806
01:22:19,000 --> 01:22:21,650
并且仅适用于静态函数。 

1807
01:22:21,650 --> 01:22:23,640
这是类型上的函数

1808
01:22:23,640 --> 01:22:26,220
不是MemoryGame实例上的函数， 

1809
01:22:26,220 --> 01:22:29,235
EmojiMemoryGame实例，但实际上是类型本身。 

1810
01:22:29,235 --> 01:22:31,970
我们实际上已经使用过了。 

1811
01:22:31,970 --> 01:22:35,560
在ContentView，Color.orange， 

1812
01:22:35,560 --> 01:22:36,483
Font.largeTitle。 

1813
01:22:37,570 --> 01:22:40,130
这些是类型，字体和颜色是类型

1814
01:22:40,130 --> 01:22:42,484
所以这些是vars 

1815
01:22:42,484 --> 01:22:44,290
但您可以使用函数或var， 

1816
01:22:44,290 --> 01:22:45,970
该类型的vars。 

1817
01:22:45,970 --> 01:22:47,220
这些是静态的。 

1818
01:22:47,220 --> 01:22:50,130
实际上，我们来看一下文档

1819
01:22:50,130 --> 01:22:51,090
并看到这种情况。 

1820
01:22:51,090 --> 01:22:54,530
那么，我们如何才能从代码中跳入文档呢？ 

1821
01:22:54,530 --> 01:22:56,000
这是一个非常酷的功能。 

1822
01:22:56,000 --> 01:22:57,680
按住Option键。 

1823
01:22:57,680 --> 01:23:00,410
当您这样做时，当您将鼠标悬停在某物上时， 

1824
01:23:00,410 --> 01:23:02,410
它上面会有一个问号。 

1825
01:23:02,410 --> 01:23:04,400
所以我要点击“字体” 

1826
01:23:04,400 --> 01:23:07,940
它给了我什么字体的简短描述

1827
01:23:07,940 --> 01:23:11,550
但这里也有一个不错的小链接。 

1828
01:23:11,550 --> 01:23:14,560
繁荣，带我去看文档，给我看字体。 

1829
01:23:14,560 --> 01:23:16,730
因此，这就是您进入文档的方式。 

1830
01:23:16,730 --> 01:23:18,930
当然，您也可以选择Window 

1831
01:23:18,930 --> 01:23:21,410
开发人员文档在这里

1832
01:23:21,410 --> 01:23:23,570
但执行该选项+单击， 

1833
01:23:23,570 --> 01:23:26,630
实际上，通常是我们进入文档的方式。 

1834
01:23:26,630 --> 01:23:28,420
如果您在此处查看“字体”， 

1835
01:23:28,420 --> 01:23:30,415
您会看到，马上就有大标题

1836
01:23:30,415 --> 01:23:32,590
看看，这是静态的。 

1837
01:23:32,590 --> 01:23:36,650
它也是一个让，所以largeTitle是一个常量。 

1838
01:23:36,650 --> 01:23:38,680
静态，让它在字体上， 

1839
01:23:38,680 --> 01:23:42,980
在实际类型本身上，即Font类型。 

1840
01:23:42,980 --> 01:23:45,130
您还可以看到所有其他这些。 

1841
01:23:45,130 --> 01:23:48,220
您可能还想在家庭作业中使用其中之一。 

1842
01:23:48,220 --> 01:23:50,030
您可以尝试一下他们的外观。 

1843
01:23:50,030 --> 01:23:52,460
就像，这些只是内置字体

1844
01:23:52,460 --> 01:23:54,500
这些是我们要使用的字体

1845
01:23:54,500 --> 01:23:57,810
因为其他所有人都在使用它们以及所有其他应用

1846
01:23:57,810 --> 01:24:00,820
因此，当用户使用您的应用程序时，又出现了另一个应用程序， 

1847
01:24:00,820 --> 01:24:02,760
他们看到相同类型的字体

1848
01:24:02,760 --> 01:24:05,350
这些字体的风格略有不同

1849
01:24:05,350 --> 01:24:07,900
还是什么都一样

1850
01:24:07,900 --> 01:24:10,690
在整个系统中，好吗？ 

1851
01:24:10,690 --> 01:24:13,430
当我们在文档中查找此处时， 

1852
01:24:13,430 --> 01:24:14,530
让我们向您展示一些功能

1853
01:24:14,530 --> 01:24:16,860
这里的文档查看器。 

1854
01:24:16,860 --> 01:24:18,420
很明显，您可以在此处搜索。 

1855
01:24:18,420 --> 01:24:20,740
例如，让我们搜索数组。 

1856
01:24:20,740 --> 01:24:23,620
如果我搜索Array，这是所有匹配项

1857
01:24:23,620 --> 01:24:24,810
它在哪里找到数组。 

1858
01:24:24,810 --> 01:24:28,790
第一个建议的可能是上课

1859
01:24:28,790 --> 01:24:29,900
或具有该名称的结构。 

1860
01:24:29,900 --> 01:24:33,000
这是数组，您可以看到元素数组，对吗？ 

1861
01:24:33,000 --> 01:24:34,070
这是一个通用类型。 

1862
01:24:34,070 --> 01:24:36,630
这是无关紧要的。它被称为元素， 

1863
01:24:36,630 --> 01:24:39,410
就像我们不在乎的那样，称为CardContent。 

1864
01:24:39,410 --> 01:24:42,960
这些描述非常详细， 

1865
01:24:42,960 --> 01:24:45,380
告诉大家有关数组的原理。 

1866
01:24:45,380 --> 01:24:48,960
您肯定想为Array阅读这篇文章， 

1867
01:24:48,960 --> 01:24:51,617
熟悉Array可以做什么。 

1868
01:24:51,617 --> 01:24:54,420
那肯定会帮助您完成家庭作业。 

1869
01:24:54,420 --> 01:24:56,710
如果您在此处向下滚动并浏览所有这些内容， 

1870
01:24:56,710 --> 01:24:59,550
我不希望您弄清楚所有这些工作原理

1871
01:24:59,550 --> 01:25:01,290
但您绝对想搜索

1872
01:25:01,290 --> 01:25:02,670
通过这些在这里看到

1873
01:25:02,670 --> 01:25:06,060
如果可以找到特定功能

1874
01:25:06,060 --> 01:25:08,720
可以帮助您完成功课，好吗？ 

1875
01:25:08,720 --> 01:25:12,198
与View一样，让我们​​来看一下View。 

1876
01:25:12,198 --> 01:25:14,080
好的，在这里查看。 

1877
01:25:14,080 --> 01:25:16,437
另一个查看这里的描述， 

1878
01:25:16,437 --> 01:25:18,370
我们将了解所有这些， 

1879
01:25:18,370 --> 01:25:21,820
我们已经在这里学到了很多有关View的知识。 

1880
01:25:21,820 --> 01:25:24,925
现在，如果您有这么多的函数和变量

1881
01:25:24,925 --> 01:25:28,180
它在这里将它们分为几个部分。 

1882
01:25:28,180 --> 01:25:32,060
有几个有趣的地方可能是布局， 

1883
01:25:32,060 --> 01:25:34,360
下周我们将学到更多。 

1884
01:25:34,360 --> 01:25:37,129
在那儿，您会发现诸如填充之类的内容

1885
01:25:37,129 --> 01:25:39,330
而且，渲染好吗？ 

1886
01:25:39,330 --> 01:25:42,300
因此，渲染就是我们可以学习如何缩放和旋转

1887
01:25:42,300 --> 01:25:45,200
并模糊其他事物。 

1888
01:25:45,200 --> 01:25:48,064
所以，这又是你可能会发现的东西

1889
01:25:48,064 --> 01:25:52,180
这里的东西将帮助您完成家庭作业。 

1890
01:25:52,180 --> 01:25:55,260
因此，部分作业实际上只是开始

1891
01:25:56,350 --> 01:25:58,540
有点在这里机动。 

1892
01:25:58,540 --> 01:25:59,373
有些东西你不是

1893
01:25:59,373 --> 01:26:01,160
会像国家一样了解一切。 

1894
01:26:01,160 --> 01:26:03,360
你会喜欢的，这到底是什么？ 

1895
01:26:03,360 --> 01:26:06,100
我不希望你从中学到任何东西

1896
01:26:06,100 --> 01:26:07,654
通过阅读文档

1897
01:26:07,654 --> 01:26:10,780
但我绝对希望您了解该文档， 

1898
01:26:10,780 --> 01:26:13,549
知道里面有什么，所以你可以四处搜寻

1899
01:26:13,549 --> 01:26:16,233
找东西好不好

1900
01:26:17,710 --> 01:26:19,740
好的，回到这里。 

1901
01:26:19,740 --> 01:26:21,270
所以我们做了一个很好的静态函数。 

1902
01:26:21,270 --> 01:26:23,420
同样，没有错误，没有警告。 

1903
01:26:23,420 --> 01:26:25,530
我们将其用作一种实用功能

1904
01:26:25,530 --> 01:26:28,150
创建我们的MemoryGame。 

1905
01:26:28,150 --> 01:26:30,830
现在，我们有了一个ViewModel，好吗？ 

1906
01:26:30,830 --> 01:26:33,310
在看我们的模型，好吗？ 

1907
01:26:33,310 --> 01:26:36,180
我们的模型，我们实际上没有我们的模型

1908
01:26:36,180 --> 01:26:37,610
选择时玩游戏

1909
01:26:37,610 --> 01:26:40,410
但希望至少说出选择的卡片。 

1910
01:26:40,410 --> 01:26:44,700
让我们回到View并使用ViewModel，好吗？ 

1911
01:26:44,700 --> 01:26:49,700
请记住，我们的View总是要使用ViewModel 

1912
01:26:50,190 --> 01:26:51,800
访问模型中的内容。 

1913
01:26:51,800 --> 01:26:53,610
也不要忘记查看

1914
01:26:53,610 --> 01:26:56,400
是世界上的首要事物

1915
01:26:56,400 --> 01:26:58,890
是反映模型的当前状态，好吗？ 

1916
01:26:58,890 --> 01:27:02,890
因此，无论模型中包含什么内容，它都希望始终显示。 

1917
01:27:02,890 --> 01:27:06,120
因此，让我们从CardView开始。 

1918
01:27:06,120 --> 01:27:09,240
目前，我们的CardView具有此变量isFaceUp 

1919
01:27:09,240 --> 01:27:11,930
但实际上，应该得到的是FaceUp 

1920
01:27:11,930 --> 01:27:14,600
从其查看的卡片中。 

1921
01:27:14,600 --> 01:27:18,900
因此，我将从isFaceUp将此变量更改为Card， 

1922
01:27:18,900 --> 01:27:23,900
这是一个MemoryGame <String> .Card。 

1923
01:27:24,170 --> 01:27:27,070
顺便说一句，您注意到我们已经输入了很多内容。 

1924
01:27:27,070 --> 01:27:28,290
这要输入很多。 

1925
01:27:28,290 --> 01:27:30,620
当然，Swift有办法做到这一点

1926
01:27:30,620 --> 01:27:31,800
我们不必花那么多钱

1927
01:27:31,800 --> 01:27:34,250
我们下周再谈。 

1928
01:27:34,250 --> 01:27:36,470
然后在这里，而不是说isFaceUp， 

1929
01:27:36,470 --> 01:27:39,130
我要说card.isFaceUp。 

1930
01:27:39,130 --> 01:27:41,560
而不是总是表现出鬼魂， 

1931
01:27:41,560 --> 01:27:44,490
我将获得卡的内容。 

1932
01:27:44,490 --> 01:27:46,560
现在，这很酷。 

1933
01:27:46,560 --> 01:27:51,560
我们的MemoryGame中的内容，这是CardContent类型， 

1934
01:27:52,110 --> 01:27:54,260
不在乎，甚至不知道它是什么

1935
01:27:54,260 --> 01:27:56,473
但是，当然，在EmojiMemoryGame中， 

1936
01:27:57,330 --> 01:27:59,340
我们将其设为字符串。 

1937
01:27:59,340 --> 01:28:02,860
因此，这就是为什么在我们的内容视图中， 

1938
01:28:02,860 --> 01:28:04,830
这是一个MemoryGames of Strings卡

1939
01:28:04,830 --> 01:28:07,310
所以卡的内容是字符串类型

1940
01:28:07,310 --> 01:28:08,423
这就是文本所要的， 

1941
01:28:08,423 --> 01:28:11,550
它想要一个文本字符串好吗？ 

1942
01:28:11,550 --> 01:28:13,700
所以在这里，我们的CardView 

1943
01:28:13,700 --> 01:28:15,860
它不再需要使用isFaceUp， 

1944
01:28:15,860 --> 01:28:18,220
它想拿某种卡。 

1945
01:28:18,220 --> 01:28:19,950
所以我们必须找到一些方法

1946
01:28:19,950 --> 01:28:22,130
为它提供卡。 

1947
01:28:22,130 --> 01:28:24,840
现在，我们如何为该东西提供卡片？ 

1948
01:28:24,840 --> 01:28:28,440
好吧，我们将通过ViewModel获得这些Cards。 

1949
01:28:28,440 --> 01:28:31,340
所以，我们这里需要某种var 

1950
01:28:31,340 --> 01:28:33,110
我将其称为viewModel 

1951
01:28:33,110 --> 01:28:36,770
同样，您不会调用var viewModel 

1952
01:28:36,770 --> 01:28:41,120
就像您不会调用var模型一样

1953
01:28:41,120 --> 01:28:43,440
但我只是想在这段代码中让您看到

1954
01:28:43,440 --> 01:28:45,510
当我访问模型时，这里同样

1955
01:28:45,510 --> 01:28:48,710
我希望您看到何时访问ViewModel。 

1956
01:28:48,710 --> 01:28:50,590
那么viewModel是什么类型？ 

1957
01:28:50,590 --> 01:28:53,940
这是一个EmojiMemoryGame游戏，好吗？ 

1958
01:28:53,940 --> 01:28:57,620
这是我们的ViewModel类型，对吗？ 

1959
01:28:57,620 --> 01:29:00,470
类EmojiMemoryGame就在那里。 

1960
01:29:00,470 --> 01:29:03,090
因此，由于这是一个类，因此是指向它的指针。 

1961
01:29:03,090 --> 01:29:05,497
如果我还有其他在ViewModel中访问过的View， 

1962
01:29:05,497 --> 01:29:07,010
他们会有指向它的指针

1963
01:29:07,010 --> 01:29:11,700
因此某个地方只有一个EmojiMemoryGame。 

1964
01:29:11,700 --> 01:29:15,208
那么，我们将在哪里创建这个EmojiMemoryGame？ 

1965
01:29:15,208 --> 01:29:17,038
好吧，我们要去创造它

1966
01:29:17,038 --> 01:29:21,390
在创建此内容视图的任何地方。 

1967
01:29:21,390 --> 01:29:23,430
我们将做与以前一样的事情

1968
01:29:23,430 --> 01:29:24,283
使用卡的isFaceUp， 

1969
01:29:24,283 --> 01:29:26,640
这实际上是我们在这里所做的相同的事情。 

1970
01:29:26,640 --> 01:29:28,890
那么，这是在哪里创建的呢？ 

1971
01:29:28,890 --> 01:29:31,180
所以，这是潜入一点的时间

1972
01:29:31,180 --> 01:29:32,280
到这个样板。 

1973
01:29:32,280 --> 01:29:34,690
记住，我告诉过你有这个AppDelegate， 

1974
01:29:34,690 --> 01:29:36,370
SceneDelegate锅炉板。 

1975
01:29:36,370 --> 01:29:39,240
好吧，如果我们单击SceneDelegate， 

1976
01:29:39,240 --> 01:29:40,840
我们会看到这里有一些垃圾

1977
01:29:40,840 --> 01:29:42,520
我们稍后再谈

1978
01:29:42,520 --> 01:29:44,840
但是这是非常重要的代码行

1979
01:29:44,840 --> 01:29:47,910
创建使用的ContentView 

1980
01:29:47,910 --> 01:29:51,760
作为Windows的主视图，好吗？ 

1981
01:29:51,760 --> 01:29:53,900
所以这个ContentView已经在抱怨

1982
01:29:53,900 --> 01:29:56,180
缺少viewModel的参数，对吗？ 

1983
01:29:56,180 --> 01:29:59,480
它知道在这里，我们有了这个viewModel 

1984
01:29:59,480 --> 01:30:01,960
它不等于任何东西

1985
01:30:01,960 --> 01:30:04,450
因此我们必须在创建它时执行此操作。 

1986
01:30:04,450 --> 01:30:08,900
所以我需要说viewModel在这里。 

1987
01:30:08,900 --> 01:30:12,410
所以我要把这个叫做游戏

1988
01:30:12,410 --> 01:30:16,507
我会说让游戏等于EmojiMemoryGame， 

1989
01:30:17,910 --> 01:30:19,750
开括号，闭括号， 

1990
01:30:19,750 --> 01:30:23,170
我得到了免费的初始化，因为这是一堂课，对吧？ 

1991
01:30:23,170 --> 01:30:25,750
一个不初始化任何内容的免费初始化

1992
01:30:25,750 --> 01:30:29,500
但幸运的是，我在这里初始化了唯一的变量

1993
01:30:29,500 --> 01:30:31,420
用这个吧？ 

1994
01:30:31,420 --> 01:30:32,903
所以这将起作用。 

1995
01:30:33,830 --> 01:30:36,747
因此，在这里，我们获得了用于传递ViewModel的游戏。 

1996
01:30:36,747 --> 01:30:39,450
顺便说一句，如果我们回到这里

1997
01:30:39,450 --> 01:30:40,830
看看我们的ContentView， 

1998
01:30:40,830 --> 01:30:42,960
它仍然会在这里抱怨。 

1999
01:30:42,960 --> 01:30:46,260
这是将其粘合到灰色区域的胶水。 

2000
01:30:46,260 --> 01:30:47,670
它正在创建一个ContentView 

2001
01:30:47,670 --> 01:30:52,240
显示在此画布上。 

2002
01:30:52,240 --> 01:30:56,376
好的，因此，此ContentView在这里也需要一个ViewModel。 

2003
01:30:56,376 --> 01:31:00,870
为此，我将即时创建一个EmojiMemoryGame 

2004
01:31:00,870 --> 01:31:04,280
因为这本质上是用于测试或其他

2005
01:31:04,280 --> 01:31:06,270
这样就可以即时创建这个东西， 

2006
01:31:06,270 --> 01:31:09,260
不需要将其放在变量中。 

2007
01:31:09,260 --> 01:31:11,290
好的，我们越来越近了。 

2008
01:31:11,290 --> 01:31:13,320
现在，我们在这里拥有ViewModel。 

2009
01:31:13,320 --> 01:31:16,710
我们如何使用ViewModel来获得卡片

2010
01:31:16,710 --> 01:31:17,850
我们要展示吗？ 

2011
01:31:17,850 --> 01:31:21,060
好吧，现在，我们将其显示为四张卡片， 

2012
01:31:21,060 --> 01:31:22,890
零，一，二或三。 

2013
01:31:22,890 --> 01:31:24,920
我们在这里使用范围。 

2014
01:31:24,920 --> 01:31:27,480
再次单击此按钮。 

2015
01:31:27,480 --> 01:31:28,880
我们正在使用这个范围

2016
01:31:28,880 --> 01:31:31,920
我告诉你这可能是任何可迭代的事情

2017
01:31:31,920 --> 01:31:33,690
那如果我们做这个呢

2018
01:31:33,690 --> 01:31:36,940
成为我们ViewModel的卡片，好吗？ 

2019
01:31:36,940 --> 01:31:40,640
这是MemoryGame <String> .Cards的数组

2020
01:31:40,640 --> 01:31:43,120
所以，这应该工作，对吧？ 

2021
01:31:43,120 --> 01:31:45,990
但这行不通，好吗？ 

2022
01:31:45,990 --> 01:31:48,400
实际上，我在这里输入了Array 

2023
01:31:48,400 --> 01:31:50,520
它说不能从价值转换

2024
01:31:50,520 --> 01:31:53,340
到Int的预期参数范围。 

2025
01:31:53,340 --> 01:31:57,290
它仍然认为我想要Int的范围在这里。 

2026
01:31:57,290 --> 01:32:01,240
那是因为有点误导你

2027
01:32:01,240 --> 01:32:04,007
当我说这可能是任何可迭代的事情时。 

2028
01:32:04,007 --> 01:32:07,200
其实是任何可迭代的东西

2029
01:32:07,200 --> 01:32:09,280
在哪里迭代的事物

2030
01:32:09,280 --> 01:32:12,940
什么是可识别的，好吗？ 

2031
01:32:12,940 --> 01:32:15,440
这些东西必须是可识别的。 

2032
01:32:15,440 --> 01:32:18,960
如果它们不是Int范围，则必须是可识别的。 

2033
01:32:18,960 --> 01:32:20,790
所以为什么？ 

2034
01:32:20,790 --> 01:32:23,020
为什么这些必须是可识别的？ 

2035
01:32:23,020 --> 01:32:27,060
好吧，例如，假设您要制作动画

2036
01:32:27,060 --> 01:32:30,670
假设这些卡片在走动，好吗？ 

2037
01:32:30,670 --> 01:32:33,410
移动到不同的顺序或类似的东西。 

2038
01:32:33,410 --> 01:32:36,470
这对于每个需要能够识别的人

2039
01:32:36,470 --> 01:32:40,520
哪个卡是哪个卡，以便它创建视图

2040
01:32:40,520 --> 01:32:43,750
对于每张Card，这就是CardView， 

2041
01:32:43,750 --> 01:32:47,520
它可以使该视图与这些即时贴保持同步。 

2042
01:32:47,520 --> 01:32:50,850
因此，这些事情必须是可识别的，并且现在， 

2043
01:32:50,850 --> 01:32:53,261
如果你看这个，这是一张纸牌，对不对？ 

2044
01:32:53,261 --> 01:32:58,261
ViewModel.cards是此MemoryGame卡数组。 

2045
01:32:59,100 --> 01:33:02,380
如果我们看一下MemoryGame卡，它们是无法识别的， 

2046
01:33:02,380 --> 01:33:04,420
无法识别它们。 

2047
01:33:04,420 --> 01:33:07,150
实际上，现在，它们都是一样的。 

2048
01:33:07,150 --> 01:33:08,433
匹配的两张卡是相同的

2049
01:33:08,433 --> 01:33:10,210
因为它们具有相同的内容， 

2050
01:33:10,210 --> 01:33:11,911
它们可能与FaceUp相同。 

2051
01:33:11,911 --> 01:33:14,410
无法识别它们。 

2052
01:33:14,410 --> 01:33:18,810
因此，斯威夫特有形式主义，形式化机制

2053
01:33:18,810 --> 01:33:22,670
用于识别事物，使事物可识别

2054
01:33:22,670 --> 01:33:25,040
它用我喜欢的东西来做

2055
01:33:25,040 --> 01:33:27,500
约束和收获。 

2056
01:33:27,500 --> 01:33:31,160
因此，当您需要一个结构来做某件事时， 

2057
01:33:31,160 --> 01:33:34,430
你约束它去做某件事

2058
01:33:34,430 --> 01:33:38,120
但是如果这样做，它将获得某些功能。 

2059
01:33:38,120 --> 01:33:40,560
现在，我们要谈论所有

2060
01:33:40,560 --> 01:33:44,163
下个星期如何制约和取得成果。 

2061
01:33:45,250 --> 01:33:47,322
而且我们已经使用了约束和收益， 

2062
01:33:47,322 --> 01:33:51,490
实际上，在这里，结肠视图是有限制和有收获的。 

2063
01:33:51,490 --> 01:33:54,857
我们限制自己必须做这个身体，好吗？ 

2064
01:33:54,857 --> 01:33:59,210
但是我们获得了View所做的所有事情，好吗？ 

2065
01:33:59,210 --> 01:34:01,703
因此，这就是结构的约束和收获。 

2066
01:34:02,592 --> 01:34:04,950
我们将通过这种限制和收获来做同样的事情

2067
01:34:04,950 --> 01:34:06,140
这个结构。 

2068
01:34:06,140 --> 01:34:09,719
我们要说的是约束和收获是可识别的。 

2069
01:34:09,719 --> 01:34:14,719
像View这样的可识别协议

2070
01:34:15,070 --> 01:34:18,900
这就是这种限制并获得业务的核心。 

2071
01:34:18,900 --> 01:34:22,640
同样，下周我们将讨论很多协议。 

2072
01:34:22,640 --> 01:34:24,410
不幸的是，你并没有收获太多

2073
01:34:24,410 --> 01:34:27,080
除非您有被识别的能力

2074
01:34:27,080 --> 01:34:29,090
但大多数情况下，你会被束缚

2075
01:34:29,090 --> 01:34:31,010
和可识别的约束

2076
01:34:31,010 --> 01:34:34,540
是你必须有一个名为id的变量

2077
01:34:34,540 --> 01:34:36,890
现在，幸运的是，它可以是您想要的任何类型。 

2078
01:34:36,890 --> 01:34:38,570
我要让我的身份证成为诚信

2079
01:34:38,570 --> 01:34:41,160
但它可以是String或您需要执行的任何操作

2080
01:34:41,160 --> 01:34:43,390
使这个东西可识别。 

2081
01:34:43,390 --> 01:34:45,980
当然，我在这里添加另一个var后， 

2082
01:34:45,980 --> 01:34:49,000
现在，我的卡片是FaceUp等等，等等，等等

2083
01:34:49,000 --> 01:34:51,610
没有做所有的变量。 

2084
01:34:51,610 --> 01:34:55,420
因此，对于这两种方式，我都需要添加一个ID。 

2085
01:34:55,420 --> 01:34:59,500
我要使用的ID是对子索引乘以2 

2086
01:34:59,500 --> 01:35:01,760
和这个人的身份证，因为我要这张卡

2087
01:35:01,760 --> 01:35:05,270
显然，拥有自己的标识符， 

2088
01:35:05,270 --> 01:35:09,930
我要对对数乘以2加1，好吗？ 

2089
01:35:09,930 --> 01:35:14,760
所以现在这些东西都有唯一的标识符。 

2090
01:35:14,760 --> 01:35:17,440
现在这是完全可识别的，这就是我们需要做的， 

2091
01:35:17,440 --> 01:35:19,340
我们只需要确保这些卡

2092
01:35:19,340 --> 01:35:21,060
是唯一可识别的

2093
01:35:21,060 --> 01:35:22,290
再次，以便他们四处走动， 

2094
01:35:22,290 --> 01:35:23,803
我们可以为它们设置动画。 

2095
01:35:23,803 --> 01:35:26,290
顺便说一句，这有点烦人

2096
01:35:26,290 --> 01:35:29,360
对于新卡，我每次都要说一次。 

2097
01:35:29,360 --> 01:35:31,660
顺便说一句，我可以把它放在这里。 

2098
01:35:31,660 --> 01:35:35,930
绝对允许您使用一些var 

2099
01:35:35,930 --> 01:35:37,760
用这种方式初始化

2100
01:35:37,760 --> 01:35:41,160
然后我们就不需要在这里了，好吗？ 

2101
01:35:41,160 --> 01:35:43,423
在那里整理了一下我们的代码。 

2102
01:35:45,170 --> 01:35:47,140
好的，既然可以识别了， 

2103
01:35:47,140 --> 01:35:49,330
当我们回到这里的观点时， 

2104
01:35:49,330 --> 01:35:50,900
它说，哦，很好，好吧， 

2105
01:35:50,900 --> 01:35:55,250
您还具有Identifiables的可迭代事物。 

2106
01:35:55,250 --> 01:35:58,280
当然，这不再是该范围内的索引了，好吗？ 

2107
01:35:58,280 --> 01:36:02,493
这个参数是数组中的Card，好吗？ 

2108
01:36:03,760 --> 01:36:07,740
当然，您知道这是一个内联函数

2109
01:36:07,740 --> 01:36:09,560
这是它的理由

2110
01:36:09,560 --> 01:36:12,480
而这些卡只是ForEaching 

2111
01:36:12,480 --> 01:36:14,770
在这个阵列中，所以这是每张卡

2112
01:36:14,770 --> 01:36:17,183
这就是我们要在这里通过的。 

2113
01:36:18,790 --> 01:36:19,990
就是这样。 

2114
01:36:19,990 --> 01:36:24,970
这就是我们将模型附加到视图的方式

2115
01:36:24,970 --> 01:36:27,490
通过我们的ViewModel好吗？ 

2116
01:36:27,490 --> 01:36:31,760
因此，我们的ViewModel本质上提供了一个窗口或门户

2117
01:36:31,760 --> 01:36:34,290
通过此卡片阵列进入我们的模型

2118
01:36:34,290 --> 01:36:36,800
通过选择我们还没有使用过的卡

2119
01:36:36,800 --> 01:36:37,750
但是我们要去。 

2120
01:36:38,840 --> 01:36:41,827
让我们在这里看到我们的模型

2121
01:36:41,827 --> 01:36:45,930
我们的观点总是会反映这一点。 

2122
01:36:45,930 --> 01:36:48,000
现在，我们今天将要用光时间

2123
01:36:48,000 --> 01:36:50,360
向您展示它如何进行自动反射， 

2124
01:36:50,360 --> 01:36:53,815
我们下周的讲座要做第一件事。 

2125
01:36:53,815 --> 01:36:56,450
但这是他所有工作的关键

2126
01:36:56,450 --> 01:36:58,370
但至少我们可以在这里看到

2127
01:36:58,370 --> 01:37:00,960
该视图始终在绘制

2128
01:37:00,960 --> 01:37:02,820
模型中有什么，好吗？ 

2129
01:37:02,820 --> 01:37:05,160
通过ViewModel获取它，但是无论获取到什么， 

2130
01:37:05,160 --> 01:37:07,090
它总是在这里画。 

2131
01:37:07,090 --> 01:37:08,420
我们将看到这一点。 

2132
01:37:08,420 --> 01:37:10,473
让我们继续，我们将运行我们的应用程序。 

2133
01:37:15,991 --> 01:37:16,824
在这里。 

2134
01:37:16,824 --> 01:37:19,540
我们有四张正面朝下的卡片。 

2135
01:37:19,540 --> 01:37:21,410
为什么我们有四张面朝下的卡？ 

2136
01:37:21,410 --> 01:37:24,470
好吧，因为在这里，当我们创建MemoryGame时， 

2137
01:37:24,470 --> 01:37:27,080
我们说我们要两副卡

2138
01:37:27,080 --> 01:37:29,740
所以正是我们为什么要得到四张卡的原因，这是两对

2139
01:37:29,740 --> 01:37:31,620
在MemoryGame中， 

2140
01:37:31,620 --> 01:37:34,360
我们所有的卡都开始朝下。 

2141
01:37:34,360 --> 01:37:37,730
因此，让我们在模型中将其更改为真实的，好吗？ 

2142
01:37:37,730 --> 01:37:41,330
现在，所有卡片都在我们的Model FaceUp true中创建。 

2143
01:37:41,330 --> 01:37:44,000
让我们看看这是否会影响我们的视图。 

2144
01:37:44,000 --> 01:37:46,310
哇，确实如此，甚至看起来， 

2145
01:37:46,310 --> 01:37:49,970
我们在那里放了两种东西。 

2146
01:37:49,970 --> 01:37:51,510
看到那个吗？ 

2147
01:37:51,510 --> 01:37:52,400
好的？ 

2148
01:37:52,400 --> 01:37:56,523
现在，我们可以再说一个。 

2149
01:37:58,660 --> 01:38:00,166
在这边

2150
01:38:00,166 --> 01:38:01,870
万圣节有什么好事？ 

2151
01:38:01,870 --> 01:38:03,910
蜘蛛呢？ 

2152
01:38:03,910 --> 01:38:05,283
是的，蜘蛛。 

2153
01:38:06,347 --> 01:38:08,920
顺便说一句，也许是蜘蛛，我们这里有两张卡片。 

2154
01:38:08,920 --> 01:38:10,920
现在我们可以说三个

2155
01:38:10,920 --> 01:38:15,390
但是另一个很酷的说法是emojis.count，对吗？ 

2156
01:38:15,390 --> 01:38:18,000
因为表情符号就是这个数组。 

2157
01:38:18,000 --> 01:38:20,000
当然，顺便说一句，我不需要这个

2158
01:38:20,000 --> 01:38:21,990
也可以推断出这一点。 

2159
01:38:21,990 --> 01:38:26,126
因此，这个emojis.count只是emojis中的一个变种， 

2160
01:38:26,126 --> 01:38:28,170
在数组中，这会告诉你

2161
01:38:28,170 --> 01:38:29,810
这里有多少东西

2162
01:38:29,810 --> 01:38:30,743
我们又跑了。 

2163
01:38:32,750 --> 01:38:33,583
我们知道了。 

2164
01:38:35,130 --> 01:38:39,040
好的，所以我们的视图非常好

2165
01:38:39,040 --> 01:38:43,440
总是反映我们在模型中看到的一切。 

2166
01:38:43,440 --> 01:38:44,350
那很棒。 

2167
01:38:44,350 --> 01:38:48,150
这种表达意图的能力如何？ 

2168
01:38:48,150 --> 01:38:50,273
就像我想选择一张卡，好吗？ 

2169
01:38:50,273 --> 01:38:54,670
我想去这里轻按卡片

2170
01:38:54,670 --> 01:38:58,360
并出于游戏目的选择它。 

2171
01:38:58,360 --> 01:39:00,470
所以，这也很容易做到

2172
01:39:00,470 --> 01:39:02,228
因为我们有这个ViewModel。 

2173
01:39:02,228 --> 01:39:06,120
对于每张卡片，我都会在上面添加一些东西

2174
01:39:06,120 --> 01:39:07,707
称为onTapGesture。 

2175
01:39:08,602 --> 01:39:11,600
因此，onTapGesture是一个函数

2176
01:39:11,600 --> 01:39:14,640
需要另一个函数作为参数。 

2177
01:39:14,640 --> 01:39:16,960
它接受的函数不带参数

2178
01:39:16,960 --> 01:39:19,530
它什么也不返回，好吗？ 

2179
01:39:19,530 --> 01:39:21,560
因此，这就是我们要使用的功能。 

2180
01:39:21,560 --> 01:39:23,560
因此，这是一个不带参数的函数

2181
01:39:23,560 --> 01:39:25,357
在这里什么也不会返回。 

2182
01:39:25,357 --> 01:39:28,850
我想在这里做的是问我的ViewModel 

2183
01:39:28,850 --> 01:39:31,290
做某事，一个意图， 

2184
01:39:31,290 --> 01:39:35,570
哪个可以选择这张卡，好吗？ 

2185
01:39:35,570 --> 01:39:39,010
这就是这张卡，我要选择这张卡。 

2186
01:39:39,010 --> 01:39:43,740
因此onTapGesture的执行只是View中的功能， 

2187
01:39:43,740 --> 01:39:46,913
所有视图都知道如何执行onTapGesture执行。 

2188
01:39:49,354 --> 01:39:51,500
这是唯一的论据，因此也是最后一个论据

2189
01:39:51,500 --> 01:39:54,290
所以我们不需要在这里。 

2190
01:39:54,290 --> 01:39:56,420
很多时候，如果我们有这样的事情， 

2191
01:39:56,420 --> 01:39:58,880
我们将使其更具可读性

2192
01:39:58,880 --> 01:40:03,355
通过将这个小的嵌入式功能放在这里

2193
01:40:03,355 --> 01:40:06,630
这样行。 

2194
01:40:06,630 --> 01:40:09,700
您还可以看到我们在这里有一个错误。 

2195
01:40:09,700 --> 01:40:13,490
现在，这是一个非常有趣的错误，因为可能

2196
01:40:13,490 --> 01:40:15,060
在大约一个半月内， 

2197
01:40:15,060 --> 01:40:17,650
这个错误将不再出现，好吗？ 

2198
01:40:17,650 --> 01:40:20,650
此问题已解决或更改， 

2199
01:40:20,650 --> 01:40:23,291
但是您想在SwiftUI中描述它。 

2200
01:40:23,291 --> 01:40:25,900
Swift，所有对Swift的更改

2201
01:40:25,900 --> 01:40:27,940
进行公开审查

2202
01:40:27,940 --> 01:40:30,240
这已经通过并获得批准

2203
01:40:30,240 --> 01:40:31,510
所以它会发生。 

2204
01:40:31,510 --> 01:40:35,260
本质上，有时发生的事情是

2205
01:40:35,260 --> 01:40:37,060
当您拥有这些内联函数时， 

2206
01:40:37,060 --> 01:40:40,670
你需要自我介绍。在前

2207
01:40:40,670 --> 01:40:43,910
这样Swift就能确切知道发生了什么，好吗？ 

2208
01:40:43,910 --> 01:40:45,840
我今天不详细解释

2209
01:40:45,840 --> 01:40:47,720
因为我们没时间了。 

2210
01:40:47,720 --> 01:40:50,260
我的意思是，下周会解释

2211
01:40:50,260 --> 01:40:51,322
或之后的一周。 

2212
01:40:51,322 --> 01:40:53,430
但这就是这个错误在这里的意思

2213
01:40:53,430 --> 01:40:54,350
是把自我。 

2214
01:40:54,350 --> 01:40:57,780
现在，我建议您每当看到此错误时， 

2215
01:40:57,780 --> 01:41:00,570
每当您看到单词需要明确的自我

2216
01:41:00,570 --> 01:41:03,490
使捕获语义明确，插入自我， 

2217
01:41:03,490 --> 01:41:06,680
只是选择修复它，好吗？ 

2218
01:41:06,680 --> 01:41:08,760
然后，这将使自己处于领先地位。 

2219
01:41:08,760 --> 01:41:12,260
我的意思是，您可以将自己放在任何var前面，好吗？ 

2220
01:41:12,260 --> 01:41:13,960
随时。 

2221
01:41:13,960 --> 01:41:16,060
将自己摆在面前永远不会有伤害。 

2222
01:41:16,060 --> 01:41:18,150
有些人采取了某种策略

2223
01:41:18,150 --> 01:41:20,480
我只是要自我介绍。在每个变量前面

2224
01:41:20,480 --> 01:41:22,200
然后我永远不会有这个问题

2225
01:41:22,200 --> 01:41:23,775
我必须在哪里修复它。 

2226
01:41:23,775 --> 01:41:26,730
鉴于在几个月内，这种自我。 

2227
01:41:26,730 --> 01:41:29,440
在这里实际上不再需要了。 

2228
01:41:29,440 --> 01:41:32,860
我不确定有什么正确的策略

2229
01:41:32,860 --> 01:41:36,450
但在此类中，如果您看到显式语义

2230
01:41:36,450 --> 01:41:40,270
插入自己的东西，只需修复它，然后将自己放在前面

2231
01:41:40,270 --> 01:41:41,570
大家都在那里。 

2232
01:41:42,770 --> 01:41:44,523
好的，让我们看看是否可行。 

2233
01:41:46,460 --> 01:41:48,527
好吧，当我们点击这些卡片时

2234
01:41:48,527 --> 01:41:49,360
然后发生点击手势

2235
01:41:49,360 --> 01:41:52,090
我们应该让选择卡出现在控制台上。 

2236
01:41:52,090 --> 01:41:53,736
因此，请尝试一下。 

2237
01:41:53,736 --> 01:41:55,890
哦，看，那边有东西。 

2238
01:41:55,890 --> 01:41:56,723
在那里。 

2239
01:41:56,723 --> 01:41:58,240
这是我们的调试器。 

2240
01:41:58,240 --> 01:42:00,130
这是我们的控制台。 

2241
01:42:00,130 --> 01:42:03,060
我们实际上可以使用这些按钮来隐藏调试器

2242
01:42:03,060 --> 01:42:06,540
所以我们只看到控制台， 

2243
01:42:06,540 --> 01:42:07,410
把这个拿回来。 

2244
01:42:07,410 --> 01:42:09,320
希望当我们单击不同的卡片时， 

2245
01:42:09,320 --> 01:42:11,130
是的，我们得到了不同的东西。 

2246
01:42:11,130 --> 01:42:13,220
所以选择了这个输出卡

2247
01:42:13,220 --> 01:42:16,280
来自这行代码。 

2248
01:42:16,280 --> 01:42:18,440
这是在我们的模型中。 

2249
01:42:18,440 --> 01:42:21,850
因此，我们的视图能够在模型中调用代码

2250
01:42:21,850 --> 01:42:26,550
只需在我们的ViewModel中执行Intent函数即可。 

2251
01:42:26,550 --> 01:42:29,327
这就是视图之间的通信方式

2252
01:42:29,327 --> 01:42:33,830
当视图中发生某些手势时，模型就会发生。 

2253
01:42:33,830 --> 01:42:38,240
您可以看到它基本上是在转动我们的卡

2254
01:42:38,240 --> 01:42:41,800
通过告诉我们有关卡的所有信息，将其转换为字符串，好吗？ 

2255
01:42:41,800 --> 01:42:44,300
其所有var的所有值。 

2256
01:42:44,300 --> 01:42:45,910
我告诉你这是一个很酷的功能

2257
01:42:45,910 --> 01:42:49,783
而且真的很适合调试，好吗？ 

2258
01:42:51,270 --> 01:42:54,570
好的，所以我们没有时间参加本周的讲座。 

2259
01:42:54,570 --> 01:42:57,280
您的作业是将其清理干净。 

2260
01:42:57,280 --> 01:43:00,070
例如，请注意这些卡没有被打乱

2261
01:43:00,070 --> 01:43:02,430
所以玩这个游戏真的很容易，对吧？ 

2262
01:43:02,430 --> 01:43:03,730
因为卡彼此相邻

2263
01:43:03,730 --> 01:43:04,760
所以你要洗牌

2264
01:43:04,760 --> 01:43:08,080
你会让他们不再像这样瘦高瘦

2265
01:43:08,080 --> 01:43:11,730
而且您还将随机放置一张牌

2266
01:43:11,730 --> 01:43:14,210
在这里，从两对到

2267
01:43:14,210 --> 01:43:15,660
我想我做了五六对， 

2268
01:43:15,660 --> 01:43:17,380
在家庭作业中说什么。 

2269
01:43:17,380 --> 01:43:19,040
所以每次都会有不同数量的卡片

2270
01:43:19,040 --> 01:43:21,633
他们都会被洗牌。 

2271
01:43:22,500 --> 01:43:23,370
那就是你的作业。 

2272
01:43:23,370 --> 01:43:26,670
因此，您可以看到大部分作业只是为了复制

2273
01:43:26,670 --> 01:43:28,711
为了达到这一点，我在这里做了什么。 

2274
01:43:28,711 --> 01:43:31,470
我提到的变化

2275
01:43:31,470 --> 01:43:33,330
其中大多数是一行代码

2276
01:43:33,330 --> 01:43:34,960
所以那里不应该为您做很多工作

2277
01:43:34,960 --> 01:43:37,790
但这是一行代码，但它意味着理解

2278
01:43:37,790 --> 01:43:39,400
这里发生了什么。 

2279
01:43:39,400 --> 01:43:40,630
好的，这就是本周了。 

2280
01:43:40,630 --> 01:43:43,440
如果您对作业有任何疑问，请尽情享受， 

2281
01:43:43,440 --> 01:43:44,860
你知道去广场

2282
01:43:44,860 --> 01:43:47,260
我们将在那里为您解答。 

2283
01:43:48,470 --> 01:43:51,693
-[播音员]有关更多信息，请访问stanford.edu。 

